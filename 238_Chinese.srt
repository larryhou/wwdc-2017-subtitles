1
00:00:22,489 --> 00:00:25,526
电池使用时间对用户来说
非常重要

2
00:00:25,826 --> 00:00:28,128
应用与电池使用时间
直接相关

3
00:00:28,629 --> 00:00:30,497
作为开发者
很重要的一点是

4
00:00:30,697 --> 00:00:32,633
我们在编写代码时
应该十分注意节省电量

5
00:00:33,367 --> 00:00:34,635
原因很简单

6
00:00:35,369 --> 00:00:37,771
如果我是用户
发现电池使用时间很短

7
00:00:38,238 --> 00:00:39,473
那么我做的第一件事情

8
00:00:39,740 --> 00:00:41,842
是转到
“电量管理”屏幕

9
00:00:42,209 --> 00:00:45,479
我会弄清楚
哪些应用耗用过多电量

10
00:00:46,313 --> 00:00:50,050
如果我发现你的应用
耗用电量最多 很可能会删除它

11
00:00:50,517 --> 00:00:53,954
而且我会很高兴
删除了你的应用

12
00:00:55,455 --> 00:01:00,060
今天 我要讨论
一些电量使用概念

13
00:01:00,594 --> 00:01:02,029
然后 我们将会讨论

14
00:01:02,095 --> 00:01:03,697
节能编码规范

15
00:01:04,096 --> 00:01:05,232
此后 我的同事将上台

16
00:01:05,532 --> 00:01:07,301
为大家介绍
一些节能调试工具

17
00:01:07,534 --> 00:01:09,670
这些工具可供你们使用
而且附带演示

18
00:01:10,404 --> 00:01:11,939
最后我们进行总结
归纳一些要点

19
00:01:13,273 --> 00:01:14,308
让我们开始

20
00:01:15,409 --> 00:01:16,777
什么是电量？

21
00:01:17,244 --> 00:01:19,880
电量是电力和时间的双重结合

22
00:01:20,147 --> 00:01:21,782
我想用一个例子来进行描述

23
00:01:21,849 --> 00:01:23,684
（什么是电量？）

24
00:01:23,750 --> 00:01:26,086
在这里可以看到
当设备处于空闲状态时

25
00:01:26,386 --> 00:01:27,487
电量耗用很低

26
00:01:28,188 --> 00:01:30,757
当设备工作时
电量耗用很高

27
00:01:31,758 --> 00:01:33,894
你还会注意到
电量耗用可能会更高

28
00:01:33,961 --> 00:01:35,529
这取决于你的工作负荷

29
00:01:35,596 --> 00:01:36,897
以及你的工作类型

30
00:01:37,698 --> 00:01:39,766
你会注意到存在开销

31
00:01:41,034 --> 00:01:45,005
需要电量来启动硬件

32
00:01:45,706 --> 00:01:47,875
以处理你的工作
或者让它返回睡眠状态

33
00:01:49,643 --> 00:01:52,779
前面我说过
电量是电力与时间的组合

34
00:01:53,413 --> 00:01:54,882
这是曲线下方的区域

35
00:01:55,649 --> 00:01:57,284
让我们进行更深层的研究

36
00:01:59,720 --> 00:02:02,956
我们将电量分布
划分为两个区域

37
00:02:03,156 --> 00:02:05,626
固定成本和动态成本

38
00:02:06,360 --> 00:02:08,729
动态成本是
你处理的工作

39
00:02:09,562 --> 00:02:13,433
固定成本是开销
前面我们已经讲过

40
00:02:13,967 --> 00:02:15,569
也就是启动硬件

41
00:02:15,636 --> 00:02:18,205
来完成你的工作所需要的电量

42
00:02:18,539 --> 00:02:20,507
因此 即使你处理
少量的工作

43
00:02:20,974 --> 00:02:22,843
你仍然需要付出
这些开销成本

44
00:02:23,710 --> 00:02:25,145
在这方面
我们将会进一步论述

45
00:02:27,080 --> 00:02:28,916
我们的设备功耗很高

46
00:02:29,616 --> 00:02:32,352
因此 作为开发者
在电量使用方面

47
00:02:33,420 --> 00:02:34,755
应该非常小心

48
00:02:35,622 --> 00:02:36,657
我们应该认真思考

49
00:02:37,057 --> 00:02:40,661
以合理地利用电量
为用户提供良好的用户体验

50
00:02:40,727 --> 00:02:43,063
当我们处理工作时
会耗用电量

51
00:02:43,230 --> 00:02:45,332
但是在其它时候
我们可以保留电量

52
00:02:47,301 --> 00:02:49,603
这时 你可能在想
哪些项目会耗用电量

53
00:02:50,204 --> 00:02:53,373
事实上 设备中的所有项目
都会耗用电量

54
00:02:53,674 --> 00:02:56,643
但是今天 我想要重点讨论四个要点

55
00:02:57,578 --> 00:03:00,147
它们包括处理

56
00:03:01,081 --> 00:03:04,952
网络 位置
以及图形

57
00:03:05,319 --> 00:03:07,287
这四点 我希望你们

58
00:03:07,354 --> 00:03:08,388
在编写应用时给予重视

59
00:03:12,326 --> 00:03:15,696
那么 我如何降低
电量耗用呢？

60
00:03:16,797 --> 00:03:19,900
首先 需要分析
你所要做的工作

61
00:03:20,167 --> 00:03:23,437
认真思考这些工作
将如何帮助你的用户

62
00:03:23,504 --> 00:03:24,505
（如何减少电量耗用）

63
00:03:24,571 --> 00:03:28,609
如果不能帮助用户 就应该放弃
或者以后再做

64
00:03:29,276 --> 00:03:30,677
接下来 你需优化你的工作

65
00:03:31,078 --> 00:03:33,146
在确定需要做的工作之后

66
00:03:33,814 --> 00:03:35,883
应该想办法快速
和高效率地完成它

67
00:03:36,850 --> 00:03:40,053
你需要进行合并
尝试批处理你的事务

68
00:03:40,287 --> 00:03:41,655
不要离散地完成这些处理

69
00:03:42,356 --> 00:03:44,758
最后 应该想办法
降低工作处理频率

70
00:03:46,894 --> 00:03:50,063
让我们来看
如何在应用中运用这些原则

71
00:03:50,130 --> 00:03:51,331
（节能编码）

72
00:03:51,632 --> 00:03:53,100
首先 我想从网络开始

73
00:03:53,567 --> 00:03:55,736
如果你要开发使用网络功能的应用

74
00:03:55,936 --> 00:03:58,672
或者你的应用提供网络功能
你应该特别注意

75
00:04:00,774 --> 00:04:03,010
让我们来看一个例子

76
00:04:03,644 --> 00:04:05,412
我在开发一个社交网络应用
这个应用

77
00:04:06,013 --> 00:04:08,048
分为三部分：

78
00:04:08,549 --> 00:04:11,718
主界面
在这里能够发布照片

79
00:04:12,519 --> 00:04:15,722
而且最终能够发送一些分析数据

80
00:04:18,425 --> 00:04:19,660
让我们先来看主界面

81
00:04:20,494 --> 00:04:21,862
在当前实现中

82
00:04:21,928 --> 00:04:25,599
我反复不断地
加载一个固定计时器

83
00:04:26,400 --> 00:04:29,002
让我们来看
这样做的电量影响

84
00:04:29,937 --> 00:04:34,474
乍看上去
这并不会耗用太多的电量

85
00:04:35,309 --> 00:04:39,713
但是前面我们说过
实际上 启动无线信号

86
00:04:40,647 --> 00:04:44,918
然后使其进入睡眠状态
这个过程会产生电量开销

87
00:04:46,820 --> 00:04:48,722
因此 虽然你仅进行少量的工作

88
00:04:48,889 --> 00:04:50,357
也会产生这些开销

89
00:04:50,557 --> 00:04:53,327
这会对电量使用情况
产生较大的影响

90
00:04:54,061 --> 00:04:55,662
那么 我们应该如何优化呢？

91
00:04:57,531 --> 00:05:01,068
首先 应该仅在
用户交互时进行重新加载

92
00:05:01,568 --> 00:05:04,204
或者在收到通知时这样做
例如紧急新闻通报

93
00:05:05,539 --> 00:05:08,342
接下来 你需要使用
NSURL会话默认会话

94
00:05:08,609 --> 00:05:11,778
有一个新属性
名为WaitsForConnectivity

95
00:05:12,646 --> 00:05:14,214
它让你能够知道

96
00:05:14,281 --> 00:05:17,251
何时连接到你选择的服务器

97
00:05:17,985 --> 00:05:21,255
另外 还需要使用
NSURL会话缓存

98
00:05:22,356 --> 00:05:27,160
这让你不必反复不断地

99
00:05:27,628 --> 00:05:30,531
加载主界面
从而避免这些额外开销

100
00:05:32,699 --> 00:05:36,036
让我们来看这些优化
对电量的影响

101
00:05:37,337 --> 00:05:41,108
这里 可以看到
反复出现的耗电高峰消失不见了

102
00:05:41,542 --> 00:05:45,012
现在 只会在用户交互
和收到通知时进行重新加载

103
00:05:45,546 --> 00:05:48,015
而且消除了
所有额外的电量开销

104
00:05:48,882 --> 00:05:50,083
这可以延长电量使用时间

105
00:05:51,985 --> 00:05:53,620
让我们来看如何进行编码

106
00:05:54,188 --> 00:05:57,891
首先 我们需要
创建一个默认会话配置

107
00:05:59,293 --> 00:06:03,864
然后我们将这个
等待连接属性设置为真

108
00:06:05,232 --> 00:06:06,800
最后
配置缓存

109
00:06:09,336 --> 00:06:10,470
这就是主要设置工作

110
00:06:10,938 --> 00:06:13,407
接下来 让我们讨论
如何发布照片

111
00:06:14,107 --> 00:06:15,475
在当前的实现中

112
00:06:16,176 --> 00:06:18,478
我想要立即发送这张照片

113
00:06:18,779 --> 00:06:20,681
每次失败后
我想要重新尝试

114
00:06:21,381 --> 00:06:23,483
我必须将这张照片
发送到我的服务器

115
00:06:24,251 --> 00:06:26,386
让我们来看这对电量的影响

116
00:06:27,521 --> 00:06:29,890
这里可以看到电量影响非常高

117
00:06:30,190 --> 00:06:32,793
我们花费大量的时间
来发送我们的照片

118
00:06:32,860 --> 00:06:33,961
最终产生超时

119
00:06:34,027 --> 00:06:35,929
也许是因为网络状况不佳

120
00:06:38,131 --> 00:06:41,301
我们再次尝试
因为必须将照片发送到服务器

121
00:06:41,568 --> 00:06:42,903
我们再次耗用很多的电量

122
00:06:43,770 --> 00:06:46,006
我们并没有为用户提供解决方法

123
00:06:46,073 --> 00:06:47,841
这张照片仍然没有
发送到服务器

124
00:06:48,375 --> 00:06:50,377
这种情况不断地反复出现

125
00:06:51,545 --> 00:06:52,846
如何进行优化呢？

126
00:06:53,881 --> 00:06:56,683
首先 应该尽量减少重试次数

127
00:06:57,451 --> 00:06:59,052
仅尝试两次或三次

128
00:06:59,887 --> 00:07:03,457
接下来 设置合适的超时
比如30秒或1分钟

129
00:07:03,524 --> 00:07:04,892
当网络状态不佳时

130
00:07:04,958 --> 00:07:06,827
不要花费太多时间进行尝试

131
00:07:08,262 --> 00:07:10,430
最后
应该批处理事务

132
00:07:10,497 --> 00:07:12,566
如果还需要同时发布其它照片

133
00:07:12,933 --> 00:07:14,334
应该一起发送它们

134
00:07:15,469 --> 00:07:18,939
最后 如果达到重试次数限制
而不确定应该如何做

135
00:07:19,306 --> 00:07:20,607
可以创建一个后台会话

136
00:07:21,275 --> 00:07:24,144
这样 就能让系统
来处理照片上传工作

137
00:07:24,211 --> 00:07:25,879
找到良好的时机来完成你的工作

138
00:07:27,381 --> 00:07:30,551
让我们来看这些优化
对电量的影响

139
00:07:31,718 --> 00:07:32,853
这里可以看到

140
00:07:33,053 --> 00:07:35,389
我们显著降低
发送照片时的

141
00:07:35,455 --> 00:07:39,226
电量使用量和资源开销

142
00:07:40,260 --> 00:07:42,196
另外 可以看到仍然发生超时

143
00:07:42,262 --> 00:07:44,164
也许是因为网络状态依旧不佳

144
00:07:44,932 --> 00:07:46,633
但是仍然进行第二次尝试

145
00:07:46,934 --> 00:07:48,168
我们创建一个后台会话

146
00:07:48,235 --> 00:07:51,605
现在 我们让系统
处理照片上传工作

147
00:07:52,406 --> 00:07:54,308
通过这种方法
可以高效率地发布照片

148
00:07:54,808 --> 00:07:57,945
现在我们来看
如何发送分析数据

149
00:07:58,011 --> 00:08:00,447
作为开发者
我们十分关心

150
00:08:00,514 --> 00:08:01,915
用户如何使用我们的应用

151
00:08:02,216 --> 00:08:04,017
我们想要确保
发送数据

152
00:08:04,418 --> 00:08:06,086
而不造成电量耗用过多

153
00:08:06,854 --> 00:08:09,389
为此 我们可以使用后台会话

154
00:08:10,057 --> 00:08:12,025
这样可以把上传或

155
00:08:12,292 --> 00:08:14,862
下载工作交给系统
在合适时机执行

156
00:08:15,362 --> 00:08:17,231
此外
还会自动进行尝试

157
00:08:17,297 --> 00:08:22,069
因此不必自己设置重试规则

158
00:08:23,871 --> 00:08:25,939
接下来 它提供吞吐量监测

159
00:08:26,006 --> 00:08:28,809
这意味着
如果吞吐量极低

160
00:08:28,876 --> 00:08:31,245
例如 如果网络状况不佳

161
00:08:31,945 --> 00:08:34,914
任务将会停止
并在系统认为将会成功时

162
00:08:35,115 --> 00:08:36,149
进行重试

163
00:08:37,751 --> 00:08:39,052
最后
有一些新属性

164
00:08:39,586 --> 00:08:41,388
名称为start time
和workload size

165
00:08:41,755 --> 00:08:44,691
可以使用它们
通知系统在最合适的时间执行工作

166
00:08:46,627 --> 00:08:49,396
最后 需要设置
这个discretionary属性

167
00:08:49,463 --> 00:08:52,499
如果你要做的工作
不会立即影响用户

168
00:08:53,333 --> 00:08:55,769
这让系统能够找到
最节省电量的时间

169
00:08:56,103 --> 00:08:57,104
来完成你的工作

170
00:08:59,773 --> 00:09:01,175
让我们来看一个例子

171
00:09:01,909 --> 00:09:05,145
在这里看到
我没有使用后台会话

172
00:09:05,212 --> 00:09:07,414
我将会在需要发送数据

173
00:09:07,481 --> 00:09:09,650
到服务器时
立即进行发送

174
00:09:10,384 --> 00:09:13,487
另外 后面还有一些
其它一些网络操作

175
00:09:14,588 --> 00:09:16,790
这里 将会产生两种开销成本

176
00:09:17,324 --> 00:09:19,626
假设我们使用后台会话

177
00:09:21,395 --> 00:09:24,565
现在可以看到后台会话允许

178
00:09:24,631 --> 00:09:27,401
合并这些事件
将它与其它网络操作组合

179
00:09:28,135 --> 00:09:29,536
帮助我们节省时间

180
00:09:29,603 --> 00:09:31,205
这些其它网络操作将在稍后发生

181
00:09:32,172 --> 00:09:34,741
这可以帮助用户
获得更长的电量使用时间

182
00:09:34,808 --> 00:09:36,443
（社交网络应用的电量影响）

183
00:09:37,978 --> 00:09:39,580
让我们来看如何进行设置

184
00:09:40,113 --> 00:09:42,916
首先 我们将创建
后台会话配置

185
00:09:43,350 --> 00:09:46,253
然后 将discretionary属性
设置为真

186
00:09:48,088 --> 00:09:50,858
接下来
设置另外一些属性

187
00:09:50,924 --> 00:09:54,061
比如开始时间和预期工作量

188
00:09:55,362 --> 00:09:56,697
最后
恢复任务

189
00:09:57,631 --> 00:10:01,101
这就是高效率的
分析数据发送方法

190
00:10:01,502 --> 00:10:03,504
接下来 我想讨论watchOS

191
00:10:04,538 --> 00:10:07,441
手表上的网络应用
会耗用大量的资源

192
00:10:07,608 --> 00:10:09,643
对于想要在屏幕熄灭时
完成的任何工作

193
00:10:09,910 --> 00:10:12,446
你应该使用后台会话

194
00:10:13,547 --> 00:10:15,782
也应该使用它进行复杂的更新

195
00:10:15,849 --> 00:10:17,684
或后台应用刷新

196
00:10:17,985 --> 00:10:21,188
这是因为这样做
能让你在任务完成时接管运行时

197
00:10:21,355 --> 00:10:24,691
从而执行你的网络操作
并在完成时通知你

198
00:10:26,994 --> 00:10:28,695
让我们进行回顾

199
00:10:29,096 --> 00:10:31,465
首先 应该确定你要做的工作

200
00:10:31,865 --> 00:10:35,068
这保证你不会
反复不断地进行事务处理

201
00:10:35,402 --> 00:10:36,737
然后
在合适的情况下

202
00:10:36,803 --> 00:10:39,706
使用后台会话
优化你的工作

203
00:10:40,340 --> 00:10:41,808
接下来
对操作进行合并

204
00:10:41,875 --> 00:10:45,279
批处理这些事务
以节省资源开销

205
00:10:45,746 --> 00:10:48,949
最后 减少你的工作
这主要通过尽量减少重试

206
00:10:49,149 --> 00:10:50,584
和设置合适的超时来实现

207
00:10:52,419 --> 00:10:54,054
关于网络部分就是这些

208
00:10:54,354 --> 00:10:57,057
接下来 我想和你们讨论位置

209
00:10:58,492 --> 00:11:02,262
作为开发者 你们有许多位置API
可供选择

210
00:11:02,563 --> 00:11:05,732
但是今天我想重点讨论
这些API的电量影响

211
00:11:05,799 --> 00:11:08,202
（位置最佳实践
位置API）

212
00:11:08,268 --> 00:11:10,537
假设我想要

213
00:11:10,604 --> 00:11:14,208
为我的应用添加导航功能

214
00:11:15,108 --> 00:11:17,711
为此 需要使用持续性位置更新

215
00:11:18,078 --> 00:11:19,680
其原因是我需要知道

216
00:11:19,746 --> 00:11:21,548
用户是否偏离我的路线

217
00:11:22,249 --> 00:11:24,251
让我能够为他们提供新的指令

218
00:11:24,318 --> 00:11:25,786
帮助他们到达目的地

219
00:11:27,487 --> 00:11:28,922
但需要注意的是

220
00:11:29,423 --> 00:11:31,458
这会阻止进入睡眠状态

221
00:11:31,525 --> 00:11:34,228
因此这会极大地影响电量

222
00:11:35,696 --> 00:11:38,665
因此 在用户到达目的地之后

223
00:11:39,032 --> 00:11:41,835
必须确保
停止这些位置更新

224
00:11:42,536 --> 00:11:44,171
确保设备
能够再次进入睡眠状态

225
00:11:45,072 --> 00:11:46,874
让我们看看应该如何做

226
00:11:47,307 --> 00:11:48,775
首先 我们创建
一个位置管理器

227
00:11:49,676 --> 00:11:51,545
然后 设置一些属性

228
00:11:51,612 --> 00:11:53,580
我想要重点讨论的属性

229
00:11:53,647 --> 00:11:55,015
是目标精度

230
00:11:55,282 --> 00:11:56,917
请认真思考你想要的精度

231
00:11:56,984 --> 00:12:00,354
因为精度越高
耗用的电量就越多

232
00:12:01,288 --> 00:12:03,190
因此 必须确保
你的确需要高精度

233
00:12:03,257 --> 00:12:04,324
然后才进行这样的设置

234
00:12:05,659 --> 00:12:09,229
接下来
需要开始更新位置

235
00:12:11,398 --> 00:12:14,701
完成之后 比如用户到达目的地时

236
00:12:15,035 --> 00:12:16,570
停止更新位置

237
00:12:17,070 --> 00:12:19,540
设备重新进入睡眠状态

238
00:12:22,676 --> 00:12:24,211
这就是连续性位置更新

239
00:12:24,778 --> 00:12:26,647
我们继续来看
其它一些API

240
00:12:26,713 --> 00:12:28,815
它们允许设备更频繁地睡眠

241
00:12:30,017 --> 00:12:31,785
第一个是requestLocation

242
00:12:32,419 --> 00:12:35,222
它获取用户的当前位置

243
00:12:35,289 --> 00:12:39,560
也许 你想要
根据用户的当前位置更新内容

244
00:12:40,327 --> 00:12:43,230
而不必担心
调用开始位置和停止位置

245
00:12:43,297 --> 00:12:45,632
和管理这些调用

246
00:12:47,534 --> 00:12:49,336
接下来 是区域监测

247
00:12:49,870 --> 00:12:52,005
区域监测让你能够

248
00:12:52,072 --> 00:12:55,309
比如说 你想要
在用户到家时更新内容

249
00:12:55,609 --> 00:12:57,244
你不必始终跟踪他们的位置

250
00:12:57,311 --> 00:13:00,214
你可以创建一个区域
当用户经过这个区域时

251
00:13:00,280 --> 00:13:02,282
你可以让运行时
处理你的工作

252
00:13:02,349 --> 00:13:04,451
（位置最佳实践）

253
00:13:04,518 --> 00:13:06,253
访问监测也是如此

254
00:13:06,820 --> 00:13:08,088
访问监测让你知道

255
00:13:08,155 --> 00:13:10,324
用户何时去经常前往的位置

256
00:13:10,858 --> 00:13:12,693
在那个时间
你也会得到一些运行时

257
00:13:12,759 --> 00:13:15,162
而不必持续地
跟踪他们的位置

258
00:13:17,064 --> 00:13:18,665
可以进行下面的设置

259
00:13:20,767 --> 00:13:22,569
最后 还有显著位置变化

260
00:13:23,136 --> 00:13:26,139
可以使用显著位置变化功能
如果你想要知道

261
00:13:26,406 --> 00:13:28,575
用户的物理位置
何时发生显著的变化

262
00:13:28,942 --> 00:13:30,711
而不想使用持续性位置功能

263
00:13:30,777 --> 00:13:33,514
因为持续性位置更新
禁止设备进入睡眠状态

264
00:13:35,182 --> 00:13:38,151
显著位置变化功能
并不禁止设备睡眠

265
00:13:38,318 --> 00:13:40,220
设备可以在更新间隙睡眠

266
00:13:40,888 --> 00:13:42,456
你可以进行一些很好的优化

267
00:13:42,756 --> 00:13:44,291
如果你想要从持续性位置转变为

268
00:13:44,358 --> 00:13:45,592
显著位置变化

269
00:13:45,893 --> 00:13:47,528
来看一个例子
假设你有一个天气应用

270
00:13:47,761 --> 00:13:49,429
需要知道
用户何时发生显著位置变化

271
00:13:49,496 --> 00:13:51,198
然后在这些时间更新天气信息

272
00:13:52,499 --> 00:13:53,867
你可以进行这样的设置

273
00:13:56,436 --> 00:13:59,072
总的来说
首先 你需要确定

274
00:13:59,139 --> 00:14:00,474
想要的精度水平

275
00:14:00,707 --> 00:14:02,843
认真思考是否确实需要高精度

276
00:14:02,910 --> 00:14:04,611
如果不需要 则可以使用较低精度

277
00:14:05,379 --> 00:14:07,214
接下来 应该优化你的工作

278
00:14:07,281 --> 00:14:09,316
尽可能使用不同于

279
00:14:09,550 --> 00:14:11,285
持续性位置更新的其它方案

280
00:14:12,286 --> 00:14:14,388
然后 需要减少工作量

281
00:14:14,621 --> 00:14:16,857
在完成工作之后
立即停止位置更新

282
00:14:17,291 --> 00:14:19,893
同样地 如果保持位置更新

283
00:14:19,960 --> 00:14:21,261
设备就不能进入睡眠状态

284
00:14:22,129 --> 00:14:26,066
最后 需要合并
工作任务 推迟位置更新

285
00:14:26,133 --> 00:14:27,968
也许以后你需要这些位置

286
00:14:28,368 --> 00:14:30,037
虽然你现在可能不需要

287
00:14:31,538 --> 00:14:32,673
关于位置就是这些

288
00:14:33,574 --> 00:14:35,175
接下来 我们讨论图形

289
00:14:35,742 --> 00:14:37,845
图形可能会消耗很多的电量

290
00:14:39,546 --> 00:14:41,481
下面介绍一些良好的指导原则

291
00:14:42,149 --> 00:14:44,585
首先 需要最大限度减少屏幕更新

292
00:14:45,319 --> 00:14:47,821
确保为用户提供
他们所需要的变化内容

293
00:14:49,256 --> 00:14:50,958
接下来
检查你的虚化效果使用情况

294
00:14:51,291 --> 00:14:53,260
不要在经常更新的元素上
使用虚化效果

295
00:14:53,327 --> 00:14:55,963
因为这会耗用大量的电池电量

296
00:14:57,130 --> 00:14:58,432
因此应该引起注意

297
00:15:00,033 --> 00:15:01,535
这是一般性指导原则

298
00:15:01,602 --> 00:15:03,570
让我们重点讨论Mac上的应用

299
00:15:04,238 --> 00:15:07,074
如果在Mac上开发应用
应该知道

300
00:15:07,140 --> 00:15:10,844
一些MacBook配备独立GPU
这些独立GPU

301
00:15:11,078 --> 00:15:14,882
能够为用户呈现精美的图形
提供极高的性能

302
00:15:15,048 --> 00:15:18,418
但是相比集成GPU
它的功耗更高

303
00:15:19,386 --> 00:15:22,923
因此 你必须确保只有集成GPU无法

304
00:15:22,990 --> 00:15:26,894
满足你的动画图形性能要求时
或者无法提供

305
00:15:27,327 --> 00:15:29,563
你需要的功能时
才使用独立GPU

306
00:15:31,865 --> 00:15:34,401
另外 如果在Mac上进行开发

307
00:15:34,635 --> 00:15:37,337
可能需要使用
Metal或OpenGL

308
00:15:38,005 --> 00:15:40,507
如果使用Metal
应该知道

309
00:15:40,574 --> 00:15:42,609
调用Create
System Default Device

310
00:15:42,676 --> 00:15:45,579
将会自动触发独立GPU

311
00:15:46,413 --> 00:15:48,182
因此 如果不需要独立GPU

312
00:15:48,248 --> 00:15:51,151
可以调用
Copy All Devices 然后选择

313
00:15:51,552 --> 00:15:53,220
功耗水平较低的设备

314
00:15:53,787 --> 00:15:57,191
这将确保在必要时
使用集成GPU

315
00:15:59,426 --> 00:16:01,662
对于使用OpenGL的开发人员

316
00:16:02,196 --> 00:16:04,698
需要确保你的应用支持多路转换

317
00:16:05,332 --> 00:16:08,202
因此应设置Automatic
Graphics Switching属性

318
00:16:08,268 --> 00:16:12,306
可在Info.plist中设置
或使用下面的示例

319
00:16:12,372 --> 00:16:13,240
（图形）

320
00:16:13,674 --> 00:16:14,975
原因是

321
00:16:15,209 --> 00:16:19,179
如果不需要独立GPU
就不必让它保持运行状态

322
00:16:19,880 --> 00:16:23,317
在设置这个属性之后
将会自动保持运行

323
00:16:25,886 --> 00:16:29,122
总结
首先需要确定

324
00:16:29,189 --> 00:16:31,892
所要完成的工作
分析虚化效果使用情况

325
00:16:32,192 --> 00:16:34,761
应确保不在经常更新的元素上使用虚化

326
00:16:35,329 --> 00:16:36,830
接下来 应该优化你的工作

327
00:16:37,464 --> 00:16:38,699
如果在Mac上开发

328
00:16:38,765 --> 00:16:41,201
应确保仅在需要提供

329
00:16:41,268 --> 00:16:43,971
优异图形性能时
才使用独立GPU

330
00:16:44,505 --> 00:16:45,506
最后

331
00:16:45,572 --> 00:16:48,675
应尽可能减少屏幕更新
以降低工作量

332
00:16:49,977 --> 00:16:51,044
关于图形就是这些

333
00:16:51,278 --> 00:16:53,380
接下来 我们讨论处理

334
00:16:53,447 --> 00:16:56,216
同样地 处理也会耗用很多电量

335
00:16:58,619 --> 00:17:00,721
下面是一些指导原则

336
00:17:01,021 --> 00:17:04,156
首先 你需要确定必须完成哪些任务

337
00:17:05,125 --> 00:17:07,895
接下来 应该快速且高效率地完成任务

338
00:17:07,961 --> 00:17:09,530
在确定这些任务之后

339
00:17:10,396 --> 00:17:12,566
还应该尽可能地避免使用计时器

340
00:17:12,633 --> 00:17:14,867
应该在用户交互的基础上执行工作

341
00:17:15,102 --> 00:17:17,771
而不是反复地使用固定的计时器

342
00:17:18,672 --> 00:17:20,840
如果确实需要使用计时器

343
00:17:20,907 --> 00:17:24,044
让尝试设置较长的间隙让系统

344
00:17:24,111 --> 00:17:25,878
将计时器与其它工作合并

345
00:17:27,513 --> 00:17:29,750
这是一些基本的处理指导原则

346
00:17:29,816 --> 00:17:32,586
今天 我想重点讨论后台处理

347
00:17:33,387 --> 00:17:36,857
对于用户来说 后台处理
可能非常占用资源

348
00:17:37,090 --> 00:17:39,960
必须思考应该在后台做什么

349
00:17:40,027 --> 00:17:44,097
主要原因是
用户并不了解后台工作

350
00:17:44,765 --> 00:17:46,166
他们看到的只是应用的前台

351
00:17:46,233 --> 00:17:49,603
因此 如果后台占用一些资源
可能并不会引起用户的注意

352
00:17:49,670 --> 00:17:51,839
但是 如果后台占用大量的资源

353
00:17:52,272 --> 00:17:54,374
将会降低用户体验

354
00:17:54,441 --> 00:17:55,742
（后台处理）

355
00:17:55,809 --> 00:17:58,512
这里是一些一般性指导原则

356
00:17:59,112 --> 00:18:02,049
首先 我们需要尽可能快地完成工作

357
00:18:02,349 --> 00:18:05,185
首先思考 “我真的
需要在后台完成这项工作吗？”

358
00:18:05,252 --> 00:18:07,621
如果是 应该找到
最高效的执行方法

359
00:18:08,088 --> 00:18:10,224
接下来 如果想要更新内容

360
00:18:10,524 --> 00:18:12,993
应尝试使用后台程序刷新API

361
00:18:13,660 --> 00:18:16,864
这将帮助你找到
最佳的时机来更新你的内容

362
00:18:17,931 --> 00:18:21,435
最后 应该确保
调用completion 处理程序

363
00:18:21,602 --> 00:18:23,337
无论你使用哪个API

364
00:18:23,570 --> 00:18:26,840
这将确保设备
尽快转变为睡眠状态

365
00:18:26,907 --> 00:18:29,276
而不会继续占用资源不放

366
00:18:32,079 --> 00:18:34,348
iOS 11中的新功能：

367
00:18:34,414 --> 00:18:37,451
这是PushKit API中
的completion处理程序

368
00:18:37,885 --> 00:18:41,221
它允许设备
很快地返回睡眠状态

369
00:18:41,288 --> 00:18:43,824
在处理你的
incoming push之后

370
00:18:44,791 --> 00:18:47,828
如果使用PushKit
应该确保这样做/font>

371
00:18:48,962 --> 00:18:50,797
让我们来看一个例子

372
00:18:51,498 --> 00:18:55,035
在这里看到 我没有调用
completion处理程序

373
00:18:55,102 --> 00:18:56,837
在这个例子中 当我接收
incoming push时

374
00:18:56,904 --> 00:18:59,873
仅进行一些处理
然后在固定时间之后

375
00:18:59,940 --> 00:19:02,176
让设备进入睡眠状态

376
00:19:03,844 --> 00:19:08,015
现在 让我们来看看
优化带来的电量影响

377
00:19:08,482 --> 00:19:11,518
通过调用completion处理程序
设备将会

378
00:19:11,585 --> 00:19:14,621
更快地进入睡眠状态
这不仅节省

379
00:19:14,688 --> 00:19:17,724
后台工作耗用的电量而且节省开销

380
00:19:18,392 --> 00:19:22,429
如果使用PushKit
将可以延长电池使用时间

381
00:19:22,496 --> 00:19:23,797
（使用COMPLETION处理程序）

382
00:19:24,965 --> 00:19:28,068
让我们来看看
Watch上的后台处理

383
00:19:28,135 --> 00:19:31,672
后台导航模式是一种新技术

384
00:19:32,206 --> 00:19:35,776
与Watch的其它后台模式一样
也存在CPU限制

385
00:19:36,743 --> 00:19:39,379
此外 如果确实想要保证尽量减少

386
00:19:39,446 --> 00:19:42,482
这种后台模式下的网络操作

387
00:19:42,683 --> 00:19:48,488
请认真地思考 我真的需要这样做吗
或者 我的用户关心

388
00:19:48,555 --> 00:19:50,457
我做的这些网络更新吗

389
00:19:51,625 --> 00:19:53,961
也许 这适用于流量重路由

390
00:19:54,628 --> 00:19:56,563
或重要的流量信息

391
00:19:57,631 --> 00:20:01,168
最后 应使用后台应用刷新
和并发更新

392
00:20:01,235 --> 00:20:02,402
来更新你的数据

393
00:20:02,703 --> 00:20:06,373
当你使用这些API时
必须使用后台会话

394
00:20:06,440 --> 00:20:08,308
以获取数据

395
00:20:08,375 --> 00:20:11,378
这样就不必等待数据进来

396
00:20:13,313 --> 00:20:14,581
总结

397
00:20:14,848 --> 00:20:17,584
首先 你应该确定
在后台进行哪些工作

398
00:20:17,651 --> 00:20:22,656
必须确保后台进程
为用户提供有用的信息

399
00:20:23,557 --> 00:20:26,393
因此需要使用后台程序刷新来
优化你的工作

400
00:20:26,460 --> 00:20:27,628
应该尽可能这样做

401
00:20:28,795 --> 00:20:31,098
接下来 通过限制事务数量来减少

402
00:20:31,164 --> 00:20:32,199
后台处理工作量

403
00:20:33,166 --> 00:20:36,170
最后 应尽可能使用后台会话

404
00:20:38,805 --> 00:20:41,508
接下来 我的同事
将会上台 与大家一起讨论

405
00:20:41,575 --> 00:20:44,745
一些可用的节能工具
并为大家进行演示

406
00:20:48,081 --> 00:20:49,249
谢谢 丹尼尔

407
00:20:52,186 --> 00:20:55,022
大家早上好
我是普拉加卡·卡拉迪卡

408
00:20:55,322 --> 00:20:56,890
是电量管理团队的工程师

409
00:20:58,492 --> 00:21:02,396
你们已经了解编写
节能代码方面的最佳实践

410
00:21:03,330 --> 00:21:06,533
现在我将介绍一些电量调试工具

411
00:21:06,600 --> 00:21:07,801
它们是我们自己开发的

412
00:21:08,569 --> 00:21:10,771
我们将了解如何使用这些工具

413
00:21:11,071 --> 00:21:15,175
来评估应用的节能效率或电量影响

414
00:21:16,210 --> 00:21:19,413
这些工具将帮助你们找到
应用中的一些

415
00:21:19,479 --> 00:21:21,748
与电量相关的高层次问题

416
00:21:22,482 --> 00:21:25,886
或主要的问题方面
并帮助你们解决这些问题

417
00:21:26,920 --> 00:21:28,789
最后
我们将进行一个演示

418
00:21:29,122 --> 00:21:33,327
我会使用一些示例应用
使用我们的新工具

419
00:21:33,560 --> 00:21:38,065
进行调试以发现电量问题
确立调试流程

420
00:21:38,131 --> 00:21:40,267
以便于你调试自己的应用

421
00:21:41,768 --> 00:21:45,639
首先 让我们来看
为什么评估应用的效率很重要

422
00:21:46,673 --> 00:21:50,277
假设你开发了一个很不错的应用
具有非常出色的功能

423
00:21:50,344 --> 00:21:52,179
但并没有评估
它的电量影响

424
00:21:52,913 --> 00:21:56,583
结果发现 这个应用的电量影响非常高

425
00:21:56,984 --> 00:21:59,586
即使只使用了很短的时间

426
00:22:00,654 --> 00:22:04,525
自然地 电量管理界面会将这个应用

427
00:22:04,591 --> 00:22:06,527
标注为最耗电的程序

428
00:22:07,027 --> 00:22:11,164
使用这个应用的用户发现
在很短的时间里

429
00:22:11,231 --> 00:22:14,434
你的应用耗用了很多的电量

430
00:22:15,202 --> 00:22:18,605
用户很可能会删除你的应用

431
00:22:18,805 --> 00:22:21,308
这绝对是你不愿意看到的

432
00:22:21,375 --> 00:22:22,276
（设置：电量）

433
00:22:22,342 --> 00:22:24,845
作为应用开发者很重要的一点是

434
00:22:24,912 --> 00:22:28,115
评估应用的电量使用效率

435
00:22:28,282 --> 00:22:29,550
或电量影响

436
00:22:30,651 --> 00:22:32,619
为了帮助你们进行评估

437
00:22:32,920 --> 00:22:35,556
我们推出经过改进的
新Energy Gauges

438
00:22:36,323 --> 00:22:40,093
这些工具是Xcode的组成部分
你们已经很熟悉

439
00:22:41,428 --> 00:22:45,032
Energy Gauges设计用于
高级概览

440
00:22:45,332 --> 00:22:48,368
显示应用的所有电量相关问题

441
00:22:49,036 --> 00:22:52,339
它们将会告诉你
应用中的哪些部分耗用过多电量

442
00:22:53,373 --> 00:22:56,577
还指导你使用正确的方法

443
00:22:56,743 --> 00:23:01,248
深入研究这些问题区域解决这些问题

444
00:23:02,983 --> 00:23:06,220
那么 可以在Xcode内哪个位置
找到Energy Gauges？

445
00:23:07,120 --> 00:23:09,356
使用XCode
启动你的应用时

446
00:23:10,090 --> 00:23:11,792
点击排除故障导航栏

447
00:23:12,726 --> 00:23:16,864
一系列的性能计量表
将在屏幕左侧打开

448
00:23:17,898 --> 00:23:22,503
这些是系统基本指标
比如CPU、内存、

449
00:23:22,836 --> 00:23:24,671
网络和磁盘等

450
00:23:25,472 --> 00:23:29,943
在iOS和macOS中
其中一个计量表是电量影响

451
00:23:31,178 --> 00:23:33,680
点击这个电量影响计量表时

452
00:23:34,081 --> 00:23:37,317
电量报告将在屏幕右侧打开

453
00:23:38,452 --> 00:23:41,188
让我们来看这个报告的各个部分

454
00:23:41,588 --> 00:23:42,990
（平均电量影响）

455
00:23:43,223 --> 00:23:45,425
在报告的左上角

456
00:23:45,859 --> 00:23:50,364
你会看到一个值
显示应用的总体耗电水平

457
00:23:50,597 --> 00:23:53,133
或总体耗电评分

458
00:23:54,468 --> 00:23:55,536
旁边有一个

459
00:23:56,236 --> 00:23:58,639
计量表
包含三个区域：

460
00:23:58,805 --> 00:24:02,576
绿色、黄色和红色区域
分别对应于低、

461
00:24:02,643 --> 00:24:05,245
高和极高电量影响

462
00:24:06,146 --> 00:24:09,082
这个报告的坏消息是

463
00:24:09,283 --> 00:24:12,586
正在调试的这个应用

464
00:24:12,653 --> 00:24:14,788
具有高平均电量影响

465
00:24:15,956 --> 00:24:19,193
好消息是对你的应用

466
00:24:19,259 --> 00:24:21,929
进行改进或优化时

467
00:24:21,995 --> 00:24:24,298
这个计量表让你知道

468
00:24:24,364 --> 00:24:25,465
是否朝正确方向发展

469
00:24:25,632 --> 00:24:28,535
也就是说 指针应该位于绿色区域
即低电量影响区域

470
00:24:28,836 --> 00:24:31,238
也会指示是否在朝错误方向发展
指针位于红色区域

471
00:24:31,305 --> 00:24:33,307
即极高
电量影响区域

472
00:24:34,308 --> 00:24:37,978
如果你的应用位于
位于黄色区域

473
00:24:38,045 --> 00:24:39,379
或高影响区域

474
00:24:39,880 --> 00:24:42,616
你应该查看

475
00:24:42,816 --> 00:24:45,052
报告右上角的饼图

476
00:24:45,118 --> 00:24:46,119
（各组件平均耗电量）

477
00:24:46,186 --> 00:24:50,424
这个屏图告诉你
主要组件

478
00:24:50,858 --> 00:24:54,561
在iOS上的平均耗电量

479
00:24:54,895 --> 00:24:56,763
前面丹尼尔已经讲过

480
00:24:57,998 --> 00:24:59,132
你应该问自己

481
00:24:59,466 --> 00:25:06,206
你的应用真需占用这么多
CPU、GPU、网络和位置资源吗？

482
00:25:07,274 --> 00:25:09,209
你可以消除

483
00:25:09,276 --> 00:25:12,312
应用不必要处理的工作

484
00:25:13,080 --> 00:25:15,649
你的应用可能存在某些漏洞

485
00:25:15,916 --> 00:25:18,352
让一些硬件始终保持运行

486
00:25:18,519 --> 00:25:21,054
从而产生严重的电量影响

487
00:25:22,189 --> 00:25:23,323
举例来说

488
00:25:23,657 --> 00:25:26,059
假设你开发一个游戏应用

489
00:25:26,360 --> 00:25:28,762
它仅使用CPU和GPU

490
00:25:29,263 --> 00:25:33,734
而且仅需要极少的位置服务
在用户开始玩游戏时

491
00:25:33,800 --> 00:25:35,569
应用访问用户的位置

492
00:25:36,336 --> 00:25:39,907
但是 如果在电量报告中
饼图告诉你

493
00:25:39,973 --> 00:25:42,576
位置服务的使用频率非常高

494
00:25:42,776 --> 00:25:45,612
这可能表明应用存在漏洞

495
00:25:45,812 --> 00:25:48,248
而持续性地访问位置

496
00:25:48,649 --> 00:25:52,152
造成过多的电量流失

497
00:25:53,720 --> 00:25:56,823
在消除应用中
不需要使用的功能之后

498
00:25:56,890 --> 00:26:00,894
接下来你应该针对饼图中

499
00:26:00,961 --> 00:26:04,631
耗电量明显过高或
耗电量最大的区域进行优化

500
00:26:05,499 --> 00:26:07,201
在这个例子中

501
00:26:07,835 --> 00:26:11,038
我们看到红色区域表示开销

502
00:26:11,104 --> 00:26:12,873
是饼图中耗电量最大的部分

503
00:26:13,774 --> 00:26:17,878
我们知道 开销是无线电和

504
00:26:17,945 --> 00:26:22,049
应用需要的所有其它系统硬件
启动和运行时

505
00:26:22,115 --> 00:26:23,951
所耗用的电量

506
00:26:24,852 --> 00:26:27,955
这似乎是正确的
因为你的应用

507
00:26:28,021 --> 00:26:30,357
还使用网络组件

508
00:26:31,024 --> 00:26:33,360
网络将会启动无线电

509
00:26:33,527 --> 00:26:36,230
这将长时间耗用电量

510
00:26:37,297 --> 00:26:41,235
因此 在本例中
可以优化网络使用

511
00:26:41,869 --> 00:26:44,071
请尝试尽可能地批处理应用中的

512
00:26:44,137 --> 00:26:48,175
所有网络活动从而降低网络

513
00:26:48,242 --> 00:26:51,178
的耗电量以及因此产生的

514
00:26:51,245 --> 00:26:52,679
相关开销

515
00:26:54,481 --> 00:26:56,717
知道应该优化哪个主要组件

516
00:26:56,783 --> 00:27:00,320
或者改进应用的哪个部分之后

517
00:27:01,321 --> 00:27:03,457
应该查看分区条形图

518
00:27:03,524 --> 00:27:05,626
或报告的即时区域

519
00:27:05,692 --> 00:27:06,593
（电量影响）

520
00:27:06,760 --> 00:27:08,729
此区域每秒更新一次

521
00:27:09,830 --> 00:27:11,231
因此很容易发现

522
00:27:11,298 --> 00:27:15,836
你的应用的耗电量是否一直正常

523
00:27:16,737 --> 00:27:19,573
因此 在使用Energy Gauge
调试应用期间

524
00:27:19,640 --> 00:27:22,876
当你执行某些操作或方案时

525
00:27:23,377 --> 00:27:28,749
在这里可以看到
应用在哪个时间点耗用电量

526
00:27:29,149 --> 00:27:32,753
哪些不同的组件在产生工作负荷

527
00:27:34,087 --> 00:27:37,891
这个区域告诉你
当应用在前台

528
00:27:37,958 --> 00:27:41,628
或后台运行时
或处于挂起状态时

529
00:27:41,862 --> 00:27:43,130
是否产生工作负荷

530
00:27:43,997 --> 00:27:47,501
在这里 你可以核实
你是否遵守良好的原则

531
00:27:47,734 --> 00:27:51,805
尽可能少在后台处理工作

532
00:27:51,872 --> 00:27:53,073
或者不处理工作

533
00:27:53,140 --> 00:27:55,576
而且当应用在后台运行时
立即进入

534
00:27:55,776 --> 00:27:57,678
挂起状态

535
00:27:59,446 --> 00:28:03,383
如果点击这些条图中的任何一个

536
00:28:03,617 --> 00:28:07,921
将会细详地描述
每个组件的电量耗用情况

537
00:28:07,988 --> 00:28:08,856
（后台）

538
00:28:09,089 --> 00:28:12,993
参考这个区域很容易发现

539
00:28:13,060 --> 00:28:17,030
在你的应用中
可以减少或合并哪些工作

540
00:28:18,065 --> 00:28:21,502
在这个例子中
可以看到 你反复不断地

541
00:28:21,568 --> 00:28:25,005
进行网络活动
因此 总是不断地

542
00:28:25,072 --> 00:28:27,941
导致网络影响
并因此而产生

543
00:28:28,008 --> 00:28:29,309
开销影响

544
00:28:29,710 --> 00:28:33,380
这个例子很好地告诉你
应该批处理所有网络工作

545
00:28:33,580 --> 00:28:36,917
这将会降低应用的电量影响

546
00:28:39,920 --> 00:28:43,223
在报告底部显示在iOS上

547
00:28:43,290 --> 00:28:47,027
耗用电量的不同组件的信息

548
00:28:47,294 --> 00:28:50,230
并提供一些有用的提示
告诉你如何减少

549
00:28:50,297 --> 00:28:53,867
各个组件的电量影响

550
00:28:55,402 --> 00:28:59,473
这些提示的右边有一些按钮
点击可查看仪表

551
00:29:00,340 --> 00:29:02,709
比如 在Energy Gauge报告中

552
00:29:02,776 --> 00:29:07,548
你应用的CPU占用率是最高的

553
00:29:07,948 --> 00:29:10,684
你想对此进行优化

554
00:29:11,218 --> 00:29:13,954
你可以点击Time Profiler仪表

555
00:29:14,354 --> 00:29:18,492
调试会话将会
进入Time Profiler仪表

556
00:29:18,559 --> 00:29:19,860
（仪表）

557
00:29:19,927 --> 00:29:24,131
Time Profiler观察进程中的
所有正在运行的线程

558
00:29:24,398 --> 00:29:28,202
以固定的间隔生成样本

559
00:29:28,769 --> 00:29:32,239
可以完成向后追溯所有这些样本

560
00:29:32,306 --> 00:29:36,176
可以在Extended View区域中
的右侧看到它们

561
00:29:37,110 --> 00:29:40,280
这可以帮助你弄清楚应用中的

562
00:29:40,347 --> 00:29:44,618
哪些代码行大量地占用CPU时间

563
00:29:44,885 --> 00:29:47,788
应用中的哪些部分占用最多CPU时间

564
00:29:48,222 --> 00:29:52,159
应用中的哪些函数
过多地执行CPU指令

565
00:29:52,392 --> 00:29:55,128
这样你可以优化这部分代码

566
00:29:55,562 --> 00:29:58,899
然后使用Energy Gauges
返回调试

567
00:30:00,934 --> 00:30:05,772
同样地 如果Energy Gauges报告
告诉你 位置服务使用频率过高

568
00:30:05,839 --> 00:30:10,077
那么应该针对这个问题进行优化

569
00:30:10,410 --> 00:30:12,946
你可以点击Location Profiler

570
00:30:13,847 --> 00:30:16,817
它将告诉你哪些代码块

571
00:30:16,884 --> 00:30:19,987
访问了核心位置管理器

572
00:30:21,054 --> 00:30:24,358
你还可以看到
这些调用所要求的精度

573
00:30:24,424 --> 00:30:29,296
以及这些调用
所产生的电量影响

574
00:30:30,030 --> 00:30:31,832
在这个例子中

575
00:30:31,899 --> 00:30:36,203
应用中的代码不断地
访问位置管理器

576
00:30:36,470 --> 00:30:40,440
而且使用最高的精度要求
因此这些位置调用

577
00:30:40,507 --> 00:30:43,410
会产生极高的电量影响

578
00:30:44,411 --> 00:30:46,647
而且也很容易发现你是否

579
00:30:46,713 --> 00:30:49,116
在系统中留下任何漏洞

580
00:30:49,483 --> 00:30:53,620
也就是说 所有这些
位置管理器调用是否被成功释放

581
00:30:54,888 --> 00:30:57,925
还可以尝试采用最佳实践方法

582
00:30:58,192 --> 00:31:02,262
在应用中尽可能地使用较低的精度

583
00:31:02,329 --> 00:31:05,432
从而降低由此产生的电量影响

584
00:31:08,635 --> 00:31:10,771
现在我们已经熟悉

585
00:31:10,838 --> 00:31:14,141
多个不同的电量管理调试工具

586
00:31:14,608 --> 00:31:19,046
让我们来看一些方案
在调试程序以解决

587
00:31:19,112 --> 00:31:21,481
电量问题时
你可能会执行这些方案

588
00:31:22,583 --> 00:31:26,286
有一些方案可能适用于所有的程序

589
00:31:26,653 --> 00:31:29,857
例如 这是一个启动和空闲方案

590
00:31:29,923 --> 00:31:33,560
无论用户是否启动应用而不进行交互

591
00:31:34,261 --> 00:31:36,363
第二个是后台运行方案

592
00:31:37,130 --> 00:31:40,400
应该尝试使用Energy Gauges
执行这些方案

593
00:31:40,467 --> 00:31:42,903
并且查看在你的应用上

594
00:31:42,970 --> 00:31:46,607
执行这些操作
会产生什么样的电量影响

595
00:31:48,008 --> 00:31:52,379
接下来 根据你开发的应用的类型

596
00:31:52,446 --> 00:31:55,349
还有一些应用专用的特定方案

597
00:31:56,016 --> 00:31:59,386
例如 如果开发导航应用

598
00:31:59,853 --> 00:32:03,023
一些专门用于你的应用的方案

599
00:32:03,423 --> 00:32:06,693
将会查找特定位置或地址

600
00:32:07,160 --> 00:32:09,663
然后获取该地址的方向

601
00:32:09,730 --> 00:32:12,566
导航到那个特定的位置

602
00:32:13,667 --> 00:32:18,906
因此应该在Energy Gauges上
为你的应用运行这些方案

603
00:32:18,972 --> 00:32:21,275
了解相应的电量影响

604
00:32:21,909 --> 00:32:25,045
在发现主要的电量相关问题之后

605
00:32:25,112 --> 00:32:27,514
进行改进或优化

606
00:32:27,781 --> 00:32:31,018
然后返回这些方案
确保Energy Gauges

607
00:32:31,084 --> 00:32:34,955
告诉你电量影响
已经降低或位于绿色区域

608
00:32:36,223 --> 00:32:40,093
关于这一点
让我进行演示 我们将尝试

609
00:32:40,160 --> 00:32:42,663
在相同的示例应用上
运行这些方案

610
00:32:42,863 --> 00:32:45,332
从而确立一个调试流程

611
00:32:45,399 --> 00:32:47,668
你可以用它调试自己的应用

612
00:32:53,841 --> 00:32:58,212
我要调试的
第一个应用是DemoBots

613
00:32:59,146 --> 00:33:02,783
我在设备上使用Xcode
启动DemoBots

614
00:33:03,984 --> 00:33:06,386
这是我们开发的一个简单游戏

615
00:33:06,987 --> 00:33:10,858
我们希望游戏仅使用CPU和GPU

616
00:33:12,125 --> 00:33:17,231
我点击Debug Navigator
然后点击Energy Impact计量表

617
00:33:18,432 --> 00:33:20,968
这是我们将要执行的第一个方案

618
00:33:21,034 --> 00:33:22,903
它是启动与空闲方案

619
00:33:23,604 --> 00:33:26,273
你希望看到在应用上执行这个操作

620
00:33:26,340 --> 00:33:29,276
将会产生什么样的电量影响

621
00:33:30,377 --> 00:33:35,182
在这里 我们看到
应用的整体评分偏高

622
00:33:35,415 --> 00:33:37,684
因为它具有较高的平均电量影响

623
00:33:38,552 --> 00:33:42,289
接下来 我们想要查看
会使用哪些组件

624
00:33:42,789 --> 00:33:45,993
不出所料
我们仅使用CPU和GPU

625
00:33:46,059 --> 00:33:49,062
没有使用其它不必要的组件 这很不错

626
00:33:49,963 --> 00:33:53,667
接下来 我们来看
这个饼图中面积最大的是哪个部分

627
00:33:53,734 --> 00:33:55,869
我们首先
可以进行什么样的优化

628
00:33:56,770 --> 00:34:02,209
我们看到GPU占用率
水平过高 约为88%

629
00:34:02,543 --> 00:34:06,346
因此 如果你在应用中

630
00:34:06,413 --> 00:34:09,917
对GPU占用率进行优化

631
00:34:09,983 --> 00:34:12,252
将会获得最好的结果

632
00:34:13,253 --> 00:34:16,123
在这里 你可以使用的一些

633
00:34:16,690 --> 00:34:19,159
最佳实践方法
是减少屏幕更新次数

634
00:34:19,226 --> 00:34:25,699
或检查虚化效果使用情况
或者尽可能减少使用不透明效果

635
00:34:26,400 --> 00:34:29,203
这能够降低GPU占用率

636
00:34:29,268 --> 00:34:32,572
和相应的电能影响

637
00:34:33,907 --> 00:34:37,344
现在我们执行另一个方案
也就是后台运行

638
00:34:37,878 --> 00:34:40,013
让我们尝试后台运行这个应用

639
00:34:41,215 --> 00:34:44,083
我们想要查看
它是否进入后台运行状态

640
00:34:44,150 --> 00:34:46,320
或者立即进入挂起状态

641
00:34:47,154 --> 00:34:48,422
在这个例子中

642
00:34:48,487 --> 00:34:51,692
应用立即进入挂起状态

643
00:34:51,757 --> 00:34:55,562
这样很好 因为实际上
这让设备进入睡眠状态

644
00:34:56,230 --> 00:34:59,366
应用不会耗用设备的电量

645
00:35:00,934 --> 00:35:04,071
让我们继续来看另一个应用

646
00:35:05,372 --> 00:35:08,375
我们要调试的第二个应用

647
00:35:09,409 --> 00:35:10,444
是EnergyBuddy

648
00:35:12,713 --> 00:35:16,049
我在设备上使用Xcode
启动EnergyBuddy

649
00:35:17,117 --> 00:35:19,553
这是我们开发的一个简单应用

650
00:35:19,620 --> 00:35:22,422
用于获取电量表的图表

651
00:35:23,023 --> 00:35:26,860
它获取电量表图片中的读数

652
00:35:27,594 --> 00:35:29,696
然后获取你的核心位置

653
00:35:29,763 --> 00:35:33,400
然后使用你的位置
获取该位置的天气信息

654
00:35:33,901 --> 00:35:37,971
所有这些信息都
在稍后存入数据库 你可以检索

655
00:35:39,273 --> 00:35:44,311
我点击Debug Navigator
然后转到Memory Impact计量表

656
00:35:45,279 --> 00:35:47,181
对不起 是Energy Impact计量表

657
00:35:47,814 --> 00:35:50,551
在这里 我们将执行第一个方案

658
00:35:51,051 --> 00:35:52,219
也就是启动与空闲方案

659
00:35:53,020 --> 00:35:53,921
因此

660
00:35:54,321 --> 00:35:57,891
在这里 我们看到
电量影响为零 这很好

661
00:35:58,559 --> 00:36:01,461
唯一使用的组件是CPU

662
00:36:01,528 --> 00:36:03,163
启动应用时需要使用它

663
00:36:04,264 --> 00:36:07,201
现在让我们执行
应用专用的方案

664
00:36:08,268 --> 00:36:10,170
让我们尝试导入一张照片

665
00:36:10,237 --> 00:36:14,308
并查看在我的应用上
执行这个特定操作

666
00:36:14,374 --> 00:36:16,810
造成的电量影响

667
00:36:18,412 --> 00:36:19,813
当我导入照片时

668
00:36:19,880 --> 00:36:25,385
我将接受一张照片
并允许EnergyBuddy访问位置

669
00:36:26,854 --> 00:36:30,090
这将生成一张图片
显示应用获取的电表读数

670
00:36:31,291 --> 00:36:34,061
在即时区域
我们可以看到

671
00:36:34,361 --> 00:36:36,630
在执行这个特定操作时

672
00:36:37,497 --> 00:36:41,034
我的应用使用CPU进行处理

673
00:36:41,401 --> 00:36:44,605
而且它还使用位置组件

674
00:36:45,906 --> 00:36:48,442
这符合我们的预期
因为我们希望

675
00:36:48,675 --> 00:36:51,011
在导入这张照片之后

676
00:36:51,078 --> 00:36:54,114
应用立即获取位置
然后使用这个位置

677
00:36:54,181 --> 00:36:55,649
获取天气信息

678
00:36:56,583 --> 00:37:01,054
但是我们看到
应用持续地访问核心位置

679
00:37:01,688 --> 00:37:04,191
这可能是代码中的一个漏洞

680
00:37:04,258 --> 00:37:07,561
持续不断地访问核心位置

681
00:37:08,061 --> 00:37:11,098
你可以在应用中修复这个问题

682
00:37:11,598 --> 00:37:15,102
然后返回这个特定的照片导入方案

683
00:37:15,169 --> 00:37:18,338
确保电量影响已经降低

684
00:37:20,207 --> 00:37:22,843
让我们尝试后台运行这个应用

685
00:37:24,411 --> 00:37:27,247
当我后台运行这个应用时
我们希望程序

686
00:37:27,314 --> 00:37:29,616
尽快进入挂起状态

687
00:37:30,984 --> 00:37:35,822
但是我们看到应用进入后台运行状态

688
00:37:35,889 --> 00:37:39,526
而且在后台运行状态下
持续地访问核心位置

689
00:37:40,294 --> 00:37:42,963
这对用户来说并没有任何用处

690
00:37:43,030 --> 00:37:46,099
可以在应用中进行优化

691
00:37:47,334 --> 00:37:51,972
我们访问核心位置
但是这种调用没有正确地结束

692
00:37:52,039 --> 00:37:54,842
因此会持续不断地使用核心位置

693
00:37:54,908 --> 00:37:59,613
从而导致非常高的位置服务使用频率
这在饼图中可以看到

694
00:38:00,714 --> 00:38:04,251
在后台运行区域
还可以看到一个灰色部分

695
00:38:04,318 --> 00:38:08,589
这是保持设备唤醒状态
所需要的恒定电量

696
00:38:08,989 --> 00:38:12,726
只要你的应用导致设备处于后台状态

697
00:38:12,793 --> 00:38:14,328
就始终会

698
00:38:14,394 --> 00:38:15,829
耗用一定的电量

699
00:38:15,896 --> 00:38:18,599
这是你的应用所固有的电量耗用

700
00:38:20,100 --> 00:38:23,203
当你尝试进行调试以发现电量问题时

701
00:38:23,570 --> 00:38:27,841
希望你在设备上运行这些方案

702
00:38:30,577 --> 00:38:35,315
确定哪些方案
对你的应用来说具有意义

703
00:38:36,083 --> 00:38:38,919
使用Energy Gauges
运行这些方案

704
00:38:39,119 --> 00:38:41,955
通过报告查看执行这些方案

705
00:38:42,022 --> 00:38:43,557
带来哪些电量影响变化

706
00:38:44,324 --> 00:38:48,395
确保在应用中进行必要的改进或优化

707
00:38:48,762 --> 00:38:50,797
使用仪表进行更深入的分析

708
00:38:51,231 --> 00:38:53,333
解决相关的电量问题

709
00:38:54,201 --> 00:38:58,505
之后应该返回方案
此时应该已经完成代码修改

710
00:38:58,572 --> 00:39:01,008
并且核实Energy Gauges已经表明

711
00:39:01,074 --> 00:39:04,845
电量影响已经降低或者进入绿色区域

712
00:39:06,046 --> 00:39:09,116
现在 我想把舞台交回给丹尼尔

713
00:39:09,183 --> 00:39:11,952
进行最后的归纳和总结

714
00:39:15,923 --> 00:39:17,491
（最后归纳）

715
00:39:17,558 --> 00:39:19,493
你们已经看到
应该使用Energy Gauges

716
00:39:19,560 --> 00:39:22,129
它帮助你发现应用中的
电量使用改进机会

717
00:39:22,896 --> 00:39:24,565
让我们进行最后的归纳和总结

718
00:39:25,766 --> 00:39:29,770
首先 希望你们尽可能地
使用NSURL会话后台会话

719
00:39:30,204 --> 00:39:33,240
这将帮助系统发现
最佳的时机来处理你的工作

720
00:39:34,141 --> 00:39:36,810
接下来 应确保
尽量少使用持续性位置访问

721
00:39:37,110 --> 00:39:39,479
请记住 这将使设备保持唤醒状态

722
00:39:40,514 --> 00:39:41,615
然后 应避免使用计时器

723
00:39:42,282 --> 00:39:45,052
如果需要计时器
应设置间隙以确保进行合并

724
00:39:45,586 --> 00:39:47,454
最后 应使用Energy Gauges

725
00:39:47,754 --> 00:39:49,823
这将帮助你发现良好的优化机会

726
00:39:50,691 --> 00:39:52,025
这里是一些相关的演讲

727
00:39:52,092 --> 00:39:54,061
这些演讲视频很有价值
希望你们观看

728
00:39:54,294 --> 00:39:55,362
非常感谢

