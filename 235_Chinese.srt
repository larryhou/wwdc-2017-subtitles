1
00:00:31,131 --> 00:00:31,999
下午好

2
00:00:32,332 --> 00:00:34,101
感谢你们的到来
我叫Noah

3
00:00:34,168 --> 00:00:35,602
我是和我的同事Warren一起来的

4
00:00:35,702 --> 00:00:39,339
我们会给你们介绍一下
有关构建视觉丰富的用户体验

5
00:00:40,607 --> 00:00:42,342
我们今天主要会介绍三个方面的内容

6
00:00:44,011 --> 00:00:46,079
第一个是平台概览

7
00:00:46,146 --> 00:00:49,850
我们会很快地介绍下

8
00:00:50,184 --> 00:00:52,186
平台上的图形框架

9
00:00:52,252 --> 00:00:54,454
它们会实现什么功能
它们是如何结合到一起使用的

10
00:00:55,455 --> 00:00:59,493
接着我们会介绍一个

11
00:00:59,560 --> 00:01:03,664
图形平台协调的重要组成部分

12
00:01:04,298 --> 00:01:08,168
还有一些你可以用来避免
常见错误的最优方法

13
00:01:08,235 --> 00:01:10,704
人们在使用CA的时候
经常会犯这样的错误

14
00:01:12,172 --> 00:01:15,242
最后我们会花点时间介绍一些小技巧

15
00:01:15,309 --> 00:01:18,846
一些很小很有趣并且很有用的技巧

16
00:01:18,912 --> 00:01:21,181
它们能给你的应用增添一些
很酷的视觉色彩

17
00:01:23,417 --> 00:01:24,251
那么

18
00:01:24,384 --> 00:01:27,221
如果你花时间看过文档

19
00:01:27,287 --> 00:01:29,056
或者只是浏览了一下
stackoverflow

20
00:01:29,122 --> 00:01:32,526
你就会发现很多的概念

21
00:01:32,993 --> 00:01:35,028
这些概念很多

22
00:01:35,095 --> 00:01:38,966
如果有时间把每个都看一下当然最好

23
00:01:39,666 --> 00:01:42,503
基本得花上一整天的时间
但是我们不能这么做

24
00:01:42,836 --> 00:01:44,271
所以我们只会从大体上讲一下

25
00:01:45,239 --> 00:01:49,443
让我们谈一下iOS
macOS和tvOS上有什么吧

26
00:01:50,878 --> 00:01:51,712
首先

27
00:01:52,045 --> 00:01:53,514
你们当中有些人可能很熟悉这个概念

28
00:01:53,580 --> 00:01:56,550
你可以用UIKit和AppKit
这两个框架构建

29
00:01:57,084 --> 00:01:59,586
你们应用中的绝大多数UI

30
00:01:59,653 --> 00:02:02,055
它们会给你提供系统控制的标准集

31
00:02:02,356 --> 00:02:03,957
它们在一定程度上是可以定制化的

32
00:02:04,024 --> 00:02:06,994
所以你可以让你的滑动条
变得比一般的酷得多

33
00:02:07,995 --> 00:02:11,565
它们还有一些很实用的内置功能

34
00:02:11,632 --> 00:02:13,300
你会获得这些标准外观

35
00:02:13,367 --> 00:02:15,836
转换动画还有诸如此类的东西

36
00:02:15,903 --> 00:02:19,239
而且你还会得到有关易用性功能
和创新动态类型的支持

37
00:02:20,807 --> 00:02:23,777
所以我说它们可以让你
在某种程度上定制一些内容

38
00:02:23,844 --> 00:02:27,114
但是如果你想做的
不仅仅是设定个颜色

39
00:02:27,181 --> 00:02:29,249
或者是图像覆盖这类操作的话

40
00:02:30,250 --> 00:02:32,653
你可能就得用到像是
Core Animation这类框架

41
00:02:33,620 --> 00:02:38,625
你可能已经注意到了 在iOS上
Core Animation是UIKit的基础

42
00:02:38,692 --> 00:02:41,962
而且它还跟Mac上的
AppKit有紧密的联系

43
00:02:43,096 --> 00:02:47,201
iOS上的视图就像是一个层

44
00:02:47,434 --> 00:02:50,571
而你应用中显示的内容

45
00:02:50,838 --> 00:02:52,773
就是这些层的体系结构
它们会一起出现

46
00:02:53,106 --> 00:02:57,444
CA很擅长处理这种问题

47
00:02:57,511 --> 00:03:01,248
它可以将已有的内容整合到一起
然后将其在层级结构中进行显示

48
00:03:01,315 --> 00:03:03,283
这些内容是可以移动的
还可以动画化等

49
00:03:03,750 --> 00:03:06,620
最后将所有的内容整合到一起
然后显示到屏幕上

50
00:03:08,589 --> 00:03:09,423
那么

51
00:03:11,992 --> 00:03:12,926
除此之外

52
00:03:13,093 --> 00:03:14,394
我们还有其他一些框架

53
00:03:14,461 --> 00:03:16,630
可以用来实现某些特殊功能

54
00:03:18,765 --> 00:03:19,600
Core Graphics

55
00:03:20,200 --> 00:03:21,702
就是其中之一
你可能已经接触过了

56
00:03:21,768 --> 00:03:26,540
它可以让你实现非常精细地
定制化2D图像绘制

57
00:03:26,607 --> 00:03:29,643
你可以选择一条路径和一些颜色

58
00:03:29,710 --> 00:03:32,379
然后将它们变成这里
好看的信息泡泡

59
00:03:33,647 --> 00:03:37,551
如果你想在运行时间构建图形
就需要用到Core Graphics

60
00:03:37,618 --> 00:03:39,953
你可以提前就把图形构建好

61
00:03:40,020 --> 00:03:42,422
你可以使用像是Photoshop
Sketch或是Illustrator这类软件

62
00:03:42,756 --> 00:03:45,425
但是Core Graphics
可以让你在代码运行期间

63
00:03:45,492 --> 00:03:47,127
在设备上就将图形构建好

64
00:03:47,761 --> 00:03:48,629
这真的很实用

65
00:03:50,163 --> 00:03:50,998
那么

66
00:03:51,932 --> 00:03:53,834
Core Graphics
对于绘制图形很实用

67
00:03:53,901 --> 00:03:55,836
我们还有另一个处理图像的框架

68
00:03:55,903 --> 00:03:59,039
它可以处理你已经有的图像
这个框架叫Core Image

69
00:04:00,407 --> 00:04:02,543
它会给图像加上一些滤镜

70
00:04:02,609 --> 00:04:09,149
你可以提供一些输入图像
把它们传到Core Image

71
00:04:09,516 --> 00:04:11,919
给它们加上个滤镜

72
00:04:12,786 --> 00:04:16,822
它最后就可以生成渲染好的
加上了滤镜的输出图像

73
00:04:17,724 --> 00:04:20,726
这里就是些简单的颜色转换效果

74
00:04:20,961 --> 00:04:22,396
就像是这样
看起来挺不错的

75
00:04:23,130 --> 00:04:24,631
深褐色
有点不太像深褐色

76
00:04:25,065 --> 00:04:26,433
我不知道这个颜色应该叫什么
这个无所谓

77
00:04:28,235 --> 00:04:30,671
你还可以实现一些有趣的风格化效果

78
00:04:31,205 --> 00:04:33,273
像是这样的卡通画效果

79
00:04:34,308 --> 00:04:39,112
Core Image的绝妙之处
就在于它优化得非常好

80
00:04:39,179 --> 00:04:41,415
我们替你实现了很多功能

81
00:04:42,382 --> 00:04:43,483
所以在你实现某些更复杂的功能

82
00:04:43,550 --> 00:04:47,554
比如同时使用多个滤镜的时候
我们就可以替你完成优化

83
00:04:47,621 --> 00:04:49,323
你可以不必

84
00:04:50,224 --> 00:04:51,058
那个

85
00:04:51,325 --> 00:04:53,126
在你的图片上一遍遍地
重复这个流程

86
00:04:53,193 --> 00:04:55,662
对每个滤镜都这么做
我们可以使其流水线化

87
00:04:56,897 --> 00:04:58,298
更棒的是

88
00:04:58,932 --> 00:05:01,068
所有这些功能基本都可以运行

89
00:05:01,301 --> 00:05:03,470
不管你设备的平行硬件是怎样的

90
00:05:03,670 --> 00:05:06,473
如果你可用的GPU资源不是很多

91
00:05:06,540 --> 00:05:09,343
它就会利用Grand Central Dispatch
这类技术在CPU上运行

92
00:05:09,610 --> 00:05:11,545
它完全是在底层运行的
而且对你是透明的

93
00:05:11,979 --> 00:05:14,014
如果你的设备支持Metal

94
00:05:14,081 --> 00:05:17,618
那么它就可以使用Metal
这很酷

95
00:05:20,521 --> 00:05:23,423
你还需要将一些其他的内容
加入到你的应用中

96
00:05:23,490 --> 00:05:26,593
我们有一些很实用的框架
可以帮助你实现这一点

97
00:05:27,294 --> 00:05:30,264
针对3D的内容 我们推出了
叫作SceneKit的工具

98
00:05:30,831 --> 00:05:34,301
它可以将3D内容加入到你的应用中

99
00:05:34,368 --> 00:05:36,837
它在Xcode中
一些非常好的集成工具

100
00:05:36,904 --> 00:05:39,406
可以让你完成一些操作
像是设置场景

101
00:05:39,840 --> 00:05:42,709
这类操作
我们过会儿还会提到它

102
00:05:44,311 --> 00:05:46,246
我要介绍的另一个框架
是SpriteKit

103
00:05:46,313 --> 00:05:50,317
它主要适用于游戏开发
它会给你提供许多动画基元

104
00:05:50,384 --> 00:05:53,954
它可以实现

105
00:05:54,021 --> 00:05:55,589
物体在屏幕上的移动和交互

106
00:05:57,624 --> 00:05:59,960
还有一个框架

107
00:06:00,027 --> 00:06:02,696
是我想要介绍的

108
00:06:02,763 --> 00:06:04,531
你可能听过它的名字
它就是Metal

109
00:06:06,300 --> 00:06:07,201
并且

110
00:06:07,668 --> 00:06:10,637
Metal就是最基本的图形API

111
00:06:10,804 --> 00:06:11,905
在我们的平台上

112
00:06:12,139 --> 00:06:13,807
其它的东西都构建在它的上面

113
00:06:13,874 --> 00:06:17,544
我刚才只说了Core Image会使用Metal
其实SceneKit会使用Metal绘图

114
00:06:17,611 --> 00:06:19,346
在支持它的设备上
SpriteKit也会使用Metal

115
00:06:19,680 --> 00:06:22,783
而且Core Animation本身
也是使用Metal的

116
00:06:24,151 --> 00:06:27,688
其实很难确切地描述Metal

117
00:06:28,222 --> 00:06:31,225
是干什么用的
因为你基本上可以利用它实现任何功能

118
00:06:31,291 --> 00:06:33,227
如果你想要使用它的话

119
00:06:34,461 --> 00:06:36,997
它其实就是能让你

120
00:06:37,064 --> 00:06:40,300
以最快的速度接入到底层

121
00:06:40,367 --> 00:06:42,102
的图形硬件

122
00:06:42,669 --> 00:06:45,138
大多数情况下
你都不会直接使用Metal

123
00:06:45,205 --> 00:06:46,673
你会通过这些框架来使用它

124
00:06:46,940 --> 00:06:48,609
但是如果你要构建一些很定制化的东西

125
00:06:48,675 --> 00:06:51,078
这些框架都不能实现此功能的话

126
00:06:51,311 --> 00:06:52,279
这时候你就应该使用Metal了

127
00:06:53,347 --> 00:06:55,582
比如说 在iPhone 7上

128
00:06:56,250 --> 00:06:57,317
抱歉 应该是7 Plus

129
00:06:57,818 --> 00:07:01,388
我们在相机应用中
有个不错的深度域效果

130
00:07:02,222 --> 00:07:04,491
它会对相机拍摄的照片

131
00:07:04,558 --> 00:07:07,427
进行一些深度重构操作

132
00:07:07,594 --> 00:07:10,531
这些数学问题已经超出我的能力范围了

133
00:07:11,398 --> 00:07:14,568
它能得到场景中每个编辑点的深度像素

134
00:07:14,635 --> 00:07:17,204
然后给它们添加一个智能的模糊滤镜

135
00:07:17,271 --> 00:07:18,906
然后你就能得到这个很棒的柔和背景了

136
00:07:19,673 --> 00:07:20,507
这

137
00:07:20,607 --> 00:07:22,876
听起来不像是我给你介绍过的其他框架
对吗？

138
00:07:22,943 --> 00:07:27,381
它是在iOS 10中开发的
而在iOS 11中 又重新开发了

139
00:07:27,447 --> 00:07:28,348
我不知道你们是否注意到了

140
00:07:28,415 --> 00:07:30,250
这些效果在测试版本中变得更棒了

141
00:07:31,385 --> 00:07:32,319
在Metal之上

142
00:07:33,954 --> 00:07:34,922
那么

143
00:07:35,222 --> 00:07:36,190
这就是快速概览

144
00:07:36,523 --> 00:07:38,258
我们就是逐渐深入介绍了这些层

145
00:07:38,825 --> 00:07:40,961
我的目的不是要给你们详细地

146
00:07:41,028 --> 00:07:42,729
解释每个东西都是做什么的

147
00:07:42,796 --> 00:07:45,499
我只是想让你们知道
这些内容能在哪找到

148
00:07:45,566 --> 00:07:46,700
所以如果你的

149
00:07:46,767 --> 00:07:48,202
应用中有些问题需要解决的话

150
00:07:48,669 --> 00:07:50,137
你就可以回忆起

151
00:07:50,871 --> 00:07:54,074
我记得有个固件能实现这个功能
让我来查一下

152
00:07:55,242 --> 00:07:57,744
为了让你们能更多地了解

153
00:07:57,811 --> 00:08:00,013
如何使用它们
还有它们的工作原理

154
00:08:00,681 --> 00:08:02,482
我想让我的同事Warren上来做个演示

155
00:08:08,522 --> 00:08:09,356
谢谢 Noah

156
00:08:17,464 --> 00:08:19,900
在这一系列的演示中
我会给你们介绍下

157
00:08:19,967 --> 00:08:21,902
刚才Noah提到过的一些框架

158
00:08:21,969 --> 00:08:24,671
让我们从UIKit定制化开始看吧

159
00:08:25,205 --> 00:08:26,740
先要说明的是

160
00:08:26,807 --> 00:08:29,309
你不需要关注每一行代码

161
00:08:29,376 --> 00:08:30,911
对于所着重标出或提到的代码

162
00:08:31,311 --> 00:08:34,748
你可以在网上找到这些示例代码
你可以把代码下载了

163
00:08:34,815 --> 00:08:36,549
然后根据自己的时间慢慢研究

164
00:08:36,616 --> 00:08:38,519
在接下来的几分钟里

165
00:08:38,585 --> 00:08:41,154
我会给你们介绍一些平台功能

166
00:08:41,221 --> 00:08:44,324
还有你应该如何使用它们
来增强你应用的用户体验

167
00:08:48,529 --> 00:08:50,030
首先我要给你们展示下

168
00:08:50,097 --> 00:08:52,766
这个UIKit定制化例子
实现了什么功能

169
00:08:55,969 --> 00:08:59,673
这里我有一个可能是
从视频编辑应用中得到的图片

170
00:08:59,940 --> 00:09:02,309
它可以让我控制照片的白平衡

171
00:09:02,943 --> 00:09:05,612
如你所见
我已经修改了UI滑动条

172
00:09:05,679 --> 00:09:06,947
图片底部的滑动条

173
00:09:07,347 --> 00:09:11,218
带有表示每个滑动条实现功能的颜色

174
00:09:11,652 --> 00:09:14,454
上面的滑动条会控制色温

175
00:09:14,855 --> 00:09:17,324
而下面的滑动条会控制色彩

176
00:09:17,558 --> 00:09:18,725
而这些滑动条结合起来

177
00:09:18,792 --> 00:09:22,429
就能让我们控制照片中的白点

178
00:09:25,098 --> 00:09:27,434
我现在想再加点功能

179
00:09:27,501 --> 00:09:28,702
让我添加一个图片吧

180
00:09:29,069 --> 00:09:31,505
我现在就实现一下
并且给你们展示下效果

181
00:09:39,646 --> 00:09:41,615
如你所见 我将一个梯度图片

182
00:09:41,682 --> 00:09:43,584
加到了每个滑动条上
而且滑动条的末尾是圆形的

183
00:09:43,650 --> 00:09:46,353
这会让滑动条看上去更漂亮

184
00:09:46,720 --> 00:09:50,023
还可以提示下这些滑动条是干什么用的

185
00:09:50,624 --> 00:09:52,292
如果我现在调节这些滑动条的话

186
00:09:52,359 --> 00:09:54,595
你会发现图像没有什么变化

187
00:09:54,661 --> 00:09:55,662
在下个例子中

188
00:09:55,729 --> 00:09:59,766
我会给你们介绍如何
真正地实现更改图像的效果

189
00:10:00,801 --> 00:10:03,537
与此同时 我还会

190
00:10:03,737 --> 00:10:08,108
更详细地解释下这个例子
这里我实例化了一个UI图像

191
00:10:11,512 --> 00:10:14,548
然后使其大小是可调节的

192
00:10:16,650 --> 00:10:18,151
利用UI图像的某个API

193
00:10:18,485 --> 00:10:23,524
然后我就可以给每个滑动条
设置不同的图像了

194
00:10:23,590 --> 00:10:26,493
最小追踪图像和最大追踪图像

195
00:10:26,860 --> 00:10:28,128
随着我拖动滑动条

196
00:10:28,195 --> 00:10:30,430
它就会重绘并且使用合适的图像

197
00:10:30,731 --> 00:10:32,566
来绘制出已经追踪到的部分

198
00:10:35,435 --> 00:10:37,504
我说过会给你们演示
如何实现这个效果的

199
00:10:37,571 --> 00:10:38,872
现在我就告诉你们如何实现

200
00:10:39,439 --> 00:10:40,307
那么

201
00:10:40,607 --> 00:10:42,075
我会使用Core Image来实现

202
00:10:43,043 --> 00:10:45,345
如你所见 这是个完全相同的UI

203
00:10:45,412 --> 00:10:46,947
但现在当我调节滑动条的时候

204
00:10:47,548 --> 00:10:49,917
我应该会进行调节的
因为这张照片是水下拍摄的

205
00:10:49,983 --> 00:10:51,218
我想让颜色变得更暖一些

206
00:10:51,485 --> 00:10:53,387
我会移除一点水藻的绿色

207
00:10:55,355 --> 00:10:57,491
你可以看到照片实时地更新了

208
00:10:58,125 --> 00:10:59,259
让我来介绍下这个功能是如何实现的

209
00:11:06,800 --> 00:11:09,236
Noah已经提过了
Core Image有许多

210
00:11:09,303 --> 00:11:10,470
可用的滤镜

211
00:11:10,571 --> 00:11:12,606
这里我们所使用的滤镜

212
00:11:13,173 --> 00:11:14,975
就是CI温度和色彩滤镜

213
00:11:15,843 --> 00:11:17,211
值得一提的是

214
00:11:17,678 --> 00:11:21,081
实际上不是CI滤镜解决了
Core Image中图像过滤的难题

215
00:11:21,448 --> 00:11:24,518
解决了这些难题的是
一个叫作CIContext的对象

216
00:11:24,918 --> 00:11:27,988
CIContext就是面向
所依赖硬件的接口

217
00:11:28,055 --> 00:11:30,724
就是它实现了图像过滤

218
00:11:30,991 --> 00:11:34,828
我已经写好了一个CIContext
我会在这个方法中直接用它

219
00:11:36,129 --> 00:11:37,397
首先我要做的是

220
00:11:37,464 --> 00:11:40,267
根据当前正被显示的照片
实例化一个CIImage

221
00:11:40,334 --> 00:11:44,705
该照片是由我屏幕中的
UIImageView显示的

222
00:11:46,206 --> 00:11:49,276
CI温度和色彩滤镜有很多不同的参数

223
00:11:49,343 --> 00:11:52,980
可以让我控制白点

224
00:11:53,313 --> 00:11:56,650
这些能让我控制白点的参数
叫作中性和目标中性矢量

225
00:11:57,184 --> 00:12:01,154
每个参数都代表了一种特定色温和色彩

226
00:12:01,989 --> 00:12:03,457
我知道

227
00:12:03,824 --> 00:12:08,562
我想要的色温和色彩是6500开氏度

228
00:12:08,896 --> 00:12:13,033
以及完美的中性零
不会泛紫红色 也不会泛绿

229
00:12:13,400 --> 00:12:15,836
我可以利用这些参数来构建一个矢量

230
00:12:16,170 --> 00:12:19,907
然后我可以利用这些参数
构建另一个矢量

231
00:12:19,973 --> 00:12:21,542
该矢量来自于我的滑动条的数值

232
00:12:22,376 --> 00:12:25,412
接着我会新建一个词典来保存这些参数

233
00:12:25,479 --> 00:12:29,082
其中包括了输入图像
我还会请求CI给我新建一个滤镜

234
00:12:30,250 --> 00:12:32,152
根据CI温度和色彩

235
00:12:33,587 --> 00:12:35,322
为了实现滤镜的功能

236
00:12:36,690 --> 00:12:37,558
我要用一点

237
00:12:37,624 --> 00:12:39,593
Grand Central Dispatch技术
来脱离主线程

238
00:12:40,194 --> 00:12:42,896
因为图像处理是一个
相当繁重的操作

239
00:12:43,697 --> 00:12:46,366
所以我会用到一个之前创建好的队列

240
00:12:46,867 --> 00:12:49,469
然后请求我的上下文环境
创建一个CG图像

241
00:12:49,536 --> 00:12:52,472
根据我刚刚创建的滤镜的输出图像

242
00:12:52,806 --> 00:12:53,740
这样做所达到的效果就是

243
00:12:53,807 --> 00:12:57,144
让需要使用滤镜的图像通过滤镜
应用滤镜的效果

244
00:12:58,378 --> 00:12:59,246
而完成了这步之后

245
00:12:59,313 --> 00:13:01,582
我会异步发送回主队列

246
00:13:02,082 --> 00:13:05,619
并且再一次在UI图像视图中
设置结果图像

247
00:13:07,921 --> 00:13:09,056
有时候

248
00:13:09,623 --> 00:13:11,425
仅使用UIKit或Core Image

249
00:13:11,692 --> 00:13:13,227
或是其他的高级框架

250
00:13:13,293 --> 00:13:14,628
是不够的

251
00:13:14,695 --> 00:13:17,865
你需要当场绘制用户界面的元素

252
00:13:18,465 --> 00:13:21,101
正如Noah提到过的
你可以使用Core Graphics

253
00:13:21,168 --> 00:13:22,002
来实现这个功能

254
00:13:22,669 --> 00:13:25,038
这是对于Core Graphics
非常简单的应用

255
00:13:25,105 --> 00:13:27,374
比方说我想画个五角星

256
00:13:30,444 --> 00:13:31,278
要实现这个功能

257
00:13:32,045 --> 00:13:34,915
我会用到iOS 10中
引入的一个API

258
00:13:35,349 --> 00:13:37,117
它叫作
UIGraphicsImageRenderer

259
00:13:38,886 --> 00:13:42,489
它能让我轻松接入
Core Graphics的上下文环境

260
00:13:42,756 --> 00:13:45,459
我就可以在里面发布绘画命令了

261
00:13:46,293 --> 00:13:48,428
为了使用这个API
我需要

262
00:13:49,663 --> 00:13:51,798
确定下来 我想在哪画这个星星

263
00:13:53,467 --> 00:13:54,968
在本例中 是我视图的中心

264
00:13:56,603 --> 00:13:59,239
我会以特定大小新建一个
UIGraphicsImageRenderer

265
00:14:00,040 --> 00:14:02,776
然后调用图像的方法
此方法有一个代码段

266
00:14:03,477 --> 00:14:05,812
我会把绘制命令发布在代码段中

267
00:14:06,446 --> 00:14:08,248
它在这个渲染上下文环境中
给我传值

268
00:14:08,615 --> 00:14:10,984
我可以从那里获得一个CG上下文环境

269
00:14:11,385 --> 00:14:13,687
这个CG上下文环境有一大堆的方法

270
00:14:14,054 --> 00:14:15,289
能让我实现像是

271
00:14:15,455 --> 00:14:19,860
绘制路径 绘制文本信息
绘制图像 还有填充和画线这些功能

272
00:14:21,228 --> 00:14:25,165
这里的数学问题不是很重要
最重要的就是这个API

273
00:14:25,933 --> 00:14:28,435
在该上下文环境中
我要设置下填充的颜色

274
00:14:28,836 --> 00:14:32,406
这里填充的颜色是黄色
因为星星是黄色的

275
00:14:33,140 --> 00:14:36,109
然后我会将上下文环境中
当前的点放到

276
00:14:36,176 --> 00:14:39,112
星星的上面
通过使用move方法

277
00:14:39,613 --> 00:14:40,480
应该是moveTo方法

278
00:14:42,082 --> 00:14:44,651
然后我会在循环中
加入一些代码

279
00:14:45,085 --> 00:14:47,487
在五角星的内部点和外部点之间

280
00:14:48,055 --> 00:14:50,424
我加完了代码之后 就可以填充该路径

281
00:14:50,757 --> 00:14:52,926
其效果就是会填充星星的轮廓

282
00:14:52,993 --> 00:14:54,127
并且创建你所见到的图像

283
00:14:55,329 --> 00:14:58,165
当然了
没有人想让一个巨大的星星

284
00:14:58,232 --> 00:14:59,833
孤零零地出现在应用的中间

285
00:15:00,367 --> 00:15:01,335
让我们再进一步

286
00:15:01,401 --> 00:15:02,970
谈一下你可以如何使用它

287
00:15:03,036 --> 00:15:05,939
作为应用的用户界面元素

288
00:15:08,041 --> 00:15:09,409
我们会通过
Core Animation来实现

289
00:15:09,943 --> 00:15:14,014
Core Animation
十分擅长于呈现位图内容

290
00:15:14,481 --> 00:15:16,483
我们可以使用刚刚生成的图像

291
00:15:16,550 --> 00:15:18,051
作为CALayer的内容

292
00:15:19,152 --> 00:15:20,687
这就是为了给你们展示下
我所追求的效果

293
00:15:20,921 --> 00:15:26,059
这里我有一个按钮
UI按钮是很常见的

294
00:15:26,894 --> 00:15:30,564
它们的使用情况会根据
上下文环境而有所不同

295
00:15:31,465 --> 00:15:34,434
如果我想让这个UI按钮
看起来更好看的话

296
00:15:34,501 --> 00:15:36,737
我就可以试着实现这样的效果

297
00:15:38,672 --> 00:15:40,107
让我再给你们演示一次

298
00:15:43,677 --> 00:15:44,611
挺可爱的 不是吗？

299
00:15:44,678 --> 00:15:46,180
这个效果有点浮夸

300
00:15:46,246 --> 00:15:47,881
你可能不会在应用中用到这样的效果

301
00:15:47,948 --> 00:15:49,983
这个效果就是为了演示用的

302
00:15:50,551 --> 00:15:51,852
让我们来说下如何实现这个效果

303
00:15:55,789 --> 00:15:58,859
我会配置一下想要显示的星星的参数

304
00:15:59,393 --> 00:16:01,895
然后我会给按钮添加一个动作

305
00:16:01,962 --> 00:16:04,598
来调用
playStarAnimation方法

306
00:16:07,401 --> 00:16:08,435
这里我会创建一个循环

307
00:16:08,502 --> 00:16:10,404
这个循环实际上是我想新建的星星数

308
00:16:10,470 --> 00:16:12,239
我会给每个星星
都创建一个CALayer

309
00:16:12,639 --> 00:16:14,708
CALayer可以实现
Core Animation

310
00:16:14,942 --> 00:16:18,712
它在屏幕上有个位置

311
00:16:18,779 --> 00:16:21,715
它可以被动画化 来回移动
并且它有自己的内容集

312
00:16:22,916 --> 00:16:25,485
我会将它的内容设成cgImage

313
00:16:25,786 --> 00:16:28,155
它代表的是我刚刚渲染的其中一个星星

314
00:16:28,222 --> 00:16:30,023
我是使用刚才提到的类来渲染的

315
00:16:31,792 --> 00:16:35,062
我会将每个星星的initialPosition
属性设成围绕按钮周围的圆形范围

316
00:16:36,930 --> 00:16:38,765
并且将它的余量
设成initialSize

317
00:16:40,267 --> 00:16:41,735
为了将它显示在屏幕上

318
00:16:41,802 --> 00:16:44,471
我需要把它作为子层加到按钮的层上面

319
00:16:47,341 --> 00:16:49,176
你肯定会发现 星星是有动画效果的

320
00:16:49,243 --> 00:16:51,645
它们会从初始位置逐渐变远

321
00:16:52,045 --> 00:16:53,814
伴随着从按钮中心发射出的光线

322
00:16:54,481 --> 00:16:55,549
这里我要做一些数学运算

323
00:16:55,616 --> 00:16:57,451
来计算一下星星的最终位置

324
00:16:58,218 --> 00:17:00,320
然后我就能构造一个变换

325
00:17:00,621 --> 00:17:05,157
该变换会同时旋转 放大
并且将层转换

326
00:17:05,224 --> 00:17:06,159
到它的最终位置

327
00:17:07,160 --> 00:17:08,729
我会把CABasicAnimation

328
00:17:08,795 --> 00:17:11,298
插入到CALayer的初始位置

329
00:17:11,365 --> 00:17:12,398
与其目标位置之间

330
00:17:13,165 --> 00:17:14,968
我可以用个更复杂的动画效果

331
00:17:15,035 --> 00:17:17,371
如果需要的话可以用
像是关键框动画之类的效果

332
00:17:17,436 --> 00:17:18,672
使其沿着一个路径移动

333
00:17:19,439 --> 00:17:21,974
我会将fromValue
设成当前的层转换

334
00:17:22,041 --> 00:17:24,478
而将toValue
设成我刚刚构造的转换

335
00:17:25,078 --> 00:17:27,047
我还会使用个定制的持续时间

336
00:17:27,446 --> 00:17:29,583
因为默认的持续时间为0.25秒

337
00:17:29,650 --> 00:17:31,985
这对于我想实现的效果来说有点太快了

338
00:17:32,753 --> 00:17:34,454
我还会使用一个EaseOut方法

339
00:17:35,189 --> 00:17:40,460
这样星星在接近目标位置的时候会变慢

340
00:17:44,798 --> 00:17:47,434
这里我不会用太多的层

341
00:17:47,501 --> 00:17:50,437
在几秒后我会从层的超视图中将其移除

342
00:17:50,504 --> 00:17:51,505
当动画结束的时候

343
00:17:56,243 --> 00:17:57,110
这些看上去都不错

344
00:17:57,177 --> 00:17:58,178
但有时候你可能还想

345
00:17:58,245 --> 00:18:00,480
更多的元素在屏幕上飞动

346
00:18:00,814 --> 00:18:02,549
对于这种情况你应该使用

347
00:18:02,916 --> 00:18:05,953
一个高级别的图形框架

348
00:18:06,186 --> 00:18:07,287
它是专门用来开发游戏的

349
00:18:07,354 --> 00:18:10,090
但你也可以在你的应用中使用它们

350
00:18:10,624 --> 00:18:12,292
让我们快速介绍一下
SpriteKit

351
00:18:13,694 --> 00:18:14,761
这是个很相似的

352
00:18:14,828 --> 00:18:17,297
我在SpriteKit中
创建的粒子效果

353
00:18:18,098 --> 00:18:22,236
你可以很容易地
将其用在你应用的内容中

354
00:18:22,569 --> 00:18:24,605
让我来介绍下 你应该如何
将SpriteKit轻松整合到

355
00:18:24,838 --> 00:18:26,106
你自己的应用中

356
00:18:30,043 --> 00:18:32,412
这差不多就是所有的代码了

357
00:18:32,579 --> 00:18:34,815
我们之所有能很轻松地实现它

358
00:18:35,349 --> 00:18:39,620
其实就是因为这个
我之前创建好的SKS文件

359
00:18:40,921 --> 00:18:43,790
而且Xcode对于粒子系统
有个挺不错的可视化编辑器

360
00:18:44,324 --> 00:18:48,328
你在这看不到纹理
因为我是通过变成的方式创建它的

361
00:18:48,795 --> 00:18:51,198
但是你会发现
如果我打开Xcode中的检查器

362
00:18:51,532 --> 00:18:54,501
我实际上可以控制许多参数

363
00:18:54,568 --> 00:18:57,004
也就是这个粒子系统的参数

364
00:18:57,804 --> 00:19:00,974
包括像是生命周期内的透明度
初始速度

365
00:19:01,041 --> 00:19:04,344
还有它速度的分布参数等等

366
00:19:05,412 --> 00:19:08,148
这样我就能通过视觉验证

367
00:19:08,215 --> 00:19:10,184
我在这个粒子系统中要实现的效果

368
00:19:10,651 --> 00:19:12,019
更棒的是我做完了这些操作后

369
00:19:12,085 --> 00:19:14,021
根本不用再写任何代码
就能实现这个效果

370
00:19:14,621 --> 00:19:17,090
相关代码其实已经被
保存在其SKS文件中了

371
00:19:19,059 --> 00:19:20,027
让我们再回来

372
00:19:20,093 --> 00:19:24,064
讲一下如何将SpriteKit
集成到你的应用中

373
00:19:24,565 --> 00:19:26,600
不管要显示什么内容

374
00:19:26,667 --> 00:19:28,235
我都得创建一个SKScene

375
00:19:28,869 --> 00:19:32,005
SKScene就是你
所有对象的生存阶段

376
00:19:32,606 --> 00:19:36,076
SKScene通过SKView
被呈现在你的应用中

377
00:19:36,577 --> 00:19:37,778
这里我创建了一个SKScene

378
00:19:37,845 --> 00:19:40,848
它有着与要呈现的视图相同的大小

379
00:19:40,914 --> 00:19:42,549
然后我会在视图上呈现这个场景

380
00:19:43,550 --> 00:19:45,152
然后我会创建一个
SKEmitterNode

381
00:19:45,219 --> 00:19:48,222
它会载入粒子系统的参数

382
00:19:49,089 --> 00:19:52,960
然后它还会驱动粒子动画

383
00:19:53,026 --> 00:19:54,161
在它运行的时候

384
00:19:54,895 --> 00:19:57,464
我还想创建一个著名的
starImages对象

385
00:19:57,631 --> 00:20:01,335
然后在我的发射器上将其设为纹理
这样每个粒子就都有星星的形状

386
00:20:02,369 --> 00:20:03,904
我会把它放到屏幕的中间

387
00:20:04,538 --> 00:20:07,574
接着我会把这个发射器
添加到场景的孩子类中

388
00:20:07,741 --> 00:20:08,876
这就是所有你要做的事情了

389
00:20:08,942 --> 00:20:10,077
我不需要开始动画化

390
00:20:10,477 --> 00:20:13,914
SpriteKit会接管
并且开始运行动画化

391
00:20:15,349 --> 00:20:18,352
2D效果挺棒的
不过你们知道什么会更酷吗？3D效果

392
00:20:18,852 --> 00:20:22,689
所以让我们在最后一个例子中
讲一下SceneKit的基本内容吧

393
00:20:24,124 --> 00:20:25,425
这里有一个类似的演示

394
00:20:25,492 --> 00:20:28,095
唯一不同的是
你会发现 星星在到处飞

395
00:20:28,161 --> 00:20:29,196
互相反弹

396
00:20:29,530 --> 00:20:32,366
最重要的是
它们是3D的效果 看起来更真实了

397
00:20:33,066 --> 00:20:36,136
让我们来看一下
SceneKit的基本内容吧

398
00:20:37,871 --> 00:20:40,541
在SceneKit中有个跟
SKScene相似的内容

399
00:20:40,607 --> 00:20:43,544
它叫作
S…in SceneKit to…

400
00:20:45,312 --> 00:20:52,085
在SceneKit中有个与
SpriteKit中SKScene相类似的类

401
00:20:52,152 --> 00:20:53,220
那就是SC

402
00:20:55,355 --> 00:20:58,759
那就是SCNScene
就跟之前提到的一样

403
00:20:58,825 --> 00:21:00,093
它保存了你

404
00:21:00,160 --> 00:21:01,595
场景中所有的对象

405
00:21:02,062 --> 00:21:03,730
我会把它设成个很漂亮的星场文字

406
00:21:03,797 --> 00:21:05,632
把它的背景设成星场纹理

407
00:21:06,033 --> 00:21:08,168
不过为了将它显示出来

408
00:21:08,235 --> 00:21:09,670
我们还需要创建一个节点

409
00:21:09,970 --> 00:21:12,439
在SCNCamera中
表示我们的观点

410
00:21:13,073 --> 00:21:14,975
我可以在这个照相机上设置很多属性

411
00:21:15,042 --> 00:21:17,244
不过我现在只关心它的位置

412
00:21:17,611 --> 00:21:20,347
我会把它放到离初始位置
往后的几个单位

413
00:21:21,315 --> 00:21:25,419
这样它就可以指向星星粒子系统了

414
00:21:26,220 --> 00:21:29,122
接着我会把它作为孩子节点
添加到场景的根节点上

415
00:21:29,890 --> 00:21:33,093
我现在还没有在屏幕上显示任何内容

416
00:21:33,660 --> 00:21:36,697
所以现在我要使用这个叫
Model I/O的框架

417
00:21:37,030 --> 00:21:40,534
Model I/O有很多
处理3D数据的功能

418
00:21:41,335 --> 00:21:43,837
在本例中 我会载入一个3D模型

419
00:21:43,904 --> 00:21:47,174
该模型是我之前以
MDLAsset的形式创建的

420
00:21:48,408 --> 00:21:51,912
在SceneKit和Model I/O间
有很多的互操作

421
00:21:52,312 --> 00:21:55,148
我可以提取一个
SCNGeometry

422
00:21:55,449 --> 00:22:00,287
它是通过我刚才载入的
MDL mesh得到的

423
00:22:02,322 --> 00:22:03,257
这个模型

424
00:22:03,323 --> 00:22:05,859
没有任何与它相关联的材料信息

425
00:22:06,260 --> 00:22:08,629
我可以通过编程来创建一个
SCNMaterial对象

426
00:22:08,695 --> 00:22:12,499
并且将漫射色设成
跟之前演示一样的黄色

427
00:22:13,834 --> 00:22:15,435
最后 为了点亮我的对象

428
00:22:15,502 --> 00:22:19,106
我需要创建一个SCNLight
并且将它关联到一个节点上

429
00:22:19,439 --> 00:22:21,175
还要给它提供一些属性

430
00:22:21,575 --> 00:22:23,443
包括位置 光的类型

431
00:22:24,411 --> 00:22:26,513
SceneKit有很多
不同类型的光效

432
00:22:26,580 --> 00:22:28,348
包括方向性的 点式的
还有聚光灯式的

433
00:22:28,682 --> 00:22:30,784
你可以选个最适合你用的

434
00:22:32,419 --> 00:22:34,988
接着我要开始动画化了

435
00:22:35,055 --> 00:22:36,823
通过调用
startStarEmitter这个方法

436
00:22:37,524 --> 00:22:39,359
这个方法会新建一个定时器

437
00:22:40,260 --> 00:22:43,163
这个定时器会每秒运行多次

438
00:22:43,230 --> 00:22:45,465
并且新建一个SCNNode

439
00:22:45,732 --> 00:22:48,502
它有一个我刚才加载的几何图形的实例

440
00:22:49,303 --> 00:22:50,437
我会把它们都加进来

441
00:22:50,504 --> 00:22:53,373
随着我将它们引入到场景中
引入到根节点上

442
00:22:53,440 --> 00:22:55,676
并且给每个图形都关联一个
physicsBody

443
00:22:55,943 --> 00:23:00,447
这样它就免费获得了符合物理学的动画

444
00:23:00,981 --> 00:23:03,383
接着我会新建一个随机上升速度

445
00:23:03,450 --> 00:23:04,952
这样可以更多样性一点

446
00:23:05,886 --> 00:23:09,223
最后我会把每个星星
从它的父节点中移除

447
00:23:09,423 --> 00:23:12,025
在几秒之后
这么做是为了清除内存

448
00:23:13,527 --> 00:23:14,895
这些演示是为了

449
00:23:14,962 --> 00:23:17,497
给你们介绍一些基本功能

450
00:23:17,831 --> 00:23:19,900
也就是我们系统上图形框架的基本功能

451
00:23:20,734 --> 00:23:24,938
现在我想请回Noah来给你们
深入介绍一下Core Animation

452
00:23:32,246 --> 00:23:33,080
谢谢 Warren

453
00:23:35,682 --> 00:23:39,386
你们有多少人已经用过
Core Animation了呢？

454
00:23:40,654 --> 00:23:41,755
很好
我很高兴能听到这一点

455
00:23:42,523 --> 00:23:45,726
你们有多少人在使用它的时候遇到了
一些奇怪的或者不能预见的问题呢？

456
00:23:46,927 --> 00:23:47,761
是的

457
00:23:48,929 --> 00:23:52,165
CA有一些关键的概念

458
00:23:52,232 --> 00:23:54,902
有时候不是马上就能明白

459
00:23:55,435 --> 00:23:57,304
所以就很容易在这些概念上遇到问题

460
00:23:57,371 --> 00:23:58,772
所以我想给你们介绍下这些问题

461
00:23:59,239 --> 00:24:03,377
并且给你们解释下问题到底出在哪里
以及为什么会出问题

462
00:24:03,710 --> 00:24:05,179
我可以直接给你们答案

463
00:24:05,245 --> 00:24:06,079
在很多这种例子当中

464
00:24:06,146 --> 00:24:07,714
答案是非常简单的

465
00:24:08,015 --> 00:24:11,151
不过我觉得
知道为什么会出问题更为重要

466
00:24:11,218 --> 00:24:13,754
在你开始解决问题之前

467
00:24:14,888 --> 00:24:18,692
让我们从动画化开始讲起吧

468
00:24:18,759 --> 00:24:23,463
它是非常重要的 对于…
我不是有意这么说的

469
00:24:24,665 --> 00:24:25,499
让我们回到正题

470
00:24:27,067 --> 00:24:30,003
有一个问题是你会经常碰到的

471
00:24:30,070 --> 00:24:32,806
在你刚开始接触CA动画的时候

472
00:24:33,373 --> 00:24:36,043
你会新建一个动画 把它加到层上

473
00:24:36,343 --> 00:24:39,012
你可以看到
层会从点A移动到点B

474
00:24:39,546 --> 00:24:41,949
然后它会跳回来
你就会说“这太奇怪了”

475
00:24:43,717 --> 00:24:47,654
而问题应该是出在调用了模型

476
00:24:47,721 --> 00:24:48,889
和表示层的内容上面

477
00:24:48,956 --> 00:24:52,526
有两个东西是马上就出现的

478
00:24:52,593 --> 00:24:54,795
了解它们之间的区别

479
00:24:54,862 --> 00:24:56,196
对于搞清楚问题出现的原因是挺重要的

480
00:24:57,798 --> 00:24:59,833
你经常需要进行交互的布局

481
00:25:00,000 --> 00:25:02,836
你要在它上面设置属性
还有添加动画等等

482
00:25:03,203 --> 00:25:04,071
就是模型层

483
00:25:04,771 --> 00:25:07,441
而显示在屏幕上的是表示层

484
00:25:08,141 --> 00:25:10,344
表示层有点像是模型层的复制

485
00:25:10,410 --> 00:25:13,447
它会根据模型层的状态来计算每个框

486
00:25:13,747 --> 00:25:16,650
还有模型层当时所有的动画

487
00:25:17,684 --> 00:25:20,454
而在上个例子中出现的问题就是

488
00:25:20,821 --> 00:25:22,890
你在这个时间点加入了动画

489
00:25:24,157 --> 00:25:26,593
你可以发现

490
00:25:27,461 --> 00:25:29,730
表示层也跟着添加了动画

491
00:25:29,796 --> 00:25:31,431
但是当动画效果结束的时候

492
00:25:31,498 --> 00:25:33,267
它就变回了模型层所显示的内容

493
00:25:35,035 --> 00:25:37,237
如果你上网看一下的话

494
00:25:37,304 --> 00:25:40,641
就会发现有好多人
给出了错误的解决方案

495
00:25:42,209 --> 00:25:45,979
他们会说
“将动画设成结束时不会被移除”

496
00:25:46,313 --> 00:25:48,448
“将动画设成影片模式就解决了”

497
00:25:50,184 --> 00:25:54,288
而问题在于这样的解决方案
会带来一些不一致性

498
00:25:54,354 --> 00:25:55,989
因为在你的动画结束之后

499
00:25:56,390 --> 00:25:58,458
模型层还有它的初始值

500
00:25:59,126 --> 00:26:00,827
这看起来是对的

501
00:26:01,228 --> 00:26:03,864
但是如果你看一下这两个图像的属性值

502
00:26:04,298 --> 00:26:07,000
就会发现表示层所显示的内容
和模型层不太一样

503
00:26:07,835 --> 00:26:09,036
这就会导致问题的出现

504
00:26:09,436 --> 00:26:12,606
当你要在一层上对齐某个物体的时候

505
00:26:12,673 --> 00:26:14,875
该物体是你之前动画化了的
你将它设成层上的位置

506
00:26:15,242 --> 00:26:18,679
而这个位置是它差不多两分钟前
所在的位置 这就很奇怪了

507
00:26:18,879 --> 00:26:20,147
这样子说不通 对吧？

508
00:26:21,748 --> 00:26:25,152
幸运的是 这个问题的解决措施很简单

509
00:26:25,219 --> 00:26:27,020
你可以完全忘掉

510
00:26:27,087 --> 00:26:28,755
我刚才所解释的那些概念性的东西

511
00:26:29,456 --> 00:26:31,225
你只需要

512
00:26:31,291 --> 00:26:33,227
在将动画添加到层上的时候

513
00:26:33,927 --> 00:26:36,230
同时设置层的模型属性

514
00:26:37,264 --> 00:26:40,133
这样的话 在动画开始的时候

515
00:26:40,200 --> 00:26:42,002
模型层会跳到它的最终状态

516
00:26:42,970 --> 00:26:44,605
而表示层能平滑地动画化

517
00:26:44,972 --> 00:26:47,107
然后它们就是一致的了

518
00:26:47,608 --> 00:26:48,442
更棒的是

519
00:26:48,642 --> 00:26:51,478
在你的模型层上就不会再有动画

520
00:26:51,912 --> 00:26:53,814
干扰状态的设定

521
00:26:53,881 --> 00:26:56,283
以致于在后面可能会出现问题了

522
00:26:57,718 --> 00:27:01,455
而它的代码就是这样的

523
00:27:01,622 --> 00:27:02,623
首先你要有个动画

524
00:27:03,290 --> 00:27:05,692
你要设定你的duration
你的fromValue和toValue

525
00:27:05,959 --> 00:27:07,995
然后在你将它添加到层上的时候

526
00:27:08,061 --> 00:27:10,631
需要同时在层上设定实际的属性值

527
00:27:11,031 --> 00:27:12,132
就是这么简单

528
00:27:13,634 --> 00:27:16,069
你需要注意下模型 表示层二分法

529
00:27:16,737 --> 00:27:19,940
还有在你添加动画的时候
要将最终状态应用到你的层上

530
00:27:22,843 --> 00:27:24,344
下面我想介绍的

531
00:27:24,411 --> 00:27:28,348
问题是我不想承认
但确实遇到过很多次的

532
00:27:29,383 --> 00:27:32,653
就是转换和框之间的交叉

533
00:27:33,687 --> 00:27:35,489
你们对于框这个概念已经相当熟悉了

534
00:27:35,556 --> 00:27:38,525
你可以设定这个矩形来定义
你的层在哪以及它有多大

535
00:27:40,060 --> 00:27:41,929
在你设置好层之后

536
00:27:42,930 --> 00:27:44,398
你想要缩小它

537
00:27:44,765 --> 00:27:47,768
通过转换把它缩小到百分之25大小

538
00:27:49,403 --> 00:27:51,672
然后在你代码的某个地方

539
00:27:51,972 --> 00:27:52,973
你将框又设回了原来的大小

540
00:27:53,674 --> 00:27:55,976
然后你的层就变回了原来的大小

541
00:27:58,011 --> 00:27:59,646
这看起来没什么问题 对吗？

542
00:28:00,914 --> 00:28:05,219
但是当你设置层上的另一个转换时
就会出现问题

543
00:28:05,285 --> 00:28:07,454
换句话说 就是你移除了已有的转换

544
00:28:07,688 --> 00:28:08,655
而设置了一些新的转换

545
00:28:09,356 --> 00:28:10,757
假如说你想旋转这个层

546
00:28:11,725 --> 00:28:14,561
将其保持原有的大小 或是改变大小

547
00:28:15,095 --> 00:28:17,664
这里你要设置一个
CGAffineTransform

548
00:28:18,298 --> 00:28:22,035
给它一个旋转角度
然后你的层就会实现这样的效果

549
00:28:23,070 --> 00:28:23,937
这样是不对的

550
00:28:25,806 --> 00:28:27,374
为什么会出现这样的问题呢？

551
00:28:28,442 --> 00:28:34,648
你需要知道的是
框是从外面开始算的层的大小

552
00:28:34,848 --> 00:28:36,683
而边是从里面开始算的层的大小

553
00:28:37,017 --> 00:28:40,354
如果你询问层框在哪里的话

554
00:28:40,420 --> 00:28:42,422
它是通过边和转换进行计算的

555
00:28:43,390 --> 00:28:47,361
换句话说
当你的层恢复其初始大小的时候

556
00:28:47,995 --> 00:28:49,930
它实际上是四倍的大小

557
00:28:49,997 --> 00:28:51,765
因为它上面还有比例转换

558
00:28:52,165 --> 00:28:54,535
你告诉它“在屏幕上
我想要这么大的尺寸”

559
00:28:54,735 --> 00:28:57,070
它会按比例缩小四倍

560
00:28:57,137 --> 00:28:59,540
它就会说“好的 我需要
比初始尺寸大四倍”

561
00:29:00,040 --> 00:29:03,076
这样看起来是没问题的
因为它在屏幕上看上去是同样的大小

562
00:29:03,410 --> 00:29:04,945
但是当你取消了转换的设置时

563
00:29:05,012 --> 00:29:07,714
它就会恢复到其初始的巨大尺寸

564
00:29:09,082 --> 00:29:13,187
总之如果你要使用转换的话

565
00:29:13,253 --> 00:29:15,155
请在使用框属性时一定要小心

566
00:29:15,222 --> 00:29:18,725
你最好不要仅设置框

567
00:29:19,193 --> 00:29:23,497
你需要考虑下
你所希望的层的大小和位置

568
00:29:24,031 --> 00:29:28,602
换句话说 在本例中
就是你想要的框的宽度和高度

569
00:29:28,869 --> 00:29:30,871
而位置就是框的中心

570
00:29:32,039 --> 00:29:33,407
差不多就是这样了

571
00:29:34,107 --> 00:29:37,211
如果框被转换所影响了
它们就会以一种奇怪的方式进行交互

572
00:29:37,277 --> 00:29:39,713
如果你将它们结合到一起
你应该会碰到很糟糕的问题

573
00:29:40,080 --> 00:29:41,782
所以请你设置下边和位置吧

574
00:29:41,849 --> 00:29:43,150
这样你就能省去很多的烦恼

575
00:29:46,186 --> 00:29:47,387
接下来

576
00:29:47,454 --> 00:29:49,723
我想在应用的上下文环境中
审视一下它们

577
00:29:51,625 --> 00:29:55,963
我们这个闪亮的小应用
可以让你将表情符号

578
00:29:56,029 --> 00:29:57,197
放到你的照片上

579
00:29:57,264 --> 00:29:58,131
它是我独创的

580
00:29:58,198 --> 00:30:00,400
我已经考虑开发它很久了

581
00:30:01,635 --> 00:30:04,705
有两个东西是用来显示这样的效果的

582
00:30:05,239 --> 00:30:09,009
第一个就是切割了层边的遮盖物

583
00:30:09,610 --> 00:30:12,179
而第二个就是它下面的阴影

584
00:30:13,247 --> 00:30:14,781
首先 让我们谈一下遮盖物

585
00:30:16,250 --> 00:30:20,721
这里我们有个定制的圆的形状

586
00:30:20,787 --> 00:30:23,023
用来裁剪表情符号的边

587
00:30:23,423 --> 00:30:26,593
你需要给CA另外一个层

588
00:30:26,660 --> 00:30:28,962
该层上有你需要的形状

589
00:30:29,429 --> 00:30:34,535
你可以用它来影响主层的透明度

590
00:30:36,336 --> 00:30:37,237
就是这样

591
00:30:37,604 --> 00:30:42,943
CA可以在接收透明度后
使用它来裁剪层的形状

592
00:30:44,011 --> 00:30:46,213
你可以用它实现很多有意思的功能

593
00:30:46,280 --> 00:30:48,582
很多情况下
人们只用了一种简单的形状 而你可以

594
00:30:48,749 --> 00:30:50,918
加个淡出效果 你可以在上面挖洞
它能让你

595
00:30:51,218 --> 00:30:53,053
在层上实现所有那些有趣的功能

596
00:30:54,588 --> 00:30:58,825
如果你想实现这样的效果

597
00:30:58,992 --> 00:31:01,962
也就是表情符号在底部有点淡出的效果

598
00:31:02,029 --> 00:31:04,164
还对其进行了裁剪 你可能会想

599
00:31:04,231 --> 00:31:08,402
“我可以用遮盖物来设置物体的透明度
来实现淡出的效果

600
00:31:08,468 --> 00:31:10,170
我这里用两个遮盖物就行了 对吧？”

601
00:31:11,038 --> 00:31:15,943
你可以这么做 但这样的实现不是很好
因为性能表现很糟

602
00:31:16,510 --> 00:31:18,612
每个遮盖物都有开销

603
00:31:18,846 --> 00:31:22,816
所以当你在一层上有多个遮盖物时
CA就得把它们就结合起来

604
00:31:22,883 --> 00:31:25,986
形成一个序列
这样才能生成最终显示在屏幕上的图像

605
00:31:26,220 --> 00:31:29,756
这里你有表情符号层
淡出遮盖物

606
00:31:30,224 --> 00:31:32,259
将它们结合起来
就得到了淡出效果的表情符号

607
00:31:32,492 --> 00:31:34,695
接着你还要有另一个
包含了表情符号的层

608
00:31:34,761 --> 00:31:39,132
该层被这个改变形状的东西遮盖了

609
00:31:39,833 --> 00:31:43,370
这么做是可以的
但还不是最理想的解决措施

610
00:31:43,437 --> 00:31:45,906
你会发现这里要花很长的时间

611
00:31:45,973 --> 00:31:48,976
光是绘制像素点 判断哪里是透明的
等等就会花很久

612
00:31:49,576 --> 00:31:55,249
会出现的这种问题都是因为
CA必须在底层绘制这些东西

613
00:31:55,415 --> 00:31:57,317
通常在你绘制普通路径的时候

614
00:31:57,384 --> 00:31:59,253
CA只需要提取一个物体中的内容

615
00:31:59,319 --> 00:32:00,821
把它放到最终的合成图像上

616
00:32:00,888 --> 00:32:01,989
然后提取另一个物体中的内容
把它也放到最终的合成图像上

617
00:32:02,055 --> 00:32:03,056
以此类推

618
00:32:03,223 --> 00:32:07,094
但是在本例中
它得创建一个单独的上下文环境

619
00:32:07,160 --> 00:32:10,197
来绘制所有这些东西
然后把它放到屏幕上

620
00:32:10,531 --> 00:32:14,067
你要绘制的东西越多
堆积的效果实现的内容就越多

621
00:32:15,502 --> 00:32:19,106
如果你还是想实现这个效果

622
00:32:20,541 --> 00:32:22,376
最好的办法就是走个捷径

623
00:32:23,844 --> 00:32:27,581
也就是你要伪装至少一个
你使用的遮盖物

624
00:32:27,981 --> 00:32:31,051
这里你可以将一个梯度覆盖放到

625
00:32:31,418 --> 00:32:35,589
这层的上面
然后将其列入所有遮盖物内容中

626
00:32:37,124 --> 00:32:39,626
而这种方法明显对某些情况不适用

627
00:32:39,793 --> 00:32:42,930
如果你的背景不是纯色的
那么你就不能用纯色梯度

628
00:32:43,130 --> 00:32:45,899
不过你可以实现一些其他功能 像是

629
00:32:46,333 --> 00:32:50,404
将你的背景绘制到另一个图片上

630
00:32:50,637 --> 00:32:53,307
然后将其淡出
作为覆盖来使用

631
00:32:53,373 --> 00:32:56,710
那…这样做一次
比让CA每帧都做要来得快

632
00:32:58,412 --> 00:33:01,048
总之就是

633
00:33:02,349 --> 00:33:03,851
每个遮盖物都有开销

634
00:33:03,917 --> 00:33:06,386
它们很有趣也很实用 不过开销有点大

635
00:33:07,154 --> 00:33:10,557
在你遮盖某些东西的时候
你层的大小会起到很大的作用

636
00:33:10,624 --> 00:33:13,293
如果你有个很大的层
却用了个小角的遮盖物

637
00:33:13,360 --> 00:33:16,096
CA还是得绘制整个图形
这样不是很理想

638
00:33:16,663 --> 00:33:20,200
所以如果可以 就用我刚才说的捷径吧
关于这个内容我就介绍完了

639
00:33:22,069 --> 00:33:24,338
下面让我们谈下阴影

640
00:33:26,106 --> 00:33:30,377
你可能很熟悉CA的阴影属性

641
00:33:30,444 --> 00:33:32,779
像是阴影透明度 阴影偏移量
阴影半径等等

642
00:33:33,046 --> 00:33:36,783
如果你使用了这些属性
你的阴影就可以正常显示

643
00:33:36,950 --> 00:33:40,587
但是如果你的应用中
有很多带有阴影的视图

644
00:33:40,654 --> 00:33:42,689
你就会发现 性能表现有点捉襟见肘了

645
00:33:42,956 --> 00:33:45,459
原因就是CA必须要

646
00:33:45,526 --> 00:33:47,928
单独为每个视图绘制阴影
而且它必须在绘制时

647
00:33:47,995 --> 00:33:51,932
包含每个视图中全部的层级结构

648
00:33:52,933 --> 00:33:57,004
我的意思是 当你的层被阴影化的时候

649
00:33:57,504 --> 00:34:01,542
CA必须首先绘制它的背景
然后绘制每个子层

650
00:34:03,410 --> 00:34:04,344
稍等一下

651
00:34:05,479 --> 00:34:10,583
还得计算出它的透明度
其结果看起来就像是这样

652
00:34:10,984 --> 00:34:12,452
这好像是在浪费时间 对吗？

653
00:34:12,518 --> 00:34:14,054
我们花了这么长时间
绘制这些可爱的符号表情

654
00:34:14,121 --> 00:34:16,356
而现在我们只能看到它们不透明的样子

655
00:34:17,291 --> 00:34:20,726
所以当子层的内容不是很重要时

656
00:34:20,793 --> 00:34:24,898
使用常规的阴影系统就有点浪费时间了

657
00:34:25,632 --> 00:34:28,768
你可以使用阴影路径属性

658
00:34:29,503 --> 00:34:32,672
我们之前提到过
你可以用Core Graphics

659
00:34:32,739 --> 00:34:37,277
来绘制不同形状的路径
然后用这些路径来实现某些功能

660
00:34:37,444 --> 00:34:40,647
CG路径在系统的其他地方也会被用到

661
00:34:40,714 --> 00:34:42,416
它会被用来实现一些跟路径有关的功能
在本例中

662
00:34:42,850 --> 00:34:46,253
你只需要创建一个层形状的路径

663
00:34:46,853 --> 00:34:50,791
将该路径传给CA 它就会绘制路径
并模糊处理它 这样来生成阴影

664
00:34:50,858 --> 00:34:53,860
会比绘制层与子层要快得多

665
00:34:55,128 --> 00:34:58,532
这就是采用此方法的主要性能优势

666
00:34:58,599 --> 00:35:00,534
另一个优势是 如果你有很多层

667
00:35:00,601 --> 00:35:02,169
都使用了同样的阴影路径实例

668
00:35:02,436 --> 00:35:05,572
CA就根本不用重新绘制阴影了

669
00:35:05,639 --> 00:35:08,175
它就可以在任何地方重用这些阴影
这是个巨大的性能提升

670
00:35:09,042 --> 00:35:11,245
当你在处理层阴影的时候

671
00:35:12,946 --> 00:35:16,750
要注意层与子层的混合 开销是很大的

672
00:35:16,817 --> 00:35:19,887
你应该尽可能地避免这么做
你可以使用阴影路径

673
00:35:20,554 --> 00:35:21,555
很简单 对吗？

674
00:35:23,590 --> 00:35:28,061
我已经给你们介绍了一些
CA的最优解决方案

675
00:35:28,128 --> 00:35:32,232
有些方法可以让你的实现更为高效

676
00:35:33,367 --> 00:35:34,401
让我们来看一些小技巧

677
00:35:34,468 --> 00:35:36,970
让我们看一些你可能没有用过的东西

678
00:35:38,939 --> 00:35:44,645
CA有一个叫作CAShapeLayer的
CALayer子类

679
00:35:45,345 --> 00:35:47,581
它会获取
Core Graphics路径

680
00:35:47,648 --> 00:35:50,117
像是我之前提过的那些
你可以给它一个线的颜色

681
00:35:50,184 --> 00:35:53,287
还有填充颜色 它就给你绘制图形了
你可能之前接触过这个类

682
00:35:53,520 --> 00:35:57,324
CA有个很酷的功能就是
它有非常多的层属性

683
00:35:57,391 --> 00:35:59,660
是可动画化的

684
00:36:00,060 --> 00:36:03,430
你可以通过这些属性来设置一个动画

685
00:36:03,497 --> 00:36:06,266
CA会正确地将其插入

686
00:36:06,333 --> 00:36:08,502
然后给你一个动画化的层

687
00:36:09,236 --> 00:36:10,871
你能通过它实现一些很酷的功能

688
00:36:11,205 --> 00:36:13,607
你可以给线的颜色加个动画

689
00:36:13,674 --> 00:36:16,076
或给填充颜色加
这些有点太显而易见了 对吧？

690
00:36:16,710 --> 00:36:17,978
我们还能实现什么功能呢？

691
00:36:18,545 --> 00:36:21,615
CAShapeLayer
有两个属性

692
00:36:21,682 --> 00:36:25,319
分别叫作strokeStart和strokeEnd
它们可以让你创建一个特效

693
00:36:25,385 --> 00:36:28,856
层会随着路径的长度自动绘制

694
00:36:29,022 --> 00:36:31,158
或是反复绘制和取消绘制

695
00:36:33,026 --> 00:36:33,927
这挺有意思的

696
00:36:33,994 --> 00:36:36,964
你可以将其用在UI的
许多不同效果上

697
00:36:37,030 --> 00:36:40,367
商标可以自动绘制
然后填充某些内容等等

698
00:36:41,502 --> 00:36:45,772
你还可以利用虚线模式属性
来实现一些有趣的功能

699
00:36:45,839 --> 00:36:48,475
特别是动画化
lineDashPhase

700
00:36:48,909 --> 00:36:52,746
如果你的层被设置成虚线样式绘制

701
00:36:53,080 --> 00:36:55,949
你就可以动画化
lineDashPhase

702
00:36:56,016 --> 00:36:58,485
从某些像素值到另外一些像素值

703
00:36:58,685 --> 00:37:00,521
它会沿着形状的边缘移动

704
00:37:00,954 --> 00:37:03,624
形成这种很酷的
像是行军蚁般的效果

705
00:37:05,659 --> 00:37:08,462
这就是形状层的内容
让我们来谈下梯度层

706
00:37:09,396 --> 00:37:10,931
你可能原来用过这些内容

707
00:37:10,998 --> 00:37:13,534
但是我猜
你们可能还没有试过将它们动画化

708
00:37:14,101 --> 00:37:16,470
所有这些属性都是可动画化的
所以你可以

709
00:37:16,537 --> 00:37:17,804
试一下 看看会得到什么效果

710
00:37:18,639 --> 00:37:21,375
你可能会得到一个层

711
00:37:21,542 --> 00:37:23,877
这是个遮盖着星星形状的梯度层

712
00:37:23,944 --> 00:37:26,446
如果你将开始点和结束点动画化

713
00:37:26,513 --> 00:37:28,615
从一边到另一边的话

714
00:37:28,815 --> 00:37:32,753
你就会得到这个闪亮的金属特效
看起来不错 对吧？

715
00:37:33,620 --> 00:37:37,391
我们其实已经把它用
在iOS UI的某个地方了

716
00:37:37,457 --> 00:37:38,625
抱歉 应该是Watch UI

717
00:37:38,926 --> 00:37:41,828
如果你用过Apple Pay
里面划卡的效果

718
00:37:41,895 --> 00:37:43,897
用的就是梯度层

719
00:37:45,432 --> 00:37:48,368
我想介绍的最后一点是层速度

720
00:37:49,136 --> 00:37:51,972
这是个挺有意思的技巧
它可能有点难用

721
00:37:52,039 --> 00:37:53,674
但是你可以用它实现一些相当酷的效果

722
00:37:54,441 --> 00:37:55,342
那么

723
00:37:57,277 --> 00:38:00,314
在CA中没有全局时间这样的概念

724
00:38:00,380 --> 00:38:05,018
它只有从一层到其子层的相对时间

725
00:38:05,085 --> 00:38:06,520
还有其子层到子子层的相对时间

726
00:38:07,554 --> 00:38:10,057
所以每层都会有不同的时间量程

727
00:38:10,123 --> 00:38:12,893
就像是 它超层上过了一秒

728
00:38:12,960 --> 00:38:14,294
而子层上过了两秒

729
00:38:15,095 --> 00:38:17,865
结果就是

730
00:38:18,131 --> 00:38:21,535
对于被加到两层中其中一层的动画
如果动画是被加到速度为2的层上

731
00:38:21,602 --> 00:38:24,304
它就会以两倍速播放
如果它是被加到0.5倍速的层上

732
00:38:24,605 --> 00:38:27,140
它就会以半倍速播放

733
00:38:28,075 --> 00:38:32,813
它可以让你将动画
或多或少地慢点播放

734
00:38:32,880 --> 00:38:34,915
不过这似乎有点没必要
你只需要

735
00:38:36,483 --> 00:38:38,485
在刚开始的时候
设好它们的持续时间就行了 对吧？

736
00:38:39,019 --> 00:38:42,256
但是当你把层速度设为0的时候
就会实现一个很酷的效果

737
00:38:43,357 --> 00:38:46,426
动画不会再变化

738
00:38:47,327 --> 00:38:48,762
动画暂停了

739
00:38:49,062 --> 00:38:50,664
这可能看上去也没什么用

740
00:38:50,731 --> 00:38:54,234
对于调用了Core Animation的对象来说
但是它会赋予你

741
00:38:54,301 --> 00:38:58,105
动画过程的控制权
通过一个叫作timeOffset的属性

742
00:38:58,805 --> 00:39:03,477
你可以让用户或是

743
00:39:03,544 --> 00:39:05,546
应用中的其他进程
与动画进行交互

744
00:39:05,612 --> 00:39:09,550
你可以获得一个复杂的动画
或者一系列子动画

745
00:39:09,850 --> 00:39:14,221
而设定某一层上的timeOffset属性
就可以让所有层

746
00:39:14,288 --> 00:39:19,293
都根据其超层的位置来进行动画化

747
00:39:20,060 --> 00:39:23,230
它可以让你实现像是这样的效果

748
00:39:24,531 --> 00:39:28,135
随着用户上下拖动
层会自己逐渐地显示出来

749
00:39:28,435 --> 00:39:32,472
而这些符号表情就会随着这个过程
来回出现消失

750
00:39:33,540 --> 00:39:34,408
还有

751
00:39:35,108 --> 00:39:37,377
这挺酷的
不过可能是我乱编的 对吗？

752
00:39:37,444 --> 00:39:38,979
这可能就是个关键框动画

753
00:39:39,213 --> 00:39:43,150
让我们看下关于它的演示吧

754
00:39:46,119 --> 00:39:49,556
这里我们有个设置好的简单测试应用

755
00:39:49,723 --> 00:39:54,862
它有个基础的视图子类
设置了所有符号表情并将它们显示出来

756
00:39:55,896 --> 00:39:56,997
没有什么花哨的东西

757
00:39:57,998 --> 00:40:02,035
主要是它提供一个列表的符号表情层

758
00:40:02,102 --> 00:40:04,204
我们能抓取这些符号表情层
然后将其动画化

759
00:40:05,439 --> 00:40:07,174
如果你看下我们的视图控制器代码

760
00:40:07,407 --> 00:40:10,611
这里没有太多东西 让我们修改一下

761
00:40:14,715 --> 00:40:17,351
我们首先要构建动画集

762
00:40:17,518 --> 00:40:20,621
来让面板层显示出来

763
00:40:22,222 --> 00:40:24,091
稍等一下

764
00:40:26,226 --> 00:40:28,629
这样我们就有一对基本的动画了

765
00:40:29,229 --> 00:40:31,465
其中一个影响边的宽度
另一个影响高度

766
00:40:31,865 --> 00:40:35,536
你会发现
我将第一个动画的持续时间设成了1

767
00:40:35,702 --> 00:40:38,739
因为它是序列中最长的动画

768
00:40:38,939 --> 00:40:43,043
这样在你计算动画所需的持续时间时
就很容易了

769
00:40:43,210 --> 00:40:46,446
0秒到1秒 0到1
百分之0到百分之100

770
00:40:48,148 --> 00:40:50,450
接着我们把这两个动画加到层中

771
00:40:52,419 --> 00:40:53,453
当我们运行的时候

772
00:40:57,257 --> 00:41:00,294
就能看到动画效果 动画只出现了一次
没有别的效果了对吧？

773
00:41:00,527 --> 00:41:04,298
我们还发现符号表情没有动画
这样子挺没意思

774
00:41:05,999 --> 00:41:07,000
那么

775
00:41:08,001 --> 00:41:09,603
让我再多变动一点东西

776
00:41:15,976 --> 00:41:16,910
那么

777
00:41:18,178 --> 00:41:20,614
这是很直观的

778
00:41:20,681 --> 00:41:22,783
我们就是设置了一系列的动画

779
00:41:22,850 --> 00:41:26,587
每层上都有一个动画且给每个动画设置
一个比前面稍晚一些的开始时间

780
00:41:27,421 --> 00:41:30,257
你会发现 我不能把开始时间设成

781
00:41:30,324 --> 00:41:32,159
未来的某个时间点

782
00:41:32,226 --> 00:41:34,461
我必须要计算出开始时间

783
00:41:34,528 --> 00:41:38,599
将父层认可的时间添加上去

784
00:41:38,832 --> 00:41:41,468
如果我将它设成0加上这个数值

785
00:41:41,635 --> 00:41:44,071
那么动画就会在原来某处开始

786
00:41:44,137 --> 00:41:46,073
这样所有代码就写好了

787
00:41:47,641 --> 00:41:49,776
如果我们重新运行下代码

788
00:41:51,311 --> 00:41:55,082
我们现在就能看到视图的入场动画
所有的符号表情都在动

789
00:41:55,616 --> 00:41:59,419
不过现在还是不能交互
让我们解决下这个问题

790
00:42:02,222 --> 00:42:03,156
那么

791
00:42:05,025 --> 00:42:07,194
让我在这设一个变量来追踪

792
00:42:07,461 --> 00:42:10,397
容器面板扩展了多少

793
00:42:11,498 --> 00:42:14,067
然后我们要设置一个简单的手势识别器

794
00:42:14,334 --> 00:42:17,538
来控制视图

795
00:42:19,840 --> 00:42:20,707
那么

796
00:42:23,944 --> 00:42:27,147
这里所实现的功能是
当这个平面手势识别器

797
00:42:27,214 --> 00:42:30,017
在视图中移动的时候
我们就可以获得它移动的距离

798
00:42:30,083 --> 00:42:31,818
截至上次有事件发生的时候

799
00:42:32,753 --> 00:42:36,657
我们会将屏幕上某个像素点

800
00:42:36,924 --> 00:42:38,425
设成一个0到1之间的值

801
00:42:39,860 --> 00:42:42,429
然后我们将当前的容器扩展设成该值

802
00:42:42,930 --> 00:42:45,032
最后我们就不用再追踪

803
00:42:45,098 --> 00:42:48,502
识别器是从哪开始的了
我们只需要将它的转换设回0

804
00:42:48,769 --> 00:42:51,972
这样在它下次被调用的时候
它就会给出其移动的距离

805
00:42:52,039 --> 00:42:54,641
从上一次你将它设为0的时候

806
00:42:56,743 --> 00:42:57,678
那么

807
00:42:58,846 --> 00:43:01,215
差不多就完成了

808
00:43:02,149 --> 00:43:05,853
你只需要将容器这个最后的关键部分

809
00:43:08,121 --> 00:43:10,023
的容器层速度设为0就可以了

810
00:43:11,792 --> 00:43:13,160
这样

811
00:43:14,561 --> 00:43:15,596
稍等一下

812
00:43:17,698 --> 00:43:18,732
这样你就实现了这个效果

813
00:43:19,399 --> 00:43:21,235
我拖动下 它就会出现

814
00:43:21,902 --> 00:43:23,136
我向上拖动 它就会消失

815
00:43:23,871 --> 00:43:25,772
向下 向上 向下

816
00:43:26,340 --> 00:43:27,307
很简单 对吧？

817
00:43:34,781 --> 00:43:39,152
这就是一些你会在CA中用到的技巧

818
00:43:39,419 --> 00:43:41,021
你可以在应用中使用这些技巧

819
00:43:41,088 --> 00:43:44,925
使应用变得更加动人
或者说拥有更加丰富的视觉感受

820
00:43:46,260 --> 00:43:48,629
现在让我们总结一下

821
00:43:50,297 --> 00:43:51,231
首先

822
00:43:52,332 --> 00:43:53,700
就是拓展了你的工具集

823
00:43:53,767 --> 00:43:56,937
我们介绍了一些API
对它们有了个大概的印象

824
00:43:57,004 --> 00:43:59,173
你可能会用它们来解决不同的问题

825
00:43:59,239 --> 00:44:01,875
如果你要处理3D内容
你现在就知道要用SceneKit了

826
00:44:02,209 --> 00:44:05,112
你需要过滤一些图像的话
就要用Core Image

827
00:44:07,381 --> 00:44:08,615
我们还介绍了一些最优解决方案

828
00:44:08,782 --> 00:44:09,783
你们不是非得用

829
00:44:09,850 --> 00:44:11,952
但它能给你节省很多时间
还能解决些麻烦的问题

830
00:44:12,019 --> 00:44:14,588
而且如果你团队中有人说

831
00:44:14,655 --> 00:44:16,490
“这个荒谬的动画问题是怎么回事？”

832
00:44:16,557 --> 00:44:19,626
你就可以说“我知道是怎么回事”
所以它们是相当实用的

833
00:44:20,627 --> 00:44:23,497
最后就是关于API的一些体验

834
00:44:23,564 --> 00:44:26,333
我讲过每个CA层属性差不多

835
00:44:26,400 --> 00:44:29,203
都是可以动画化的
而我们只介绍了其中的五个

836
00:44:29,469 --> 00:44:31,905
还有很多的层属性
还有很多你能实现的很棒的效果

837
00:44:32,139 --> 00:44:34,908
如果你将这些属性结合起来用的话
就会发现

838
00:44:34,975 --> 00:44:37,211
当你把属性结合起来的时候
能实现的效果如此之多

839
00:44:37,711 --> 00:44:40,214
我们有一些不错的
讲解这些属性的示例代码

840
00:44:40,280 --> 00:44:43,317
这些代码涵盖了比我们所讲
多得多的细节

841
00:44:44,218 --> 00:44:48,155
所以你们在演讲结束后要做的第一件事
就是下载演讲的示例代码

842
00:44:48,622 --> 00:44:50,691
把这些示例代码看一下
不幸的是

843
00:44:50,891 --> 00:44:54,194
那个演示还没有被放到上面
不过我们会尽快把它放上去

844
00:44:54,895 --> 00:44:58,065
不幸的是 你们错过了很多的演讲

845
00:44:59,533 --> 00:45:01,568
但是我强烈建议
你们回去看看这些演讲的视频

846
00:45:01,635 --> 00:45:05,405
今年我们加了些很酷的功能
特别是在UIKit和SceneKit中

847
00:45:06,573 --> 00:45:09,710
明天有关于SpriteKit的演讲
如果你觉得可以这么早来就去听一下

848
00:45:10,077 --> 00:45:11,278
我不能确定会不会来

849
00:45:12,980 --> 00:45:14,815
这就是我要讲的所有内容了

850
00:45:14,882 --> 00:45:16,617
我希望能在狂欢中看到你们
谢谢你们

