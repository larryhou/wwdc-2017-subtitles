1
00:00:22,789 --> 00:00:23,624
嘿 你们好！

2
00:00:23,690 --> 00:00:29,329
嗨 大家好 下午好
欢迎参加今年的演讲

3
00:00:29,897 --> 00:00:32,665
看看那些HLS家伙们
最近一直在搞什么鬼

4
00:00:33,500 --> 00:00:36,403
尽管幻灯片上放不下 你们很可能
会得到你们要得到的东西

5
00:00:37,971 --> 00:00:41,175
我是Roger Pantos
我是你们今晚的演讲人

6
00:00:41,775 --> 00:00:44,311
我们将会谈到一大堆内容

7
00:00:44,611 --> 00:00:47,447
我们有一些很有意思的新编解码器

8
00:00:47,681 --> 00:00:53,353
我们有一些新流媒体功能
我们还对API做了一些改进

9
00:00:53,987 --> 00:00:58,358
但首先我们要宣布一件事

10
00:00:58,792 --> 00:01:01,762
我很高兴地宣布

11
00:01:02,062 --> 00:01:08,936
IETF已经批准将HLS规范
作为因特网草案发布

12
00:01:14,741 --> 00:01:19,213
那么这意味着当前在网站上发布的草案

13
00:01:19,279 --> 00:01:22,082
也就是-23

14
00:01:22,349 --> 00:01:26,053
将进入IETF发布过程 一旦通过

15
00:01:26,286 --> 00:01:28,288
它将会被分配一个RFC编号

16
00:01:29,056 --> 00:01:32,826
我们大约在过去的8年
或9年里一直在更新草案

17
00:01:32,893 --> 00:01:37,464
有一点儿问题 好的
嗯 为什么是现在？

18
00:01:37,531 --> 00:01:38,665
为什么要发布RFC？

19
00:01:38,999 --> 00:01:42,936
其中一个原因是我们
从某些人中听到了一些反馈

20
00:01:43,170 --> 00:01:45,939
他们说写规范有点儿恐怖

21
00:01:46,006 --> 00:01:48,208
需要一直修改草稿

22
00:01:48,675 --> 00:01:50,544
我们听到了这个反馈 我们非常理解

23
00:01:50,911 --> 00:01:54,748
那么把规范发布为RFC

24
00:01:54,948 --> 00:01:59,620
将允许它作为一个稳定的引用

25
00:01:59,987 --> 00:02:03,657
意思是你可以满怀信心地
在它上边进行创建

26
00:02:03,724 --> 00:02:06,560
你可以在其它规范中引用它

27
00:02:06,793 --> 00:02:09,496
我们希望它可以帮助

28
00:02:09,562 --> 00:02:12,499
稍微改善一下
行业某些区域中的某些事

29
00:02:13,500 --> 00:02:17,337
现在我们会停止更新HLS吗？

30
00:02:17,571 --> 00:02:20,908
不 当然不会 我们会继续衍变它

31
00:02:22,910 --> 00:02:29,116
我们会让它变得更好
为用户打造越来越棒的流媒体体验

32
00:02:29,583 --> 00:02:31,785
从我们今天要讲的东西开始

33
00:02:32,186 --> 00:02:34,054
那么我们的实现方式是

34
00:02:34,288 --> 00:02:37,124
引入一个新的因特网草案

35
00:02:37,424 --> 00:02:40,761
将会建在即将出现的RFC上作为基准

36
00:02:41,061 --> 00:02:42,729
并关注它

37
00:02:43,764 --> 00:02:49,002
好的 现在让我们来看本次演讲的
第二个大新闻 就是HEVC

38
00:02:49,436 --> 00:02:53,841
你应该从主题演讲和其它地方
听到了Apple选择了HEVC

39
00:02:53,907 --> 00:02:55,809
作为我们的下一代视频编解码器

40
00:02:56,310 --> 00:02:59,913
现在我们为什么这么做？
一个词就是效率

41
00:03:00,314 --> 00:03:02,649
首先是编码效率

42
00:03:04,384 --> 00:03:10,757
HEVC大约比AVC的效率高40%

43
00:03:10,824 --> 00:03:13,794
我的意思是它取决于你的内容
和你的编码器性能

44
00:03:13,861 --> 00:03:16,396
但40%是一个不错的大概估计

45
00:03:16,964 --> 00:03:20,634
对于我们中
那些通过网络搬运媒体的人来说

46
00:03:21,001 --> 00:03:25,772
这很令人激动
因为首先它意味着你的用户即将看到

47
00:03:25,939 --> 00:03:28,842
启动速度快了40% 品质优良

48
00:03:29,009 --> 00:03:31,411
当播放器随着时间的流逝
适应了它的方式

49
00:03:31,612 --> 00:03:34,214
你会发现内容比原来提升了40%

50
00:03:34,982 --> 00:03:41,088
这对于我们来说很重要
HEVC很棒 你能从哪儿得到它？

51
00:03:42,122 --> 00:03:46,193
嗯 正如我们所说过的
我们正在扩大HEVC的可用范围

52
00:03:46,360 --> 00:03:49,763
其实在我们最新设备上 装有A9
和更高版本芯片的

53
00:03:49,830 --> 00:03:54,034
最新iOS设备上以及
我们最新一代的Macintosh

54
00:03:54,368 --> 00:03:57,137
我们都支持把HEVC嵌入硬件

55
00:03:57,204 --> 00:03:59,973
那就包含了
对FairPlay流媒体的支持

56
00:04:01,008 --> 00:04:03,810
即便是在较老的设备上

57
00:04:04,778 --> 00:04:06,547
没有那种硬件支持的设备

58
00:04:06,713 --> 00:04:10,350
我们仍然要部署一个
软件HEVC编解码器

59
00:04:10,751 --> 00:04:14,388
那将用于装有iOS 11的
全部iOS设备上

60
00:04:14,621 --> 00:04:17,357
那包括装有tvOS 11
的Apple TV

61
00:04:17,591 --> 00:04:22,496
升级到High Sierra
的Macintosh

62
00:04:23,230 --> 00:04:26,934
HEVC即将出现在许多不同的地方

63
00:04:27,201 --> 00:04:28,335
我们希望你们能使用它

64
00:04:30,237 --> 00:04:33,707
为了配合HLS使用它
你需要记住几个要点

65
00:04:34,341 --> 00:04:40,747
第一是HEVC代表全新的内容编码

66
00:04:40,814 --> 00:04:44,017
意思就是

67
00:04:44,318 --> 00:04:47,554
好的一面是没有任何兼容版本的负担

68
00:04:47,888 --> 00:04:49,857
所以我们决定

69
00:04:50,524 --> 00:04:52,793
是时候把我们的注意力重新聚焦在

70
00:04:53,193 --> 00:04:55,796
单一容器格式上来了

71
00:04:56,096 --> 00:04:58,398
我们查看了可选方案并决定

72
00:04:58,632 --> 00:05:02,536
碎片式的MPEG-4最有潜力

73
00:05:02,836 --> 00:05:07,774
那意味着如果你要把你的HEVC内容
部署为HLS

74
00:05:08,141 --> 00:05:11,411
它需要被打包为MP4碎片

75
00:05:16,650 --> 00:05:21,788
现在另一件不错的事就是让编码过程

76
00:05:21,955 --> 00:05:25,826
更确切地说是加密过程变得稍微
简单点了

77
00:05:26,894 --> 00:05:29,530
因为我们老朋友cbcs模式的常见加密

78
00:05:29,596 --> 00:05:34,968
处理HEVC的方式
与处理H.264的方式一样

79
00:05:35,235 --> 00:05:36,470
所以没有什么新规则

80
00:05:36,537 --> 00:05:39,740
你只需要做同样的事
来处理你的HEVC位流就可以了

81
00:05:43,510 --> 00:05:47,414
有了新的编解码器 你就可以把它部署

82
00:05:47,581 --> 00:05:50,751
到一个其中某些设备
不支持HEVC的生态系统中

83
00:05:50,984 --> 00:05:55,689
所以你把你的位流
标记为HEVC非常关键

84
00:05:55,756 --> 00:05:58,659
从而使不支持HEVC的设备绕开它

85
00:05:59,560 --> 00:06:02,196
实现方式是 当然了在HLS中

86
00:06:02,262 --> 00:06:04,665
是在你的主播放列表中有编解码器属性

87
00:06:05,799 --> 00:06:09,736
我这里有一个HEVC的编解码器
参数的例子

88
00:06:09,803 --> 00:06:12,039
它比H.264稍微复杂点

89
00:06:12,105 --> 00:06:14,575
它包含了更多的东西 但没有那么糟糕

90
00:06:15,475 --> 00:06:19,580
整个格式都在HEVC规范中有记录

91
00:06:21,048 --> 00:06:23,851
那么说到H.264格式的老客户端

92
00:06:24,084 --> 00:06:28,021
很自然地有一个兼容性的问题…

93
00:06:28,822 --> 00:06:32,759
首先你能把单一资产部署

94
00:06:33,293 --> 00:06:36,830
到老的和新的客户端吗？答案是是的

95
00:06:40,234 --> 00:06:41,235
我们继续

96
00:06:42,636 --> 00:06:48,108
你可以在同一个主播放列表中
混合HEVC和H.264变量

97
00:06:48,509 --> 00:06:52,679
那将会适用于常规的视频方差
以及I-frame方差

98
00:06:52,746 --> 00:06:55,983
你也可以有这些的
HEVC和H.264版本

99
00:06:56,650 --> 00:07:01,755
正如我所说 你的确需要将HEVC
打包为MPEG-4碎片

100
00:07:02,055 --> 00:07:06,326
但对于落后的兼容性H.264
可以是TransForce帧

101
00:07:06,460 --> 00:07:09,263
或碎片式MPEG-4格式 随你选择

102
00:07:10,264 --> 00:07:13,166
标注媒体播放列表
变得更加关键和重要了

103
00:07:13,433 --> 00:07:15,969
从而让我们了解什么是什么

104
00:07:18,739 --> 00:07:23,010
最后我们实际上更新了
如果你们还不知道的话

105
00:07:23,076 --> 00:07:26,480
我们有一个文档叫作HLS编写指南

106
00:07:26,847 --> 00:07:29,583
是Apple TV
及其内容的最佳范例

107
00:07:30,484 --> 00:07:33,687
我认为我们修改了名称
但无论怎样都没什么关系

108
00:07:33,887 --> 00:07:37,291
因为实际上今天就有一场演讲

109
00:07:37,591 --> 00:07:42,095
叫作HLS编写更新
我们更新了HEVC的内容

110
00:07:42,329 --> 00:07:44,631
那么现在的编写指南

111
00:07:44,698 --> 00:07:47,568
有了针对HEVC的额外注意事项

112
00:07:47,634 --> 00:07:52,272
以及推荐位速率层的初始设置

113
00:07:52,339 --> 00:07:54,975
让你们大家能使用它
那么请参看那场演讲

114
00:07:55,309 --> 00:07:57,077
我听说那场演讲的演讲者做得很棒

115
00:07:59,613 --> 00:08:00,480
接下来

116
00:08:02,115 --> 00:08:07,721
我们有了一个新的字母格式
叫作IMSC

117
00:08:08,088 --> 00:08:11,558
现在你们中有很多人
还没有听说过IMSC

118
00:08:12,159 --> 00:08:16,563
在消费者中
它目前还不像VTT那么有名

119
00:08:18,198 --> 00:08:23,570
但它应该是一种更有名的格式的孙子

120
00:08:23,637 --> 00:08:26,106
叫作时序文本标记语言或TTML

121
00:08:26,473 --> 00:08:30,611
TTML非常有表现力

122
00:08:30,677 --> 00:08:33,679
但不怎么是轻量级的编辑语言

123
00:08:33,746 --> 00:08:35,749
主要用作字幕编辑

124
00:08:36,149 --> 00:08:40,053
用于夹层和互换之类的

125
00:08:40,787 --> 00:08:46,193
那么时序文本工作组所做的工作

126
00:08:46,693 --> 00:08:49,563
就是精简了TTML 稍微改进了它

127
00:08:49,830 --> 00:08:52,165
从而通过因特网
给消费者提交常规字幕

128
00:08:52,533 --> 00:08:54,701
那么这就叫作IMSC

129
00:08:55,769 --> 00:08:57,871
现在我们也接纳VTT

130
00:08:57,938 --> 00:09:01,441
那么很明显就提出了这个问题
IMSC有什么不一样？

131
00:09:01,842 --> 00:09:08,115
主要不同点就是IMSC
比VTT有更好的支持、

132
00:09:08,182 --> 00:09:11,718
更广泛的样式控件

133
00:09:11,785 --> 00:09:14,555
VTT只有一些基本的样式控件

134
00:09:14,755 --> 00:09:17,090
然后其余的部分就依赖于CSS

135
00:09:18,158 --> 00:09:22,362
IMSC有更多自带的样式功能组合

136
00:09:22,563 --> 00:09:28,001
主要用于你对字幕的样式处理

137
00:09:28,802 --> 00:09:32,906
因此它获得了一定量的关注

138
00:09:32,973 --> 00:09:35,008
尤其是在广播行业

139
00:09:35,509 --> 00:09:41,415
甚至去年被选为MPEG
公共媒体应用格式的基准格式

140
00:09:41,481 --> 00:09:46,019
我们去年就跟你们提到过

141
00:09:47,020 --> 00:09:51,992
那么我们在iOS 11和其它
各种发布中所做的是

142
00:09:52,359 --> 00:09:56,029
我们延伸了

143
00:09:56,697 --> 00:09:59,967
IMSC的第一代底层实施

144
00:10:00,334 --> 00:10:05,305
已经是你们的囊中之物了
我们期待继续精炼它

145
00:10:06,006 --> 00:10:06,874
那么…

146
00:10:07,608 --> 00:10:09,576
…对于HEVC

147
00:10:09,776 --> 00:10:13,213
你需要了解几点关于IMSC的要点
从而可以与HLS一起使用

148
00:10:13,514 --> 00:10:15,148
第一点是它是如何打包的

149
00:10:15,849 --> 00:10:19,286
与VTT不同
VTT的片段就是小文本文件

150
00:10:20,454 --> 00:10:24,091
IMSC的传输
在MPEG-4第30章有定义

151
00:10:24,491 --> 00:10:29,630
从根本上来说 它实质上
是MPEG-4碎片内的XML文本

152
00:10:29,696 --> 00:10:33,500
它利用了MPEG-4的全部定时设施

153
00:10:34,001 --> 00:10:38,071
我说是文本 因为IMSC实际上
定义了两个配置文件

154
00:10:38,305 --> 00:10:40,274
一个图像配置文件和一个文本配置文件

155
00:10:40,607 --> 00:10:44,778
我们的客户端
仅支持IMSC的文本配置文件

156
00:10:45,946 --> 00:10:49,449
所以当你标注你的播放列表时

157
00:10:49,516 --> 00:10:52,186
你应该这样做 因为你同样面临着

158
00:10:52,252 --> 00:10:54,688
老客户端不能识别IMSC的问题

159
00:10:54,955 --> 00:11:00,594
你希望给IMSC添加编解码器标签
并且我在这里也提供了一个例子

160
00:11:00,794 --> 00:11:04,164
就是stpp.TTML.im1t

161
00:11:04,398 --> 00:11:08,335
它本质上是在表达
我的播放列表中有遵循

162
00:11:08,535 --> 00:11:11,471
IMSC1文本配置文件的字幕

163
00:11:13,473 --> 00:11:17,711
我几乎是同时谈了IMSC和HEVC

164
00:11:17,778 --> 00:11:21,548
我只想强调它们并没有关联

165
00:11:21,815 --> 00:11:24,952
你可以单独使用它们
你可以结合使用HEVC和VTT

166
00:11:25,018 --> 00:11:28,488
你可结合使用IMSC和H.264
你可以将它们全部结合在一起使用

167
00:11:29,556 --> 00:11:33,460
并且你甚至可以有一个VTT
和IMSC的单一播放列表

168
00:11:33,694 --> 00:11:37,931
较新的客户端可受益于IMSC的样式

169
00:11:38,098 --> 00:11:41,068
而较老的客户端可以继续使用VTT

170
00:11:41,134 --> 00:11:43,871
让我们看一个播放列表
并演示给你们看具体的效果

171
00:11:44,404 --> 00:11:46,440
我这里有一个主播放列表的碎片

172
00:11:46,673 --> 00:11:50,544
上边几行你们应该非常熟悉

173
00:11:50,611 --> 00:11:54,648
那是主播放列表的样子 如果你有一个

174
00:11:54,715 --> 00:11:58,752
叫作bipbop gear1的
视频变量并且它含有基于VTT的字幕

175
00:11:59,586 --> 00:12:06,326
接下来的几行标签有同样的视频层
但位于其编解码器属性中

176
00:12:06,393 --> 00:12:08,795
你可以看到它被标记为IMSC

177
00:12:09,196 --> 00:12:14,701
那么前边几行
将会拉动VTT.m3u8播放列表

178
00:12:14,902 --> 00:12:18,338
后边几行会拉动IMSC
如果客户端可以识别的话

179
00:12:18,906 --> 00:12:23,110
如果我们深入去看这两个媒体播放列表
它们实际上非常相似

180
00:12:24,311 --> 00:12:29,550
正如你所期待的 你可以看到VTT
只是一个.VTT片段的列表

181
00:12:30,083 --> 00:12:34,621
而IMSC也是一种
在本例中是一种MP4片段

182
00:12:34,688 --> 00:12:37,991
因为有MPEG-4片段
它也标记了这些碎片

183
00:12:38,192 --> 00:12:41,328
因为这是碎片式MPEG-4所要求的

184
00:12:41,395 --> 00:12:43,830
就是我们要能指向电影盒子

185
00:12:43,997 --> 00:12:46,099
那么除此之外 它们非常相似

186
00:12:46,500 --> 00:12:51,371
那么IMSC和VTT非常相似
它们实现的是同样的功能

187
00:12:53,674 --> 00:12:56,210
我为什么要为IMSC
切换我的HLS流媒体？

188
00:12:56,476 --> 00:12:59,379
嗯 你可能会切换你的流媒体 如果

189
00:13:00,347 --> 00:13:03,951
首先是如果你想控制更多的样式

190
00:13:04,184 --> 00:13:08,555
并且你的播放设备中
没有完整的CSS解析器

191
00:13:08,722 --> 00:13:12,025
那么IMSC就变得很有吸引力了

192
00:13:13,794 --> 00:13:19,666
第二个原因是你可能
已经以TTML编写了字幕

193
00:13:19,733 --> 00:13:22,035
或者也许你从服务供应商那儿获得了

194
00:13:22,236 --> 00:13:23,871
其中一种格式的字幕

195
00:13:24,137 --> 00:13:27,875
你可能发现转换TTML的IMSC

196
00:13:27,941 --> 00:13:31,111
比转换为VTT更简单
也许精确度也更高

197
00:13:31,311 --> 00:13:35,516
因为它们是非常相似的格式

198
00:13:36,149 --> 00:13:38,886
那么另一个原因也是最终的原因

199
00:13:39,253 --> 00:13:43,524
即你可能发现自己不管怎样
正在创建IMSC1流媒体

200
00:13:44,424 --> 00:13:49,263
我们之前提到CMAF要求

201
00:13:49,496 --> 00:13:52,232
在CMAF演示中使用IMSC字幕

202
00:13:52,666 --> 00:13:56,336
并且如果你发现自己想要利用

203
00:13:56,403 --> 00:14:00,073
那么多我们希望CMAF
可以生产的可兼容设备

204
00:14:00,374 --> 00:14:02,609
那么你最终将采纳IMSC1流媒体

205
00:14:02,910 --> 00:14:04,178
并且你也许…

206
00:14:05,312 --> 00:14:07,014
抱歉 你可能会…

207
00:14:09,316 --> 00:14:11,318
…抛弃VTT流媒体

208
00:14:11,385 --> 00:14:15,255
那将会简化你的工具链
和你的生产流程 那么…

209
00:14:17,991 --> 00:14:19,726
…现在说了这么多

210
00:14:20,694 --> 00:14:23,664
也许哪个也不适合你 在这种情况下

211
00:14:24,231 --> 00:14:28,001
坚持VTT是一个不错的选择
它仍会继续存在 事实上

212
00:14:28,702 --> 00:14:31,104
也许你主要面向的是北美市场

213
00:14:31,171 --> 00:14:34,308
在这种情况下608也没问题
它哪儿也不去

214
00:14:34,741 --> 00:14:36,443
那么我们有了不同的选择

215
00:14:37,611 --> 00:14:40,414
现在我提到很多次IMSC1

216
00:14:40,681 --> 00:14:43,984
可能会有一个疑问一直存在
即是否有IMSC2？

217
00:14:44,451 --> 00:14:46,587
答案是也许吧

218
00:14:47,454 --> 00:14:50,924
还没有最终确定 实际上仍在进展中

219
00:14:50,991 --> 00:14:56,430
但时序文本工作组计划
定义一个IMSC2

220
00:14:56,630 --> 00:14:59,800
我们关注的其中一个功能是

221
00:15:00,033 --> 00:15:03,003
一些更沉默的控件

222
00:15:03,170 --> 00:15:07,741
特别针对某些高级日语塑型功能

223
00:15:08,375 --> 00:15:10,811
比如“shatai”和
“tatsuyoko”

224
00:15:11,111 --> 00:15:17,384
那么简而言之IMSC2

225
00:15:17,551 --> 00:15:20,320
我们希望在它接下来的几年里
能取得进展

226
00:15:20,387 --> 00:15:22,422
那么请大家关注它

227
00:15:23,490 --> 00:15:27,461
好的 那么这就是编解码器相关的内容
现在让我们谈谈流媒体功能

228
00:15:27,828 --> 00:15:33,600
首先我想谈一下我们希望能让

229
00:15:33,901 --> 00:15:37,804
那些长期忍受折磨的人们在生产
实时流媒体方面变得稍微简单点儿

230
00:15:38,172 --> 00:15:41,975
帮助他们维护强健的体验

231
00:15:42,543 --> 00:15:45,779
因为HLS播放器通常很不错

232
00:15:45,846 --> 00:15:49,283
当一切都在后台运行良好时

233
00:15:49,616 --> 00:15:52,419
但当在后台发生问题时

234
00:15:52,486 --> 00:15:55,455
客户端实际上可以做得更好
帮助疏通流程

235
00:15:55,522 --> 00:15:56,790
让我来演示给你看

236
00:15:57,291 --> 00:16:00,194
那么在这里我们有 我猜在这里

237
00:16:00,527 --> 00:16:04,698
我们有典型的实时HLS播放列表

238
00:16:04,765 --> 00:16:06,266
目标时长为10秒

239
00:16:06,333 --> 00:16:08,335
片段是 你知道的 10秒左右

240
00:16:08,702 --> 00:16:10,771
10秒之后你可能想重新加载它

241
00:16:11,538 --> 00:16:15,442
底部是FileSequence12
但出现了FileSequence13

242
00:16:15,809 --> 00:16:19,079
10秒之后你再次重新加载
出现了FileSequence14

243
00:16:19,246 --> 00:16:21,682
当然了它们的出现并不是什么魔法

244
00:16:21,882 --> 00:16:25,052
你已经有了某种编码器
正在咀嚼媒体资源

245
00:16:25,319 --> 00:16:30,290
每隔10秒钟它就会在CEN中
写入一个新片段文件

246
00:16:30,924 --> 00:16:32,793
如果…会怎么样呢

247
00:16:33,660 --> 00:16:35,929
…不管什么原因编码器突然重启了？

248
00:16:36,196 --> 00:16:38,432
或者也许你用胳膊肘

249
00:16:38,498 --> 00:16:40,567
或什么敲了微波炉里的盘子
丢掉了媒体源

250
00:16:41,235 --> 00:16:46,406
嗯 在这个HLS客户端之前没有获知

251
00:16:46,573 --> 00:16:48,909
那种情况发生的方式
所以也没有什么方式来解决

252
00:16:49,443 --> 00:16:53,747
但现在我们定义了一个新标签
叫作GAP标签

253
00:16:54,214 --> 00:16:56,850
那么现在你可以在后台做的是

254
00:16:57,050 --> 00:17:02,122
当你丢掉编码器或丢掉媒体源时
你的打包工具

255
00:17:02,422 --> 00:17:07,094
可以继续写入片段
但不是写入媒体数据

256
00:17:07,261 --> 00:17:12,299
它可以仅仅写入一个虚拟URL
并给其附加一个GAP标签

257
00:17:12,900 --> 00:17:18,137
并且它可以继续这样做
直到那个流媒体的编码被禁用

258
00:17:18,338 --> 00:17:23,676
那么10秒钟之后 你可能会获得
另一个片段作为一个缺口

259
00:17:24,178 --> 00:17:27,580
那么这就告诉播放器说流媒体仍然存在

260
00:17:27,647 --> 00:17:30,217
它仍然在继续 它仍然在更新

261
00:17:30,617 --> 00:17:34,154
但对于媒体数据来说并没有那么棒

262
00:17:35,689 --> 00:17:38,158
一旦东西被重新存储
一旦你的编码器回来了

263
00:17:38,225 --> 00:17:41,528
或你已经清理了你的微波炉盘子
或诸如此类

264
00:17:42,162 --> 00:17:46,867
然后打包工具可以继续像以前一样
生产片段

265
00:17:47,100 --> 00:17:50,237
那么对于客户端来说
GAP标签意味着什么？

266
00:17:51,271 --> 00:17:55,576
它主要表达这里没有媒体数据

267
00:17:56,243 --> 00:18:00,681
那么当然了 作为第一近似值

268
00:18:01,014 --> 00:18:04,117
会下载它
因为并不是播放器不应该尝试

269
00:18:04,418 --> 00:18:09,456
而更有意思的是一旦播放器
看到GAP标签出现

270
00:18:09,523 --> 00:18:13,727
在媒体播放列表中
它可以离开并尝试寻找另一个

271
00:18:13,794 --> 00:18:17,831
没有同样缺口的变量
因为你可能有多个冗余的编码器

272
00:18:18,031 --> 00:18:20,501
生产不同的变量或冗余的变量

273
00:18:20,567 --> 00:18:23,136
也许我们正在播放
2-megabit流媒体

274
00:18:23,303 --> 00:18:26,006
且我们可能发现
当我们发现1-megabit流媒体

275
00:18:26,073 --> 00:18:30,043
哦 它实际上没有缺口
那么我们只需要切换到它

276
00:18:30,110 --> 00:18:31,879
我们可以通过
1-megabit流媒体播放

277
00:18:32,212 --> 00:18:35,849
一旦我们完成对缺口的处理
我们切换回3-megabit流媒体

278
00:18:35,916 --> 00:18:40,687
2-megabit流媒体都可以
用户甚至都感觉不到 那么…

279
00:18:42,122 --> 00:18:48,328
…我们还有一种情况

280
00:18:48,862 --> 00:18:50,964
就是你可能只有一个编码器
或如我所说的

281
00:18:51,031 --> 00:18:52,733
你可能打破了你的媒体源

282
00:18:52,799 --> 00:18:54,902
你可能没有用于整个缺口的媒体

283
00:18:54,968 --> 00:18:57,471
并且在那种情况下
我们的播放器的行为是

284
00:18:57,671 --> 00:19:00,908
我们将会处于实时流媒体情境中
并继续无声播放

285
00:19:01,108 --> 00:19:03,510
直到媒体回来
然后我们可以恢复正常播放

286
00:19:04,511 --> 00:19:08,182
现在新GAP标签和其它一些东西

287
00:19:08,448 --> 00:19:12,486
在HLS规范的beta版本中有描述
我昨晚还在写

288
00:19:12,886 --> 00:19:15,622
那么我认为我们今天会发布它
非常棒

289
00:19:17,558 --> 00:19:18,992
我都等不及想看到它了

290
00:19:23,030 --> 00:19:26,800
是的 好的 反馈当然是很受欢迎了

291
00:19:28,936 --> 00:19:31,305
那么这是GAP标签
让我们谈谈另一个新功能

292
00:19:31,371 --> 00:19:33,874
这也是用于后台的

293
00:19:34,842 --> 00:19:38,045
我们所做的是我们支持

294
00:19:38,245 --> 00:19:41,448
在m3u8播放列表中
简单的变量置换

295
00:19:41,615 --> 00:19:45,018
为此我们借用了一点儿PHP语法

296
00:19:46,186 --> 00:19:49,456
那么意思就是如果你看到一些
像那个突出显示的东西…

297
00:19:49,857 --> 00:19:51,992
…在播放列表中 它所表达的是

298
00:19:52,259 --> 00:19:54,261
把那个用大括号括起来的东西

299
00:19:54,328 --> 00:19:58,398
用变量值替换 变量名称就是文件名称

300
00:19:58,665 --> 00:19:59,633
那么如果

301
00:19:59,700 --> 00:20:01,869
变量值恰巧是foo

302
00:20:02,135 --> 00:20:04,671
你最终会得到一个foo.ts字符串

303
00:20:05,873 --> 00:20:06,740
现在

304
00:20:08,175 --> 00:20:11,078
要定义这些东西
我们定义了一个新标签

305
00:20:11,512 --> 00:20:13,680
非常简单 我稍后会向你们介绍

306
00:20:13,747 --> 00:20:19,553
它要么在播放列表内定义一个变量
要么导入它

307
00:20:19,920 --> 00:20:23,123
现在就是这里让事情变得有意思了

308
00:20:23,190 --> 00:20:24,791
因为你记得我说过会让

309
00:20:24,858 --> 00:20:26,727
创建流媒体的人们生活好过一点儿吧

310
00:20:26,793 --> 00:20:27,761
那么是如何实现的呢？

311
00:20:27,828 --> 00:20:29,897
我的意思是 是的
你可以…如果你有…

312
00:20:30,464 --> 00:20:34,168
大喇叭一样的URL 你可以使用变量
来让你的播放列表变短

313
00:20:34,568 --> 00:20:37,704
但我的意思是[听不清]已做得很好了

314
00:20:38,105 --> 00:20:39,907
那么就不是…这有点儿…但是

315
00:20:40,507 --> 00:20:42,109
有意思的是

316
00:20:42,176 --> 00:20:45,646
当你可以在主播放列表中定义变量

317
00:20:46,079 --> 00:20:48,081
并在媒体播放列表中使用它时

318
00:20:48,649 --> 00:20:52,319
那允许你提前通过小占位符

319
00:20:52,519 --> 00:20:54,388
来构建你的媒体播放列表

320
00:20:54,454 --> 00:20:57,291
以一种有点儿像后期绑定的方式填充

321
00:20:57,524 --> 00:20:59,326
当定义你的主播放列表时

322
00:20:59,393 --> 00:21:01,195
那么比如说你可以

323
00:21:01,261 --> 00:21:04,731
在你的媒体播放列表
或CDN中有一大堆变量引用

324
00:21:04,998 --> 00:21:06,466
且你能生产自己的主播放列表

325
00:21:06,533 --> 00:21:08,468
从你的应用中动态地生产

326
00:21:08,535 --> 00:21:12,239
在那点上你就可以表明
“我希望我的变量像这样”

327
00:21:12,539 --> 00:21:15,876
然后突然你CDN上的所有
媒体播放列表都将会利用它

328
00:21:16,276 --> 00:21:17,945
那么让我们看看会是什么样子

329
00:21:18,946 --> 00:21:20,247
这是主播放列表

330
00:21:20,314 --> 00:21:22,149
这是个很简单的例子

331
00:21:22,449 --> 00:21:24,852
我在这里有一个定义标签
我有两个属性

332
00:21:24,918 --> 00:21:27,588
名称属性表明了变量名称是auth

333
00:21:28,155 --> 00:21:31,358
它有一个值就是auth令牌的定义

334
00:21:32,259 --> 00:21:35,863
你可以在主播放列表中的
许多地方使用这个

335
00:21:36,163 --> 00:21:39,333
比如说 在这里的gear1中
我决定

336
00:21:39,499 --> 00:21:43,971
把auth令牌附加给
第一个变量URL

337
00:21:45,639 --> 00:21:48,375
但现在让我们想象一下
我们加载那个媒体播放列表

338
00:21:49,243 --> 00:21:52,679
再一次 媒体播放列表可以有变量
就像猪播放列表一样

339
00:21:52,746 --> 00:21:55,682
在本例中 我有一个路径
包含这个又大又长的路径

340
00:21:55,749 --> 00:21:57,985
我不想重复输入这么一大长串

341
00:21:58,051 --> 00:22:00,187
但第二个定义更有意思

342
00:22:00,254 --> 00:22:02,256
在本例中 我们正在导入

343
00:22:02,322 --> 00:22:05,092
我们在主播放列表中
定义的auth变量

344
00:22:05,259 --> 00:22:09,863
并且我们正在把它应用到不同的地方
比如媒体播放列表中的这个URL

345
00:22:10,497 --> 00:22:14,268
那么这就允许你

346
00:22:14,334 --> 00:22:16,203
获得一种疏耦合效果

347
00:22:16,270 --> 00:22:18,005
在你的主播放和媒体播放列表之间

348
00:22:18,071 --> 00:22:21,642
我认为人们将会发现
它的很多有意思的用途

349
00:22:22,876 --> 00:22:26,013
接下来 好的
那么我们谈了一些后台功能

350
00:22:26,180 --> 00:22:28,715
让我们来谈一些你可以实际用来

351
00:22:28,782 --> 00:22:31,885
提供引人注目的用户体验的东西

352
00:22:32,819 --> 00:22:35,255
现在我是什么意思呢？嗯 比如说

353
00:22:36,089 --> 00:22:38,225
如果你想让用户可以

354
00:22:38,292 --> 00:22:39,660
当他们正在看比赛时

355
00:22:39,726 --> 00:22:43,697
你希望他们可以看到一个摄像头
看到某人传球了

356
00:22:43,764 --> 00:22:46,700
但同时又能看到守门员那儿的摄像头

357
00:22:46,767 --> 00:22:48,936
他们也能从守门员的角度看比赛

358
00:22:49,169 --> 00:22:51,538
或者如果你正在看比赛

359
00:22:51,605 --> 00:22:56,343
并且你希望看到
哈密尔顿汽车里的摄像头

360
00:22:56,643 --> 00:22:59,413
但你还想关注一下他后面的维特尔

361
00:23:00,214 --> 00:23:03,283
那么在那种情况下

362
00:23:04,051 --> 00:23:06,286
将这些功能合并起来的是

363
00:23:06,720 --> 00:23:11,258
播放多个相互同步的
实时流媒体的功能

364
00:23:11,725 --> 00:23:13,794
从而一个不会超过另一个

365
00:23:15,429 --> 00:23:16,430
这是你的未来

366
00:23:18,232 --> 00:23:21,101
那么为此

367
00:23:21,735 --> 00:23:25,706
我们只要求你有一个
或多个实时流媒体

368
00:23:26,073 --> 00:23:30,744
通过使用日期-时间标签来相互同步

369
00:23:30,811 --> 00:23:33,213
从根本上说意思就是
你把日期放到播放列表中

370
00:23:33,280 --> 00:23:34,848
日期就会在

371
00:23:35,282 --> 00:23:37,985
全部播放列表中衍生或派生出来
来自一个公共时钟

372
00:23:38,151 --> 00:23:40,420
一旦你完成了 然后你就可以创建

373
00:23:40,621 --> 00:23:45,492
多个独立的AVPlayer
并且你可以开始第一个播放

374
00:23:45,692 --> 00:23:49,162
然后开始同步开始第二个播放
通过使用

375
00:23:49,229 --> 00:23:52,766
AVPlayer setRatetime
atHostTime方法

376
00:23:53,233 --> 00:23:57,104
现在我应该站出来说

377
00:23:57,571 --> 00:24:02,209
AVPlayer中使用该方法会给你带来
严肃的AVFoundation街头信誉

378
00:24:02,543 --> 00:24:04,978
因为它并不是世界上最简单的API

379
00:24:07,014 --> 00:24:08,882
但是为了帮助你脱离困境

380
00:24:09,316 --> 00:24:11,985
今年我们实际上有一些示例代码

381
00:24:12,753 --> 00:24:15,656
是一款Apple TV应用
叫作SyncStartTV

382
00:24:16,190 --> 00:24:17,758
我认为

383
00:24:18,192 --> 00:24:21,161
我不能仅说 也许我可以展示一下
你们想看吗？

384
00:24:21,228 --> 00:24:22,129
是的

385
00:24:22,196 --> 00:24:23,697
好了 让我们来实际看一下吧

386
00:24:24,932 --> 00:24:27,501
我要切换到Apple TV

387
00:24:27,968 --> 00:24:30,671
如果我还记得是哪台设备的话
我想应该是这台

388
00:24:31,038 --> 00:24:33,407
我们有…我有我的小…

389
00:24:33,841 --> 00:24:37,077
为了演示实施同步流媒体

390
00:24:37,144 --> 00:24:41,548
我首先要生产一个实时流媒体组件

391
00:24:42,249 --> 00:24:45,252
那么我要稍微谈一下
这里正在发生什么

392
00:24:45,652 --> 00:24:50,057
我写了一个小应用…
把源从后面的摄像头取出来

393
00:24:50,357 --> 00:24:55,662
进行剖析 实际上是为它服务
手机作为一个HLS流媒体

394
00:24:55,996 --> 00:24:58,799
那么我有两个家伙 两台手机

395
00:24:58,866 --> 00:25:02,202
两个都做同一件事 左边一台
右边一台

396
00:25:02,269 --> 00:25:05,739
它们实际上已经联网了

397
00:25:06,006 --> 00:25:09,877
并且它们用了一个时钟
是一个很漂亮的精确的时钟

398
00:25:10,210 --> 00:25:11,812
是它们之间共享的时钟

399
00:25:12,546 --> 00:25:15,916
那么它们正在做它们自己的事

400
00:25:16,316 --> 00:25:18,051
那么让我开始我的…

401
00:25:19,853 --> 00:25:20,787
我没有…

402
00:25:22,189 --> 00:25:24,758
我没有权限来做一些更令人激动的事

403
00:25:24,825 --> 00:25:27,661
所以让们来做这个吧

404
00:25:28,529 --> 00:25:31,198
那么让我们看一下 我要启动我的…

405
00:25:32,866 --> 00:25:34,101
这里正在发生一些事

406
00:25:34,701 --> 00:25:37,638
让我们启动其中一个摄像头

407
00:25:37,704 --> 00:25:40,174
事实上让我们把它们都放在这儿

408
00:25:41,008 --> 00:25:42,242
你已经得到了…

409
00:25:43,076 --> 00:25:44,378
右侧在线了

410
00:25:45,479 --> 00:25:48,549
左侧也在线了 好的 那么…

411
00:25:50,083 --> 00:25:50,951
好了

412
00:25:53,620 --> 00:25:55,322
我的遥控也正确地定位了

413
00:25:55,389 --> 00:25:56,390
好的 SyncStartTV

414
00:25:56,456 --> 00:25:57,925
当你启动SyncStartTV时

415
00:25:58,959 --> 00:26:03,397
它会给你机会选择左侧或右侧视频

416
00:26:03,463 --> 00:26:06,200
让我们选择这家伙
弹出了一个Bonjour选择器

417
00:26:06,400 --> 00:26:08,969
你可以在Bonjour中
看到我的两个流媒体

418
00:26:09,036 --> 00:26:12,005
让我们从Stage Right开始
看看那正发生什么

419
00:26:12,072 --> 00:26:16,076
那儿并没发生什么
让我们启动这家伙…

420
00:26:17,678 --> 00:26:19,880
好的 现在选择左边的视频

421
00:26:20,948 --> 00:26:21,849
并且

422
00:26:23,650 --> 00:26:24,852
看一下

423
00:26:26,386 --> 00:26:27,321
它们是同步的！

424
00:26:32,826 --> 00:26:33,694
哦 天啊

425
00:26:34,094 --> 00:26:34,995
等一下

426
00:26:56,116 --> 00:26:57,084
好了

427
00:27:00,721 --> 00:27:01,655
谢谢

428
00:27:02,990 --> 00:27:05,425
我该如何返回幻灯片呢？好的 就这样

429
00:27:06,460 --> 00:27:08,428
这对于各个年龄段的人来说
都很有趣

430
00:27:09,096 --> 00:27:12,599
好的 那么我猜我正好
跳过了我的幻灯片

431
00:27:12,866 --> 00:27:15,802
哦 嗯 关于这种演示
我想提到的一件事就是

432
00:27:15,869 --> 00:27:17,738
你同时显示多个流媒体时

433
00:27:17,804 --> 00:27:21,441
一定要谨慎地确保其中一个流媒体

434
00:27:21,508 --> 00:27:23,677
不会占用你的全部带宽

435
00:27:23,744 --> 00:27:25,078
而让另一个流媒体忍饥挨饿

436
00:27:25,145 --> 00:27:27,814
那么通常你可以
通过给每个流媒体限流实现

437
00:27:28,115 --> 00:27:32,686
为此 今年我们还要给你们提供
另一个工具 就是一个分辨率帽

438
00:27:33,220 --> 00:27:37,157
那么本质上来说
正如它的名字所暗指的那样

439
00:27:37,224 --> 00:27:39,526
它允许你以编程方式表达“你知道吗？

440
00:27:39,593 --> 00:27:41,895
我要在一个480p的
小窗口中显示这个

441
00:27:42,129 --> 00:27:44,765
切换到1080p就毫无意义”

442
00:27:45,132 --> 00:27:46,633
那么

443
00:27:48,101 --> 00:27:50,103
当你有一个获取视频缩略图的应用

444
00:27:50,170 --> 00:27:51,772
或多个流媒体或如此内容应用时

445
00:27:51,839 --> 00:27:54,508
你不想深入查看
播放列表的血淋淋的细节

446
00:27:54,575 --> 00:27:58,612
那么设置一个带宽帽
这是一个很方便的东西

447
00:28:00,147 --> 00:28:03,183
有一种情况 当你设置最大分辨率时

448
00:28:03,250 --> 00:28:06,820
实际上比任何东西都要更小…
比任何可用的层都要小

449
00:28:06,887 --> 00:28:10,057
在那种情况下
我们只需要拾取最低的一个并播放

450
00:28:10,958 --> 00:28:12,192
非常简单易用

451
00:28:12,392 --> 00:28:13,694
如果你有一个播放项

452
00:28:13,760 --> 00:28:16,563
你只需要把它的偏好
最大分辨率设置为CG大小

453
00:28:16,930 --> 00:28:19,032
在几分钟之内就会起作用

454
00:28:20,000 --> 00:28:21,735
两个 稍微有点儿上和下

455
00:28:23,103 --> 00:28:25,806
好的 那么让我们谈谈其它东西

456
00:28:26,039 --> 00:28:30,077
去年我们引入了HLS脱机支持

457
00:28:30,277 --> 00:28:32,679
就是能下载你的HLS流媒体

458
00:28:32,746 --> 00:28:35,449
并在其它地方播放
比如飞机上 当没有网络时

459
00:28:35,516 --> 00:28:38,151
当我们谈到那个时 我们提到了

460
00:28:38,619 --> 00:28:40,554
将来某一天我们会

461
00:28:40,621 --> 00:28:43,991
在管理磁盘空间方面
起到一个更积极的角色

462
00:28:44,224 --> 00:28:47,361
那时候说的那个将来就是现在
所以我想给你们介绍

463
00:28:47,427 --> 00:28:50,664
在iOS 11中
我们的设置应用的新功能

464
00:28:51,131 --> 00:28:54,601
这有一个部分 用户可以进入并查看

465
00:28:54,835 --> 00:28:59,139
拥又脱机资产的全部应用
以及它们的使用占据了多少磁盘空间

466
00:28:59,473 --> 00:29:03,277
并且用户可以选择删除它们
如果他们想释放磁盘空间的话

467
00:29:04,011 --> 00:29:08,115
那么这对于你们这些家伙来说
意味着首先

468
00:29:08,182 --> 00:29:12,886
现在的OS稍微能

469
00:29:13,287 --> 00:29:18,192
离开并删除你的资产
当你的应用没在运行时

470
00:29:18,759 --> 00:29:20,794
有多种不同的实现方式

471
00:29:20,861 --> 00:29:23,497
用户可以自己决定实现

472
00:29:23,864 --> 00:29:27,134
或我们会问用户是否可以删除
他们的某些内容

473
00:29:27,201 --> 00:29:30,470
如果我们需要空间的话
比如像OS更新或之类的

474
00:29:30,537 --> 00:29:34,541
那么在iOS 11中
我们引入了一个新API

475
00:29:34,875 --> 00:29:39,713
允许你改变要删除哪些资产的选择

476
00:29:40,147 --> 00:29:43,217
它叫作AVAssetDownload
StorageManager

477
00:29:43,884 --> 00:29:49,389
它的使用方式是你给你
磁盘上的每一个脱机资产

478
00:29:49,456 --> 00:29:52,059
都创建一个政策
你通过管理工具设置它

479
00:29:52,626 --> 00:29:55,996
现在 下载存储管理政策

480
00:29:56,063 --> 00:30:00,133
有两个属性 失效日期和优先级

481
00:30:00,334 --> 00:30:03,403
今天我们只需要定义两个优先级
分别是重要和默认

482
00:30:03,470 --> 00:30:04,471
对于绝大多数人来说

483
00:30:06,673 --> 00:30:11,211
你要做的是将用户
尚未观看的资产标记为重要

484
00:30:11,512 --> 00:30:14,581
一旦我看了 就把它们切换回默认

485
00:30:14,648 --> 00:30:16,617
失效日期属性

486
00:30:16,683 --> 00:30:22,623
是为了防止你的资产在某一时刻
变得不再能被播放

487
00:30:22,689 --> 00:30:25,158
比如你可能发现你处于这种情况下

488
00:30:25,225 --> 00:30:27,928
某一个节目可能离开了你的目录

489
00:30:27,995 --> 00:30:29,763
你不再有播放它的权限了

490
00:30:29,830 --> 00:30:32,032
如果是这种情况 你可以设置失效日期

491
00:30:32,099 --> 00:30:35,736
那么它会在删除队列中起作用

492
00:30:37,004 --> 00:30:39,806
那么它的使用是非常简单直接的

493
00:30:40,207 --> 00:30:43,577
DownloadStorageManager
是一个单元素集合 你可以获取它

494
00:30:43,644 --> 00:30:46,680
创建一个新的可变政策 并设置属性

495
00:30:46,980 --> 00:30:48,515
然后你就告诉存储管理工具

496
00:30:48,582 --> 00:30:53,187
使用那个政策来处理AVAsset
在一个特别的文件URL

497
00:30:54,021 --> 00:30:57,157
你稍后还可以返回并查看当前政策

498
00:30:58,325 --> 00:31:00,394
那么这是按照你的方式进行的

499
00:31:02,462 --> 00:31:04,998
关于脱机的另一件事是

500
00:31:05,933 --> 00:31:08,202
我们从采用它的一些人那儿
得到了一些反馈

501
00:31:08,669 --> 00:31:12,372
下载一个以上的表演时

502
00:31:12,439 --> 00:31:15,008
比如 如果你想要英文音频
还想要西班牙语音频

503
00:31:15,642 --> 00:31:17,845
也许比它预计的要难一点儿

504
00:31:18,045 --> 00:31:21,715
首先如果你的应用受制于进入后台

505
00:31:21,982 --> 00:31:23,817
并在半途中退出了

506
00:31:24,117 --> 00:31:27,187
那么我很高兴地告诉你
在iOS 11中 我们引入了

507
00:31:27,588 --> 00:31:30,424
一种新方式来分批处理你的脱机下载

508
00:31:30,490 --> 00:31:32,960
它叫作AggregateAssetDownloadTask

509
00:31:33,193 --> 00:31:36,029
它允许你 对于一个指定资产

510
00:31:36,897 --> 00:31:41,101
表明一个像这样的媒体选择数组

511
00:31:41,502 --> 00:31:44,271
然后当你踢开下载任务时

512
00:31:44,705 --> 00:31:47,908
我们就开始执行 我们会下载每一个
我们会给你汇报进度

513
00:31:47,975 --> 00:31:49,877
然后当整件事情完成时我们会通知你

514
00:31:50,077 --> 00:31:51,879
希望它能让事情
变得稍微简单点了

515
00:31:53,247 --> 00:31:54,348
谢谢

516
00:31:55,983 --> 00:31:59,520
好的 今天我们要讲的另一部分内容

517
00:32:00,087 --> 00:32:04,558
都与在你的设备上管理内容相关

518
00:32:04,992 --> 00:32:10,030
这是一个非常复杂的话题 所以我要

519
00:32:10,097 --> 00:32:14,801
把你们交给我们自己的
HLS钥匙专家Anil Katti

520
00:32:14,868 --> 00:32:16,270
他会跟大家具体讲一下

521
00:32:16,637 --> 00:32:17,638
谢谢大家

522
00:32:26,180 --> 00:32:27,114
谢谢Roger

523
00:32:27,981 --> 00:32:30,517
大家晚上好 欢迎参加WWDC

524
00:32:31,952 --> 00:32:35,422
那么两年前我们引入了
FairPlay Streaming

525
00:32:35,522 --> 00:32:40,561
一个概念保护技术
帮助保护你的HLS资产

526
00:32:41,595 --> 00:32:44,831
自从这次引入之后
我们看到了明显的增长

527
00:32:45,599 --> 00:32:47,568
FairPlay Streaming
用于生产

528
00:32:47,634 --> 00:32:50,204
提交到我们平台上的高级内容

529
00:32:51,071 --> 00:32:55,242
今天我很激动地宣布一些针对

530
00:32:55,309 --> 00:32:57,544
FairPlay Streaming
钥匙提交过程的改进

531
00:32:58,078 --> 00:33:00,981
那将允许你简化你的流程

532
00:33:02,082 --> 00:33:04,151
熟练你的FairPlay
Streaming采用技能

533
00:33:05,018 --> 00:33:08,021
并支持新的内容生产功能

534
00:33:09,656 --> 00:33:12,025
但在我们谈这些改进之前

535
00:33:12,092 --> 00:33:15,229
我想先快速回顾一下
FairPlay Streaming

536
00:33:16,997 --> 00:33:20,534
FairPlay Streaming
指定了如何提交

537
00:33:20,868 --> 00:33:23,370
如何安全地提交内容解密钥匙

538
00:33:24,037 --> 00:33:27,274
在FairPlay Streaming系统中
有三个主要元素

539
00:33:28,008 --> 00:33:29,543
以媒体为中心的应用

540
00:33:30,744 --> 00:33:33,647
就是拥有播放会话的应用

541
00:33:34,248 --> 00:33:39,019
一方面有钥匙服务器
可以提供解密钥匙

542
00:33:39,653 --> 00:33:41,989
而另一方面AVFoundation

543
00:33:42,356 --> 00:33:45,726
为你提供内容的解密和播放支持

544
00:33:47,761 --> 00:33:51,331
提交内容解密钥匙一共有五个步骤

545
00:33:51,598 --> 00:33:55,002
那么这些步骤开始执行
是当用户浏览你的应用

546
00:33:55,335 --> 00:33:57,204
尝试选择某个视频进行播放时

547
00:33:57,771 --> 00:34:00,407
当用户这么做时
你的应用会创建一个资产

548
00:34:00,774 --> 00:34:03,610
并且由AVFoundation决定播放

549
00:34:05,012 --> 00:34:07,481
当AVFoundation
收到播放请求时

550
00:34:07,614 --> 00:34:09,315
它就开始传递播放列表

551
00:34:09,583 --> 00:34:11,618
当它看到内容是加密的时

552
00:34:11,685 --> 00:34:13,954
就使用FairPlay
Streaming提交钥匙

553
00:34:14,221 --> 00:34:18,192
通过给你发送钥匙请求
向你的应用请求钥匙

554
00:34:18,625 --> 00:34:20,092
通过委托回调

555
00:34:21,094 --> 00:34:24,364
在那点上 你可以使用钥匙请求对象

556
00:34:24,464 --> 00:34:30,003
创建一个服务器播放情境
或简称为SPC

557
00:34:30,737 --> 00:34:32,272
它是一个加密的数据块

558
00:34:32,505 --> 00:34:35,775
包含你的钥匙服务器所请求的信息

559
00:34:36,176 --> 00:34:38,078
用以创建内容解密钥匙

560
00:34:39,246 --> 00:34:42,449
然后你的应用把内容解密钥匙
发送给你的钥匙服务器

561
00:34:42,850 --> 00:34:46,987
并从那儿获取内容钥匙情境
或简称为CKC

562
00:34:48,021 --> 00:34:52,025
它是另一个包含解密钥匙的加密数据块

563
00:34:54,862 --> 00:34:59,099
最后一步 你的应用提供CKC

564
00:34:59,533 --> 00:35:03,437
作为对它最初接收到的钥匙
请求对象的一个响应

565
00:35:04,771 --> 00:35:06,974
那么假如AVFoundation

566
00:35:07,140 --> 00:35:10,010
已经加载了播放列表
并且现在媒体数据

567
00:35:10,711 --> 00:35:13,814
拥有它用于解密内容

568
00:35:14,181 --> 00:35:16,517
和开始播放的FairPlay
Streaming钥匙

569
00:35:18,151 --> 00:35:19,520
嗯 在某种意义上

570
00:35:19,753 --> 00:35:22,756
FairPlay Streaming钥匙
类似于这些其它资源

571
00:35:23,957 --> 00:35:25,626
并且事实上 如果你回顾一下

572
00:35:25,792 --> 00:35:28,629
如果你今天使用
FairPlay Streaming提交钥匙

573
00:35:28,896 --> 00:35:32,599
FairPlay Streaming钥匙
是通过AVAsset附件API提交的

574
00:35:32,666 --> 00:35:34,535
与其它自定义资源相似

575
00:35:35,569 --> 00:35:38,939
但差不多是时候
终结这种相似了 对吧？

576
00:35:39,106 --> 00:35:42,176
FairPlay Streaming
钥匙是专用资源

577
00:35:42,376 --> 00:35:45,145
定义有非常具体的操作

578
00:35:45,712 --> 00:35:47,581
我现在要给你看一些例子

579
00:35:49,049 --> 00:35:53,387
AVFoundation允许你释放
FairPlay Streaming钥匙

580
00:35:53,554 --> 00:35:57,324
以便你可以把它们
保存在你的应用存储中并稍后使用

581
00:35:57,624 --> 00:36:00,661
就像当用户尝试脱机播放内容时一样

582
00:36:02,696 --> 00:36:04,131
你可能还会定义

583
00:36:04,198 --> 00:36:07,401
FairPlay Streaming钥匙
在某时间段之后失效

584
00:36:08,268 --> 00:36:09,736
钥匙必须得更新

585
00:36:09,803 --> 00:36:12,272
在它们失效之前 以便继续解密

586
00:36:13,907 --> 00:36:16,443
随着内容生产功能的持续衍变

587
00:36:16,910 --> 00:36:18,212
FairPlay Streaming钥匙

588
00:36:18,278 --> 00:36:21,949
将持续变得更具体
而钥匙提交过程也是

589
00:36:23,717 --> 00:36:26,386
进一步说
FairPlay Streaming钥匙

590
00:36:26,620 --> 00:36:29,990
不一定要与资产相关联 当加载时

591
00:36:30,757 --> 00:36:33,427
那么我们认为通过去耦钥匙加载

592
00:36:33,994 --> 00:36:36,129
从媒体加载中或甚至是播放

593
00:36:36,730 --> 00:36:39,166
我们可以给你提供更多的灵活性

594
00:36:39,666 --> 00:36:42,836
可以用来处理现有的一些难点

595
00:36:43,136 --> 00:36:45,672
还可以提供更棒的用户体验

596
00:36:46,807 --> 00:36:48,408
那么考虑到这一切

597
00:36:48,775 --> 00:36:51,044
我们很高兴引入了一个新API

598
00:36:51,678 --> 00:36:55,949
它将允许你更好地管理
和提交内容解密钥匙

599
00:36:56,850 --> 00:36:58,819
AVContentKeySession简介

600
00:37:00,387 --> 00:37:03,290
AVContentKeySession
是一个AVFoundation类

601
00:37:03,357 --> 00:37:05,792
用于处理内容解密钥匙

602
00:37:06,026 --> 00:37:10,497
它允许你从媒体加载中去耦钥匙加载

603
00:37:10,664 --> 00:37:12,432
或甚至是播放 就此而言

604
00:37:13,534 --> 00:37:15,736
它还给你提供了一个更好的控制

605
00:37:16,103 --> 00:37:18,372
针对内容解密钥匙的生存周期

606
00:37:19,606 --> 00:37:20,707
那么如果你回顾一下

607
00:37:21,408 --> 00:37:26,413
你的应用只在收到来自

608
00:37:26,480 --> 00:37:27,447
AVFoundation
的钥匙请求后才会加载钥匙

609
00:37:28,682 --> 00:37:30,684
并且…但那个…

610
00:37:31,251 --> 00:37:33,487
你可以通过AVContentKeySession
改变这种方式

611
00:37:34,087 --> 00:37:37,691
通过AVContentKeySession
你可以决定何时加载钥匙

612
00:37:38,392 --> 00:37:41,662
然而 如果你选择
在请求播放之前不加载钥匙

613
00:37:42,296 --> 00:37:45,265
AVFoundation
将按需要给你发送钥匙请求

614
00:37:45,566 --> 00:37:46,633
就像它今天做的这样

615
00:37:47,935 --> 00:37:52,372
那么现在 我们给你提供了
两种触发钥匙加载过程的方式

616
00:37:54,007 --> 00:37:54,908
你可以使用…

617
00:37:55,342 --> 00:37:57,911
你的应用可以使用
AVContentKeySession

618
00:37:58,145 --> 00:38:00,447
来明确启动钥匙加载过程

619
00:38:01,348 --> 00:38:04,618
或AVFoundation按需要
启动钥匙加载过程

620
00:38:04,685 --> 00:38:06,486
当它看到内容被加密时

621
00:38:07,654 --> 00:38:10,524
那么让我们看看如何用
AVContentKeySession

622
00:38:10,591 --> 00:38:12,092
启动钥匙加载过程

623
00:38:12,526 --> 00:38:13,427
这对你们很有帮助

624
00:38:14,127 --> 00:38:16,330
那么首先 今天我们要使用的钥匙

625
00:38:16,396 --> 00:38:17,965
是关于开始播放的钥匙

626
00:38:20,501 --> 00:38:24,571
钥匙加载时间对于
你的播放开始时间非常重要

627
00:38:24,905 --> 00:38:27,508
因为应用通常当它们

628
00:38:28,342 --> 00:38:30,444
收到按需钥匙请求时才会加载钥匙

629
00:38:31,845 --> 00:38:35,315
你可以提升
你用户收到的播放开始体验

630
00:38:35,749 --> 00:38:37,017
如果你可以加载钥匙

631
00:38:37,084 --> 00:38:40,053
甚至在用户选择
要播放的内容之前加载

632
00:38:41,488 --> 00:38:43,824
AVContentKeySession
就允许你这么做

633
00:38:44,024 --> 00:38:48,161
你可以使用AVContentKeySession
启动钥匙加载过程

634
00:38:48,729 --> 00:38:50,731
然后通过你得到的钥匙请求

635
00:38:51,365 --> 00:38:54,635
在播放会话中独立加载钥匙

636
00:38:55,969 --> 00:38:57,604
现在我们调用这个钥匙预加载

637
00:38:59,139 --> 00:39:01,909
在钥匙加载完成之后 你可以请求播放

638
00:39:02,075 --> 00:39:02,976
那么

639
00:39:03,043 --> 00:39:05,045
在播放期间 你不必加载任何钥匙

640
00:39:05,112 --> 00:39:07,915
并且播放…会立即开始解密

641
00:39:09,183 --> 00:39:11,151
我今天要给大家展示的第二个用例

642
00:39:11,218 --> 00:39:15,756
随着时间收到了越来越多的盛赞
它与实时播放有关

643
00:39:17,324 --> 00:39:20,527
我们看到向我们平台上
提交的实时内容数量

644
00:39:20,594 --> 00:39:22,396
有了显著增长

645
00:39:22,563 --> 00:39:27,034
这都归因于用户在我们的设备上
获得的更拟真和更集成的体验

646
00:39:28,101 --> 00:39:33,774
有更多的用户在我们的设备上关注
体育运动以及其它实时事件

647
00:39:34,708 --> 00:39:38,011
开发人员也使用
更高级的内容生产功能 比如

648
00:39:38,545 --> 00:39:41,982
钥匙旋转和钥匙更新
以添加额外的保护层

649
00:39:42,049 --> 00:39:43,951
当提交附加实时内容时

650
00:39:46,453 --> 00:39:48,255
由于实时流媒体的性质

651
00:39:49,122 --> 00:39:53,026
你的钥匙服务器会同时遭受
上百万次钥匙请求的轰炸

652
00:39:53,093 --> 00:39:55,229
当钥匙被旋转或更新时

653
00:39:56,296 --> 00:40:01,134
嗯 你可以使用
AVContentKeySession来缓和这种情况

654
00:40:01,368 --> 00:40:04,538
通过在起始点平衡加载钥匙请求

655
00:40:05,706 --> 00:40:10,210
让我通过一个简单的图例
解释一下要如何实现

656
00:40:12,613 --> 00:40:15,249
请考虑这么一个情境 上百万个用户

657
00:40:15,315 --> 00:40:18,085
正在观看一个很受欢迎的实时流媒体
比如Apple的Keynote演讲

658
00:40:19,119 --> 00:40:22,289
他们开始观看的时间点可能都不一样

659
00:40:22,489 --> 00:40:24,825
但当需要升级或更新钥匙时

660
00:40:25,259 --> 00:40:28,362
他们都会在完全一样的时间点
向你的钥匙服务器发送请求

661
00:40:29,263 --> 00:40:32,165
那代表了短时间内
钥匙服务器上会有巨大的负载

662
00:40:32,232 --> 00:40:35,702
然后一切都回归正常

663
00:40:36,203 --> 00:40:40,140
直到下一次再升级或更新钥匙 对吧？

664
00:40:40,474 --> 00:40:44,611
那么这种模式会持续
给你的钥匙服务器带来输入负载

665
00:40:45,646 --> 00:40:50,017
你可以使用AVContentKeySession
来分散钥匙请求

666
00:40:50,717 --> 00:40:54,454
通过在一个小的时间窗口内
选择一个随机点

667
00:40:54,521 --> 00:40:58,926
当钥匙失效之前 并启动钥匙加载自己

668
00:41:00,093 --> 00:41:03,797
那么这就允许你调整你的实时供应

669
00:41:04,164 --> 00:41:06,800
而不用给社交安全钥匙服务器增加负载

670
00:41:09,136 --> 00:41:13,807
那么现在我们看了一些用例
证明通过AVContentKeySession

671
00:41:13,874 --> 00:41:18,378
启动钥匙加载过程是很有帮助的
让我们来看看如何在代码中实现

672
00:41:19,880 --> 00:41:22,482
你可以启动钥匙加载过程

673
00:41:22,549 --> 00:41:24,751
仅通过三行代码 就那么简单

674
00:41:25,485 --> 00:41:26,320
就在这里

675
00:41:27,321 --> 00:41:30,090
那么你要做的第一件事

676
00:41:30,157 --> 00:41:33,527
就是为FairPlay Streaming
创建AVContentKeySession实例

677
00:41:35,162 --> 00:41:37,865
然后把你的应用设为
contentKeySession代理

678
00:41:39,132 --> 00:41:40,367
你应该会在你在这里

679
00:41:40,434 --> 00:41:43,470
指定的委托队列上收到全部委托回调

680
00:41:45,105 --> 00:41:50,110
第三步是调用
processContentKeyRequest方法

681
00:41:50,177 --> 00:41:52,546
那将启动钥匙加载过程

682
00:41:54,281 --> 00:41:56,149
那么在这里需要注意几点

683
00:41:57,985 --> 00:42:00,020
要使用这个功能不需要对你的钥匙

684
00:42:00,087 --> 00:42:03,423
或你的钥匙服务器模块
实施进行任何修改

685
00:42:04,591 --> 00:42:07,961
这是…这里的全部实施都是在客户端上
这很棒

686
00:42:09,296 --> 00:42:10,330
第二

687
00:42:11,465 --> 00:42:13,767
你在这里指定的标识符

688
00:42:14,768 --> 00:42:18,972
应该与你在媒体播放列表中的
EXT-X-KEY标签中

689
00:42:19,039 --> 00:42:20,207
指定的标识符相匹配

690
00:42:20,941 --> 00:42:25,012
那将允许我们匹配

691
00:42:25,078 --> 00:42:28,815
你在这里加载的钥匙
和你在播放过程中所请求的钥匙

692
00:42:30,551 --> 00:42:31,485
第三

693
00:42:32,653 --> 00:42:36,456
你应该有一个带外的过程

694
00:42:37,324 --> 00:42:40,093
从钥匙服务器上获取特别资产的钥匙

695
00:42:40,160 --> 00:42:43,330
以便你可以在这点上加载全部钥匙

696
00:42:45,532 --> 00:42:48,969
当你在AVContentKeySession上
调用processContentKeyRequest方法时

697
00:42:49,570 --> 00:42:52,739
我们给你发送一个
AVContentKey请求对象

698
00:42:53,473 --> 00:42:54,808
通过一个委托回调

699
00:42:55,175 --> 00:42:58,078
并且这与
当AVFoundation启动

700
00:42:58,145 --> 00:43:00,914
钥匙加载过程时的委托方法一模一样

701
00:43:02,249 --> 00:43:04,318
那么现在你可以使用钥匙请求对象

702
00:43:04,384 --> 00:43:07,321
来执行FairPlay Streamings
全部的指定操作 比如

703
00:43:07,955 --> 00:43:10,157
你可以请求SPC

704
00:43:10,224 --> 00:43:13,427
这与你通过AVAsset
钥匙排序请求

705
00:43:13,493 --> 00:43:15,462
来请求SPC的方式非常相似

706
00:43:16,730 --> 00:43:20,067
然后你要把SPC发送到你的
钥匙服务器 获取CKC

707
00:43:21,134 --> 00:43:25,772
最后一步是用CKC创建响应对象

708
00:43:25,839 --> 00:43:29,042
并把它设为
对ContentKeyRequest对象的响应

709
00:43:31,445 --> 00:43:35,349
那么当你响应钥匙请求时
你必须记住几点

710
00:43:36,483 --> 00:43:40,087
一旦你将CKC设为对钥匙请求的响应

711
00:43:41,355 --> 00:43:44,157
你就可以在设备上
使用一个安全解密slot

712
00:43:44,224 --> 00:43:46,059
这些slot的数量有限

713
00:43:47,160 --> 00:43:51,198
那么为任意数量的钥匙启动
钥匙加载过程都没问题

714
00:43:51,265 --> 00:43:54,701
并且你可以还可以为全部
不同的钥匙请求获取CKC

715
00:43:55,536 --> 00:43:57,070
但一定要小心最后一步

716
00:43:58,205 --> 00:44:00,707
你应该只在那些你预测

717
00:44:00,774 --> 00:44:02,876
可能在播放过程中
用的钥匙上设置CKC

718
00:44:03,677 --> 00:44:06,013
而且要恰好在请求播放之前进行

719
00:44:09,850 --> 00:44:13,086
那么以此为背景 让我们

720
00:44:13,153 --> 00:44:16,957
改变一下方式 了解一下我们如何

721
00:44:17,624 --> 00:44:19,760
在脱机HLS播放情境中
使用AVContentKeySession

722
00:44:21,962 --> 00:44:27,334
去年当我们修改
FairPlay Streaming来保护

723
00:44:27,801 --> 00:44:30,270
你的脱机HLS资产时
也引入了持久钥匙

724
00:44:31,438 --> 00:44:35,442
AVContentKeySession
也可以用于创建持久钥匙

725
00:44:36,977 --> 00:44:41,582
在请求加载HLS资产之前

726
00:44:42,082 --> 00:44:47,120
你可以使用AVContentKeySession
来启动钥匙加载过程

727
00:44:47,187 --> 00:44:50,490
并使用钥匙请求对象来创建持久钥匙

728
00:44:51,525 --> 00:44:55,028
然后你可以把持久钥匙保存到你的应用
存储中以备将来的不时之需

729
00:44:56,830 --> 00:44:59,666
然后这将会让你的流程
稍微变得简单点儿

730
00:44:59,733 --> 00:45:01,368
因为现在你不必

731
00:45:01,568 --> 00:45:04,471
在你的主播放列表中
定义EXT-X会话钥匙以及等等

732
00:45:05,105 --> 00:45:06,573
你只需要使用
AVContentKeySession即可

733
00:45:09,309 --> 00:45:13,981
更进一步 当创建和使用持久钥匙时

734
00:45:14,248 --> 00:45:17,551
你应该也使用
AVContentKeyRequest的子类

735
00:45:17,618 --> 00:45:19,720
即AVPersistableContentKeyRequest

736
00:45:20,521 --> 00:45:25,092
我要在代码中解释一下如何请求
和AVPersistableContentKeyRequest

737
00:45:25,158 --> 00:45:30,030
以及工作…以及如何使用
AVPersistableContentKeyRequest

738
00:45:31,999 --> 00:45:34,635
那么如果你回顾一下 这是当你启动

739
00:45:34,701 --> 00:45:37,137
钥匙加载过程时调用的那个委托方法

740
00:45:39,072 --> 00:45:42,209
在这点上
如果你尝试创建一个持久钥匙

741
00:45:42,643 --> 00:45:45,379
你应该只响应钥匙请求并请求

742
00:45:45,445 --> 00:45:49,550
PersistableContentKeyRequest
我们将给你发送

743
00:45:49,616 --> 00:45:54,354
AVPersistableContentKeyRequest对象
通过一个新委托回调

744
00:45:56,456 --> 00:45:58,458
你可以使用
AVPersistableContentKeyRequest

745
00:45:58,525 --> 00:46:01,361
来执行FairPlay Streaming的全部操作

746
00:46:01,929 --> 00:46:03,230
比如创建SPC

747
00:46:04,097 --> 00:46:08,035
把SPC发送到你的钥匙服务器
获取CKC并使用CKC

748
00:46:08,669 --> 00:46:10,370
创建一个持久钥匙

749
00:46:10,871 --> 00:46:12,840
你可把持久钥匙
保存在你的应用存储中

750
00:46:12,906 --> 00:46:15,509
以便你可以稍后当用户脱机时使用它

751
00:46:16,710 --> 00:46:18,979
当是时候使用持久钥匙时

752
00:46:19,479 --> 00:46:23,750
你所要做的就是通过持久钥匙
数据块创建一个响应对象

753
00:46:24,418 --> 00:46:27,754
并将其设为ContentKeyRequest
对象上的一个响应

754
00:46:28,956 --> 00:46:29,790
就是这样

755
00:46:31,458 --> 00:46:34,328
如果你今天使用
FairPlay Streaming

756
00:46:34,561 --> 00:46:37,097
来提交钥匙 你可以观察到

757
00:46:37,164 --> 00:46:39,333
AVContentKeySession与

758
00:46:39,399 --> 00:46:42,836
你今天用过的AVAssetResourceLoader
API的工作方式相似

759
00:46:44,671 --> 00:46:49,176
我们没用AVAssetResourceLoading请求
而是用了AVContentKeyRequest

760
00:46:50,611 --> 00:46:52,946
AVAsset
恰好位于委托调用分离的地方

761
00:46:53,013 --> 00:46:54,915
它叫作AVContentKeySession委托

762
00:46:56,717 --> 00:46:58,519
然而 这是一个关键的不同点

763
00:46:58,785 --> 00:47:00,921
与AVAssetResourceLoader不同

764
00:47:00,988 --> 00:47:03,023
AVContentKeySession
创建时并没有绑定

765
00:47:03,257 --> 00:47:05,592
一个资产

766
00:47:06,627 --> 00:47:11,665
所以你可以在任意一点上创建
AVContentKeySession

767
00:47:12,566 --> 00:47:14,368
并用它加载全部钥匙

768
00:47:15,269 --> 00:47:19,806
就在你请求播放之前
你应该添加你的AVAsset

769
00:47:20,240 --> 00:47:22,142
作为内容钥匙接收器

770
00:47:23,043 --> 00:47:26,113
这将允许你的AVAsset获取

771
00:47:26,180 --> 00:47:28,448
你通过ContentKeySession
对象预加载的全部钥匙

772
00:47:31,118 --> 00:47:33,520
现在我们有两个API

773
00:47:34,188 --> 00:47:36,223
AVContentKeySession
和AVAssetResourceLoader

774
00:47:36,290 --> 00:47:38,859
你可能会在想应该用哪个API

775
00:47:38,926 --> 00:47:40,694
来加载资源的不同类型

776
00:47:40,761 --> 00:47:42,729
那么我们有一个建议

777
00:47:43,497 --> 00:47:47,434
使用AVContentKeySession
来加载内容解密钥匙

778
00:47:47,501 --> 00:47:51,138
使用AVAssetResourceLoader
来加载其它东西

779
00:47:52,105 --> 00:47:54,875
我必须指出我们并没有

780
00:47:54,942 --> 00:47:58,111
在这一点上复制AVAssetResource
Loader的钥匙处理方式

781
00:47:58,178 --> 00:48:01,315
所以你可以继续使用
AVAssetResourceLoader

782
00:48:01,715 --> 00:48:04,117
来加载FairPlay Streaming钥匙
就像你今天所做的一样

783
00:48:04,251 --> 00:48:06,587
但我们强烈建议你切换为

784
00:48:06,653 --> 00:48:09,056
AVContentKeySession
来执行

785
00:48:10,657 --> 00:48:11,992
那么谁负责

786
00:48:12,059 --> 00:48:14,361
加载解密钥匙呢 如果某个资产

787
00:48:14,428 --> 00:48:17,598
既有AVAssetResourceLoader委托

788
00:48:17,664 --> 00:48:19,600
又有与之关联的
AVContentKeySession委托？

789
00:48:20,701 --> 00:48:22,536
嗯 为了保持一致性

790
00:48:22,603 --> 00:48:27,274
我们强制只使用

791
00:48:27,341 --> 00:48:29,276
AVContentKeySession委托
加载全部内容解密钥匙

792
00:48:31,144 --> 00:48:35,282
我们的AVAssetResourceLoader委托
会收到全部资源加载请求

793
00:48:35,349 --> 00:48:38,552
包括那四个内容解密钥匙

794
00:48:39,786 --> 00:48:44,958
应用应该推迟全部的内容解密钥匙加载

795
00:48:45,926 --> 00:48:48,795
通过在加载请求上调用完成加载

796
00:48:48,862 --> 00:48:52,799
AVFoundation可以再次允许
向AVContentKeySession委托发起请求

797
00:48:53,233 --> 00:48:54,902
让我们在代码中看看是如何实现的

798
00:48:55,169 --> 00:48:56,136
非常简单

799
00:48:56,904 --> 00:48:58,739
那么这里有一个委托方法

800
00:48:59,139 --> 00:49:02,109
当AVFoundation
尝试加载资源时调用

801
00:49:02,676 --> 00:49:05,479
当你看到资源是用于内容解密钥匙时

802
00:49:05,913 --> 00:49:09,183
你应该设置内容管道
表明它是一个内容钥匙

803
00:49:09,750 --> 00:49:11,451
并调用完成加载

804
00:49:11,952 --> 00:49:14,621
那么在那点上我们将向

805
00:49:14,688 --> 00:49:18,258
AVContentKeySession委托发送
新的内容钥匙加载请求

806
00:49:19,193 --> 00:49:23,197
如果是其它资源
你就可以继续在这里加载资源了

807
00:49:25,365 --> 00:49:29,136
那么我希望这个新API
可以给你提供一些情境

808
00:49:29,203 --> 00:49:31,939
关于通过AVContentKeySession
可以实现哪些功能

809
00:49:33,140 --> 00:49:36,176
在我结束演讲之前
我还要跟你们分享一个很棒的功能

810
00:49:36,677 --> 00:49:40,948
这可以通过
AVContentKeySession获得

811
00:49:43,650 --> 00:49:47,588
我们为FairPlay Streaming持久钥匙

812
00:49:47,654 --> 00:49:50,991
提供双重失效窗口支持

813
00:49:51,592 --> 00:49:54,194
现在这个双重失效窗口是什么？

814
00:49:55,229 --> 00:49:57,631
如果你曾经在iTunes上租过电影

815
00:49:58,298 --> 00:50:02,836
你可以看到你有…一旦你租了一部电影
你有30天的时间来观看它

816
00:50:03,670 --> 00:50:07,541
一旦你开始观看电影
你就有24小时的时间来看完它

817
00:50:08,041 --> 00:50:11,211
我们把这个称为租赁的
双重失效窗口模式

818
00:50:13,413 --> 00:50:16,183
那么这个功能可以允许你

819
00:50:16,817 --> 00:50:18,552
定义和自定义

820
00:50:18,719 --> 00:50:22,089
两个失效窗口
为FairPlay Streaming持久钥匙

821
00:50:23,023 --> 00:50:28,061
那将允许你支持比如
租赁功能这样的功能项

822
00:50:28,996 --> 00:50:29,830
通过…

823
00:50:30,864 --> 00:50:33,534
而不需要在服务器端进行大量的编程

824
00:50:33,600 --> 00:50:37,938
最棒的是它既可以在脱机播放时
使用又可以在在线播放时使用

825
00:50:39,573 --> 00:50:42,910
那么为了使用这个功能
你首先要选择加入

826
00:50:42,976 --> 00:50:45,112
通过在你的CKC中发送适当的描述符

827
00:50:45,746 --> 00:50:48,382
那将允许你指定两个失效窗口

828
00:50:49,049 --> 00:50:51,251
第一个叫作存储失效窗口

829
00:50:51,318 --> 00:50:55,222
一旦创建持久钥匙即启动

830
00:50:55,455 --> 00:50:58,592
然后还有一个播放失效窗口

831
00:50:58,892 --> 00:51:01,929
当持久钥匙用于开始播放时启动

832
00:51:03,397 --> 00:51:05,899
为了更好地描述这个功能 让我给你…

833
00:51:06,700 --> 00:51:08,335
让我们一起看一个事件的时间轴

834
00:51:08,402 --> 00:51:10,971
和脱机播放的情境

835
00:51:12,840 --> 00:51:13,941
当用户

836
00:51:14,608 --> 00:51:16,877
租了一部电影脱机播放时

837
00:51:16,944 --> 00:51:19,813
你要创建一个带CKC的持久钥匙

838
00:51:19,980 --> 00:51:22,282
选择加入使用这个功能

839
00:51:23,584 --> 00:51:28,222
持久钥匙会在存储
失效窗口的末端失效

840
00:51:28,288 --> 00:51:31,091
在我们的例子中是30天

841
00:51:31,158 --> 00:51:34,228
（持久钥匙的双重失效窗口）

842
00:51:34,294 --> 00:51:37,831
你可以把持久钥匙存在你应用的存储中

843
00:51:37,898 --> 00:51:40,634
并可以用它来响应稍后的钥匙请求

844
00:51:41,401 --> 00:51:44,037
现在当用户在这30天内返回来

845
00:51:44,104 --> 00:51:48,208
并要求你开始播放时…要求你播放内容

846
00:51:48,809 --> 00:51:50,010
你会得到一个钥匙请求

847
00:51:50,077 --> 00:51:53,080
你可以用这个持久钥匙
来响应钥匙请求

848
00:51:54,214 --> 00:51:58,051
在那点上 我们将给你发送一个
更新了的持久钥匙

849
00:51:58,519 --> 00:52:00,954
这个更新了的持久钥匙
被设为在播放终点失效

850
00:52:01,121 --> 00:52:04,024
在我们的例子中是24小时

851
00:52:05,158 --> 00:52:07,127
同时我们还明确地

852
00:52:07,194 --> 00:52:10,030
失效了你创建的原始持久钥匙

853
00:52:10,264 --> 00:52:12,266
所以你要

854
00:52:12,332 --> 00:52:15,836
在你的应用存储中保存
更新了的持久钥匙 并用它

855
00:52:15,903 --> 00:52:18,472
响应将来的钥匙加载请求

856
00:52:18,772 --> 00:52:23,010
这就是当用户停止并在
接下来的24小时内回复播放时

857
00:52:24,244 --> 00:52:27,648
关于代码 这与我们

858
00:52:27,714 --> 00:52:30,817
在前几张幻灯片中所看到的
持久钥匙的流程相似

859
00:52:30,884 --> 00:52:33,954
然而我们将发送给你这个
新的更新了的持久钥匙

860
00:52:34,087 --> 00:52:37,090
通过一个新的
AVContentKeySession委托回调

861
00:52:39,226 --> 00:52:41,395
那么这是我们今年针对

862
00:52:41,461 --> 00:52:44,364
FairPlay Streaming
钥匙提交过程所做出的全部改进

863
00:52:45,532 --> 00:52:48,402
总之 我们引入了

864
00:52:48,468 --> 00:52:49,536
两个新的编解码器

865
00:52:49,603 --> 00:52:54,608
我们今年引入了[听不清]
HEVC和IMSC1

866
00:52:56,276 --> 00:52:58,912
我们添加了EXT-X-GAP标签

867
00:52:58,979 --> 00:53:01,849
允许你在你的实时流媒体中表示缺口

868
00:53:02,783 --> 00:53:09,790
现在你可以在你的HLS流媒体中定义
并使用PHP样式变量了

869
00:53:11,258 --> 00:53:15,095
你现可同步两个或多个HLS流媒体

870
00:53:16,997 --> 00:53:19,199
并且我们提供新API

871
00:53:19,266 --> 00:53:24,638
以供你更好地控制脱机HLS资产

872
00:53:26,473 --> 00:53:30,344
现在有一个新API
AVContentKeySession允许你

873
00:53:30,410 --> 00:53:33,380
更好地管理和提交内容解密钥匙

874
00:53:34,681 --> 00:53:35,782
最后

875
00:53:36,450 --> 00:53:41,588
我们给全部FairPlay Streaming
持久钥匙添加了双重失效窗口支持

876
00:53:41,655 --> 00:53:46,860
那将会允许你支持脱机
HLS资产的租赁模式

877
00:53:48,262 --> 00:53:52,232
我们做出了这么多的新功能
我们都感到非常激动

878
00:53:52,299 --> 00:53:54,334
我们期待你们能采用它们

879
00:53:55,836 --> 00:53:57,571
感谢你们来参加本场演讲

880
00:53:58,038 --> 00:54:02,509
你可以在开发者网站上访问
我们的演讲页面获取更多信息

881
00:54:03,143 --> 00:54:08,148
你还可以下载我们在本场演讲中

882
00:54:08,382 --> 00:54:09,416
提到的全部实例代码

883
00:54:11,318 --> 00:54:13,587
我们最近有许多相关的演讲

884
00:54:14,087 --> 00:54:15,689
我强烈建议你们

885
00:54:15,822 --> 00:54:20,194
观看错误处理最佳范例
和HLS编写更新演讲

886
00:54:20,727 --> 00:54:24,164
这些有在线视频
并且你的WWDC应用中也有

887
00:54:24,765 --> 00:54:27,401
如果你错过了其它现场演讲

888
00:54:27,467 --> 00:54:31,505
你总是可以从你的WWDC应用中
观看它们的视频

889
00:54:32,239 --> 00:54:34,942
脱机或在线看均可

890
00:54:35,776 --> 00:54:36,810
非常感谢

891
00:54:36,877 --> 00:54:38,846
希望你们在本周剩余大会中
度过一段美好时光 晚安

