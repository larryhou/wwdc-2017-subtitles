1
00:00:24,516 --> 00:00:26,736
[掌声]

2
00:00:27,236 --> 00:00:28,126
>> 大家早上好

3
00:00:28,746 --> 00:00:30,476
欢迎来到 VR with Metal 2

4
00:00:31,156 --> 00:00:32,646
我是 Rav Dhiraj

5
00:00:32,646 --> 00:00:34,466
是 Apple GPU 软件团队的一员

6
00:00:35,676 --> 00:00:37,446
大家都已经在

7
00:00:37,446 --> 00:00:39,006
Introducing Metal 2 讲座中了解到

8
00:00:39,416 --> 00:00:40,726
我们今年又推出了不少

9
00:00:40,726 --> 00:00:41,626
新特性

10
00:00:42,436 --> 00:00:43,546
在这场演讲中 我将会

11
00:00:43,606 --> 00:00:45,476
特别集中讲一下

12
00:00:45,476 --> 00:00:46,986
我们在 Metal 2 中添加的

13
00:00:46,986 --> 00:00:47,666
对 VR 的支持

14
00:00:48,226 --> 00:00:51,426
首先 我想简短总结一下

15
00:00:51,506 --> 00:00:53,396
我们在 macOS High Sierra 中

16
00:00:53,396 --> 00:00:54,626
推出的新功能

17
00:00:54,626 --> 00:00:57,106
然后再深入讲解

18
00:00:57,106 --> 00:00:58,386
构建 VR App 有哪些要求

19
00:00:59,186 --> 00:01:00,976
最后 再仔细讲一下

20
00:01:00,976 --> 00:01:02,576
你们可以如何利用

21
00:01:02,576 --> 00:01:04,046
我们在 OS 中添加的

22
00:01:04,046 --> 00:01:05,906
最新的外接 GPU 支持

23
00:01:05,906 --> 00:01:06,436
这项功能

24
00:01:09,256 --> 00:01:09,516
好了

25
00:01:09,516 --> 00:01:11,166
我希望大家已经都知道

26
00:01:11,216 --> 00:01:12,276
虚拟现实是什么了

27
00:01:12,786 --> 00:01:14,706
但为防万一 我还是解释一下

28
00:01:14,706 --> 00:01:17,526
它是一种沉浸式的 360 度 3D

29
00:01:17,606 --> 00:01:20,246
体验 可以通过控制器

30
00:01:20,246 --> 00:01:21,726
直接操控物体

31
00:01:22,366 --> 00:01:24,476
还有一个房间大小的

32
00:01:24,476 --> 00:01:25,676
交互环境供人探索

33
00:01:25,676 --> 00:01:27,476
这要多亏了

34
00:01:27,476 --> 00:01:28,826
高度精确的动作追踪

35
00:01:30,036 --> 00:01:31,306
我们 Apple 认为

36
00:01:31,306 --> 00:01:32,716
VR 对于在座的开发者来说

37
00:01:32,716 --> 00:01:34,786
是一个为用户创造新体验的

38
00:01:34,786 --> 00:01:36,646
很棒的媒介

39
00:01:37,276 --> 00:01:40,956
Metal 2 以三种方式

40
00:01:40,956 --> 00:01:41,846
为此提供支持

41
00:01:42,516 --> 00:01:46,766
首先 提供一个快速 panel

42
00:01:46,846 --> 00:01:48,316
让画面帧直接显示

43
00:01:48,316 --> 00:01:49,776
在 VR 头戴显示器上 这用到了新的

44
00:01:50,296 --> 00:01:52,006
Direct to Display 功能

45
00:01:53,616 --> 00:01:56,136
其次 推出特别为 VR

46
00:01:56,136 --> 00:01:57,696
设计的新功能

47
00:01:57,756 --> 00:02:00,026
比如 Viewport Array

48
00:02:01,506 --> 00:02:03,006
最后 为外接 GPU

49
00:02:03,076 --> 00:02:04,366
提供基础支持

50
00:02:04,366 --> 00:02:06,096
以便开发者能够

51
00:02:06,096 --> 00:02:07,796
使用更多样的

52
00:02:07,796 --> 00:02:08,705
Mac 硬件

53
00:02:08,946 --> 00:02:10,616
支持 VR 的 Mac 硬件

54
00:02:10,616 --> 00:02:11,066
进行工作

55
00:02:11,606 --> 00:02:13,566
好了 我们现在开始

56
00:02:13,566 --> 00:02:15,566
讲解 macOS High Sierra

57
00:02:15,696 --> 00:02:16,036
的新功能

58
00:02:17,056 --> 00:02:18,726
我们添加了对于 HTC ViveVR 头戴显示器

59
00:02:18,726 --> 00:02:20,186
的即插即玩功能

60
00:02:20,396 --> 00:02:21,616
这是内置的

61
00:02:21,616 --> 00:02:24,286
这个头戴显示器

62
00:02:24,286 --> 00:02:26,346
与 Valve SteamVR runtime

63
00:02:26,346 --> 00:02:28,436
一起工作 提供了一系列功能

64
00:02:28,436 --> 00:02:30,206
其中就包括 VR

65
00:02:30,206 --> 00:02:31,086
compositor （矫正器）

66
00:02:32,556 --> 00:02:33,946
Valve 还把他们的

67
00:02:34,006 --> 00:02:36,796
OpenVR API 添加进了 macOS

68
00:02:36,796 --> 00:02:39,136
这样你们就能创造与 SteamVR

69
00:02:39,136 --> 00:02:40,136
兼容的 VR App了

70
00:02:40,416 --> 00:02:41,466
我们在去年

71
00:02:41,466 --> 00:02:43,006
与 Valve 密切合作

72
00:02:43,106 --> 00:02:45,216
协调我们的发布

73
00:02:45,216 --> 00:02:47,256
现在 SteamVR 和 OpenVR

74
00:02:47,726 --> 00:02:49,566
的 beta 版本都可以下载了

75
00:02:49,636 --> 00:02:50,746
就在这周

76
00:02:51,386 --> 00:02:55,376
在继续之前

77
00:02:55,406 --> 00:02:57,156
我想讲一下 VR compositor

78
00:02:57,156 --> 00:02:57,856
的具体功能

79
00:02:59,056 --> 00:03:00,616
一言以蔽之

80
00:03:00,716 --> 00:03:02,766
它会让你的 App 渲染的画面失真

81
00:03:02,816 --> 00:03:05,106
以配合 VR 头戴显示器中的透镜

82
00:03:05,106 --> 00:03:06,156
从而显示出正常的画面

83
00:03:07,186 --> 00:03:08,526
在这个示例中 你们可以看到

84
00:03:08,686 --> 00:03:10,296
compositor 用桶形失真

85
00:03:10,296 --> 00:03:12,106
来抵消透镜

86
00:03:12,106 --> 00:03:13,516
的枕形畸变效果

87
00:03:15,676 --> 00:03:16,696
在实际应用中

88
00:03:16,696 --> 00:03:18,306
会比这个示例

89
00:03:18,306 --> 00:03:19,056
复杂得多

90
00:03:19,356 --> 00:03:20,746
compositor 需要去

91
00:03:20,746 --> 00:03:21,916
处理色差现象

92
00:03:21,916 --> 00:03:24,316
还要呈现一个

93
00:03:24,316 --> 00:03:26,176
Chaperone UI

94
00:03:26,206 --> 00:03:28,146
以便开发者们能够了解

95
00:03:28,286 --> 00:03:31,256
他们的 VR 空间的边界

96
00:03:31,466 --> 00:03:32,316
好了

97
00:03:32,316 --> 00:03:33,436
现在你有了对 VR 头戴显示器的

98
00:03:33,486 --> 00:03:36,386
内置支持 有了

99
00:03:36,896 --> 00:03:39,066
SteamVR 的 VR compositor

100
00:03:39,066 --> 00:03:41,296
还有了 API 框架

101
00:03:41,396 --> 00:03:42,976
下面我们就开始深入讲解如何创造

102
00:03:42,976 --> 00:03:43,286
VR App

103
00:03:44,756 --> 00:03:46,096
我们有两种选择

104
00:03:46,866 --> 00:03:49,156
第一是使用现有的

105
00:03:49,156 --> 00:03:50,996
支持 VR 的游戏引擎

106
00:03:51,786 --> 00:03:53,426
这是很多开发者喜欢的

107
00:03:53,426 --> 00:03:55,126
很好的选择 因为它

108
00:03:55,126 --> 00:03:56,566
把 VR compositor 的一些复杂性

109
00:03:56,566 --> 00:03:57,726
隐藏起来了

110
00:03:58,456 --> 00:04:00,356
同时它也提供了一个熟悉的

111
00:04:00,356 --> 00:04:01,786
内容创造工具链

112
00:04:03,156 --> 00:04:04,916
那么第二个选择

113
00:04:04,916 --> 00:04:06,906
是写一个原生的 VR App

114
00:04:06,906 --> 00:04:08,106
直接调用 openVR

115
00:04:08,926 --> 00:04:10,766
这会让你的 App 能够用

116
00:04:11,086 --> 00:04:12,716
VR compositor 全面控制

117
00:04:12,716 --> 00:04:13,756
渲染与同步

118
00:04:14,236 --> 00:04:15,236
但要以一些额外的复杂性

119
00:04:15,236 --> 00:04:16,366
作为这样做的代价

120
00:04:16,935 --> 00:04:19,906
选择哪一种方法取决于

121
00:04:19,906 --> 00:04:20,875
你的 App 的目标

122
00:04:21,486 --> 00:04:23,346
我们先来说一说

123
00:04:23,846 --> 00:04:24,946
游戏引擎吧

124
00:04:26,796 --> 00:04:29,306
你们在主旨演讲中已经见到

125
00:04:29,426 --> 00:04:31,316
Epic 公司的虚幻4引擎的实用

126
00:04:31,316 --> 00:04:32,976
这是个强有力的平台

127
00:04:32,976 --> 00:04:34,066
在上面可以构建你的 VR

128
00:04:34,066 --> 00:04:34,966
体验

129
00:04:36,246 --> 00:04:38,416
对于 VR 的支持会在今年晚些时候

130
00:04:38,416 --> 00:04:40,676
推出 你还可以在 Epic 的官网上找到

131
00:04:40,676 --> 00:04:42,646
教程以及其他

132
00:04:42,646 --> 00:04:43,586
相关信息

133
00:04:44,966 --> 00:04:46,656
我们还很高兴地看到

134
00:04:46,696 --> 00:04:48,936
Unity 也会在未来的引擎版本中

135
00:04:48,936 --> 00:04:50,596
在 macOS 中加入对 VR 的支持

136
00:04:51,896 --> 00:04:53,116
我们正与他们密切合作

137
00:04:53,116 --> 00:04:54,296
以确保引擎为

138
00:04:54,296 --> 00:04:56,266
VR 回放和使用 Metal 开发

139
00:04:56,266 --> 00:04:58,586
进行了优化

140
00:05:02,076 --> 00:05:03,396
说到这里

141
00:05:03,396 --> 00:05:04,636
我想用一些时间谈谈

142
00:05:04,766 --> 00:05:06,936
一个特别的 Unity 游戏 那就是

143
00:05:06,936 --> 00:05:08,336
Space Pirate Trainer

144
00:05:08,806 --> 00:05:10,396
我们与 Unity 和 I-Illusions 合作

145
00:05:10,396 --> 00:05:12,556
把 Space Pirate Trainer

146
00:05:12,556 --> 00:05:14,596
的一个早期版本

147
00:05:14,666 --> 00:05:16,196
带入了 macOS

148
00:05:16,916 --> 00:05:19,836
I-Illusion 把他们的 App

149
00:05:20,066 --> 00:05:21,916
放到我们的平台上的速度

150
00:05:21,916 --> 00:05:23,176
真是非常惊人

151
00:05:23,716 --> 00:05:25,916
他们只用了几小时

152
00:05:25,916 --> 00:05:28,536
就完成了可运行的版本

153
00:05:28,536 --> 00:05:30,386
几天内就推出了完全可游玩的

154
00:05:30,386 --> 00:05:30,786
正式版本

155
00:05:31,926 --> 00:05:33,476
我们玩这个游戏

156
00:05:33,566 --> 00:05:35,166
玩得不亦乐乎

157
00:05:35,206 --> 00:05:36,336
而且我们认为

158
00:05:36,336 --> 00:05:38,516
这个游戏很好地

159
00:05:38,516 --> 00:05:39,886
代表了你们用 Unity 可以

160
00:05:40,146 --> 00:05:40,766
构建出的 VR 体验

161
00:05:42,176 --> 00:05:43,166
我们希望你们能够通过 WWDC

162
00:05:43,166 --> 00:05:44,136
来了解一下

163
00:05:44,136 --> 00:05:45,936
我们相信你们一定会也爱上它的

164
00:05:47,556 --> 00:05:50,636
Unity 和虚幻 4 引擎

165
00:05:50,636 --> 00:05:52,376
是 VR 开发的两大优秀平台

166
00:05:54,536 --> 00:05:56,536
但是你们当然也可以

167
00:05:56,536 --> 00:05:58,136
选择去写一个原生的 SteamVR App

168
00:05:58,496 --> 00:05:59,756
直接调用

169
00:05:59,846 --> 00:06:00,766
OpenVR 框架

170
00:06:01,566 --> 00:06:02,906
我们会详细讲到

171
00:06:02,906 --> 00:06:03,996
要如何把这个框架添加进

172
00:06:03,996 --> 00:06:05,756
你们的 App 这场演讲后面会讲到

173
00:06:06,006 --> 00:06:07,436
你们可以在 OpenVR GitHub 上

174
00:06:07,476 --> 00:06:09,386
下载到二进制代码和

175
00:06:09,386 --> 00:06:10,366
API 文档

176
00:06:12,776 --> 00:06:14,286
很快还会有一个

177
00:06:14,346 --> 00:06:16,416
针对 Metal 的范例 App

178
00:06:16,416 --> 00:06:17,786
可供下载

179
00:06:18,626 --> 00:06:19,676
现在 为了给大家一个基本概念

180
00:06:19,676 --> 00:06:21,556
我想先提供一个 VR App

181
00:06:21,556 --> 00:06:23,616
开发的基础讲解

182
00:06:23,616 --> 00:06:25,316
这个环节 我想把它叫做

183
00:06:25,316 --> 00:06:27,026
VR App 构建入门

184
00:06:28,666 --> 00:06:29,856
我们将会讲到

185
00:06:29,856 --> 00:06:30,356
以下几点

186
00:06:31,106 --> 00:06:32,706
首先是在 VR 开发

187
00:06:32,766 --> 00:06:34,176
过程中会遇到的

188
00:06:34,176 --> 00:06:35,246
一些挑战

189
00:06:36,496 --> 00:06:38,376
然后会讲一点

190
00:06:38,376 --> 00:06:40,206
我们的平台上的独有特点

191
00:06:40,916 --> 00:06:43,096
然后是深入剖析

192
00:06:43,096 --> 00:06:45,306
VR 框架

193
00:06:46,156 --> 00:06:47,136
最后 以一些针对

194
00:06:47,226 --> 00:06:48,826
VR App 的最佳范例作为结尾

195
00:06:50,326 --> 00:06:51,246
所以 我们要讲的很多

196
00:06:51,636 --> 00:06:53,066
就先从概况开始吧

197
00:06:54,106 --> 00:06:57,586
在 60 Hz 显示下

198
00:06:57,586 --> 00:07:00,166
传统的非 VR 动画

199
00:07:00,706 --> 00:07:03,696
每一帧大约有 16.7 毫秒的时间

200
00:07:03,696 --> 00:07:06,986
供你使用

201
00:07:07,166 --> 00:07:09,986
在很多情况下 App 可以

202
00:07:10,396 --> 00:07:12,856
把整个帧的时间预算用在

203
00:07:12,856 --> 00:07:14,016
GPU 运算上面

204
00:07:14,566 --> 00:07:17,266
但是 VR 工作

205
00:07:17,326 --> 00:07:19,656
必须要针对每秒 90 帧

206
00:07:19,656 --> 00:07:20,676
的显示方式

207
00:07:20,676 --> 00:07:22,766
这样才能

208
00:07:22,806 --> 00:07:24,686
在 Vive 这样的头戴显示器上

209
00:07:24,686 --> 00:07:26,446
达到流畅无卡顿的

210
00:07:26,446 --> 00:07:26,806
显示效果

211
00:07:27,756 --> 00:07:29,186
这就把每帧的时间

212
00:07:29,186 --> 00:07:31,116
压缩到了 11 毫秒左右

213
00:07:33,276 --> 00:07:35,186
此外 VR compositor

214
00:07:35,186 --> 00:07:37,296
还要用 GPU 为

215
00:07:37,296 --> 00:07:39,136
VR 头戴显示器的失真

216
00:07:39,136 --> 00:07:39,616
做调整

217
00:07:40,716 --> 00:07:42,136
这大约需要 1 毫秒

218
00:07:42,136 --> 00:07:44,266
这就让你的 App

219
00:07:44,266 --> 00:07:46,446
每帧可利用的时间

220
00:07:46,446 --> 00:07:48,026
缩短到了 10 毫秒

221
00:07:48,796 --> 00:07:51,726
相当于非 VR 工作的

222
00:07:51,726 --> 00:07:52,036
60%

223
00:07:52,776 --> 00:07:55,636
这还没完

224
00:07:55,636 --> 00:07:57,656
你的 App 在每一帧

225
00:07:57,656 --> 00:07:58,276
还有其它工作

226
00:07:59,306 --> 00:08:01,256
包括左右眼画面的

227
00:08:01,556 --> 00:08:03,106
立体渲染

228
00:08:04,096 --> 00:08:05,786
很多情况下还包括

229
00:08:05,786 --> 00:08:07,416
高分辨率的渲染工作

230
00:08:08,476 --> 00:08:10,086
Vive 头显设备的分辨率是

231
00:08:10,086 --> 00:08:12,836
2160 x 1200

232
00:08:13,186 --> 00:08:15,476
这比1080的高清标准

233
00:08:15,476 --> 00:08:16,586
还多出 25% 的像素

234
00:08:17,576 --> 00:08:19,676
此外 很多 VR App

235
00:08:19,676 --> 00:08:22,696
还会以 1.2 到 1.4 倍的画面比例

236
00:08:22,746 --> 00:08:24,216
进行渲染 以保证高质量的画面

237
00:08:25,366 --> 00:08:28,316
也就是说 你的 App

238
00:08:28,316 --> 00:08:30,246
要在更少的时间内做更多工作

239
00:08:31,526 --> 00:08:32,645
欢迎来到 VR 开发的世界

240
00:08:34,596 --> 00:08:35,186
好了

241
00:08:35,186 --> 00:08:36,535
我们来说一说平台的具体特点吧

242
00:08:38,336 --> 00:08:40,535
Metal 2 推出了一项新的

243
00:08:40,535 --> 00:08:42,806
Direct to Display 功能

244
00:08:42,806 --> 00:08:44,166
用在其支持的头显设备上 比如

245
00:08:44,166 --> 00:08:44,596
Vive

246
00:08:45,476 --> 00:08:47,886
这是一个低延迟通道

247
00:08:47,926 --> 00:08:49,446
绕过了 OS window

248
00:08:49,446 --> 00:08:51,376
compositor 并给予 VR

249
00:08:51,376 --> 00:08:54,256
compositor 比如 SteamVR

250
00:08:54,256 --> 00:08:55,896
直接在头显设备上

251
00:08:55,896 --> 00:08:57,646
显示画面的能力

252
00:08:58,326 --> 00:09:00,146
这一功能避免了 OS 去做

253
00:09:00,146 --> 00:09:03,546
像素处理或是额外拷贝

254
00:09:03,806 --> 00:09:05,276
如果为了保证这条快速通道

255
00:09:05,346 --> 00:09:06,926
让 macOS 不把 VR 头显设备

256
00:09:06,996 --> 00:09:09,846
当成显示设备

257
00:09:09,896 --> 00:09:11,366
那它将一文不值 毫无意义

258
00:09:11,956 --> 00:09:13,146
它们会被隐藏在系统里

259
00:09:13,286 --> 00:09:15,376
无法提供任何扩展的

260
00:09:15,376 --> 00:09:16,056
桌面功能

261
00:09:16,746 --> 00:09:20,676
总结一下 以前的模型

262
00:09:20,676 --> 00:09:22,976
是你可以 或者说一个 App

263
00:09:23,516 --> 00:09:25,276
可以通过操作系统的

264
00:09:25,366 --> 00:09:26,336
window compositor 来显示画面

265
00:09:28,316 --> 00:09:30,086
现在则是一个 VR App

266
00:09:30,136 --> 00:09:32,456
直接通过 VR compositor

267
00:09:32,496 --> 00:09:33,756
在头显设备上显示画面

268
00:09:34,566 --> 00:09:36,446
这就是 Metal 2 为了 VR

269
00:09:36,516 --> 00:09:39,716
推出的 Direct to Display 功能

270
00:09:41,416 --> 00:09:41,976
好了

271
00:09:42,206 --> 00:09:43,556
我们继续 macOS 平台特点的话题

272
00:09:43,616 --> 00:09:46,126
我们来说一说你们的 App

273
00:09:46,126 --> 00:09:48,026
如何选择 metal 设备

274
00:09:48,026 --> 00:09:49,296
进行工作

275
00:09:50,276 --> 00:09:52,266
在 macOS 里 VR compositor

276
00:09:52,316 --> 00:09:54,546
可以要求 OS

277
00:09:54,546 --> 00:09:57,006
为与头显设备相连的 GPU

278
00:09:57,006 --> 00:09:58,346
寻找设备

279
00:09:59,556 --> 00:10:00,786
出于性能方面的考虑

280
00:10:01,356 --> 00:10:02,776
你的 App 会选择与

281
00:10:02,776 --> 00:10:04,766
compositor 正在使用的设备

282
00:10:04,766 --> 00:10:04,976
相同的设备

283
00:10:06,266 --> 00:10:07,226
我们与 Valve 共同工作

284
00:10:07,226 --> 00:10:08,476
以确保有一个 API

285
00:10:08,476 --> 00:10:10,566
负责这一点 它就是

286
00:10:10,856 --> 00:10:13,186
GetOutputDevice 它能找到

287
00:10:13,186 --> 00:10:14,266
作为你渲染目标的 Metal 设备

288
00:10:14,876 --> 00:10:15,486
就这么简单

289
00:10:18,486 --> 00:10:20,416
接下来 我们说一下在 macOS 上

290
00:10:20,416 --> 00:10:22,236
管理 drawable 表面的问题

291
00:10:23,576 --> 00:10:25,376
VR compositor 和你的 App

292
00:10:25,376 --> 00:10:28,126
为 drawable 表面分别保留了

293
00:10:28,396 --> 00:10:29,576
不同的 pool

294
00:10:30,196 --> 00:10:32,276
在典型的一帧画面里 你的 App 会

295
00:10:32,556 --> 00:10:34,176
把它渲染成它所具有的纹理

296
00:10:34,176 --> 00:10:36,926
再提交给

297
00:10:36,926 --> 00:10:37,736
VR compositor

298
00:10:38,806 --> 00:10:40,666
然后这些会被合成到

299
00:10:40,666 --> 00:10:42,186
compositor 所具有的一个表面

300
00:10:42,186 --> 00:10:44,076
这个表面将会

301
00:10:44,076 --> 00:10:45,246
显示在头戴设备上

302
00:10:47,006 --> 00:10:49,716
在 macOS 中 把这些

303
00:10:49,716 --> 00:10:51,376
经过渲染的数据

304
00:10:51,556 --> 00:10:53,496
从你的 App 转移到 compositor 上

305
00:10:53,496 --> 00:10:54,286
IO surface 是理想的媒介

306
00:10:54,816 --> 00:10:56,346
所以请确保你们制作的

307
00:10:56,346 --> 00:10:58,066
Metal 纹理要得到

308
00:10:58,416 --> 00:10:59,566
IO surface 的支持

309
00:11:01,076 --> 00:11:02,596
我们来看看

310
00:11:02,656 --> 00:11:03,926
你要如何制造

311
00:11:03,926 --> 00:11:04,606
这些纹理

312
00:11:06,616 --> 00:11:08,046
你要建立一个

313
00:11:08,156 --> 00:11:09,766
纹理描述符

314
00:11:09,766 --> 00:11:11,436
指明渲染目标

315
00:11:11,476 --> 00:11:13,266
使用标志 因为你的 App

316
00:11:13,266 --> 00:11:14,406
会对它进行渲染

317
00:11:15,276 --> 00:11:17,416
但也要有着色器读取使用标志

318
00:11:18,146 --> 00:11:19,336
因为 compositor 会把它

319
00:11:19,426 --> 00:11:20,926
作为一个输入

320
00:11:21,406 --> 00:11:24,726
然后 要制作左右眼

321
00:11:24,946 --> 00:11:26,976
纹理 你只需要把之前分配的

322
00:11:27,066 --> 00:11:29,966
IO surface 和这个

323
00:11:29,966 --> 00:11:31,586
纹理描述符

324
00:11:31,626 --> 00:11:33,096
传送给

325
00:11:33,096 --> 00:11:34,696
newTextureWithDescriptor 就可以了

326
00:11:35,366 --> 00:11:35,596
好的

327
00:11:35,716 --> 00:11:36,786
现在我想花几分钟时间

328
00:11:36,786 --> 00:11:39,266
讲一下 或者说描述一下

329
00:11:39,266 --> 00:11:40,676
VR App 中的典型一帧

330
00:11:41,576 --> 00:11:43,076
这很重要 因为你的 App

331
00:11:43,076 --> 00:11:45,086
和 VR compositor 必须要

332
00:11:45,086 --> 00:11:46,376
同步工作

333
00:11:47,436 --> 00:11:49,186
我之前说过

334
00:11:49,186 --> 00:11:50,826
你的 App 渲染后的输出

335
00:11:50,826 --> 00:11:53,096
要被传送到 VR compositor 里

336
00:11:53,096 --> 00:11:54,336
用 GPU 进行额外的处理

337
00:11:55,726 --> 00:11:57,756
因为 GPU 属于共享资源

338
00:11:57,806 --> 00:12:00,596
因此保持同步与安排工作时间

339
00:12:00,596 --> 00:12:02,486
就非常重要了

340
00:12:03,086 --> 00:12:05,436
我们就从一帧的开头

341
00:12:05,436 --> 00:12:06,026
说起吧

342
00:12:06,946 --> 00:12:08,706
你的 App 需要请求

343
00:12:08,706 --> 00:12:10,506
VR 系统 获取头显设备

344
00:12:10,506 --> 00:12:12,196
的动作 它需要这个来渲染

345
00:12:12,196 --> 00:12:12,746
这一帧

346
00:12:13,936 --> 00:12:15,766
对 SteamVR 来说 这是用

347
00:12:15,866 --> 00:12:17,316
WaitGetPoses 调用来完成的

348
00:12:18,366 --> 00:12:20,406
然后你的 App

349
00:12:20,406 --> 00:12:22,116
在获得这些输入后

350
00:12:22,246 --> 00:12:24,246
可以立即对这一帧渲染后的命令

351
00:12:24,246 --> 00:12:24,946
进行编码

352
00:12:25,536 --> 00:12:28,406
然后 在你在对命令缓冲

353
00:12:28,406 --> 00:12:30,136
进行编码后

354
00:12:30,176 --> 00:12:31,836
你可以将它提交给 Metal

355
00:12:31,836 --> 00:12:32,576
在 GPU 上排队

356
00:12:33,146 --> 00:12:35,296
然后 将你的左右眼纹理

357
00:12:35,296 --> 00:12:37,956
提交给 SteamVR

358
00:12:38,946 --> 00:12:40,666
这会唤起 compositor

359
00:12:40,666 --> 00:12:42,606
让它开始为这一帧的

360
00:12:42,606 --> 00:12:43,896
GPU 工作进行编码

361
00:12:44,476 --> 00:12:46,976
然后 因为执行顺序非常重要

362
00:12:46,976 --> 00:12:49,286
你的 App 还需要

363
00:12:49,286 --> 00:12:50,816
告诉 VR compositor

364
00:12:50,816 --> 00:12:53,526
交给 GPU 的工作

365
00:12:53,596 --> 00:12:54,896
被安排在何时开始

366
00:12:56,656 --> 00:12:58,566
所以 对 Metal SteamVR App 来说

367
00:12:58,646 --> 00:13:00,706
你只需要等待 直到你的

368
00:13:00,706 --> 00:13:02,746
命令缓冲被安排好

369
00:13:02,746 --> 00:13:04,496
然后你就可以调用 SteamVR

370
00:13:04,496 --> 00:13:06,406
PostPresentHandoff 函数了

371
00:13:07,136 --> 00:13:08,886
这会告诉 VR compositor

372
00:13:09,136 --> 00:13:10,726
它可以把工作交给 GPU 了

373
00:13:10,726 --> 00:13:13,026
这一工作将按正确顺序

374
00:13:13,476 --> 00:13:14,366
进行排队

375
00:13:14,366 --> 00:13:16,886
我们看一下

376
00:13:16,886 --> 00:13:18,346
这在你的 draw loop 里是什么样子

377
00:13:18,706 --> 00:13:20,276
在 loop 的顶端

378
00:13:20,686 --> 00:13:22,006
有你的 WaitGetPoses call

379
00:13:22,006 --> 00:13:23,876
从头显设备里收集

380
00:13:23,876 --> 00:13:24,396
输入

381
00:13:25,656 --> 00:13:27,196
然后你要建立命令缓冲

382
00:13:27,196 --> 00:13:29,536
渲染你的场景

383
00:13:29,536 --> 00:13:30,706
然后把它提交给 GPU

384
00:13:31,826 --> 00:13:33,146
然后 在这里 你会

385
00:13:33,236 --> 00:13:35,086
把左右眼纹理提交给

386
00:13:35,186 --> 00:13:36,576
SteamVR

387
00:13:37,906 --> 00:13:39,876
然后 你等到

388
00:13:39,876 --> 00:13:40,796
命令缓冲被安排好

389
00:13:40,836 --> 00:13:43,466
你就可以调用

390
00:13:43,466 --> 00:13:45,086
PostPresentHandoff 告诉

391
00:13:45,086 --> 00:13:47,226
VR compositor 它现在可以

392
00:13:47,456 --> 00:13:49,966
把工作交给 GPU 了

393
00:13:51,926 --> 00:13:53,496
再强调一件事

394
00:13:55,056 --> 00:13:57,046
在我们

395
00:13:57,046 --> 00:13:58,486
把这个图表应用在

396
00:13:58,486 --> 00:14:00,676
下一帧的同时 需要注意是

397
00:14:00,986 --> 00:14:04,086
WaitGetPoses 而不是

398
00:14:04,196 --> 00:14:06,556
垂直中断定义了

399
00:14:06,556 --> 00:14:08,046
你的 App 的一帧的开始

400
00:14:08,896 --> 00:14:09,956
这一点很重要

401
00:14:09,956 --> 00:14:11,026
我们很快就会

402
00:14:11,026 --> 00:14:12,116
回来再说到这里

403
00:14:13,136 --> 00:14:15,016
好了

404
00:14:15,986 --> 00:14:17,396
我们接下来看一些

405
00:14:17,396 --> 00:14:18,416
很棒的实践

406
00:14:19,026 --> 00:14:22,626
首先是要避免

407
00:14:22,626 --> 00:14:24,596
在 CPU 编码命令时

408
00:14:24,596 --> 00:14:26,146
在一帧的开始产生

409
00:14:26,146 --> 00:14:27,836
GPU 气泡

410
00:14:29,036 --> 00:14:31,646
SteamVR 提供了一个

411
00:14:31,646 --> 00:14:33,216
很有用的机制来

412
00:14:33,216 --> 00:14:35,206
让你很早开始这一帧的工作

413
00:14:35,626 --> 00:14:37,216
让你的 App 有

414
00:14:37,276 --> 00:14:38,856
2 到 3 毫秒的时间运行开始

415
00:14:40,286 --> 00:14:41,226
这应该看上去

416
00:14:41,276 --> 00:14:41,786
不陌生

417
00:14:42,456 --> 00:14:43,836
把一帧的开始

418
00:14:43,836 --> 00:14:46,126
与 WaitGetPoses 对齐

419
00:14:46,126 --> 00:14:47,416
就保证了你利用到了

420
00:14:47,416 --> 00:14:48,966
这一优化

421
00:14:49,226 --> 00:14:50,576
让运行开始

422
00:14:54,076 --> 00:14:54,636
好的

423
00:14:54,716 --> 00:14:57,076
接下来 保证你的 App

424
00:14:57,076 --> 00:14:59,146
不会在把它们发送给 GPU 前

425
00:14:59,196 --> 00:15:00,396
建立大型的单片命令缓冲

426
00:15:00,396 --> 00:15:02,146
因为这也会

427
00:15:02,146 --> 00:15:03,936
造成 GPU 气泡

428
00:15:05,496 --> 00:15:07,966
你要做的是

429
00:15:07,966 --> 00:15:09,416
在可能的地方分割命令缓冲

430
00:15:09,656 --> 00:15:11,206
在进行过程中提交它们

431
00:15:11,206 --> 00:15:13,466
以保证 GPU 的应用在这一帧中达到

432
00:15:13,466 --> 00:15:13,866
最大化

433
00:15:14,406 --> 00:15:18,246
我们建议的下一个优化

434
00:15:18,246 --> 00:15:19,886
是尝试把你的左右眼

435
00:15:19,956 --> 00:15:22,046
绘制合并到一起

436
00:15:25,036 --> 00:15:26,836
Metal 2 Viewport Array

437
00:15:26,836 --> 00:15:28,296
特性为你提供了一个很好的机制

438
00:15:28,296 --> 00:15:30,296
帮你完成这一点

439
00:15:30,296 --> 00:15:32,036
它让你的 App 在

440
00:15:32,096 --> 00:15:34,176
vertex shader （顶点着色器）里

441
00:15:34,596 --> 00:15:35,546
选择逐个几何体目标视口

442
00:15:36,326 --> 00:15:37,796
这可以大幅度

443
00:15:37,796 --> 00:15:39,666
降低你的 draw call 资源消耗

444
00:15:39,666 --> 00:15:41,256
让你能够使用一个 draw call 来

445
00:15:41,916 --> 00:15:43,626
同时渲染左右眼场景

446
00:15:45,386 --> 00:15:46,726
我们来看一个示例

447
00:15:46,726 --> 00:15:48,296
展示如何用 instancing 来

448
00:15:48,676 --> 00:15:50,236
让你的 Metal App

449
00:15:50,236 --> 00:15:51,746
用上 Viewport Array

450
00:15:53,136 --> 00:15:54,016
我要先指出

451
00:15:54,016 --> 00:15:55,616
你需要制造一个

452
00:15:55,616 --> 00:15:57,446
两倍宽的纹理

453
00:15:57,446 --> 00:15:58,956
因为你现在要

454
00:15:58,956 --> 00:16:00,356
用同一个纹理

455
00:16:00,356 --> 00:16:02,266
渲染左右眼场景

456
00:16:03,836 --> 00:16:05,766
然后你只需要建立你的

457
00:16:05,766 --> 00:16:07,386
Viewpoint array 它定义了

458
00:16:07,386 --> 00:16:10,026
你的左右眼视口的边界

459
00:16:12,786 --> 00:16:13,906
然后你可以把这个

460
00:16:13,946 --> 00:16:15,216
Viewport array 交给你的

461
00:16:15,216 --> 00:16:16,976
渲染命令编码 你可以用

462
00:16:17,416 --> 00:16:18,426
setViewports API 做到这一点

463
00:16:19,586 --> 00:16:20,586
然后 在这里 你需要

464
00:16:20,586 --> 00:16:21,826
制作一个实例到

465
00:16:21,976 --> 00:16:23,706
DrawPrimitives 调用

466
00:16:23,766 --> 00:16:26,286
实例数量是 2

467
00:16:26,286 --> 00:16:27,366
从而把 draw 分配到左右眼

468
00:16:27,416 --> 00:16:28,066
视口上

469
00:16:29,286 --> 00:16:31,046
我们会在顶点着色器里

470
00:16:31,366 --> 00:16:33,836
使用实例 ID 当作我们的 eye index

471
00:16:35,286 --> 00:16:36,136
我们来看一下这个

472
00:16:36,136 --> 00:16:36,786
顶点着色器

473
00:16:37,406 --> 00:16:39,536
我先要指出的是

474
00:16:39,536 --> 00:16:42,126
这个视口是

475
00:16:42,456 --> 00:16:44,096
由新的 viewpoint_array_index

476
00:16:44,316 --> 00:16:45,436
属性选择出来的

477
00:16:47,756 --> 00:16:49,276
我之前说过

478
00:16:49,406 --> 00:16:50,166
我们正在使用 instance_ID

479
00:16:50,166 --> 00:16:52,486
作为我们的 eye index

480
00:16:52,826 --> 00:16:54,186
我们将能够使用它

481
00:16:54,186 --> 00:16:56,416
访问我们的视口关联数据

482
00:16:56,416 --> 00:16:57,936
就好像这个示例里的

483
00:16:57,966 --> 00:16:59,646
这个模型投影矩阵

484
00:17:00,716 --> 00:17:03,166
最后 一定要记得

485
00:17:03,166 --> 00:17:05,006
让你的视口索引

486
00:17:05,476 --> 00:17:06,705
和 instance_ID 关联起来

487
00:17:06,746 --> 00:17:08,006
这样在栅格化你的图像时

488
00:17:08,066 --> 00:17:10,056
能够保证选择了正确的视口

489
00:17:11,465 --> 00:17:13,465
这就是使用新的

490
00:17:13,465 --> 00:17:15,286
Viewport Array 特性减少

491
00:17:15,346 --> 00:17:17,906
你的 VR App 的 draw call 开销

492
00:17:18,856 --> 00:17:18,976
的方法

493
00:17:20,296 --> 00:17:20,846
好了

494
00:17:21,006 --> 00:17:22,386
今天我想说的最后一个优化

495
00:17:22,386 --> 00:17:24,006
是一个公认的

496
00:17:24,066 --> 00:17:25,465
最佳方法

497
00:17:25,465 --> 00:17:27,406
你会想去尝试减少

498
00:17:27,406 --> 00:17:29,716
在每一帧着色的

499
00:17:29,716 --> 00:17:30,876
像素数量

500
00:17:31,406 --> 00:17:33,236
由于镜头扭曲的特性

501
00:17:33,236 --> 00:17:35,816
你渲染的场景中

502
00:17:35,816 --> 00:17:37,876
大约 15% 的部分

503
00:17:37,876 --> 00:17:39,386
在 VR 头显设备上是看不到的

504
00:17:40,136 --> 00:17:41,626
这幅图中的蓝色区域

505
00:17:41,626 --> 00:17:42,586
就代表了看不到的部分

506
00:17:43,536 --> 00:17:45,976
幸好 SteamVR 提供了一个

507
00:17:46,056 --> 00:17:47,786
基于网格的模板掩码

508
00:17:47,866 --> 00:17:49,466
专为 Vive 头显设备设计

509
00:17:49,626 --> 00:17:51,006
你可以用它来剔除这些

510
00:17:51,066 --> 00:17:51,576
像素

511
00:17:52,096 --> 00:17:54,296
非常易用

512
00:17:54,326 --> 00:17:55,996
效果也非常之好

513
00:17:55,996 --> 00:17:56,866
好了

514
00:17:57,876 --> 00:18:00,586
这就是今天这个

515
00:18:00,666 --> 00:18:01,976
构建 VR App 的简短介绍的全部内容

516
00:18:02,766 --> 00:18:03,716
背景介绍完毕

517
00:18:03,716 --> 00:18:05,256
我想请 Valve 软件公司的

518
00:18:05,256 --> 00:18:06,916
Nat Brown 上台

519
00:18:06,996 --> 00:18:08,836
为大家深入讲解

520
00:18:08,836 --> 00:18:10,886
macOS 系统上的 SteamVR

521
00:18:12,016 --> 00:18:13,726
[掌声]

522
00:18:13,726 --> 00:18:14,126
谢谢 Nat

523
00:18:14,356 --> 00:18:14,746
>> 谢谢 Rav

524
00:18:16,146 --> 00:18:17,516
嗨 大家好

525
00:18:17,566 --> 00:18:20,486
我是 Nat 在 Valve 负责 VR 工作

526
00:18:20,786 --> 00:18:22,546
如果你们还不知道 Valve

527
00:18:22,546 --> 00:18:24,076
我们是个游戏公司

528
00:18:24,076 --> 00:18:25,186
我们发行游戏

529
00:18:25,186 --> 00:18:28,636
我们在 Steam 上有

530
00:18:28,636 --> 00:18:29,276
许多玩家

531
00:18:29,636 --> 00:18:30,896
实践证明 游戏

532
00:18:30,896 --> 00:18:33,266
对于用户界面

533
00:18:33,266 --> 00:18:34,186
和人机交互来说

534
00:18:34,186 --> 00:18:35,226
是一个非常有趣的严峻考验

535
00:18:35,676 --> 00:18:36,766
在 Valve 我们围绕着

536
00:18:36,766 --> 00:18:39,006
游戏和输入 进行了很多

537
00:18:39,006 --> 00:18:39,306
实验

538
00:18:40,156 --> 00:18:42,356
但多年来的 VR 原形体

539
00:18:42,886 --> 00:18:44,186
却并没有真正适用在

540
00:18:44,186 --> 00:18:45,346
制作游戏或者其他任何内容上面

541
00:18:46,366 --> 00:18:47,866
知道我们发现了这个

542
00:18:47,866 --> 00:18:50,106
完美的结合体

543
00:18:50,106 --> 00:18:52,096
包括 90 赫兹低余辉显示

544
00:18:52,096 --> 00:18:53,716
以及用这两个追踪控制器实现的

545
00:18:53,716 --> 00:18:54,536
房间范围内的准确追踪

546
00:18:55,276 --> 00:18:57,056
我们认为这就是 VR 领域的

547
00:18:57,056 --> 00:18:58,076
神奇突破

548
00:18:58,726 --> 00:19:00,826
我想它可以与

549
00:19:00,826 --> 00:19:02,776
你第一次使用

550
00:19:03,246 --> 00:19:04,546
低延迟精确触屏的

551
00:19:04,546 --> 00:19:06,216
智能手机的感受相比

552
00:19:06,216 --> 00:19:07,066
感觉非常神奇

553
00:19:07,396 --> 00:19:08,536
这就是 VR 领域的

554
00:19:08,536 --> 00:19:11,526
神奇突破

555
00:19:11,746 --> 00:19:12,916
一旦房间大小的 VR 环境

556
00:19:12,916 --> 00:19:14,216
成为了现实 我们就知道自己终于可以

557
00:19:14,216 --> 00:19:16,166
构建 VR 游戏和 VR

558
00:19:16,166 --> 00:19:16,496
内容了

559
00:19:17,516 --> 00:19:19,366
我们授权了各方面的 VR

560
00:19:19,366 --> 00:19:22,296
技术 比如基站

561
00:19:22,466 --> 00:19:24,686
头显设备镜片设计等等

562
00:19:24,686 --> 00:19:26,686
非独家地授权给了

563
00:19:26,686 --> 00:19:28,156
HTC 和 LG 等等合作伙伴

564
00:19:28,156 --> 00:19:30,016
我们还有一个大型项目

565
00:19:30,016 --> 00:19:31,486
把 Lighthouse 追踪技术

566
00:19:31,486 --> 00:19:32,816
授权给了很多不同的合作伙伴

567
00:19:33,756 --> 00:19:37,196
我们对于软件栈的办法

568
00:19:37,196 --> 00:19:38,336
你们也许已经听说了

569
00:19:38,336 --> 00:19:39,906
那就是

570
00:19:39,906 --> 00:19:42,186
SteamVr runtime

571
00:19:42,416 --> 00:19:43,936
SteamVr 有一个应用模型

572
00:19:43,936 --> 00:19:45,506
在上面 和一个硬件

573
00:19:45,506 --> 00:19:46,876
与驱动模型 在下面

574
00:19:47,016 --> 00:19:49,266
我们的目标是

575
00:19:49,266 --> 00:19:50,606
大力推广 VR 领域的实践

576
00:19:50,606 --> 00:19:52,096
因为我们现在还处于

577
00:19:52,096 --> 00:19:53,546
VR 初期 还不了解它

578
00:19:53,546 --> 00:19:55,006
能够发展成什么样子

579
00:19:55,546 --> 00:19:57,236
我们想制作这个模型

580
00:19:57,236 --> 00:19:58,746
让人们在里面实验

581
00:19:58,746 --> 00:19:59,576
VR 硬件和内容 同时

582
00:19:59,576 --> 00:19:59,976
减少风险

583
00:20:00,046 --> 00:20:03,036
你们可以去

584
00:20:03,036 --> 00:20:04,246
也许不是你们 但总有人可以去

585
00:20:04,536 --> 00:20:06,186
设计新的头显设备

586
00:20:06,186 --> 00:20:08,346
新的追踪系统 新的

587
00:20:08,346 --> 00:20:08,896
控制器

588
00:20:09,066 --> 00:20:10,526
然后 你们可以到

589
00:20:10,526 --> 00:20:12,146
Open VR 平台上

590
00:20:12,146 --> 00:20:13,526
写一个驱动程序然后直接插入设备

591
00:20:14,036 --> 00:20:15,116
然后你就可以访问

592
00:20:15,116 --> 00:20:16,606
正在运行的

593
00:20:16,606 --> 00:20:17,336
所有内容了

594
00:20:18,056 --> 00:20:19,596
这会给你真实世界的

595
00:20:19,596 --> 00:20:21,666
测试 能让你的硬件变得

596
00:20:21,666 --> 00:20:21,966
更好

597
00:20:21,966 --> 00:20:23,266
因为你和你的顾客

598
00:20:23,496 --> 00:20:25,426
可以直接将你的新创意

599
00:20:25,426 --> 00:20:26,566
和其他在这个平台上的

600
00:20:26,566 --> 00:20:27,326
硬件进行对比

601
00:20:27,826 --> 00:20:29,246
这样一来 硬件开发者就不必

602
00:20:29,246 --> 00:20:30,566
开发特定内容

603
00:20:30,916 --> 00:20:32,206
内容开发者也不必

604
00:20:32,206 --> 00:20:33,926
去赌哪一个硬件

605
00:20:33,926 --> 00:20:34,486
会胜出了

606
00:20:34,486 --> 00:20:36,476
他们只需要集中精力

607
00:20:37,236 --> 00:20:38,906
做好内容就可以了

608
00:20:38,906 --> 00:20:41,486
下面讲到关联到

609
00:20:41,486 --> 00:20:42,336
Open VR 框架的应用

610
00:20:42,336 --> 00:20:44,286
这是一个很小的库

611
00:20:44,286 --> 00:20:45,786
它只知道去定义

612
00:20:46,106 --> 00:20:47,166
当前被安装的 runtime

613
00:20:47,576 --> 00:20:49,336
它找到这个 VR 用户库

614
00:20:49,336 --> 00:20:50,546
这是一个共享库

615
00:20:50,546 --> 00:20:51,816
它要么能够关联到

616
00:20:51,816 --> 00:20:53,556
要么能够启动

617
00:20:53,556 --> 00:20:55,006
SteamVR 的其他 runtime

618
00:20:55,006 --> 00:20:55,596
进程

619
00:20:55,996 --> 00:20:57,156
这是 vrmonitor 进程

620
00:20:57,156 --> 00:20:58,516
你们会看到许多

621
00:20:58,516 --> 00:21:00,066
这样的小窗口

622
00:21:00,066 --> 00:21:01,486
这是一个 UI 和设置

623
00:21:01,486 --> 00:21:02,066
应用

624
00:21:02,066 --> 00:21:03,586
它会显示连接

625
00:21:03,586 --> 00:21:04,536
头显设备和控制器

626
00:21:04,536 --> 00:21:05,886
以及追踪感应器的

627
00:21:05,886 --> 00:21:06,326
状态

628
00:21:06,836 --> 00:21:11,896
vrserver 负责

629
00:21:12,006 --> 00:21:13,656
追踪驱动

630
00:21:13,836 --> 00:21:14,976
加载交替驱动

631
00:21:14,976 --> 00:21:16,806
它还会把姿态和其他信息

632
00:21:16,806 --> 00:21:19,076
放入共享内存

633
00:21:19,076 --> 00:21:21,136
以便让你的应用

634
00:21:21,136 --> 00:21:22,656
和 SteaVR runtime 的其他部分

635
00:21:22,706 --> 00:21:24,836
能够访问它

636
00:21:25,106 --> 00:21:26,336
这是 vrcompositor 你们刚刚

637
00:21:26,336 --> 00:21:28,066
已经稍微了解过了

638
00:21:28,276 --> 00:21:30,696
这个进程有点像

639
00:21:30,696 --> 00:21:31,086
Windows Server

640
00:21:31,326 --> 00:21:33,026
它把场景和 overlay 绘制在

641
00:21:33,026 --> 00:21:33,636
头显设备上

642
00:21:33,636 --> 00:21:35,506
它还会根据镜片失真和颜色

643
00:21:35,536 --> 00:21:36,666
来矫正图像

644
00:21:36,886 --> 00:21:37,716
还有一件从某种程度来看

645
00:21:37,716 --> 00:21:39,526
是隐藏起来的 你们可能

646
00:21:39,526 --> 00:21:42,656
不太明白的事 那就是它还

647
00:21:42,656 --> 00:21:43,746
会矫正动态画面中的

648
00:21:43,746 --> 00:21:44,726
拖尾和重影

649
00:21:45,086 --> 00:21:48,506
它还会在应用无法

650
00:21:48,506 --> 00:21:50,216
达到帧率时

651
00:21:50,216 --> 00:21:51,446
消失在稳定跟踪区域

652
00:21:51,716 --> 00:21:52,846
因为我们不想让人们

653
00:21:52,846 --> 00:21:53,846
碰到一些意外情况

654
00:21:54,526 --> 00:21:55,926
vrcompositor

655
00:21:55,926 --> 00:21:56,946
与 Metal 进行通讯

656
00:21:56,946 --> 00:21:57,386
你们已经了解过了

657
00:21:57,596 --> 00:21:59,066
它通过 Direct to Display

658
00:21:59,066 --> 00:22:00,026
Metal 2 API

659
00:22:00,026 --> 00:22:01,546
把画面直接显示在头显设备上

660
00:22:03,146 --> 00:22:03,526
我们看一下

661
00:22:03,526 --> 00:22:05,216
最后要说的是

662
00:22:05,496 --> 00:22:06,266
vrdashboard

663
00:22:06,486 --> 00:22:09,216
这部分的 UI 让你

664
00:22:09,216 --> 00:22:10,606
能够选择应用

665
00:22:10,936 --> 00:22:12,176
让你控制音量

666
00:22:12,576 --> 00:22:13,636
等其他系统设置

667
00:22:14,486 --> 00:22:16,256
我们提供一个默认的

668
00:22:16,256 --> 00:22:17,586
向你展示你的 Steam 库

669
00:22:17,586 --> 00:22:18,606
除非你选择应用

670
00:22:18,956 --> 00:22:20,096
但实际上有一个 API

671
00:22:20,096 --> 00:22:21,206
你也可以写你自己的

672
00:22:21,446 --> 00:22:22,736
dashboard 应用

673
00:22:22,966 --> 00:22:24,646
Valve 和 Apple 我们已经

674
00:22:24,646 --> 00:22:25,886
更加密切地合作

675
00:22:26,086 --> 00:22:27,336
就在大约一年前开始

676
00:22:27,646 --> 00:22:28,776
我们把端口从 OpenGL 转换到 Metal

677
00:22:28,776 --> 00:22:30,286
并没有让我们花费太多代价

678
00:22:30,686 --> 00:22:31,856
Metal 是个非常酷的 API

679
00:22:31,856 --> 00:22:34,116
它对于我们实现 VR 的高性能运行

680
00:22:34,116 --> 00:22:35,716
起到了关键作用

681
00:22:35,876 --> 00:22:38,166
大约一年前 我们对 Apple 最大的要求

682
00:22:38,166 --> 00:22:39,836
就是这个 Direct to

683
00:22:39,836 --> 00:22:40,536
Display 的特性

684
00:22:40,986 --> 00:22:42,126
因为要确保

685
00:22:42,126 --> 00:22:43,476
VR compositor 有达到头显设备的

686
00:22:43,476 --> 00:22:45,846
最快的可预测通道

687
00:22:45,846 --> 00:22:46,966
这非常重要

688
00:22:47,906 --> 00:22:50,046
同时我们还非常需要

689
00:22:50,046 --> 00:22:52,166
非常准确的低方差 VBL

690
00:22:52,276 --> 00:22:53,606
也就是垂直中断事件

691
00:22:53,956 --> 00:22:54,726
这样我们就可以设置

692
00:22:54,726 --> 00:22:56,216
VR 显示帧的节拍

693
00:22:56,216 --> 00:22:57,856
并且可以

694
00:22:57,856 --> 00:22:58,936
精确预测

695
00:22:58,936 --> 00:23:00,086
这些动作

696
00:23:00,316 --> 00:23:01,736
精确预测动作

697
00:23:01,966 --> 00:23:04,156
实际上要比动作发生之间的时间

698
00:23:04,156 --> 00:23:06,016
和显示出现的时间

699
00:23:06,316 --> 00:23:07,366
更为重要

700
00:23:07,366 --> 00:23:08,496
如果我们知道什么时候会发生

701
00:23:08,496 --> 00:23:09,436
那是更加重要的

702
00:23:10,656 --> 00:23:12,816
最后 我们在进程

703
00:23:12,816 --> 00:23:13,836
和线程之间的同步方面

704
00:23:13,836 --> 00:23:15,456
遇到了一些阻碍

705
00:23:15,816 --> 00:23:17,196
其他一切都运行良好

706
00:23:17,196 --> 00:23:18,516
Metal 速度很快

707
00:23:18,516 --> 00:23:21,596
我们也有了超精确低方差 VBL

708
00:23:21,596 --> 00:23:22,816
但还是存在一些

709
00:23:22,816 --> 00:23:24,116
同步方面的问题

710
00:23:24,316 --> 00:23:25,906
不过 Apple 帮助我们找到了

711
00:23:25,906 --> 00:23:28,066
更好的方法去发送信号

712
00:23:28,066 --> 00:23:29,446
和在所有的进程与线程之间

713
00:23:29,446 --> 00:23:30,716
进行低调速差异的

714
00:23:30,716 --> 00:23:31,376
同步

715
00:23:33,286 --> 00:23:37,416
我这个 VR 帧的图表

716
00:23:37,496 --> 00:23:38,306
比较复杂

717
00:23:39,466 --> 00:23:40,686
你们中的大多数人

718
00:23:40,686 --> 00:23:41,776
永远不会看到这么深

719
00:23:41,776 --> 00:23:42,686
但我还是想给你们

720
00:23:42,686 --> 00:23:43,066
看一看

721
00:23:43,556 --> 00:23:46,746
HTC Vibe 的

722
00:23:46,746 --> 00:23:48,646
低余辉 OLED 显示屏使用了

723
00:23:48,646 --> 00:23:49,126
全局照明

724
00:23:49,996 --> 00:23:52,146
显示图像上的所有像素

725
00:23:52,146 --> 00:23:54,226
都会在同时在极短时间内闪烁

726
00:23:54,726 --> 00:23:56,276
这在 VR 中很常见

727
00:23:56,276 --> 00:23:57,556
因为头部动作

728
00:23:57,556 --> 00:23:57,936
很快

729
00:23:58,426 --> 00:24:00,676
我们要保证

730
00:24:00,676 --> 00:24:02,506
画面不会在用户眼前

731
00:24:02,506 --> 00:24:03,526
产生拖尾或者撕裂

732
00:24:03,886 --> 00:24:05,566
panel 会照亮

733
00:24:05,566 --> 00:24:07,776
大约 2 毫秒每帧

734
00:24:07,776 --> 00:24:09,266
在它被 GPU 显示之后

735
00:24:09,266 --> 00:24:10,966
因为 panel 需要时间

736
00:24:11,036 --> 00:24:12,326
去充能 然后才可以

737
00:24:12,326 --> 00:24:14,096
发出全局照明脉冲

738
00:24:14,916 --> 00:24:16,266
这里 光子就从

739
00:24:16,266 --> 00:24:17,076
这里出来

740
00:24:17,076 --> 00:24:18,046
我们要在这个序列中

741
00:24:18,106 --> 00:24:19,246
跟踪这个红框

742
00:24:19,636 --> 00:24:23,436
光子在这里

743
00:24:23,436 --> 00:24:24,236
被释放出来

744
00:24:24,836 --> 00:24:25,916
因为这个时机

745
00:24:26,316 --> 00:24:27,706
应用通常会选择一个动作

746
00:24:27,756 --> 00:24:28,926
就像大家已经知道的一样

747
00:24:28,986 --> 00:24:30,986
应用从 IVR compositor 唤醒动作里

748
00:24:30,986 --> 00:24:31,406
选择一个动作

749
00:24:31,646 --> 00:24:33,946
唤醒动作会延迟

750
00:24:33,946 --> 00:24:36,096
并为那个未来的光子释放

751
00:24:36,096 --> 00:24:37,356
发回一个动作

752
00:24:37,616 --> 00:24:39,526
这里是渲染

753
00:24:39,526 --> 00:24:41,146
你把它显示在那里

754
00:24:41,366 --> 00:24:42,386
在中间这里

755
00:24:42,516 --> 00:24:43,796
但光子不会从那里

756
00:24:43,796 --> 00:24:44,056
出去

757
00:24:44,056 --> 00:24:46,916
所以我们必须要

758
00:24:46,916 --> 00:24:49,426
预测 25 毫秒之后的动作

759
00:24:50,076 --> 00:24:54,206
25 毫秒是

760
00:24:54,206 --> 00:24:56,206
两帧再加上运行开始时

761
00:24:56,366 --> 00:24:57,186
那一瞬间

762
00:24:57,236 --> 00:24:58,036
你们已经知道

763
00:24:58,036 --> 00:25:00,516
运行开始是非常重要的

764
00:25:00,516 --> 00:25:01,706
我们想要尽可能地

765
00:25:01,706 --> 00:25:04,146
给你们那 11 毫秒 GPU 时间

766
00:25:04,146 --> 00:25:05,826
去给用户展现

767
00:25:05,826 --> 00:25:07,376
最好的画面

768
00:25:08,396 --> 00:25:11,006
最后发生的事

769
00:25:11,006 --> 00:25:11,656
在这里

770
00:25:11,726 --> 00:25:12,736
你们可以看到这一帧

771
00:25:12,736 --> 00:25:14,156
会延伸到

772
00:25:14,156 --> 00:25:14,926
一开始的地方

773
00:25:15,416 --> 00:25:16,906
那是因为这个应用

774
00:25:16,906 --> 00:25:19,486
比较复杂

775
00:25:19,486 --> 00:25:20,526
你的游戏引擎

776
00:25:20,526 --> 00:25:22,566
可能会在暗中这样做

777
00:25:23,356 --> 00:25:24,726
它需要处理

778
00:25:24,726 --> 00:25:26,586
一些物理和输入事件

779
00:25:27,146 --> 00:25:28,386
在这里

780
00:25:28,386 --> 00:25:29,526
这个工作需要占用

781
00:25:29,526 --> 00:25:29,916
一些 CPU 时间

782
00:25:30,496 --> 00:25:32,046
那个代码实际上也需要

783
00:25:32,106 --> 00:25:33,286
动作信息

784
00:25:33,936 --> 00:25:35,346
它需要知道

785
00:25:35,346 --> 00:25:36,526
什么时候按键了

786
00:25:36,526 --> 00:25:37,366
控制器在哪里

787
00:25:37,366 --> 00:25:38,456
也许它正在插入

788
00:25:38,746 --> 00:25:39,576
一些关于动作的东西

789
00:25:39,576 --> 00:25:41,546
或者你在阻挡一些东西

790
00:25:41,796 --> 00:25:42,796
或者你在发射一些东西

791
00:25:43,556 --> 00:25:47,026
所以 实际上这个线程

792
00:25:47,026 --> 00:25:48,146
它会在差不多同时唤醒

793
00:25:48,146 --> 00:25:49,626
因为唤醒动作

794
00:25:49,626 --> 00:25:51,476
给了它这个重要的

795
00:25:51,586 --> 00:25:52,126
同步点

796
00:25:52,466 --> 00:25:53,866
但它会调用

797
00:25:53,866 --> 00:25:55,346
一个不同的 API

798
00:25:55,346 --> 00:25:56,756
因为它正试着获得

799
00:25:56,756 --> 00:25:57,346
一个更远的动作

800
00:25:57,536 --> 00:25:59,106
36 毫秒之后

801
00:25:59,106 --> 00:26:00,776
所以它需要

802
00:26:00,776 --> 00:26:02,746
调用 getDevice

803
00:26:02,746 --> 00:26:04,026
来精确追踪动作

804
00:26:04,406 --> 00:26:06,946
我说这些是为了让你们知道

805
00:26:06,946 --> 00:26:09,636
OpenVR 有一些

806
00:26:09,636 --> 00:26:12,706
很深的 API 让你们用来

807
00:26:12,706 --> 00:26:13,746
调试你们的应用

808
00:26:13,746 --> 00:26:15,856
让你们能够精确预测

809
00:26:15,856 --> 00:26:16,806
头显设备和控制器

810
00:26:16,806 --> 00:26:18,806
将会在哪里

811
00:26:19,236 --> 00:26:21,696
基础就是你需要它们在哪里

812
00:26:21,696 --> 00:26:23,106
你的代码需要它们在哪里

813
00:26:23,106 --> 00:26:24,946
唤醒动作的意义就在于

814
00:26:24,946 --> 00:26:26,526
它在运行开始时就及时

815
00:26:26,526 --> 00:26:28,176
给你一个预测点

816
00:26:28,176 --> 00:26:29,376
你就会知道这些光子

817
00:26:29,376 --> 00:26:30,506
何时会释放出来

818
00:26:31,536 --> 00:26:35,316
最后让我们说一说

819
00:26:35,316 --> 00:26:36,276
你需要做什么

820
00:26:36,276 --> 00:26:37,426
来使用

821
00:26:37,426 --> 00:26:38,366
SteamVr 和 macOS

822
00:26:38,366 --> 00:26:39,656
首先 这是 Steam 上的一个工具

823
00:26:39,656 --> 00:26:41,816
开发者需要安装

824
00:26:41,816 --> 00:26:43,546
Steam 并注册免费账户

825
00:26:43,546 --> 00:26:44,906
才能开始

826
00:26:45,696 --> 00:26:47,626
如果你们还没有使用 Steam

827
00:26:47,626 --> 00:26:47,996
快开始用吧

828
00:26:49,336 --> 00:26:51,086
接下来是安装 SteamVR 本身

829
00:26:51,166 --> 00:26:53,066
SteamVR 在工具中的

830
00:26:53,066 --> 00:26:53,946
Library 菜单里

831
00:26:54,296 --> 00:26:56,046
搜索 SteamVR 右键点击

832
00:26:56,046 --> 00:26:58,366
选择 Properties

833
00:26:58,366 --> 00:27:00,246
选择 Beta

834
00:27:00,246 --> 00:27:00,776
进入 Beta

835
00:27:01,246 --> 00:27:02,006
现在还是 beta 版本

836
00:27:02,316 --> 00:27:03,206
然后安装它

837
00:27:03,206 --> 00:27:04,566
我们会保持 SteamVR 的更新

838
00:27:04,566 --> 00:27:05,946
你们发现 bug 后我们就会去修复

839
00:27:07,166 --> 00:27:08,346
最后 你们要去 GitHub

840
00:27:08,346 --> 00:27:09,896
下载 OpenVR header 和

841
00:27:09,896 --> 00:27:11,686
框架

842
00:27:11,686 --> 00:27:12,796
我在这里放了一个链接

843
00:27:15,556 --> 00:27:17,096
这是最酷的部分

844
00:27:17,656 --> 00:27:18,886
你要把 OpenVR

845
00:27:18,886 --> 00:27:20,766
bootstrapping 框架

846
00:27:20,766 --> 00:27:21,526
放到你的应用里

847
00:27:22,106 --> 00:27:24,166
你链接到的 OpenVR 框架

848
00:27:24,166 --> 00:27:25,756
表达了你构建

849
00:27:25,756 --> 00:27:27,216
并测试的

850
00:27:27,216 --> 00:27:28,436
runtime 界面的版本

851
00:27:29,146 --> 00:27:30,866
这会让我们能

852
00:27:30,946 --> 00:27:32,736
升级 runtime 和进行

853
00:27:32,736 --> 00:27:33,616
版本更新

854
00:27:33,616 --> 00:27:35,306
我们会很积极地

855
00:27:35,536 --> 00:27:36,196
进行更新

856
00:27:36,386 --> 00:27:38,376
在 Xcode 里 不要去把框架

857
00:27:38,376 --> 00:27:39,146
添加到你的 link phase

858
00:27:39,146 --> 00:27:40,796
而应该到通用设置里

859
00:27:40,986 --> 00:27:42,216
把它设置成 embedded binary （嵌入式二进制文件）

860
00:27:42,216 --> 00:27:43,786
它会被安装到

861
00:27:43,786 --> 00:27:45,136
你的应用程序包里的

862
00:27:45,136 --> 00:27:46,086
内容框架部分

863
00:27:46,896 --> 00:27:50,506
好了 最后 我们真的需要

864
00:27:50,506 --> 00:27:51,296
你们的反馈

865
00:27:51,476 --> 00:27:53,016
因此 我们直接在

866
00:27:53,016 --> 00:27:54,426
vrmonitor 的 UI 里放了一些东西

867
00:27:54,426 --> 00:27:56,266
有个指针可以直接到 SteamVR 的

868
00:27:56,266 --> 00:27:57,756
支持网站和硬件

869
00:27:57,756 --> 00:27:58,756
讨论群

870
00:27:59,046 --> 00:28:00,646
你可以上报 bug

871
00:28:00,646 --> 00:28:01,976
制作系统报告并

872
00:28:01,976 --> 00:28:03,306
发送给我们 也可以直接发到我手上

873
00:28:03,306 --> 00:28:05,476
我的邮箱地址是

874
00:28:05,476 --> 00:28:07,736
natb@valvesoftware.com

875
00:28:07,736 --> 00:28:08,586
不过我更希望你们使用这个工具

876
00:28:09,196 --> 00:28:12,396
非常感谢大家

877
00:28:12,396 --> 00:28:13,826
我真的很期待看到

878
00:28:13,826 --> 00:28:15,306
你们使用 VR 的工作成果

879
00:28:15,376 --> 00:28:16,616
还要谢谢 Apple 的每个人

880
00:28:16,616 --> 00:28:18,246
让 VR 在 macOS 上发光

881
00:28:19,336 --> 00:28:19,716
谢谢大家

882
00:28:20,516 --> 00:28:22,636
[掌声]

883
00:28:23,136 --> 00:28:23,576
>> 谢谢 Nat

884
00:28:24,886 --> 00:28:25,926
与 Valve 合作非常愉快

885
00:28:25,926 --> 00:28:27,376
此时此刻 我仍然

886
00:28:27,376 --> 00:28:28,236
震惊于我们在过去一年

887
00:28:28,236 --> 00:28:29,636
所取得的成绩

888
00:28:31,206 --> 00:28:31,816
好了

889
00:28:31,816 --> 00:28:33,506
我们接着谈谈

890
00:28:33,506 --> 00:28:35,466
我们在 macOS High Sierra 里添加的

891
00:28:35,466 --> 00:28:37,296
外接 GPU 支持吧

892
00:28:37,986 --> 00:28:40,816
外接 GPU 是一个

893
00:28:40,816 --> 00:28:42,196
独立的底盘 上面

894
00:28:42,306 --> 00:28:44,436
有个桌面级别的 GPU

895
00:28:44,436 --> 00:28:47,146
可以通过 thunderbolt

896
00:28:47,146 --> 00:28:48,926
直接插到主系统上

897
00:28:49,856 --> 00:28:52,186
之前说过

898
00:28:52,466 --> 00:28:54,216
这样做的主要原因

899
00:28:54,216 --> 00:28:55,876
是让你们这样的开发者能够

900
00:28:55,876 --> 00:28:58,166
使用更多样的 Mac 硬件

901
00:28:58,256 --> 00:28:59,936
去制作更出色的 VR App

902
00:29:00,686 --> 00:29:02,196
这是个很棒的 workflow

903
00:29:02,196 --> 00:29:03,436
你可以用你的 MacBook Pro

904
00:29:03,436 --> 00:29:05,996
和外接 GPU

905
00:29:06,236 --> 00:29:07,946
来获得制作 VR 应用所需的

906
00:29:07,946 --> 00:29:08,696
渲染性能

907
00:29:08,696 --> 00:29:11,466
当然 这还能为

908
00:29:11,466 --> 00:29:12,896
其他 GPU 应用场景

909
00:29:12,936 --> 00:29:15,086
提供额外的性能支持

910
00:29:15,086 --> 00:29:17,506
比如游戏和专业 App

911
00:29:18,576 --> 00:29:22,706
大家在周一了解过了

912
00:29:22,706 --> 00:29:24,246
我们和 Sonnet 与 AMD 合作

913
00:29:24,246 --> 00:29:26,426
为你们提供了一个

914
00:29:26,426 --> 00:29:28,666
外部图像开发者套装

915
00:29:28,706 --> 00:29:32,226
里面有一块 AMD Radeon RX-580 GPU

916
00:29:32,556 --> 00:29:34,616
这个套装已经优化过

917
00:29:34,616 --> 00:29:36,106
适配所有的能兼容 Thunderbolt3

918
00:29:36,106 --> 00:29:37,966
的 Mac 设备

919
00:29:37,966 --> 00:29:38,906
今天就能通过开发者计划

920
00:29:38,906 --> 00:29:40,626
购买这个套装

921
00:29:41,236 --> 00:29:41,966
好了

922
00:29:42,246 --> 00:29:44,066
接下来讲要如何

923
00:29:44,066 --> 00:29:45,846
识别外接 GPU

924
00:29:46,556 --> 00:29:48,116
这个设备枚举代码

925
00:29:48,116 --> 00:29:49,196
看上去应该很不陌生

926
00:29:50,616 --> 00:29:52,646
CopyAllDevices 会显示出

927
00:29:52,646 --> 00:29:54,166
系统中所有支持 Metal 的设备

928
00:29:54,906 --> 00:29:56,336
然后你可以识别出

929
00:29:56,336 --> 00:29:58,626
外部 GPU 了 方法就是

930
00:29:58,626 --> 00:30:00,576
识别设备的

931
00:30:00,576 --> 00:30:00,976
可删除属性就可以了

932
00:30:01,976 --> 00:30:03,466
这和你们之前

933
00:30:03,546 --> 00:30:04,936
识别我们平台上的

934
00:30:04,936 --> 00:30:06,646
低电量设备的方法很类似

935
00:30:06,646 --> 00:30:10,336
现在 我们来稍微讲一下

936
00:30:10,336 --> 00:30:11,246
Thunderbolt 带宽功能

937
00:30:12,816 --> 00:30:15,086
Thunderbolt 3 提供的

938
00:30:15,146 --> 00:30:16,386
理论带宽是

939
00:30:16,436 --> 00:30:18,326
Thunderbolt 2 的两倍 这很好

940
00:30:19,166 --> 00:30:20,406
但不要忘了

941
00:30:20,406 --> 00:30:21,806
这只不过是

942
00:30:21,806 --> 00:30:24,056
我们平台上

943
00:30:24,306 --> 00:30:25,956
内置 GPU 总线驱动带宽

944
00:30:25,956 --> 00:30:27,116
的四分之一而已

945
00:30:28,356 --> 00:30:29,286
这很重要

946
00:30:29,906 --> 00:30:31,586
你现在可以选择

947
00:30:31,586 --> 00:30:33,896
是使用带宽更高的

948
00:30:34,006 --> 00:30:36,426
内置 GPU

949
00:30:36,516 --> 00:30:38,656
还是使用大约

950
00:30:38,656 --> 00:30:39,926
四分之一带宽的

951
00:30:39,926 --> 00:30:40,466
高性能外接 GPU

952
00:30:41,126 --> 00:30:43,536
在决定使用哪个 GPU 的时候

953
00:30:43,536 --> 00:30:45,056
要把带宽的因素

954
00:30:45,056 --> 00:30:47,486
也考虑进去

955
00:30:48,816 --> 00:30:50,606
此外 用户现在可以

956
00:30:50,606 --> 00:30:52,706
在不同的 GPU 上接不同的显示设备了

957
00:30:52,896 --> 00:30:55,746
在这个环境下

958
00:30:55,746 --> 00:30:57,746
要使用一个 GPU 渲染

959
00:30:58,006 --> 00:30:59,576
另一个 GPU 显示的话 就会有个缺点

960
00:30:59,576 --> 00:31:00,516
因为数据需要

961
00:31:00,516 --> 00:31:02,226
通过链接传输

962
00:31:03,736 --> 00:31:05,046
所以 内容会在哪里显示

963
00:31:05,106 --> 00:31:08,946
这是你在决定使用哪个 GPU 时

964
00:31:08,946 --> 00:31:10,526
必须要考虑的

965
00:31:10,646 --> 00:31:12,176
一个重要因素

966
00:31:13,606 --> 00:31:14,206
这添加了一些

967
00:31:14,206 --> 00:31:15,106
复杂性

968
00:31:15,856 --> 00:31:16,806
但幸好

969
00:31:16,866 --> 00:31:18,566
你可以做一点

970
00:31:18,566 --> 00:31:20,156
简单的事情 让你的 App

971
00:31:20,216 --> 00:31:21,656
在多 GPU 环境下

972
00:31:21,656 --> 00:31:22,196
表现良好

973
00:31:23,136 --> 00:31:24,116
我们先讲 GPU 的选择

974
00:31:25,646 --> 00:31:27,066
我们强烈建议

975
00:31:27,066 --> 00:31:29,836
你使用同一块 GPU

976
00:31:29,836 --> 00:31:31,516
渲染和驱动你 App 的

977
00:31:31,516 --> 00:31:31,916
显示设备

978
00:31:32,506 --> 00:31:34,306
我把这称为 GPU 选择的

979
00:31:34,306 --> 00:31:35,116
黄金法则

980
00:31:36,216 --> 00:31:37,356
我们展开一下

981
00:31:37,356 --> 00:31:38,306
制作一个决策树

982
00:31:39,756 --> 00:31:41,186
如果你的 App 渲染的内容

983
00:31:41,226 --> 00:31:43,226
会被显示出来

984
00:31:43,226 --> 00:31:46,006
你就要去选择

985
00:31:46,656 --> 00:31:48,436
驱动那个显示设备的 GPU

986
00:31:48,656 --> 00:31:49,596
这是我们的黄金法则

987
00:31:50,776 --> 00:31:51,936
但是如果你的 App

988
00:31:51,976 --> 00:31:53,986
要进行计算或者其他

989
00:31:53,986 --> 00:31:55,956
离线渲染操作

990
00:31:55,956 --> 00:31:57,616
那你就要决定是否要

991
00:31:57,616 --> 00:31:59,526
使用低能耗 GPU 了

992
00:31:59,526 --> 00:32:00,116
如果可能的话

993
00:32:01,126 --> 00:32:02,646
这在移动设备上

994
00:32:02,646 --> 00:32:04,006
尤其有用

995
00:32:04,276 --> 00:32:05,596
因为选择这个设备

996
00:32:05,666 --> 00:32:07,136
会极大地节省电量

997
00:32:07,916 --> 00:32:09,066
但当然 如果你

998
00:32:09,066 --> 00:32:11,186
需要把 GPU 性能用在 VR 上面

999
00:32:11,186 --> 00:32:12,546
你就得选择

1000
00:32:12,546 --> 00:32:14,216
外接 GPU 了

1001
00:32:14,216 --> 00:32:17,126
我们回到黄金法则上

1002
00:32:17,126 --> 00:32:19,256
看看要如何

1003
00:32:19,256 --> 00:32:21,196
识别驱动特定显示的

1004
00:32:21,196 --> 00:32:22,556
Metal 设备吧

1005
00:32:23,866 --> 00:32:24,806
你们会发现

1006
00:32:24,876 --> 00:32:25,766
这是很容易的

1007
00:32:26,496 --> 00:32:27,576
有一个现有的

1008
00:32:27,576 --> 00:32:29,416
图像 API 会让你

1009
00:32:29,416 --> 00:32:30,176
识别这个设备

1010
00:32:30,996 --> 00:32:32,646
你只需要得到你的窗口

1011
00:32:33,216 --> 00:32:34,586
所在的显示设备的 ID

1012
00:32:34,586 --> 00:32:36,026
方法就是去询问

1013
00:32:36,026 --> 00:32:36,906
NSScreenNumber

1014
00:32:37,636 --> 00:32:39,516
然后调用

1015
00:32:39,576 --> 00:32:42,116
CGDirectDisplayCopyCurrentMetalDevice

1016
00:32:42,116 --> 00:32:44,076
来获取驱动这个显示的

1017
00:32:44,146 --> 00:32:45,346
Metal 设备

1018
00:32:46,036 --> 00:32:46,606
就这么简单

1019
00:32:46,606 --> 00:32:47,306
好了

1020
00:32:49,236 --> 00:32:51,586
我们已经知道

1021
00:32:51,586 --> 00:32:53,056
每个显示设备

1022
00:32:53,056 --> 00:32:55,346
都可以接到不同的 GPU 上

1023
00:32:55,346 --> 00:32:57,656
你的 App 就需要在显示移动时

1024
00:32:57,656 --> 00:32:58,706
操作 GPU 的迁移

1025
00:32:59,116 --> 00:33:00,566
不好意思 我是说在你的窗口

1026
00:33:00,566 --> 00:33:01,706
在这些显示中移动的时候

1027
00:33:03,776 --> 00:33:05,586
你可以通过

1028
00:33:05,656 --> 00:33:07,646
注册新的

1029
00:33:07,646 --> 00:33:08,946
其实不是新的 是我们已有的

1030
00:33:09,376 --> 00:33:10,926
通知管理 叫做

1031
00:33:11,206 --> 00:33:12,896
WindowDidChangeScreen 来实现这一点

1032
00:33:12,896 --> 00:33:14,416
我们看一看你们要

1033
00:33:14,416 --> 00:33:15,826
如何处理这个通知管理

1034
00:33:16,406 --> 00:33:18,506
首先要找到

1035
00:33:18,596 --> 00:33:21,406
你的 App 现在所在的显示的

1036
00:33:21,406 --> 00:33:23,286
Metal 设备 方法就是

1037
00:33:23,286 --> 00:33:24,626
调用我们刚才说过的

1038
00:33:24,626 --> 00:33:26,196
核心图像 API

1039
00:33:27,476 --> 00:33:28,586
如果这就是你当前正在

1040
00:33:28,586 --> 00:33:29,646
渲染的同一个设备

1041
00:33:29,686 --> 00:33:31,106
那你就能提前完成了

1042
00:33:31,106 --> 00:33:33,036
因为不需要 GPU 迁移

1043
00:33:33,036 --> 00:33:35,336
然后 你要进行

1044
00:33:35,566 --> 00:33:37,606
设备迁移

1045
00:33:37,606 --> 00:33:39,316
切换到使用新设备

1046
00:33:39,316 --> 00:33:39,966
进行所有渲染

1047
00:33:41,016 --> 00:33:43,236
这就是使用显示

1048
00:33:43,236 --> 00:33:45,246
更改通知来操作

1049
00:33:45,246 --> 00:33:46,376
GPU 迁移

1050
00:33:46,376 --> 00:33:48,166
但外接 GPU

1051
00:33:48,166 --> 00:33:50,076
插入系统

1052
00:33:50,366 --> 00:33:51,756
或者拔出系统时该怎样呢

1053
00:33:53,116 --> 00:33:54,786
Metal 2 推出了

1054
00:33:54,786 --> 00:33:56,526
3 个新通知 在这种情况下

1055
00:33:56,526 --> 00:33:57,146
帮助你

1056
00:33:58,316 --> 00:34:01,016
第一个是 DeviceWasAdded

1057
00:34:01,016 --> 00:34:02,616
适用于外接 GPU 插入时

1058
00:34:03,726 --> 00:34:05,076
DeviceWasRemoved 适用于

1059
00:34:05,116 --> 00:34:06,336
拔出时

1060
00:34:06,336 --> 00:34:08,735
还有 DeviceRemovalRequested

1061
00:34:08,735 --> 00:34:10,896
适用于 OS 准备在未来某个时间点

1062
00:34:10,896 --> 00:34:12,795
移除外接 GPU 的情况

1063
00:34:14,235 --> 00:34:15,406
我们看看你要如何

1064
00:34:15,406 --> 00:34:16,716
注册并响应

1065
00:34:16,716 --> 00:34:18,706
这些通知

1066
00:34:19,815 --> 00:34:21,315
你要使用新的

1067
00:34:21,416 --> 00:34:24,016
CopyAllDevicesWithObserver API

1068
00:34:24,686 --> 00:34:25,786
这是我们在 Metal 2 中新推出的

1069
00:34:26,846 --> 00:34:27,936
这会让你为这些新的

1070
00:34:28,045 --> 00:34:30,416
设备变更通知注册

1071
00:34:30,416 --> 00:34:31,686
handler

1072
00:34:32,686 --> 00:34:34,136
在这个示例里

1073
00:34:34,136 --> 00:34:35,536
我们只需要调用一个叫

1074
00:34:35,896 --> 00:34:37,266
handleGPUHotPlug 的函数

1075
00:34:37,976 --> 00:34:38,876
我们来看一看

1076
00:34:39,666 --> 00:34:41,126
这真的很简单直接

1077
00:34:41,616 --> 00:34:43,446
你只需要检查

1078
00:34:43,446 --> 00:34:45,216
并直接回应每一条通知

1079
00:34:46,686 --> 00:34:47,676
但我想在这里

1080
00:34:47,676 --> 00:34:48,275
指出几件事

1081
00:34:49,315 --> 00:34:50,966
首先 你的 App

1082
00:34:50,966 --> 00:34:51,896
应该把

1083
00:34:51,946 --> 00:34:53,436
DeviceRemovalRequested

1084
00:34:53,436 --> 00:34:55,696
通知 当成要迁移出

1085
00:34:55,795 --> 00:34:57,966
外接 GPU 的提示

1086
00:34:58,446 --> 00:35:02,216
第二 如果你的 App

1087
00:35:02,216 --> 00:35:02,796
没有接收到

1088
00:35:02,796 --> 00:35:04,116
DeviceRemovalRequested

1089
00:35:04,116 --> 00:35:06,016
通知 那它就应该

1090
00:35:06,016 --> 00:35:08,186
把 DeviceWasRemoved 当成

1091
00:35:08,286 --> 00:35:10,246
意外的 GPU 移除

1092
00:35:10,826 --> 00:35:13,646
意外的 GPU 移除是指

1093
00:35:13,646 --> 00:35:15,316
你的外接 GPU 在系统不知情的情况下

1094
00:35:15,436 --> 00:35:17,036
切断了连接

1095
00:35:17,156 --> 00:35:18,566
或者失去了电力

1096
00:35:19,926 --> 00:35:20,986
这就等于

1097
00:35:20,986 --> 00:35:22,196
有人进入了你的系统

1098
00:35:22,196 --> 00:35:24,116
拔掉了 GPU

1099
00:35:24,896 --> 00:35:26,126
既然硬件已经

1100
00:35:26,126 --> 00:35:28,286
不在了 一些 Metal API

1101
00:35:28,286 --> 00:35:30,086
调用就会开始出现错误

1102
00:35:30,646 --> 00:35:32,486
因此你需要在 App 中

1103
00:35:32,536 --> 00:35:33,986
添加防护代码

1104
00:35:33,986 --> 00:35:34,556
以防这种情况发生

1105
00:35:35,146 --> 00:35:36,516
让它能够坚持住

1106
00:35:36,616 --> 00:35:37,786
直到收到迁移通知

1107
00:35:37,786 --> 00:35:39,236
并从容地

1108
00:35:39,236 --> 00:35:41,076
切换到系统中的

1109
00:35:41,076 --> 00:35:41,696
另一块 GPU 上

1110
00:35:42,876 --> 00:35:44,116
还有一点需要指出

1111
00:35:44,296 --> 00:35:45,756
那就是如果你在外接 GPU 的

1112
00:35:45,756 --> 00:35:47,916
本地内存上有临时数据

1113
00:35:47,916 --> 00:35:49,646
你的 App 就可能需要

1114
00:35:49,646 --> 00:35:50,926
重新生成数据 因为它

1115
00:35:50,926 --> 00:35:51,386
已经没有了

1116
00:35:51,386 --> 00:35:52,066
好了

1117
00:35:53,346 --> 00:35:55,666
现在讲一些最佳实践

1118
00:35:56,456 --> 00:35:57,916
我们建议你们

1119
00:35:57,916 --> 00:35:59,716
不要在迁移后立即

1120
00:35:59,966 --> 00:36:02,466
释放设备

1121
00:36:02,466 --> 00:36:04,106
因为用户喜欢在不同显示设备之间

1122
00:36:04,106 --> 00:36:05,066
移动窗口

1123
00:36:05,946 --> 00:36:08,356
所以请

1124
00:36:08,426 --> 00:36:10,126
采用延迟 teardown 策略 留出一些合理时间

1125
00:36:12,136 --> 00:36:14,566
此外 如果你的 App

1126
00:36:14,566 --> 00:36:16,936
有复杂的 UI 有很多窗口

1127
00:36:16,936 --> 00:36:19,366
你也许 也许需要

1128
00:36:19,366 --> 00:36:21,476
分别针对每个窗口

1129
00:36:21,526 --> 00:36:22,306
控制 GPU 迁移

1130
00:36:23,426 --> 00:36:25,526
最后 我们建议

1131
00:36:25,526 --> 00:36:27,086
你在多 GPU 场景下

1132
00:36:27,086 --> 00:36:29,516
存储 App 以保证

1133
00:36:29,516 --> 00:36:30,736
你不需要

1134
00:36:30,736 --> 00:36:32,356
在 GPU 之间来回传送数据

1135
00:36:32,426 --> 00:36:35,986
做无用功

1136
00:36:36,186 --> 00:36:36,446
好了

1137
00:36:36,696 --> 00:36:38,196
我们回到 VR 上来

1138
00:36:38,196 --> 00:36:39,816
看一看这种使用场景下的

1139
00:36:39,816 --> 00:36:40,676
最佳实践

1140
00:36:41,816 --> 00:36:44,156
首先 最明显的

1141
00:36:44,156 --> 00:36:45,616
保证你把 VR 头显设备

1142
00:36:45,736 --> 00:36:47,536
直接插到外接 GPU 上

1143
00:36:48,836 --> 00:36:50,076
不那么明显但同样重要的是

1144
00:36:50,076 --> 00:36:51,766
你要确保你的 App

1145
00:36:51,766 --> 00:36:53,256
把它的 UI 或是

1146
00:36:53,256 --> 00:36:56,256
镜像 VR 内容

1147
00:36:56,256 --> 00:36:57,746
显示到同样被

1148
00:36:57,746 --> 00:36:59,336
外接 GPU 驱动的显示器上

1149
00:37:00,036 --> 00:37:01,206
这会确保

1150
00:37:01,206 --> 00:37:03,626
VR compositor 和你的 App

1151
00:37:03,626 --> 00:37:05,316
都使用外接 GPU 进行渲染

1152
00:37:05,906 --> 00:37:08,396
最后 要保证你

1153
00:37:08,396 --> 00:37:10,846
在外接 GPU 的本地内存上

1154
00:37:10,846 --> 00:37:12,556
存储尽可能多的数据

1155
00:37:12,906 --> 00:37:14,226
这样你就不需要通过

1156
00:37:14,226 --> 00:37:15,416
Thunderbolt 链接传输数据了

1157
00:37:15,416 --> 00:37:17,016
除非这是绝对必要的

1158
00:37:18,216 --> 00:37:19,236
好了

1159
00:37:20,376 --> 00:37:22,096
这就是今天讲座的

1160
00:37:22,096 --> 00:37:22,826
全部内容

1161
00:37:23,046 --> 00:37:24,386
我们来快速回顾一下

1162
00:37:24,386 --> 00:37:25,196
今天谈到的东西

1163
00:37:25,476 --> 00:37:27,676
最重要的是你们现在

1164
00:37:27,676 --> 00:37:29,526
可以在 macOS 上开发 VR 内容了

1165
00:37:31,376 --> 00:37:32,886
我们添加了对 HTC Vibe 头显设备的

1166
00:37:33,126 --> 00:37:34,716
内置支持

1167
00:37:35,336 --> 00:37:37,366
我们与 Valve 合作

1168
00:37:37,366 --> 00:37:39,296
为在我们平台上的 SteamVR

1169
00:37:39,546 --> 00:37:41,046
runtime 推出了一个

1170
00:37:41,046 --> 00:37:43,106
优化版本的 Metal

1171
00:37:44,966 --> 00:37:46,216
此外 两个最流行的

1172
00:37:46,306 --> 00:37:48,486
游戏引擎 Unity

1173
00:37:48,486 --> 00:37:50,566
和虚幻 4 会在不久的将来

1174
00:37:50,636 --> 00:37:52,596
在 Mac 中加入 VR 支持

1175
00:37:53,766 --> 00:37:55,406
但当然 我们也鼓励

1176
00:37:55,406 --> 00:37:56,806
你们构建自己的原生 VR

1177
00:37:56,806 --> 00:37:57,296
App

1178
00:37:58,126 --> 00:37:59,726
最后 我们还添加了

1179
00:37:59,726 --> 00:38:00,626
对外接 GPU 的支持

1180
00:38:00,626 --> 00:38:02,846
我们希望这能

1181
00:38:02,846 --> 00:38:04,606
让你保证你的 App

1182
00:38:04,746 --> 00:38:06,946
在多 GPU 环境下

1183
00:38:06,946 --> 00:38:08,326
表现良好

1184
00:38:08,376 --> 00:38:09,376
让你们能利用上

1185
00:38:09,376 --> 00:38:10,706
外接 GPU 的强劲性能

1186
00:38:12,696 --> 00:38:14,746
我们非常期待看到

1187
00:38:14,746 --> 00:38:15,696
你们使用这个新技术

1188
00:38:15,696 --> 00:38:17,206
创造出的成果

1189
00:38:18,436 --> 00:38:19,396
一定要记得去

1190
00:38:19,396 --> 00:38:20,406
看 Metal Track 的

1191
00:38:20,406 --> 00:38:20,756
其他讲座

1192
00:38:21,086 --> 00:38:22,666
昨天有一场很棒的

1193
00:38:22,666 --> 00:38:23,706
Introducing Metal 2 讲座

1194
00:38:23,706 --> 00:38:24,826
如果你们没赶上

1195
00:38:24,926 --> 00:38:26,126
我建议你们去上网

1196
00:38:26,176 --> 00:38:27,186
看一看

1197
00:38:28,076 --> 00:38:29,466
我们明天下午

1198
00:38:29,466 --> 00:38:30,766
还有两场讲座

1199
00:38:31,336 --> 00:38:32,726
Metal 2 Optimization and

1200
00:38:32,726 --> 00:38:34,696
Debugging 和 Using Metal 2 for

1201
00:38:34,696 --> 00:38:35,136
Compute

1202
00:38:35,326 --> 00:38:36,636
我们希望在那里见到你们

1203
00:38:37,516 --> 00:38:38,196
我会去的

1204
00:38:38,196 --> 00:38:39,286
非常感谢大家

1205
00:38:39,336 --> 00:38:40,476
祝你们在 WWDC 大有收获

1206
00:38:41,016 --> 00:38:43,000
[掌声]

