1
00:00:24,424 --> 00:00:25,526
大家好

2
00:00:26,560 --> 00:00:28,862
希望大家度过一个美好的WWDC

3
00:00:29,563 --> 00:00:31,899
欢迎来到“创建了不起的
基于文档的应用”演讲

4
00:00:34,101 --> 00:00:37,471
今天我们要谈谈文件应用的新功能

5
00:00:37,905 --> 00:00:39,740
以及如何将其整合到你们的应用中

6
00:00:40,541 --> 00:00:42,376
首先 让我们先谈谈文件应用

7
00:00:43,877 --> 00:00:45,812
这款应用最大的功能之一

8
00:00:46,246 --> 00:00:48,882
就是它将全部云供应商
集合到了一个地方

9
00:00:49,316 --> 00:00:51,952
这是通过新的共享文件
扩展实现的

10
00:00:52,452 --> 00:00:55,489
使用此共享文件扩展的全部云供应商

11
00:00:55,556 --> 00:00:59,626
都将会出现在我的iPad
侧边栏的iCloud驱动旁边

12
00:01:00,727 --> 00:01:02,930
如果你想了解更多关于此扩展的信息

13
00:01:03,697 --> 00:01:06,200
我们邀请你观看
“文件共享增强功能”演讲

14
00:01:06,266 --> 00:01:07,434
时间是明天上午11点整

15
00:01:09,870 --> 00:01:12,806
系统中默认有两种文件共享

16
00:01:13,273 --> 00:01:15,375
第一种是iCloud驱动供应商

17
00:01:15,742 --> 00:01:19,213
它显示用户iCloud驱动
文件夹内的全部文件

18
00:01:19,279 --> 00:01:21,548
以及系统全部应用的

19
00:01:21,748 --> 00:01:23,584
云容器中的全部文件

20
00:01:25,853 --> 00:01:28,155
第二种共享是在我的iPad上共享

21
00:01:28,856 --> 00:01:31,892
它允许用户利用他们设备的存储

22
00:01:32,759 --> 00:01:33,894
它会显示应用容器内

23
00:01:33,961 --> 00:01:36,330
文档文件夹中的内容

24
00:01:37,164 --> 00:01:40,534
如果你希望你的应用成为这种
本地存储共享的一部分

25
00:01:41,134 --> 00:01:43,070
你的应用必须得是一款
基于文档的应用

26
00:01:43,604 --> 00:01:47,274
或支持文件共享
并能在适当的位置打开文档

27
00:01:48,575 --> 00:01:51,712
正如我之前所说的
我们会在内部显示文档

28
00:01:51,778 --> 00:01:53,614
文档文件夹中的文件

29
00:01:53,680 --> 00:01:56,650
所以请保持
这个文件夹中的内容干净整洁

30
00:01:57,117 --> 00:01:59,853
你应该只包含那些
对于用户来说很重要的文件

31
00:02:00,521 --> 00:02:01,955
同时你得谨记

32
00:02:02,222 --> 00:02:04,892
这些文件不会被同步到多台设备中

33
00:02:04,958 --> 00:02:07,261
而是仍然是iCloud备份的
一部分

34
00:02:09,729 --> 00:02:12,299
现在我想谈谈新的最近列表视图

35
00:02:13,200 --> 00:02:14,968
这个视图会显示近期打开、导入

36
00:02:15,035 --> 00:02:17,938
和修改过的全部文档

37
00:02:18,672 --> 00:02:21,742
同时它可以按标签显示全部文档

38
00:02:22,342 --> 00:02:24,878
以及与他人共享的全部文档

39
00:02:27,948 --> 00:02:30,050
标签是管理文件的一个不错的方式

40
00:02:30,384 --> 00:02:32,920
在iOS 11中
有一个新的标签UI

41
00:02:32,986 --> 00:02:36,390
可以允许用户创建
新的标签并进行管理

42
00:02:37,391 --> 00:02:39,593
用户可以将标签同步到多台设备上

43
00:02:40,327 --> 00:02:43,297
并且标签会被同步到你的全部设备上

44
00:02:45,465 --> 00:02:46,400
最后一点

45
00:02:46,667 --> 00:02:49,903
我要谈的文件应用的最后一个功能

46
00:02:50,070 --> 00:02:51,238
就是最近列表弹出框

47
00:02:51,805 --> 00:02:54,074
用户可以呈现这种弹出框

48
00:02:54,374 --> 00:02:56,610
当在文件应用中实施长按时

49
00:02:57,678 --> 00:03:00,180
这个弹出框会显示全部最近的文档

50
00:03:00,447 --> 00:03:03,150
并且用户通过一次轻触就能打开
全部文档

51
00:03:03,917 --> 00:03:05,452
它还允许用户

52
00:03:05,786 --> 00:03:07,921
将文档导入到任何应用中

53
00:03:08,121 --> 00:03:09,857
通过新添加的拖拽手势

54
00:03:12,993 --> 00:03:16,663
现在你一定想在你的应用中
包含全部这些很棒的功能

55
00:03:16,897 --> 00:03:18,365
（你的应用怎么样？）

56
00:03:18,432 --> 00:03:19,466
（开发者的请求）

57
00:03:19,533 --> 00:03:21,335
通过上次发布

58
00:03:21,502 --> 00:03:23,604
我们收到了你们提出的很多请求

59
00:03:24,371 --> 00:03:27,407
你们想要文件浏览统一的UI

60
00:03:28,408 --> 00:03:32,513
你们希望你们的应用可以从系统中的
其他应用中打开任意文件

61
00:03:34,915 --> 00:03:36,617
你们不想写太多的代码

62
00:03:36,850 --> 00:03:40,420
来采用已经
是系统一部分的云供应商

63
00:03:41,588 --> 00:03:44,625
并且你们想深度整合那些…

64
00:03:45,192 --> 00:03:47,995
在整个系统中整合自定义内容类型

65
00:03:48,996 --> 00:03:51,899
嗯 今天我们要来看一些新的API

66
00:03:52,933 --> 00:03:56,670
我稍后再谈我们对这些
请求的处理进度

67
00:03:58,205 --> 00:04:02,142
首先我想谈谈新的文档浏览器API

68
00:04:05,479 --> 00:04:06,313
今天…

69
00:04:06,380 --> 00:04:09,716
今年有一个新类
即UI文档浏览器视图控制器

70
00:04:09,917 --> 00:04:13,153
我知道这很拗口
所以从现在起我把它叫作浏览器VC

71
00:04:14,821 --> 00:04:17,156
跟这个配套的还有一个
新的XCode模板

72
00:04:17,224 --> 00:04:20,994
可以让你从零开始
创建一个基于文档的新应用

73
00:04:22,129 --> 00:04:23,197
此外

74
00:04:23,263 --> 00:04:26,633
UI文档选择器会获得
浏览器VC的一些功能

75
00:04:29,036 --> 00:04:31,805
那么现在让我们先谈谈浏览器VC

76
00:04:32,339 --> 00:04:36,443
视图控制器会向应用提供
与文件…应用相同的功能

77
00:04:36,743 --> 00:04:40,581
事实上文件应用只是这个浏览器VC
之上的一个很薄的层

78
00:04:43,350 --> 00:04:46,420
通过这个视图控制器
你就不用再写

79
00:04:46,486 --> 00:04:49,289
更多的代码来整合任意支持

80
00:04:49,656 --> 00:04:51,024
文件共享的云存储供应商了

81
00:04:53,961 --> 00:04:56,163
同时它会支持外观自定义

82
00:04:56,396 --> 00:04:57,831
让它看起来跟你的应用相匹配

83
00:04:59,266 --> 00:05:01,235
通过这个视图控制器

84
00:05:01,301 --> 00:05:05,172
你的应用可以获得我们之前
看到过的最近列表弹出框

85
00:05:08,141 --> 00:05:10,677
在这个浏览器VC中
Spotlight扮演了一个关键角色

86
00:05:11,478 --> 00:05:12,913
通过这个视图控制器

87
00:05:13,447 --> 00:05:17,184
你文档中的全部元数据
将在Spotlight中被自动索引

88
00:05:17,251 --> 00:05:19,219
如果你需要进一步整合

89
00:05:19,286 --> 00:05:22,689
你必须注册你自己的CSSearchableItem

90
00:05:23,323 --> 00:05:25,993
当前系统中有两个CSSearchableItem

91
00:05:26,326 --> 00:05:27,895
要复制它们

92
00:05:28,128 --> 00:05:32,332
浏览器VC必须使用这个
CSSearchableItem的contentURL

93
00:05:32,666 --> 00:05:34,201
所以你的设置必须适当

94
00:05:34,434 --> 00:05:36,637
如果你想了解更多关于
Core Spotlight的相关信息

95
00:05:36,703 --> 00:05:38,839
今天下午4:10有一场演讲

96
00:05:43,443 --> 00:05:46,079
在Apple公司
我们非常注重用户的隐私权

97
00:05:46,580 --> 00:05:49,449
为此 我们在创建浏览器VC时

98
00:05:49,950 --> 00:05:52,920
从始至终都考虑到了隐私权

99
00:05:53,754 --> 00:05:55,522
当用户安装你的应用后

100
00:05:55,589 --> 00:05:57,791
你只能看到应用容器内的

101
00:05:57,858 --> 00:05:59,059
全部文档

102
00:06:00,494 --> 00:06:02,963
你可以导入和创建新文档

103
00:06:03,197 --> 00:06:07,067
但只能在默认的安全位置
你不能挑挑拣拣

104
00:06:08,435 --> 00:06:13,240
那么如何在系统其它地方
获取文件呢？

105
00:06:13,874 --> 00:06:15,909
嗯 你可以通过用户交互实现

106
00:06:16,577 --> 00:06:18,879
浏览器VC在不同的进程中运行

107
00:06:19,246 --> 00:06:21,215
一旦用户轻触某个文档

108
00:06:21,849 --> 00:06:25,519
浏览器VC将会把该文档的访问权
转交给你的应用

109
00:06:27,588 --> 00:06:30,924
现在让我们看一眼UI文档
选择器视图控制器

110
00:06:30,991 --> 00:06:34,661
正如我刚才所说的
我们会获得浏览器VC的某些功能

111
00:06:35,195 --> 00:06:37,564
比如浏览器视图和最近列表视图

112
00:06:38,932 --> 00:06:41,201
同时 它将支持同时打开和导入

113
00:06:41,268 --> 00:06:43,003
多个文档

114
00:06:43,403 --> 00:06:44,671
如果你想支持它

115
00:06:44,738 --> 00:06:47,341
你需要将
allowsMultipleSelection设为真

116
00:06:48,008 --> 00:06:52,012
为了支持多个文档
我们不支持带有

117
00:06:52,679 --> 00:06:55,082
PickDocumentAtURL委托方法的
文档…选择器

118
00:06:55,449 --> 00:06:59,052
而是倾向于同时支持
多个URL的委托方法

119
00:07:01,154 --> 00:07:01,989
同时今年

120
00:07:02,055 --> 00:07:04,691
我们不支持UI文档菜单视图控制器

121
00:07:04,758 --> 00:07:07,227
而支持UI文档浏览器视图控制器

122
00:07:09,796 --> 00:07:10,631
现在

123
00:07:11,164 --> 00:07:13,400
我们了解了浏览器API的大概内容

124
00:07:13,800 --> 00:07:15,536
让我们来看看如何
在你的应用中使用

125
00:07:15,702 --> 00:07:18,405
这个UI文档浏览器视图控制器

126
00:07:19,773 --> 00:07:20,874
那么首先来看最重要的

127
00:07:21,475 --> 00:07:23,443
你需要配置Info.plist

128
00:07:24,011 --> 00:07:28,115
在这里 你需要将UI支持文档
浏览器的键值设为是

129
00:07:28,882 --> 00:07:30,050
这将告诉系统

130
00:07:30,117 --> 00:07:33,053
你的应用是一个基于
UI文档浏览器的应用

131
00:07:34,254 --> 00:07:35,989
然后你需要声明

132
00:07:36,056 --> 00:07:38,392
你的应用所支持的内容类型

133
00:07:38,792 --> 00:07:40,994
这很重要 因为浏览器VC

134
00:07:41,195 --> 00:07:42,696
将通过这个内容类型

135
00:07:42,863 --> 00:07:45,732
来了解要在你的应用中
显示哪些文件

136
00:07:47,734 --> 00:07:51,071
你必须要了解的一点是
UI文档浏览器视图控制器

137
00:07:51,138 --> 00:07:53,540
必须是你应用中的根视图控制器

138
00:07:53,874 --> 00:07:55,108
否则就不起作用

139
00:07:57,277 --> 00:07:58,245
正如我之前所说的

140
00:07:58,312 --> 00:08:00,681
浏览器VC支持外观自定义

141
00:08:01,248 --> 00:08:02,916
默认是这个样子

142
00:08:03,116 --> 00:08:05,285
白色背景和蓝色浅色调

143
00:08:06,119 --> 00:08:07,387
它有两个属性

144
00:08:07,554 --> 00:08:10,057
你可以用来进一步自定义

145
00:08:10,457 --> 00:08:13,126
浏览器界面样式有三种模式：

146
00:08:13,393 --> 00:08:16,196
暗色、白色和亮色以及浅色调

147
00:08:17,064 --> 00:08:20,133
如果你使用暗色样式
和橘色浅色调

148
00:08:20,200 --> 00:08:21,635
你的应用看起来就是这样的：

149
00:08:24,438 --> 00:08:26,840
那么现在
我们配置了浏览器VC

150
00:08:27,207 --> 00:08:30,477
你的应用要支持的第一个东西
是支持文档的打开

151
00:08:31,678 --> 00:08:33,480
那么让我们看看要如何实现

152
00:08:34,448 --> 00:08:35,315
首先

153
00:08:35,381 --> 00:08:37,451
用户要轻触其中一个文档

154
00:08:38,619 --> 00:08:39,986
在这里 浏览器VC

155
00:08:40,320 --> 00:08:42,956
将获取并下载文档信息

156
00:08:43,023 --> 00:08:44,525
一旦文档准备好了

157
00:08:45,192 --> 00:08:47,661
它将会把访问权交给你的应用

158
00:08:48,195 --> 00:08:50,030
并调用didPickDelegate方法

159
00:08:50,631 --> 00:08:53,800
在这里 你只需要加载并显示文档

160
00:08:56,103 --> 00:08:58,205
当打开文档时 浏览器VC

161
00:08:58,372 --> 00:09:01,642
会向你的应用提供该URL的
持久访问权

162
00:09:02,976 --> 00:09:06,880
现在把它存起来 要想还原它的话
只存URL是远远不够的

163
00:09:06,947 --> 00:09:10,217
你需要存储与此URL
相关联的书签数据

164
00:09:10,617 --> 00:09:15,088
因为这是追踪URL使用权的信息

165
00:09:17,157 --> 00:09:19,459
文档打开的代码是这样的

166
00:09:19,526 --> 00:09:20,794
你只需要实施

167
00:09:20,861 --> 00:09:23,063
documentBrowser、
didPickDocumentURL

168
00:09:23,931 --> 00:09:26,266
并显示视图控制器即可

169
00:09:28,569 --> 00:09:29,970
跟UI文档选择器类似

170
00:09:30,037 --> 00:09:33,273
浏览器VC支持同时打开多个文档

171
00:09:33,841 --> 00:09:35,709
如果你希望你的应用支持这个功能

172
00:09:35,776 --> 00:09:38,512
你需要
将allowsPickingMultipleItems设为真

173
00:09:41,615 --> 00:09:44,852
现在你的应用可以打开
系统中的任意文件了

174
00:09:45,485 --> 00:09:48,088
下一步是能创建新文档

175
00:09:48,422 --> 00:09:51,091
你可以在两个地方创建新文档

176
00:09:51,592 --> 00:09:53,260
第一个地方是最近列表视图

177
00:09:53,527 --> 00:09:57,097
如果用户轻触这里的创建按钮
将会创建一个新文档

178
00:09:57,164 --> 00:10:00,501
在你应用的默认安全位置

179
00:10:01,335 --> 00:10:03,637
如果用户在浏览视图中
轻触创建按钮

180
00:10:03,704 --> 00:10:05,138
将会创建一个新文档

181
00:10:05,205 --> 00:10:07,307
在浏览视图的当前位置

182
00:10:08,141 --> 00:10:10,010
现在让我们看看流程

183
00:10:10,244 --> 00:10:12,679
一旦用户轻触其中一个创建按钮

184
00:10:14,181 --> 00:10:16,216
你的应用将会收到
一个导入处理器

185
00:10:16,283 --> 00:10:19,887
现在 如果你已经有了源URL
你可以调用导入处理器

186
00:10:20,487 --> 00:10:21,355
如果你没有

187
00:10:21,622 --> 00:10:23,824
如果你的应用需要
显示模板选择器

188
00:10:23,891 --> 00:10:26,493
以便了解要选择哪个源URL

189
00:10:27,127 --> 00:10:28,028
现在正是时候

190
00:10:28,328 --> 00:10:31,532
你呈现一个模板选择器
并调用导入处理器

191
00:10:31,598 --> 00:10:35,169
导入处理器将会把那个文件
移动到共享文件中

192
00:10:35,602 --> 00:10:37,437
一旦文件处于共享文件中

193
00:10:37,905 --> 00:10:40,474
它将通过一个Succeed委托方法
把你的应用调回来

194
00:10:41,308 --> 00:10:42,876
在这里 对于文档打开来说

195
00:10:43,177 --> 00:10:45,412
你只需要加载并呈现文档

196
00:10:47,214 --> 00:10:50,484
现在导入操作可能由于多种原因
导致失败

197
00:10:50,817 --> 00:10:51,818
如果你失败了

198
00:10:52,085 --> 00:10:54,988
你需要处理报错
并向用户呈现一些UI

199
00:10:55,789 --> 00:10:58,892
现在让我们来看看如何用代码实现

200
00:10:59,459 --> 00:11:00,761
首先你需要实施

201
00:11:00,827 --> 00:11:03,230
documentBrowser
didRequestDocumentCreation

202
00:11:03,964 --> 00:11:05,332
在这里 正如我之前所说的

203
00:11:05,399 --> 00:11:07,668
你可以随意呈现一个模板选择器

204
00:11:08,001 --> 00:11:10,437
在本例中 所呈现的模板选择器

205
00:11:10,704 --> 00:11:16,009
将通过用户为该模板所选择的URL
将我们调回来

206
00:11:16,376 --> 00:11:19,413
并会告诉我们
用户是否取消了文档创建

207
00:11:20,881 --> 00:11:25,118
一旦我们获得URL 我们只需通过
一个模型调用导入处理器

208
00:11:25,385 --> 00:11:27,855
有两种不同模式：复制和移动

209
00:11:28,655 --> 00:11:30,757
如果用户取消了文档创建

210
00:11:30,824 --> 00:11:34,962
我们仍需要调用导入处理器
但URL为无 模式为空

211
00:11:35,562 --> 00:11:36,430
这非常重要

212
00:11:36,797 --> 00:11:40,501
这将会告诉浏览器VC
创建操作已经结束

213
00:11:43,670 --> 00:11:45,405
一旦文档被完全导入

214
00:11:45,472 --> 00:11:48,275
将会调用documentBrowser
didImportDocumentAtsourceURL

215
00:11:48,542 --> 00:11:50,310
toDestinationURL

216
00:11:50,644 --> 00:11:54,515
在这里 你只需要加载
并呈现文档的UI

217
00:11:55,048 --> 00:11:57,584
正如我所说过的
导入操作可能会失败

218
00:11:57,985 --> 00:11:59,119
如果失败了

219
00:11:59,686 --> 00:12:03,423
将调用DocumentBrowser
failedToImportDocumentURL

220
00:12:03,724 --> 00:12:06,727
在这里 你需要处理报错
并给用户呈现一些UI

221
00:12:09,162 --> 00:12:13,634
现在我们正在同时处理由不同进程

222
00:12:14,001 --> 00:12:16,970
不同应用和不同设备操作的文档

223
00:12:18,338 --> 00:12:22,543
为此 使用NS文件协调
和NS文件呈现器非常重要

224
00:12:22,609 --> 00:12:26,413
以避免这些进程之间的一些风险状况

225
00:12:27,548 --> 00:12:31,285
现在因为文档是在应用容器外部

226
00:12:31,718 --> 00:12:34,121
浏览器VC使用的是
安全范围内的URL

227
00:12:34,555 --> 00:12:37,491
这就意味着你需要
开始和停止使用该URL

228
00:12:37,958 --> 00:12:41,161
以便有权读写URL

229
00:12:42,129 --> 00:12:44,198
我们强烈推荐你们使用UI文档

230
00:12:44,698 --> 00:12:45,532
通过UI文档

231
00:12:45,999 --> 00:12:48,302
你可以获得文件协调、文件呈现器

232
00:12:48,502 --> 00:12:50,637
和安全范围内的URL支持
都是免费的

233
00:12:51,004 --> 00:12:52,940
还有其它功能 比如自动保存

234
00:12:54,107 --> 00:12:56,210
如果你想了解
关于UI文档的更多信息

235
00:12:56,577 --> 00:12:59,313
请观看WWDC 2015的

236
00:12:59,379 --> 00:13:01,415
“创建基于文档的应用”演讲

237
00:13:02,583 --> 00:13:05,018
现在让我们欢迎我的同事拉斐尔上台

238
00:13:05,085 --> 00:13:06,653
为大家演示如何在你的应用中使用

239
00:13:06,720 --> 00:13:09,156
UI文档浏览器视图控制器

240
00:13:09,623 --> 00:13:10,457
拉斐尔

241
00:13:13,627 --> 00:13:14,461
谢谢 保

242
00:13:15,262 --> 00:13:16,430
大家早上好

243
00:13:17,231 --> 00:13:18,665
那么现在你们已经了解了

244
00:13:18,732 --> 00:13:21,468
新的UI文档浏览器视图
控制器的API了

245
00:13:21,535 --> 00:13:24,638
我要给大家做一个简短的演示

246
00:13:24,705 --> 00:13:27,474
在iOS 11中创建一款基于
文档的了不起的应用是如何简单

247
00:13:29,409 --> 00:13:31,812
我们要创建一个很简单的粒子编辑器

248
00:13:31,879 --> 00:13:35,215
左侧是粒子系统 右侧是检验

249
00:13:35,282 --> 00:13:38,118
允许你自定义粒子系统的一些属性

250
00:13:38,952 --> 00:13:41,922
现在每个粒子系统都属于一个文档

251
00:13:41,989 --> 00:13:44,892
因此使用UI文档浏览器视图控制器

252
00:13:44,958 --> 00:13:46,927
是我们这款应用的完美选择

253
00:13:47,694 --> 00:13:49,530
那么现在让我们切换到XCode

254
00:13:59,473 --> 00:14:02,943
Xcode 11为基于文档的应用
准备了新模板

255
00:14:03,243 --> 00:14:04,144
让我们来试试

256
00:14:09,483 --> 00:14:12,519
让我们把它命名为粒子
然后创建新应用

257
00:14:15,122 --> 00:14:16,223
现在一旦实例化

258
00:14:16,290 --> 00:14:18,392
这个模板上就拥有了你从零开始创建

259
00:14:18,458 --> 00:14:21,028
基于文档的应用的一切东西

260
00:14:21,662 --> 00:14:23,997
首先 我们目标的Info.plist

261
00:14:24,064 --> 00:14:26,700
已经按保之前提到的方式进行了设置

262
00:14:26,767 --> 00:14:27,701
键也对

263
00:14:28,168 --> 00:14:31,605
接下来 我们有一个
DocumentBrowserViewController子类

264
00:14:31,905 --> 00:14:35,876
拥有稍后进行自定义的全部代码

265
00:14:37,244 --> 00:14:39,546
它还有一个ViewController子类

266
00:14:39,613 --> 00:14:41,048
文档视图控制器

267
00:14:41,114 --> 00:14:44,184
将会控制文件内容的呈现

268
00:14:46,486 --> 00:14:49,089
下一步 正如保刚才提到过的

269
00:14:49,156 --> 00:14:51,291
我们有UIDocuments的子类

270
00:14:51,358 --> 00:14:54,228
在运行时 作为文档的模型

271
00:14:55,495 --> 00:14:58,165
最后这点也很重要
设置storyBoard

272
00:14:58,232 --> 00:15:02,369
将文档浏览器视图控制器
作为已设置好的根视图控制器

273
00:15:02,903 --> 00:15:05,806
并且文档视图控制器已准备好实例化

274
00:15:05,873 --> 00:15:08,575
当我们创建新文件或打开现有文件时

275
00:15:09,443 --> 00:15:11,078
让我们看一眼我们得到了什么

276
00:15:11,144 --> 00:15:13,780
通过在模拟器中启动这个模板

277
00:15:24,658 --> 00:15:27,194
现在 一旦开始
我们会看到新的最近列表视图

278
00:15:27,261 --> 00:15:30,597
有你之前可能创建的最近的文档

279
00:15:31,031 --> 00:15:34,535
当然 我们并没有创建过任何文件
所以让我们切回到浏览视图

280
00:15:37,204 --> 00:15:41,341
我们看到侧边栏左侧是云存储供应商

281
00:15:41,408 --> 00:15:43,577
就在新增加的我的iPad上的存储旁边

282
00:15:44,211 --> 00:15:47,281
我们还看到偏好和我们的标签

283
00:15:47,748 --> 00:15:50,551
被同步到了你的全部设备上

284
00:15:51,285 --> 00:15:54,087
在屏幕中央 我们可以看到一个
大的创建文档按钮

285
00:15:54,154 --> 00:15:56,490
允许你创建新文档

286
00:15:56,557 --> 00:15:57,424
那么让我们点击它

287
00:15:58,759 --> 00:16:01,361
嗯 什么也没发生 这在预料之中

288
00:16:01,428 --> 00:16:04,765
这是因为我们还没有通知
UIDocumentBrowserViewController

289
00:16:04,831 --> 00:16:07,668
在应用中创建新文件的意思

290
00:16:08,068 --> 00:16:09,169
那么让我们来修复一下

291
00:16:10,637 --> 00:16:14,341
因此 我们要切回UIDocument
BrowserViewController子类

292
00:16:15,242 --> 00:16:16,710
正如保之前所提到过的

293
00:16:16,777 --> 00:16:20,514
当用户轻触创建文档按钮时
我们将回调

294
00:16:20,581 --> 00:16:23,483
DocumentBrowser
ViewControllerDelegate函数

295
00:16:24,218 --> 00:16:26,787
didRequestDocumentCreation
WithHandler

296
00:16:27,821 --> 00:16:32,159
现在我们要做的是将新创建

297
00:16:32,226 --> 00:16:35,495
文件的URL传给
DocumentBrowserViewController

298
00:16:36,830 --> 00:16:41,935
现在 在我们的例子中 让我向目标中
添加一个新的粒子文件

299
00:16:43,871 --> 00:16:47,541
确保将其添加到我们的目标中并结束

300
00:16:51,345 --> 00:16:56,517
现在当运行时 我们只需要开始
并获取此添加文档的URL

301
00:16:56,717 --> 00:16:58,452
通过我们的NS mainBundle

302
00:16:59,253 --> 00:17:00,654
一旦我们获取URL

303
00:17:00,721 --> 00:17:04,691
就把它传给我们从委托函数中
获得的importHandler

304
00:17:05,192 --> 00:17:07,961
然后复制URL

305
00:17:09,796 --> 00:17:12,833
现在UIDocument
BrowserViewController将获得这个URL

306
00:17:12,900 --> 00:17:15,736
并在后台替你执行所有的艰巨任务

307
00:17:16,036 --> 00:17:19,306
比如将文件移动到合适的位置
和处理URL

308
00:17:20,339 --> 00:17:22,643
一旦完成 它将会提供一个回调

309
00:17:22,709 --> 00:17:26,747
didImportDocumentAt sourceURL

310
00:17:27,614 --> 00:17:29,917
或failedToImportDocumentAtURL

311
00:17:30,651 --> 00:17:33,353
现在如果我们没有成功导入
新创建的文件

312
00:17:33,654 --> 00:17:35,389
因为我们想成为一名好的开发人员

313
00:17:35,455 --> 00:17:38,091
我们应该继续并实施恰当的报错处理

314
00:17:38,158 --> 00:17:40,661
比如把报错呈现给用户

315
00:17:41,695 --> 00:17:43,964
然而如果我们成功了 我们可以继续

316
00:17:44,031 --> 00:17:46,300
并呈现我们刚才所创建的文档

317
00:17:49,036 --> 00:17:52,072
现在假如用户选择了一个现有文件

318
00:17:52,139 --> 00:17:53,173
在那种情况下

319
00:17:53,240 --> 00:17:57,244
我们要回调
didPickDocumentURLs函数

320
00:17:58,378 --> 00:17:59,947
同样 我们只需要继续

321
00:18:00,214 --> 00:18:03,450
比如说我们得到的第一个文档URL

322
00:18:04,084 --> 00:18:04,918
然后呈现它

323
00:18:05,986 --> 00:18:07,788
现在 在应用中呈现文档

324
00:18:08,322 --> 00:18:11,725
意味着将其中一个
DocumentViewControllers实例化

325
00:18:12,526 --> 00:18:17,598
产生一个我们想要打开的
用文档URL初始化的文档

326
00:18:18,265 --> 00:18:21,435
然后我们只需要继续并呈现
documentViewController

327
00:18:21,902 --> 00:18:23,871
现在让我们再看看模拟器

328
00:18:31,879 --> 00:18:33,013
应用再次启动了

329
00:18:33,080 --> 00:18:36,517
我们在浏览视图中
并且我们可以轻触创建文档按钮

330
00:18:36,917 --> 00:18:38,886
然后就出现了
DocumentViewController

331
00:18:38,952 --> 00:18:41,355
其中包含我们刚创建的
文件的详细信息

332
00:18:42,022 --> 00:18:45,092
完成后 我们可以再次关闭
DocumentViewController

333
00:18:45,259 --> 00:18:48,829
返回到rootViewController
或DocumentBrowserViewController

334
00:18:51,098 --> 00:18:54,168
现在让我们切换到一个更高级的版本

335
00:18:54,234 --> 00:18:57,070
已经编好了全部代码

336
00:18:57,137 --> 00:19:00,741
左侧有粒子系统渲染器
右侧有编辑器

337
00:19:01,041 --> 00:19:02,009
这样我们就可以重点关注

338
00:19:02,075 --> 00:19:04,912
DocumentBrowserViewController
相关的代码

339
00:19:11,451 --> 00:19:13,954
在此之前
我要移除我们刚创建的应用

340
00:19:14,021 --> 00:19:16,690
避免其它冲突

341
00:19:25,365 --> 00:19:28,202
现在这仍然是一样的
仍然是同一个项目

342
00:19:28,268 --> 00:19:32,472
它基于我们一开始实例化的模板

343
00:19:33,040 --> 00:19:35,075
让我介绍一下我们给粒子应用

344
00:19:35,142 --> 00:19:38,111
Info.plist做的一些附件

345
00:19:38,779 --> 00:19:44,117
首先 SupportDocumentBrowser
的键值仍为是

346
00:19:44,318 --> 00:19:46,019
就像保刚才解释过的一样

347
00:19:47,120 --> 00:19:50,357
但更多的是 在已导出的UTI部分

348
00:19:50,858 --> 00:19:54,428
我们正在为粒子文件
创建一个新的UTI类型

349
00:19:55,696 --> 00:19:57,831
我们要赋予它一个
DescriptionParticles

350
00:19:58,365 --> 00:19:59,967
我们给它一个Identifier

351
00:20:00,300 --> 00:20:04,872
并让它遵守UTI类型的公共数据
和公共内容

352
00:20:06,173 --> 00:20:10,077
那意味着我们的粒子文件
是一连串的数据

353
00:20:10,143 --> 00:20:12,946
并且拥有文档文件的语义

354
00:20:14,481 --> 00:20:17,184
现在
在Additional exported UTI属性中

355
00:20:18,051 --> 00:20:20,654
我们定义了我们的文件应该有…

356
00:20:21,054 --> 00:20:24,024
哇哦！抱歉

357
00:20:26,860 --> 00:20:29,096
…应该有粒子扩展

358
00:20:29,162 --> 00:20:33,367
意思是系统中任何有
.particles扩展名的文件

359
00:20:33,800 --> 00:20:37,271
都将被识别为
新创建的UTI类型的文件

360
00:20:39,139 --> 00:20:40,941
那么现在已经做好了UTI类型

361
00:20:41,008 --> 00:20:44,311
我们可以继续 告诉应用说我们
实际上已经能支持了

362
00:20:44,678 --> 00:20:48,715
那么在文档类型中 我们需要再次
提到我们的粒子文件格式

363
00:20:49,082 --> 00:20:52,019
我们识别了标识符

364
00:20:52,319 --> 00:20:54,788
在附加文档类型属性中

365
00:20:55,322 --> 00:21:01,328
我们定义CFBundleTypeRole为编辑器
而LSHandlerRank为所有者

366
00:21:01,929 --> 00:21:04,865
如果你想了解更多信息
请参看此文档

367
00:21:07,134 --> 00:21:09,369
那么现在已经设置好了UTI类型

368
00:21:09,970 --> 00:21:13,040
意思是DocumentBrowserView
Controller将确保

369
00:21:13,106 --> 00:21:16,877
只允许用户选择新文件类型的文档

370
00:21:17,711 --> 00:21:21,682
它还能确保当你在DocumentBrowser
ViewController中搜索时

371
00:21:21,982 --> 00:21:25,219
你只能看到匹配
此UI类型的搜索结果

372
00:21:26,386 --> 00:21:27,588
最后这点也很重要

373
00:21:27,654 --> 00:21:30,424
在任何UI文档交互控制

374
00:21:30,490 --> 00:21:33,060
和不同的粒子文件应用中

375
00:21:33,227 --> 00:21:35,796
你会看到在我们的应用中
打开文件的操作

376
00:21:38,098 --> 00:21:40,467
那么现在让我们看看实际的文档

377
00:21:40,534 --> 00:21:42,569
切换到UIDocument子类

378
00:21:43,370 --> 00:21:45,239
现在UI文档很强大

379
00:21:45,305 --> 00:21:47,608
我们强烈鼓励大家使用它

380
00:21:47,908 --> 00:21:50,711
正如保刚才所说的
它拥有许多很棒的功能

381
00:21:50,777 --> 00:21:52,112
比如自动保存

382
00:21:52,179 --> 00:21:56,617
文件协调、NS文件呈现
版本控制等等…

383
00:21:57,251 --> 00:22:00,687
因此 UIDocument和
UIDocumentBrowserViewController

384
00:22:00,754 --> 00:22:02,389
从字面上看实际上是互生的

385
00:22:02,589 --> 00:22:04,558
那么让我们看看我们正在做什么

386
00:22:06,760 --> 00:22:10,564
现在文档显示出文档正处于运行中

387
00:22:10,631 --> 00:22:13,967
那么很明显
因为我们正在谈粒子系统

388
00:22:14,201 --> 00:22:17,070
它应该有一个
对SCNParticleSystem的引用

389
00:22:19,706 --> 00:22:21,308
接下来我们要

390
00:22:21,375 --> 00:22:24,311
保存和加载文件

391
00:22:24,678 --> 00:22:28,515
因此 我们需要为类型覆盖函数内容

392
00:22:29,316 --> 00:22:30,751
并加载内容

393
00:22:31,652 --> 00:22:33,420
现在我们实际上所需要做的就是

394
00:22:33,487 --> 00:22:37,024
把现有的粒子系统归档或不归档

395
00:22:37,558 --> 00:22:39,893
这能起作用是因为
我们的SCNParticleSystem

396
00:22:39,960 --> 00:22:41,795
已经遵守NS编码了

397
00:22:42,429 --> 00:22:44,031
所以我们实际上不需要做很多

398
00:22:44,097 --> 00:22:46,600
我们使用KeyedArchiver归档数据

399
00:22:47,201 --> 00:22:51,839
或使用NS KeyedUnarchiver
取出现有数据

400
00:22:53,841 --> 00:22:55,943
这就是你需要对文档做的全部操作

401
00:22:56,009 --> 00:22:58,312
让我们看看DocumentViewController

402
00:22:59,046 --> 00:23:03,383
这是控制呈现文档内容的

403
00:23:03,851 --> 00:23:06,653
那么很明显 在我们呈现
DocumentViewController之前

404
00:23:06,720 --> 00:23:09,223
我们应该把它传给文档的引用

405
00:23:14,094 --> 00:23:17,331
在本例中 设置文档函数是不同步的

406
00:23:17,397 --> 00:23:21,068
这是因为加载文档应该是不同步的

407
00:23:21,134 --> 00:23:22,803
因为包含文件I/O

408
00:23:23,170 --> 00:23:26,406
我们要从磁盘中读取
你不应该在主线程上读取

409
00:23:26,773 --> 00:23:29,176
那么让我们看看该如何实施

410
00:23:32,212 --> 00:23:34,681
首先我们要保持对文档的引用

411
00:23:35,482 --> 00:23:37,818
然后我们继续并加载ViewController

412
00:23:38,118 --> 00:23:41,121
然后我们在文档上调用Open函数

413
00:23:41,722 --> 00:23:43,924
现在应该完成了后台的全部工作

414
00:23:43,991 --> 00:23:46,126
一旦回来 它将会给我们一个回调

415
00:23:48,462 --> 00:23:51,398
现在如果在文档加载过程中
出现任何错误

416
00:23:51,665 --> 00:23:53,634
我们就会调用handleError

417
00:23:53,700 --> 00:23:56,737
在UIDocument子类中
允许用户交互

418
00:23:57,137 --> 00:24:00,841
因为我们想成为一名了不起的开发人员
我们必须得实施这个函数

419
00:24:01,341 --> 00:24:04,211
如果成功了
我们可以继续并获取文档

420
00:24:04,278 --> 00:24:07,948
并把它传给particleViewController
和editorViewController

421
00:24:08,916 --> 00:24:11,952
现在DocumentViewController实际上
只是一个容器视图控制器

422
00:24:12,019 --> 00:24:14,855
左侧是一个粒子系统
右侧是编辑器

423
00:24:15,923 --> 00:24:18,792
现在无论是什么情况
我们都必须调用completionHandler

424
00:24:19,393 --> 00:24:21,929
用于表明我们已经
完成了对文档的设置

425
00:24:24,131 --> 00:24:25,599
这就是关于文档的打开

426
00:24:25,666 --> 00:24:29,469
但是当然了 我们还想在某一时刻
遣散DocumentViewController

427
00:24:32,005 --> 00:24:32,840
同样

428
00:24:32,906 --> 00:24:34,541
这次我们不调用Open函数了

429
00:24:34,608 --> 00:24:37,177
很明显我们要调用Close函数

430
00:24:38,045 --> 00:24:41,782
这又是不同步的 因为我们正在
保存文档 如果需要的话

431
00:24:42,950 --> 00:24:46,386
在completionHandler中 我们只需要
遣散DocumentViewController

432
00:24:47,387 --> 00:24:50,123
DocumentViewController
几乎已经完成使命了

433
00:24:50,190 --> 00:24:53,861
因此我们可以继续并再看一眼
DocumentBrowserViewController

434
00:24:54,795 --> 00:24:58,232
这是控制呈现文档视图控制器的

435
00:24:58,298 --> 00:25:01,802
无论是创建新文件或是打开现有文件

436
00:25:03,470 --> 00:25:04,838
让我们再看一眼

437
00:25:06,874 --> 00:25:08,308
那么当我们创建新文件时

438
00:25:08,375 --> 00:25:11,311
我们得到一个对didRequestDocument
CreationWithHandler的回调

439
00:25:11,812 --> 00:25:14,047
我们从NS mainBundle中获取了URL

440
00:25:14,448 --> 00:25:17,551
并通过importHandler
和复制操作将其传回

441
00:25:18,585 --> 00:25:21,922
我们将得到一个对
didImportDocumentAtURL

442
00:25:21,989 --> 00:25:23,724
或failedToImportDocumentAtURL
的回调

443
00:25:25,325 --> 00:25:27,794
如果成功 我们将继续并呈现文档

444
00:25:27,861 --> 00:25:31,932
就跟我们之前打开一个现有文件一样

445
00:25:33,600 --> 00:25:35,002
现在当我们想呈现一个文档时

446
00:25:35,068 --> 00:25:38,238
我们从storyBoard
把DocumentViewController实例化

447
00:25:38,305 --> 00:25:42,142
并通过我们刚完成的带有对新创建的
文档实例

448
00:25:42,309 --> 00:25:46,146
引用的函数setDocument传递文档

449
00:25:47,080 --> 00:25:50,717
完成后 我们只需要继续并呈现
DocumentViewController

450
00:25:50,984 --> 00:25:53,020
让我们在模拟器中看一下

451
00:26:05,365 --> 00:26:06,533
（最近列表）

452
00:26:06,600 --> 00:26:10,237
切回浏览视图并点击创建文档按钮

453
00:26:10,904 --> 00:26:12,105
创建了一个新文件

454
00:26:12,506 --> 00:26:17,377
好了 一个漂亮的粒子应用
右侧有检验器

455
00:26:17,978 --> 00:26:22,216
我们可以稍微修改一下值
尺寸和颜色

456
00:26:23,116 --> 00:26:24,218
完成后

457
00:26:24,284 --> 00:26:27,221
我们只需要通过按完成按钮
再次关闭文档

458
00:26:29,523 --> 00:26:33,560
太棒了 那么创建文档和打开文档
立竿见影

459
00:26:33,961 --> 00:26:35,996
但还有一点我并不是特别喜欢

460
00:26:36,063 --> 00:26:40,567
就是DocumentBrowserViewController
是白色的

461
00:26:40,834 --> 00:26:44,037
而ParticleViewController
却是很暗的颜色

462
00:26:44,371 --> 00:26:45,472
那么让我们来修改一下

463
00:26:46,173 --> 00:26:47,341
正如保刚才所提到的

464
00:26:47,407 --> 00:26:50,811
有三种浏览器用户界面样式
供你选择

465
00:26:50,878 --> 00:26:53,881
首先 暗色、亮色和白色

466
00:26:54,348 --> 00:26:58,151
很明显暗色看起来很符合我们的情境

467
00:26:59,620 --> 00:27:03,023
因此让我们切回到
DocumentBrowserViewController子类

468
00:27:04,124 --> 00:27:07,060
现在子类的viewDidLoad方法

469
00:27:07,127 --> 00:27:09,730
是配置文档浏览器的最佳时刻

470
00:27:10,964 --> 00:27:13,133
在这种情况下 我们要做的是

471
00:27:15,068 --> 00:27:17,337
将browserUserInterfaceStyle
设置为暗色

472
00:27:18,172 --> 00:27:21,074
还可以修改
DocumentBrowserViewController

473
00:27:21,141 --> 00:27:23,477
视图的tintColor

474
00:27:23,644 --> 00:27:26,613
在本例中 使用橙黄色

475
00:27:26,680 --> 00:27:29,116
应该会很符合我们激情四溢的粒子

476
00:27:29,783 --> 00:27:30,617
让我们看一眼

477
00:27:39,326 --> 00:27:40,160
好了

478
00:27:40,360 --> 00:27:42,863
这是同一个
DocumentBrowserViewController

479
00:27:42,930 --> 00:27:44,264
只是色调较暗

480
00:27:44,331 --> 00:27:46,934
这比刚才那个看起来好多了

481
00:27:47,000 --> 00:27:50,137
当我们打开
DocumentViewController时

482
00:27:50,871 --> 00:27:54,074
现在即使是控制UI也更新了外观

483
00:27:55,008 --> 00:27:56,410
让我们创建一个新文件夹

484
00:27:59,279 --> 00:28:00,414
把它命名为火焰

485
00:28:04,818 --> 00:28:05,986
然后打开一个新文档

486
00:28:07,521 --> 00:28:09,289
现在两个视图控制器之间的过渡

487
00:28:09,356 --> 00:28:11,792
变得更流畅了 看起来也更棒了

488
00:28:12,860 --> 00:28:15,796
那么这就是第一个演示
要告诉大家的全部内容

489
00:28:16,730 --> 00:28:19,666
为了获得一个我们目前
所学习的内容的概览

490
00:28:19,733 --> 00:28:21,468
让我们把舞台交回给保

491
00:28:34,848 --> 00:28:37,684
让我们看一下我们在演示中
所看到的内容

492
00:28:38,952 --> 00:28:42,356
首先我们看到了
如何从Xcode模板中

493
00:28:42,422 --> 00:28:43,724
创建基于文档的新应用

494
00:28:44,291 --> 00:28:48,028
然后我们看到了如何创建新文档
以及如何打开文档

495
00:28:48,996 --> 00:28:53,100
最后我们看到了如何自定义
浏览器VC的外观

496
00:28:53,367 --> 00:28:55,469
使其看起来与应用的其它部分相匹配

497
00:28:57,371 --> 00:29:00,507
现在我们了解了
浏览器VC的基本功能

498
00:29:00,908 --> 00:29:03,610
让我们看看如何利用它获得更多功能

499
00:29:03,677 --> 00:29:06,613
并为用户提供一种了不起的体验

500
00:29:07,948 --> 00:29:11,351
在这部分中 我会谈到三个话题：

501
00:29:11,652 --> 00:29:15,956
open-in-place、如何在浏览器VC中
提供自定义动作

502
00:29:16,023 --> 00:29:18,692
以及如何创建很棒的打开体验

503
00:29:20,661 --> 00:29:22,696
那么首先让我们谈谈open-in-place

504
00:29:23,263 --> 00:29:26,066
open-in-place是与iOS 9
一起发布的一个很棒的功能

505
00:29:26,834 --> 00:29:30,404
它允许应用共享文件而无需复制

506
00:29:32,306 --> 00:29:33,440
同时正因为如此

507
00:29:33,507 --> 00:29:36,443
当你访问这些文档时需要谨慎

508
00:29:36,510 --> 00:29:39,213
因为其它应用可能已经访问过它们了

509
00:29:40,681 --> 00:29:43,183
现在浏览器VC也使用这个功能

510
00:29:43,250 --> 00:29:46,086
用于从最近列表弹出框中打开文件

511
00:29:46,720 --> 00:29:49,489
那么如果你在你的应用中
使用浏览器VC

512
00:29:49,556 --> 00:29:51,959
你真的需要利用一下
open-in-place功能

513
00:29:52,359 --> 00:29:54,895
如果你是从Xcode模板中开始的
那非常简单

514
00:29:54,962 --> 00:29:56,263
你什么也不需要做

515
00:29:56,330 --> 00:29:59,666
如果不是 那么你需要实施
支持open-in-place

516
00:30:00,033 --> 00:30:01,535
让我们看一下代码

517
00:30:01,902 --> 00:30:02,736
首先我们需要

518
00:30:02,803 --> 00:30:05,873
实施ApplicationOpenInputURL
委托方法

519
00:30:06,740 --> 00:30:10,377
在这里 第一件事就是查看
输入URL是否为文件URL

520
00:30:10,777 --> 00:30:14,815
如果是 我们可以从浏览器VC中调用
revealDocument方法

521
00:30:15,249 --> 00:30:18,085
这个方法将会在
最近列表视图中展示文档

522
00:30:18,151 --> 00:30:19,953
并且如果准备好了会进行回调

523
00:30:20,988 --> 00:30:24,758
现在我们可以加载并呈现文档了
就像我们在打开和创建文档时一样

524
00:30:25,092 --> 00:30:28,362
如果失败了 我们就需要处理报错
并向用户呈现一些UI

525
00:30:30,631 --> 00:30:34,735
现在让我们看看如何向浏览器VC中
添加自定义动作

526
00:30:35,602 --> 00:30:37,938
有三种方式添加自定义动作

527
00:30:38,105 --> 00:30:40,474
第一种是UI文档浏览器动作

528
00:30:40,941 --> 00:30:42,009
你可以添加动作

529
00:30:42,075 --> 00:30:43,677
当用户长按

530
00:30:43,744 --> 00:30:46,780
文档时和当用户进入选择模式时

531
00:30:48,081 --> 00:30:49,249
要创建动作

532
00:30:49,316 --> 00:30:51,685
你需要在处理器中提供

533
00:30:51,919 --> 00:30:55,455
localizedTitle和有效性

534
00:30:55,822 --> 00:30:58,659
有效性有两个值：菜单和导航栏

535
00:30:59,092 --> 00:31:02,729
菜单会使动作呈现 当用户长按时

536
00:31:03,163 --> 00:31:05,499
而导航栏会使动作呈现

537
00:31:05,566 --> 00:31:07,634
当用户进入选择模式时

538
00:31:08,635 --> 00:31:10,671
处理器会提供用户想要为该动作

539
00:31:10,871 --> 00:31:13,440
使用的URL数组

540
00:31:14,341 --> 00:31:18,078
现在与打开URL不同
这是你获取这些URL的唯一方法

541
00:31:18,145 --> 00:31:21,682
除非你的应用被毙掉

542
00:31:22,649 --> 00:31:25,919
现在我们有了动作
你需要设置所支持的内容类型

543
00:31:25,986 --> 00:31:30,190
浏览器VC会使用内容类型来了解
何时显示你的动作

544
00:31:30,924 --> 00:31:33,527
然后你需要设置支持多项

545
00:31:33,927 --> 00:31:37,130
来表明你是否可以同时支持多个项

546
00:31:37,531 --> 00:31:40,234
并且你只需要将你
刚创建的自定义行动

547
00:31:40,300 --> 00:31:42,669
设置到浏览器VC的
自定义动作数组中即可

548
00:31:44,471 --> 00:31:47,674
第二种动作类型是UI栏按钮项

549
00:31:48,342 --> 00:31:51,812
你可以在最近列表VC的导航栏中
添加这些动作

550
00:31:52,312 --> 00:31:55,415
并浏览…抱歉
最近列表视图和浏览器视图

551
00:31:55,616 --> 00:31:59,119
并且你可以将它们添加到
导航栏的后面或侧面

552
00:32:02,289 --> 00:32:04,558
第三种动作类型是

553
00:32:04,625 --> 00:32:07,060
UI活动视图控制器

554
00:32:08,128 --> 00:32:10,531
浏览器VC会显示这个视图控制器

555
00:32:10,597 --> 00:32:13,166
当用户实施共享动作时

556
00:32:14,635 --> 00:32:18,105
浏览器VC会让你控制
这个动作视图控制器

557
00:32:18,172 --> 00:32:19,406
在呈现它之前

558
00:32:19,740 --> 00:32:22,109
同时它会让你添加自定义行动

559
00:32:22,176 --> 00:32:24,478
当它正在创建这个
UI活动视图控制器时

560
00:32:25,379 --> 00:32:26,680
那么让我们来看一下代码

561
00:32:27,481 --> 00:32:30,117
如果你想添加附加的动作 你需要

562
00:32:30,184 --> 00:32:34,288
向documentURL委托方法实施
文档浏览器应用活动

563
00:32:35,355 --> 00:32:38,325
如果你想获取这个活动视图控制器

564
00:32:38,859 --> 00:32:43,830
你需要实施DocumentBrowser
willPresentactivityViewController

565
00:32:45,465 --> 00:32:47,134
这就是关于动作的全部内容

566
00:32:47,901 --> 00:32:50,470
现在因为你们已经了解了文件应用

567
00:32:50,637 --> 00:32:52,573
有一个很棒的打开过渡

568
00:32:52,739 --> 00:32:54,842
是从缩略图到全屏

569
00:32:56,109 --> 00:32:58,579
文件应用之所以能实现这个功能

570
00:32:58,779 --> 00:33:01,515
归功于新的UIDocumentBrowser
TransitionController

571
00:33:03,150 --> 00:33:07,120
这个类可以让你设置显示加载进度

572
00:33:07,354 --> 00:33:11,291
当你加载文档时 在缩略图顶部

573
00:33:11,592 --> 00:33:15,162
并且它还让你使用缩放过渡动画

574
00:33:15,362 --> 00:33:19,967
当你呈现文档视图控制器时

575
00:33:20,834 --> 00:33:22,669
那么现在让我们看一下工作流程

576
00:33:23,370 --> 00:33:27,641
首先你需要获取
用户刚刚选择的URL

577
00:33:28,509 --> 00:33:31,144
在这里 你要开始加载文档内容

578
00:33:31,512 --> 00:33:34,848
加载时你需要更新过渡控制器

579
00:33:36,316 --> 00:33:39,887
一旦文档加载完全
你只需要呈现文档

580
00:33:40,287 --> 00:33:44,758
并使用过渡控制器来驱动
呈现时的动画即可

581
00:33:46,460 --> 00:33:48,929
那么现在让我们看看是如何实现的

582
00:33:49,496 --> 00:33:53,300
首先一旦你获得用户所选择的URL

583
00:33:54,268 --> 00:33:55,869
你需要创建进度对象

584
00:33:55,936 --> 00:33:58,205
那会追踪文档的加载

585
00:33:59,039 --> 00:34:01,341
在这里 你还要创建过渡控制器

586
00:34:01,942 --> 00:34:05,312
那会追踪加载并驱动动画

587
00:34:05,546 --> 00:34:07,147
从缩略图到全屏

588
00:34:07,414 --> 00:34:10,617
现在你只需要将进度
设置到过渡控制器上

589
00:34:11,552 --> 00:34:13,286
在这里 我们已经准备加载文档了

590
00:34:13,719 --> 00:34:15,522
在本例中 loadDocument方法

591
00:34:15,688 --> 00:34:19,193
会加载文档同时会升级
我们之前创建的进度

592
00:34:19,560 --> 00:34:22,862
当文档加载完全后
它会回调我们

593
00:34:23,263 --> 00:34:25,666
在这里 我们只需要呈现
文档视图控制器

594
00:34:26,400 --> 00:34:29,136
现在如果我们停在这里
我们会从UIKit中获得动画效果

595
00:34:29,402 --> 00:34:30,904
是从底部开始的一个滑动

596
00:34:31,405 --> 00:34:33,706
但我们想要这个更好的缩放过渡

597
00:34:34,174 --> 00:34:36,877
为此 我们需要实施所呈现的

598
00:34:36,944 --> 00:34:38,411
视图控制器的过渡委托

599
00:34:39,612 --> 00:34:41,315
过渡委托需要实施

600
00:34:41,380 --> 00:34:44,051
UI视图控制器过渡委托协议

601
00:34:44,751 --> 00:34:47,454
在此协议中
你需要实施两个主方法：

602
00:34:47,754 --> 00:34:50,190
为所呈现的视图控制器
实施动画控制器

603
00:34:50,257 --> 00:34:52,893
以及为所遣散的视图控制器
实施动画控制器

604
00:34:53,193 --> 00:34:54,862
在这里 你只需要返回

605
00:34:54,928 --> 00:34:57,331
我们之前所创建的过渡控制器

606
00:34:58,532 --> 00:35:01,735
现在让我们把舞台交还给拉斐尔
让他给大家展示如何实施

607
00:35:01,802 --> 00:35:02,903
这些高级功能

608
00:35:03,203 --> 00:35:04,037
拉斐尔

609
00:35:06,874 --> 00:35:07,708
谢谢 保

610
00:35:08,742 --> 00:35:11,778
那么在第二个演示中
我想给大家展示三点

611
00:35:12,112 --> 00:35:16,416
第一是open-in-place
以及如何简便地

612
00:35:16,850 --> 00:35:20,220
在你的文档浏览器视图控制器
应用中采用它

613
00:35:20,888 --> 00:35:23,257
接下来我们要看看自定义动作

614
00:35:23,724 --> 00:35:26,927
我们会添加一个在长按菜单中
显示的新动作

615
00:35:26,994 --> 00:35:28,629
当你按住一个文档时

616
00:35:29,062 --> 00:35:31,098
最后这点也很重要
我们要实施

617
00:35:31,164 --> 00:35:34,601
一个自定义视图控制器过渡
来改善用户体验

618
00:35:34,668 --> 00:35:37,404
当我们打开现有文件或创建新文件时

619
00:35:37,471 --> 00:35:38,305
那么让我们

620
00:35:38,372 --> 00:35:40,140
跳回我们的项目中

621
00:35:48,749 --> 00:35:50,284
现在让我们谈谈open-in-place

622
00:35:52,219 --> 00:35:56,323
open-in-place是和iOS 9一起
引入的一个了不起的功能

623
00:35:56,390 --> 00:35:57,658
它可以让你直接操作

624
00:35:57,724 --> 00:36:00,260
用户所选择的文件而不是其副本

625
00:36:01,361 --> 00:36:03,564
现在采用open-in-place非常简单

626
00:36:03,630 --> 00:36:06,767
而且事实上 如果你用的是
基于文档的应用模板

627
00:36:07,034 --> 00:36:08,735
你简直什么也不需要做

628
00:36:09,636 --> 00:36:14,241
它的流程是当用户在你的应用外部
轻触文档时

629
00:36:14,775 --> 00:36:17,044
iOS会调用你应用的委托函数

630
00:36:17,544 --> 00:36:20,814
并打开URL及其选项
让我们具体看一下

631
00:36:26,486 --> 00:36:30,157
在这个函数中
我们首先要做的是确保

632
00:36:30,224 --> 00:36:33,260
我们从IOS中获取的URL
确实是一个文件URL

633
00:36:33,560 --> 00:36:35,963
如果不是 我们很可能要返回

634
00:36:36,029 --> 00:36:37,898
因为我们并不是处于
我们所期待的情境中

635
00:36:38,732 --> 00:36:42,870
一旦通过测试 我们会得到文档
浏览器视图控制器

636
00:36:43,070 --> 00:36:45,539
也就是应用的根视图控制器

637
00:36:45,939 --> 00:36:49,743
并且我们会将URL
传给revealDocument函数

638
00:36:51,445 --> 00:36:53,647
现在文档浏览器视图控制器会再次

639
00:36:53,714 --> 00:36:56,316
替你在后台实现全部艰巨的任务

640
00:36:56,750 --> 00:37:01,121
它会处理URL 如果需要就移除URL
完成后

641
00:37:01,655 --> 00:37:04,525
我们会得到一个回调
以及completionHandler

642
00:37:05,192 --> 00:37:08,262
现在再一次 如果我们得到报错
因为我们想成为一名好的开发人员

643
00:37:08,629 --> 00:37:10,697
我们需要适当地处理报错

644
00:37:10,764 --> 00:37:13,400
比如向用户显示警告视图

645
00:37:14,668 --> 00:37:19,373
如果一切都没问题
我们只需要继续并呈现文档

646
00:37:19,606 --> 00:37:21,942
为那个新的显示文档URL

647
00:37:23,177 --> 00:37:24,378
这几乎是你全部

648
00:37:24,444 --> 00:37:26,180
需要做的来支持open-in-place

649
00:37:26,246 --> 00:37:28,015
在你的基于文档的应用中

650
00:37:29,917 --> 00:37:32,085
现在让我们看一下自定义动作

651
00:37:33,220 --> 00:37:35,822
那么我们的粒子系统很漂亮 是吧？

652
00:37:35,889 --> 00:37:38,225
我们可能想与朋友们共享

653
00:37:38,825 --> 00:37:42,462
那么我要添加一个新动作
当你长按文档时执行

654
00:37:42,529 --> 00:37:46,967
将这个粒子系统导出为GIF文件
或GIF文件

655
00:37:48,001 --> 00:37:51,004
现在让我们再看一下
文档浏览器视图控制器

656
00:37:52,239 --> 00:37:56,009
viewDidLoad方法是配置
这些动作的最佳时刻

657
00:38:03,584 --> 00:38:07,154
因此我要实例化一个
新的UI文档浏览器行动

658
00:38:07,788 --> 00:38:12,426
我赋予它一个标识符 是整个应用内的
唯一标识符 一个localizedTitle

659
00:38:12,960 --> 00:38:15,529
并且将有效性设定为仅菜单

660
00:38:15,996 --> 00:38:18,899
那么这将会确保这个动作只能

661
00:38:19,166 --> 00:38:22,970
当你在文档浏览器视图控制器
网格内长按时执行

662
00:38:24,838 --> 00:38:28,242
我们还赋予它一个处理器 就是那个

663
00:38:28,308 --> 00:38:30,244
无论何时用户轻触动作时执行的那个

664
00:38:30,711 --> 00:38:35,482
在本例中 我们继续并在控制台上
记录信息

665
00:38:36,984 --> 00:38:41,221
接下来 我们将所支持的
行动内容类型定义为

666
00:38:41,288 --> 00:38:45,759
“com.example.particles”
仅为我们之前定义的UTI类型

667
00:38:46,326 --> 00:38:50,898
那么就可以确保只有我们的文件
可以在菜单中获得这个行动

668
00:38:51,999 --> 00:38:54,368
最后这点也很重要
我们所需要做的就是…

669
00:38:55,068 --> 00:38:58,338
定义文档浏览器视图
控制器的自定义行动

670
00:38:58,405 --> 00:39:01,241
使其数组中包含这个新创建的动作

671
00:39:02,342 --> 00:39:03,944
让我们在模拟器中试一下

672
00:39:11,118 --> 00:39:14,154
现在 在我们的现有文件中长按

673
00:39:14,655 --> 00:39:17,658
我们看到这里显示了一个新动作
导出为GIF

674
00:39:18,859 --> 00:39:21,094
一旦轻触那个
我们会看到在控制台中

675
00:39:21,361 --> 00:39:24,064
执行了该动作的处理程序

676
00:39:25,766 --> 00:39:26,800
非常简单

677
00:39:27,401 --> 00:39:30,671
现在让我们看我要展示给你们的

678
00:39:30,737 --> 00:39:34,041
第三个很酷的东西
就是自定义视图控制器过渡

679
00:39:34,942 --> 00:39:37,444
目前当我们呈现文档视图控制器时

680
00:39:37,511 --> 00:39:41,315
我们会得到一个
由UIKit提供的上滑动画

681
00:39:41,815 --> 00:39:45,586
这已经很酷了
但这并不是我们真正想要的方式

682
00:39:45,919 --> 00:39:48,322
相反 它应该是这样的

683
00:39:48,722 --> 00:39:50,757
用户轻触文档缩略图

684
00:39:50,958 --> 00:39:53,594
缩略图放大进入粒子系统

685
00:39:53,660 --> 00:39:55,996
位于文档视图控制器的左侧

686
00:39:56,563 --> 00:39:58,832
让我们看一下该如何实现

687
00:40:02,202 --> 00:40:05,506
因此 让我们切回
我们之前创建的呈现…

688
00:40:06,807 --> 00:40:09,109
文档函数

689
00:40:09,943 --> 00:40:12,779
现在 自定义视图控制器过渡的
工作方式是

690
00:40:13,080 --> 00:40:15,616
你将自己注册为要呈现的

691
00:40:15,682 --> 00:40:18,252
视图控制器过渡委托

692
00:40:19,052 --> 00:40:23,924
在呈现之前 UIKit会调用我们
并请求过渡控制器

693
00:40:24,658 --> 00:40:26,527
我们就返回过渡控制器

694
00:40:26,727 --> 00:40:29,596
然后那个对象就会控制驱动动画

695
00:40:29,663 --> 00:40:32,065
将视图控制器A改为视图控制器B

696
00:40:32,966 --> 00:40:36,637
在本例中 视图控制器A就是
文档浏览器视图控制器

697
00:40:37,070 --> 00:40:39,406
视图控制器B就是文档视图控制器

698
00:40:40,607 --> 00:40:43,710
保刚才提到过
文档浏览器视图控制器

699
00:40:43,777 --> 00:40:46,613
已经提供了这个过渡控制器

700
00:40:47,014 --> 00:40:48,715
我们只需要保持引用

701
00:40:48,982 --> 00:40:51,885
并将其回传给
UIKit要调用的函数即可

702
00:40:57,291 --> 00:41:00,894
那么首先我们将自己注册为

703
00:41:00,961 --> 00:41:03,897
要呈现的文档视图
控制器的过渡委托

704
00:41:07,134 --> 00:41:10,404
接下来我们要获取新的过渡控制器

705
00:41:10,470 --> 00:41:14,041
通过给文档URL调用过渡控制器

706
00:41:14,208 --> 00:41:16,310
在我们的UI文档浏览器
视图控制器上

707
00:41:17,277 --> 00:41:20,814
现在这个对象并不需要很多配置

708
00:41:21,048 --> 00:41:23,417
它真正需要的唯一一个东西
就是目标视图

709
00:41:24,184 --> 00:41:26,720
目标视图是我们要实现动画的那一个

710
00:41:26,787 --> 00:41:29,590
在本例中就是左侧的粒子系统

711
00:41:32,125 --> 00:41:34,228
我们保持对刚通过变量

712
00:41:34,294 --> 00:41:37,097
获取的过渡控制器的引用

713
00:41:39,233 --> 00:41:42,102
现在我们需要做的最后一件事
就是实施

714
00:41:42,469 --> 00:41:45,239
UI视图控制器过渡委托协议

715
00:41:53,647 --> 00:41:55,582
因此 我们需要实施两个函数：

716
00:41:55,649 --> 00:41:58,285
为presentedViewController
实施animationController

717
00:41:58,752 --> 00:42:01,188
同时 因为我们想支持关闭文档

718
00:42:01,355 --> 00:42:03,824
为dismissedViewController
实施animationController

719
00:42:04,658 --> 00:42:07,861
在两个函数中
我们所要做的就是返回我们

720
00:42:07,928 --> 00:42:09,096
刚获取的过渡控制器

721
00:42:10,030 --> 00:42:11,465
让我们在模拟器中试一下

722
00:42:23,043 --> 00:42:24,044
很漂亮 不是吗？

723
00:42:24,111 --> 00:42:27,748
我们有一个从缩略图
到粒子系统的很好的过渡

724
00:42:28,448 --> 00:42:30,717
当我们完成文件修改后

725
00:42:30,918 --> 00:42:35,189
我们轻触完成按钮来结束文件
然后就漂亮地过渡回

726
00:42:35,255 --> 00:42:37,257
UI文档浏览器视图控制器

727
00:42:39,026 --> 00:42:41,028
那么这就是第二个演示的全部内容

728
00:42:41,094 --> 00:42:43,330
让我们看一下我们目前所学到的内容

729
00:42:47,868 --> 00:42:50,337
首先我们看了如何简便地

730
00:42:50,404 --> 00:42:52,873
在你的应用中支持open-in-place

731
00:42:53,173 --> 00:42:56,944
实际上UI文档浏览器视图控制器
会替你完成全部艰巨的任务

732
00:42:58,512 --> 00:43:01,748
接下来我们实施了一个自定义行动

733
00:43:01,949 --> 00:43:05,586
仅当你在文档浏览器视图控制器中
长按一个文档时执行

734
00:43:07,421 --> 00:43:11,258
最后这点也很重要
我们极大地改善了用户体验

735
00:43:11,325 --> 00:43:14,194
当打开和关闭文档时

736
00:43:14,261 --> 00:43:15,863
通过实施自定义视图控制器过渡

737
00:43:15,929 --> 00:43:18,465
使用UI文档浏览器过渡控制器

738
00:43:19,900 --> 00:43:21,935
这就是第二个演示的全部内容

739
00:43:22,302 --> 00:43:25,072
要了解关于快速预览相关的新功能

740
00:43:25,138 --> 00:43:28,141
让我们把舞台交给
我的同事兼朋友马克西姆

741
00:43:28,942 --> 00:43:29,843
马克西姆

742
00:43:31,912 --> 00:43:32,946
谢谢 拉斐尔

743
00:43:34,181 --> 00:43:35,449
大家下午好

744
00:43:39,953 --> 00:43:43,156
我相信你们一定都见过文件应用中
很棒的缩略图功能吧

745
00:43:43,857 --> 00:43:46,927
而且我相信你一定希望
你自己的缩略图

746
00:43:46,994 --> 00:43:49,496
可以在任何基于
文档浏览器的应用中显示出来

747
00:43:50,364 --> 00:43:51,465
现在你将会看到

748
00:43:51,532 --> 00:43:54,201
这是如何变为可能的
全都归功于新的缩略图扩展

749
00:43:56,069 --> 00:43:58,539
当前 如果我们是在本场演讲中

750
00:43:58,605 --> 00:44:00,274
所创建的粒子应用的粉丝

751
00:44:00,908 --> 00:44:02,743
我们所能使用的都是通用图标

752
00:44:04,011 --> 00:44:07,080
我们可以极大地改善用户体验
通过显示

753
00:44:07,648 --> 00:44:11,818
能暗示用户文件内容的
代表性缩略图

754
00:44:13,487 --> 00:44:15,155
那么如何提供已经被下载的

755
00:44:15,322 --> 00:44:18,725
以及设备上可用的文件的缩略图呢？

756
00:44:21,895 --> 00:44:25,199
这个功能在iOS 11之前就已经
通过UI文档实现了

757
00:44:26,900 --> 00:44:29,937
你要做的就是创建UI文档的子类

758
00:44:30,204 --> 00:44:32,206
并从子类中返回缩略图

759
00:44:33,807 --> 00:44:36,476
这仅能用于通过你的应用创建的文件

760
00:44:37,144 --> 00:44:40,314
并且它的性能很好
因为当iOS请求

761
00:44:40,647 --> 00:44:44,084
缩略图的子类时
文件已经被加载出来了

762
00:44:44,885 --> 00:44:46,553
让我们快速看一下代码

763
00:44:47,354 --> 00:44:48,255
我们需要做的是…

764
00:44:49,122 --> 00:44:52,626
…实施fileAttributesToWritetoURL

765
00:44:52,693 --> 00:44:56,630
在你的UI文档子类中
为saveOperation方法

766
00:44:56,697 --> 00:45:00,601
并从这个函数中返回一个缩略图字典

767
00:45:03,237 --> 00:45:07,841
这很棒
但这只能用于通过应用创建的文件

768
00:45:08,342 --> 00:45:10,844
那么你要如何为你的应用和其他应用

769
00:45:10,911 --> 00:45:13,413
所创建的文件提供缩略图呢？

770
00:45:15,315 --> 00:45:19,520
为此 我们要给大家提供一个
新的缩略图扩展 适用于整个系统

771
00:45:19,820 --> 00:45:24,157
这意味着这个扩展…

772
00:45:24,424 --> 00:45:30,564
意味着任何通过你的扩展
创建的缩略图都会显示

773
00:45:30,631 --> 00:45:34,635
在可显示你的扩展
所能提供缩略图的文件的

774
00:45:34,701 --> 00:45:36,970
任何基于文档浏览器的应用中显示

775
00:45:38,539 --> 00:45:40,574
这个扩展可应用于全部云供应商

776
00:45:41,708 --> 00:45:43,377
并且是快速预览框架的一部分

777
00:45:45,212 --> 00:45:46,513
让我们看看是如何使用的

778
00:45:46,947 --> 00:45:50,984
首先你的基于文档浏览器的应用
正在显示…

779
00:45:51,051 --> 00:45:52,553
假如说基于文档浏览器的应用

780
00:45:52,619 --> 00:45:54,488
正在显示一组文件

781
00:45:55,055 --> 00:45:57,024
如果我们想显示这些文件的缩略图

782
00:45:57,090 --> 00:46:00,894
并拥有一个良好的用户体验
那么就是快速预览缩略图

783
00:46:01,962 --> 00:46:05,065
快速预览 我们注意到其中某些文件

784
00:46:05,132 --> 00:46:07,734
你的扩展可以提供缩略图

785
00:46:07,801 --> 00:46:10,704
那么它就会将请求转给你的扩展

786
00:46:12,539 --> 00:46:14,541
你的扩展将会生成缩略图

787
00:46:15,742 --> 00:46:17,411
并将它们返回到快速预览

788
00:46:17,911 --> 00:46:20,414
最终将其返回到

789
00:46:20,480 --> 00:46:22,049
请求缩略图的应用中

790
00:46:22,516 --> 00:46:24,184
然后进行显示

791
00:46:25,586 --> 00:46:27,087
让我们看看该如何实现

792
00:46:29,223 --> 00:46:30,891
实际上非常简单

793
00:46:30,958 --> 00:46:33,560
因为我们在Xcode中
添加了一个新模板

794
00:46:33,627 --> 00:46:36,630
包含示例代码以及Info.plist

795
00:46:38,098 --> 00:46:39,900
在创建你的扩展之后

796
00:46:40,367 --> 00:46:42,870
你需要前往Info.plist文件并编辑它

797
00:46:43,437 --> 00:46:45,038
因此你要做的第一件事就是

798
00:46:45,105 --> 00:46:48,075
添加你能提供缩略图的全部UTI

799
00:46:48,141 --> 00:46:50,344
到QLSupportedContentTypes数组

800
00:46:51,044 --> 00:46:54,982
请注意 你只能为你所拥有的UTI
提供和导出缩略图

801
00:46:55,682 --> 00:46:59,319
并且iOS会检查UTI质量
而不是UTI一致性

802
00:46:59,386 --> 00:47:04,758
因此 我们要确保列出
plist值内的全部UTI

803
00:47:06,293 --> 00:47:08,829
现在要如何给文件提供缩略图呢？

804
00:47:09,029 --> 00:47:09,897
有两种方式

805
00:47:10,564 --> 00:47:14,168
你可以拖动缩略图
或返回图片文件URL

806
00:47:14,701 --> 00:47:16,870
最强大的方法当然是第一个了

807
00:47:16,937 --> 00:47:19,339
拖动缩略图
因为它是最灵活的一个方式

808
00:47:19,840 --> 00:47:21,041
让我们看看是如何使用的

809
00:47:23,911 --> 00:47:27,047
那么在这个扩展中
你需要实施的任何方法

810
00:47:27,114 --> 00:47:31,351
都会收到QLFileThumbnailRequest
类的一个参数

811
00:47:31,418 --> 00:47:33,520
包含三个属性

812
00:47:34,388 --> 00:47:37,658
文件URL 就是我们
要发送文件的文件URL

813
00:47:38,058 --> 00:47:42,462
所请求的缩略图的最大尺寸
以及比例

814
00:47:44,665 --> 00:47:48,035
我们要做的就是
返回一个QLThumbnailReply对象

815
00:47:48,101 --> 00:47:51,338
包含绘板和contextSize

816
00:47:51,605 --> 00:47:53,907
让我们看看为何需要返回contextSize

817
00:47:56,076 --> 00:47:58,412
请求的最大尺寸参数

818
00:47:59,079 --> 00:48:02,382
表明了你可以绘制缩略图的

819
00:48:02,449 --> 00:48:03,984
CGContext的最大尺寸

820
00:48:05,219 --> 00:48:09,623
现在假如我们想把这个图片
拖到我们的环境中

821
00:48:09,690 --> 00:48:13,827
你可以看到 当处于全尺寸中时
它比环境的最大尺寸还要大

822
00:48:13,894 --> 00:48:17,531
所以我们需要缩小一点儿

823
00:48:18,098 --> 00:48:22,135
确保它能放到CGContext里面

824
00:48:22,402 --> 00:48:26,640
但如果我们把这个图片
加载到左侧的环境中

825
00:48:26,974 --> 00:48:31,445
我们就需要返回一个带有
未使用过的透明像素的缩略图

826
00:48:31,512 --> 00:48:33,947
意思是一个浮动缩略图
这并不是我们想要的

827
00:48:34,781 --> 00:48:38,619
所以我们得决定要绘制

828
00:48:38,685 --> 00:48:41,221
和传给QLThumbnailReply的
正确环境尺寸

829
00:48:42,055 --> 00:48:46,693
得益于此 我们的绘板会收到
与所请求的尺寸

830
00:48:47,828 --> 00:48:51,298
contextSize正确匹配的CGContext

831
00:48:51,899 --> 00:48:55,002
并且我们可以
按我们所想绘制缩略图

832
00:48:57,070 --> 00:48:59,206
现在如果你不想绘制缩略图

833
00:48:59,273 --> 00:49:03,477
而是倾向于返回一个图片文件URL

834
00:49:04,044 --> 00:49:05,245
也非常简单

835
00:49:07,047 --> 00:49:09,349
你会收到同一个
QLFileThumbnailRequest

836
00:49:09,983 --> 00:49:12,252
并且你所需要返回的就是一个

837
00:49:12,319 --> 00:49:14,121
包含图片文件URL的
QLThumbnailReply

838
00:49:14,288 --> 00:49:15,389
在这种情况下

839
00:49:15,455 --> 00:49:18,258
快速预览将会自己决定

840
00:49:18,325 --> 00:49:20,827
缩小或放大缩略图

841
00:49:20,894 --> 00:49:23,063
它会保持文件的长宽比

842
00:49:23,330 --> 00:49:25,165
从而使缩略图看起来效果不错

843
00:49:27,701 --> 00:49:30,070
现在让我们看一下这部分的代码

844
00:49:31,071 --> 00:49:34,007
你需要实施的唯一一个方法叫作

845
00:49:34,074 --> 00:49:37,144
provideThumbnailForRequestHandler

846
00:49:40,881 --> 00:49:43,650
在这个例子中
我们要做的第一件事就是提取

847
00:49:43,717 --> 00:49:46,920
QLFileThumbnailRequest的全部参数

848
00:49:47,387 --> 00:49:51,758
意思是文件URL、最大尺寸和比例

849
00:49:52,726 --> 00:49:56,930
除了这些参数
我们还要决定环境尺寸

850
00:49:56,997 --> 00:50:00,367
我们绘制缩略图的环境 就像我们
在刚才的例子中看到过的一样

851
00:50:03,270 --> 00:50:08,275
之后正如我们所说过的
我们需要提供一个绘板

852
00:50:09,109 --> 00:50:11,979
那么在这里 我们创建一个绘板
并在绘板内

853
00:50:12,045 --> 00:50:13,881
绘制缩略图

854
00:50:14,248 --> 00:50:17,584
因此 绘板需要返回一个成功值来向

855
00:50:17,651 --> 00:50:21,755
快速预览表明 无论是或否
它实际上可以提供缩略图

856
00:50:23,223 --> 00:50:24,858
最后我们创建QLThumbnailReply

857
00:50:24,925 --> 00:50:28,128
在contextSize和绘板之外

858
00:50:28,195 --> 00:50:31,331
并且用我们的回复以及

859
00:50:31,398 --> 00:50:34,835
一个NSR参数
调用completionHandler

860
00:50:35,369 --> 00:50:37,871
在这里 我们传递无 因为我们总是
希望提供一个缩略图

861
00:50:37,938 --> 00:50:42,042
但如果由于某些原因你不想总是
返回全部请求的缩略图

862
00:50:42,109 --> 00:50:45,245
你可以提供一个NS报错

863
00:50:45,679 --> 00:50:49,316
来快速表明你不希望为此请求
提供缩略图

864
00:50:51,652 --> 00:50:53,921
如果你想返回一个图片文件URL

865
00:50:53,987 --> 00:50:58,325
而不是绘制一个缩略图文件请求

866
00:50:58,725 --> 00:51:01,929
你可以实施同样的方法
但需要调用的是completionHandler

867
00:51:01,995 --> 00:51:05,132
用一个包含图片文件URL的
QLThumbnailReply

868
00:51:05,666 --> 00:51:09,503
在这个简单的例子中 我们只返回了
来自我们主供应商的图片

869
00:51:13,106 --> 00:51:14,741
在创建扩展后

870
00:51:14,808 --> 00:51:18,078
你当然希望能看到漂亮的新缩略图了

871
00:51:18,912 --> 00:51:23,483
你可以在任何显示你文件的基于文档
浏览器的应用中进行查看

872
00:51:23,884 --> 00:51:26,320
那么在这里 我们可以从截图中看到

873
00:51:26,720 --> 00:51:31,158
缩略图来自扩展…

874
00:51:31,225 --> 00:51:33,694
粒子应用的扩展

875
00:51:34,461 --> 00:51:38,298
但我们处于文件应用的最近列表内部
但我们仍能看到它们

876
00:51:42,135 --> 00:51:46,206
你现在了解如何创建很棒的
基于文档的应用了吧

877
00:51:46,273 --> 00:51:49,209
通过UI文档浏览器视图控制器

878
00:51:49,276 --> 00:51:50,677
和缩略图扩展

879
00:51:51,178 --> 00:51:53,947
那么要如何进一步改善用户体验呢？

880
00:51:54,915 --> 00:52:00,020
如果你导出自定义UTI
你很可能希望能提供预览

881
00:52:00,087 --> 00:52:04,057
iOS可以在任何应用中显示

882
00:52:05,459 --> 00:52:07,628
我们现在看这个是如何实现的

883
00:52:07,694 --> 00:52:09,596
通过新的快速浏览预览扩展

884
00:52:12,633 --> 00:52:17,905
默认情况下
快速预览仅支持有限的文件类型

885
00:52:18,539 --> 00:52:23,210
意思是默认情况下快速预览不会
预览你的自定义文件类型

886
00:52:24,111 --> 00:52:28,949
但我有个好消息
因为从iOS 11开始

887
00:52:30,284 --> 00:52:32,386
你将可以向快速预览提供预览

888
00:52:32,953 --> 00:52:36,223
并扩展快速预览的功能

889
00:52:36,857 --> 00:52:38,792
因为我们将向第三方开放快速预览

890
00:52:40,894 --> 00:52:45,832
我们要把快速预览开放给第三方
所以当你预览扩展时

891
00:52:46,433 --> 00:52:47,734
将是系统范围内的

892
00:52:47,801 --> 00:52:51,138
意思是任何使用快速预览的应用

893
00:52:51,205 --> 00:52:53,240
都将能显示你的预览

894
00:52:53,440 --> 00:52:57,511
并且你还可以决定提供由你的应用

895
00:52:57,578 --> 00:52:58,812
进行索引的Spotlight项预览

896
00:52:59,246 --> 00:53:03,483
这些预览将会可见
当你在支持[听不清]的iPhone上

897
00:53:03,550 --> 00:53:05,485
瞥一眼Spotlight结果时

898
00:53:06,987 --> 00:53:11,158
你的预览在快速预览中
将会享受一等待遇

899
00:53:11,758 --> 00:53:14,161
它们将得益于完整的快速预览体验

900
00:53:14,494 --> 00:53:17,264
并作为QL预览控制器的一部分
进行预览

901
00:53:17,331 --> 00:53:19,399
就像在预览中创建的其它结果一样

902
00:53:20,501 --> 00:53:22,636
快速预览将会获取显示加载指示器

903
00:53:22,703 --> 00:53:25,339
当等待你的扩展返回预览时

904
00:53:25,772 --> 00:53:26,773
让我们看一下流程

905
00:53:27,374 --> 00:53:33,514
首先快速预览注意到
它不能自己预览文件

906
00:53:33,580 --> 00:53:35,415
但它会请求扩展预览

907
00:53:35,949 --> 00:53:38,619
你的扩展将会花一点时间生成预览

908
00:53:39,786 --> 00:53:42,022
同时快速预览显示一个加载指示器

909
00:53:42,389 --> 00:53:43,991
你不需要处理这个

910
00:53:44,825 --> 00:53:48,328
当你的扩展准备显示预览时

911
00:53:48,395 --> 00:53:50,631
你需要在代码中
调用completionHandler

912
00:53:50,697 --> 00:53:54,968
以便通知快速预览可以显示预览了

913
00:53:56,570 --> 00:53:59,740
跟缩略图扩展相似
你可以很简单地上手

914
00:53:59,907 --> 00:54:02,176
因为我们为你准备了一个新模板

915
00:54:02,242 --> 00:54:05,812
包含一些示例代码、一个storybook
还有一个Info.plist

916
00:54:08,215 --> 00:54:11,084
创建扩展之后 你想把它放在

917
00:54:11,151 --> 00:54:15,622
这个Info.plist中并编辑它
添加你能支持的全部UTI…

918
00:54:16,023 --> 00:54:20,027
抱歉 向QLSupportedContentTypes
数组中添加你所支持的全部UTI

919
00:54:20,994 --> 00:54:24,298
与缩略图扩展不同
缩略图扩展只能

920
00:54:24,364 --> 00:54:26,800
提供你自己拥有的
预览的图片并在此导入

921
00:54:28,101 --> 00:54:31,538
iOS会检查UTI质量
而不是UTI一致性

922
00:54:32,706 --> 00:54:35,609
如果你想为由你的应用

923
00:54:35,943 --> 00:54:38,412
表明的Spotlight项提供预览

924
00:54:38,478 --> 00:54:42,649
你需要把QLSupportsSearchableItems
的键值设为是

925
00:54:44,184 --> 00:54:48,055
现在让我们快速看一下代码

926
00:54:48,255 --> 00:54:49,990
如果你想为文件提供预览

927
00:54:51,225 --> 00:54:54,027
你需要实施preparePreviewOfFile

928
00:54:54,194 --> 00:54:56,430
在URL completionHandler方法中

929
00:54:57,431 --> 00:55:01,335
而你所需要做的就是
加载文件并调用completionHandler

930
00:55:01,401 --> 00:55:03,971
从而使快速预览显示你的预览

931
00:55:04,905 --> 00:55:07,007
你可以异步调用completionHandler

932
00:55:07,074 --> 00:55:09,109
这正适合本例中的情况

933
00:55:11,078 --> 00:55:14,581
如果你想提供Spotlight预览
你需要实施

934
00:55:14,648 --> 00:55:18,619
preparePreviewOfSearchableItems
identifier queryString

935
00:55:18,685 --> 00:55:20,153
completionHandler方法

936
00:55:20,487 --> 00:55:23,123
queryString参数可以用于

937
00:55:23,190 --> 00:55:25,626
突出显示预览中的任意部分

938
00:55:25,792 --> 00:55:29,263
这是用户在Spotlight中
输入的queryString

939
00:55:29,329 --> 00:55:33,834
在与你的应用索引的项交互之前

940
00:55:35,235 --> 00:55:39,606
跟文件示例中一样

941
00:55:39,806 --> 00:55:42,075
你所要做的就是准备好你的控制器

942
00:55:42,142 --> 00:55:43,577
并调用completionHandler

943
00:55:46,280 --> 00:55:49,449
你可以在使用快速预览的
任意应用中测试你的预览

944
00:55:49,516 --> 00:55:52,519
比如邮箱或信息

945
00:55:52,986 --> 00:55:55,322
或在Spotlight中
如果你支持Spotlight预览的话

946
00:55:55,389 --> 00:55:57,257
这正是本例中的情况

947
00:55:57,524 --> 00:56:00,794
在这里 我们窥视了一下
粒子应用提供的结果

948
00:56:05,599 --> 00:56:09,303
我希望用一些性能建议
来结束本场演讲

949
00:56:09,870 --> 00:56:13,006
当处理扩展时 你要一直确保快速

950
00:56:13,073 --> 00:56:14,775
那么在本例中 这是非常重要的

951
00:56:15,576 --> 00:56:17,344
你必须迅速绘制缩略图

952
00:56:17,411 --> 00:56:19,046
考虑一下…

953
00:56:20,180 --> 00:56:26,153
考虑一下 比如说用户
使用了文档浏览器

954
00:56:26,220 --> 00:56:28,956
你希望能尽可能快地显示
你的缩略图

955
00:56:29,022 --> 00:56:30,357
从而获得一个良好的用户体验

956
00:56:31,024 --> 00:56:33,961
对于快速浏览预览 你还要确保

957
00:56:34,394 --> 00:56:38,098
迅速加载预览
因为快速预览必须得快

958
00:56:39,700 --> 00:56:42,803
同时请注意
你不应该实施任何后台任务

959
00:56:42,870 --> 00:56:44,638
在调用completionHandler之后

960
00:56:46,406 --> 00:56:49,176
请谨记 因为扩展内容非常有限

961
00:56:50,377 --> 00:56:54,248
因此请避免连接两个大型库
并检查遗漏

962
00:56:55,649 --> 00:56:58,519
现在让我们迅速回顾一下
我们今天所谈到的东西

963
00:56:59,786 --> 00:57:03,824
首先我们谈了一些文档浏览器API

964
00:57:04,291 --> 00:57:05,359
API

965
00:57:05,692 --> 00:57:08,095
我们主要讲了UI文档
浏览器视图控制器

966
00:57:08,161 --> 00:57:09,463
以及如何利用它

967
00:57:10,497 --> 00:57:13,400
来创建一个了不起的基于文档的应用

968
00:57:13,967 --> 00:57:16,503
你了解了它的基本功能和高级功能

969
00:57:17,471 --> 00:57:22,776
然后我们看了如何在iOS 11中
自定义享受一等待遇的文件标签

970
00:57:22,843 --> 00:57:27,314
这都归功于新的缩略图
和快速浏览预览扩展

971
00:57:28,615 --> 00:57:33,320
现在让我们再看一下在过去的两年中
我们所收到你们的请求

972
00:57:33,587 --> 00:57:36,456
看我们是如何处理它们的

973
00:57:37,090 --> 00:57:38,825
那么这就是我们今天谈到的全部内容

974
00:57:40,694 --> 00:57:42,362
UI文档浏览器视图控制器

975
00:57:42,696 --> 00:57:45,032
给你提供了一个
统一的UI用于文件浏览

976
00:57:46,900 --> 00:57:49,102
新的本地存储和iCloud共享

977
00:57:49,169 --> 00:57:53,240
提供了一个以安全方式
从其他应用中获取文件的方式

978
00:57:55,843 --> 00:57:58,912
新的文件共享扩展
允许你流畅地获取

979
00:57:58,979 --> 00:58:00,480
其它云共享

980
00:58:01,815 --> 00:58:05,452
现在iOS可以深度整合
自定义文件类型

981
00:58:08,222 --> 00:58:11,425
照例 如果你希望获得关于
本场演讲的更多信息

982
00:58:11,491 --> 00:58:14,127
请访问Apple的官网

983
00:58:15,462 --> 00:58:17,831
我们邀请你观看如下这些相关演讲：

984
00:58:17,898 --> 00:58:23,504
本周稍早些的“拖放”演讲
和即将到来的

985
00:58:23,704 --> 00:58:26,006
iOS和macOS中
“Core Spotlight新特性”

986
00:58:26,073 --> 00:58:28,041
以及“文件共享增强功能”演讲

987
00:58:28,642 --> 00:58:34,515
你还可以参考2017年发布的
“创建基于文档的应用”

988
00:58:35,682 --> 00:58:38,919
感谢大家的参与 再一次希望大家
度过一个美好的WWDC

989
00:58:39,319 --> 00:58:40,254
再见

