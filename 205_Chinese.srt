1
00:00:20,187 --> 00:00:21,021
早上好

2
00:00:21,288 --> 00:00:22,523
感谢大家的参与

3
00:00:23,090 --> 00:00:24,358
我是伊恩·帕克斯

4
00:00:25,659 --> 00:00:26,493
谢谢大家

5
00:00:29,062 --> 00:00:31,832
我是伊恩·帕克斯
我是watchOS软件团队的一员

6
00:00:32,064 --> 00:00:35,035
我很激动地要跟大家
分享watchOS 4中的新特性

7
00:00:35,135 --> 00:00:38,038
以及此次更新对于开发者的意义

8
00:00:38,138 --> 00:00:41,642
以便你们可以继续
在watchOS平台上提交很棒的应用

9
00:00:42,309 --> 00:00:45,212
距离我们首次发布
Apple Watch仅两年时间

10
00:00:45,345 --> 00:00:47,214
这个平台却已经取得了很大的进展

11
00:00:47,648 --> 00:00:49,583
我们将继续从用户那儿学习

12
00:00:49,816 --> 00:00:53,187
并了解Apple Watch如何
使他们的生活变得与众不同

13
00:00:53,554 --> 00:00:57,157
今年 我们在watchOS 4中
增加了许多新功能

14
00:00:58,492 --> 00:01:01,328
比如 新闻应用
可以让你浏览标题

15
00:01:01,428 --> 00:01:03,230
并标记稍后想要阅读的标题

16
00:01:03,864 --> 00:01:08,302
全新设计的音乐体验
可以同步多个播放列表

17
00:01:08,502 --> 00:01:11,872
并且拥有新界面既有趣又简单易用

18
00:01:11,939 --> 00:01:13,974
（音乐群星专辑50首）

19
00:01:16,143 --> 00:01:19,513
我们还尝试让整个进程更加高效

20
00:01:19,947 --> 00:01:22,049
比如可以直接在锻炼界面内

21
00:01:22,115 --> 00:01:23,817
获取正在播放的音乐界面

22
00:01:26,353 --> 00:01:30,023
以及从新的Siri表盘中

23
00:01:30,524 --> 00:01:32,292
整理和显示一天中的重要信息

24
00:01:33,994 --> 00:01:37,931
当然了 我们为开发者
引入了很多新功能

25
00:01:38,031 --> 00:01:40,667
以便你们可以
创造更棒的watchOS应用

26
00:01:41,335 --> 00:01:44,371
那么 去年我们
针对如何创建了不起的手表体验

27
00:01:44,471 --> 00:01:46,874
引入了三条指导原则

28
00:01:47,074 --> 00:01:50,143
并且我们会在系统应用中
以及为你们创建框架时

29
00:01:50,210 --> 00:01:52,579
继续遵从这三条原则

30
00:01:53,580 --> 00:01:55,115
让我们回顾一下

31
00:01:55,182 --> 00:01:58,785
看它们在watchOS中
是如何继续推动交互的

32
00:02:00,721 --> 00:02:02,990
首先是使我们的应用精简了

33
00:02:03,390 --> 00:02:05,959
Apple Watch上的
交互时间很短

34
00:02:06,193 --> 00:02:09,463
屏幕尺寸比其它平台上的更小

35
00:02:09,696 --> 00:02:13,867
因此我们需要仔细考虑
要在用户界面上呈现哪些信息

36
00:02:14,301 --> 00:02:16,603
并确保这些信息构思巧妙

37
00:02:16,670 --> 00:02:20,741
因此用户可以迅速了解并响应该信息

38
00:02:20,974 --> 00:02:22,976
（精简化）

39
00:02:27,347 --> 00:02:30,217
第二条是让信息变得可操作

40
00:02:30,484 --> 00:02:35,322
意思是将用户所能响应的东西

41
00:02:35,422 --> 00:02:38,725
要么放在应用内部 比如更换曲目

42
00:02:39,293 --> 00:02:41,628
要么放在当前环境中

43
00:02:41,762 --> 00:02:43,897
在我出门时

44
00:02:43,997 --> 00:02:46,099
快速地瞥一眼天气状况

45
00:02:46,200 --> 00:02:47,401
让我了解是否需要带伞

46
00:02:48,035 --> 00:02:51,605
但可操作的信息还可以是音频形式

47
00:02:52,139 --> 00:02:56,210
例如 在我锻炼时
我可以通过耳机获得教练的辅导

48
00:02:56,276 --> 00:02:58,545
当我跟不上训练的步伐时提醒我

49
00:02:59,780 --> 00:03:01,381
最后一条是可响应

50
00:03:02,015 --> 00:03:05,586
性能对于watchOS应用来说
的确是个至关重要的衡量标准

51
00:03:05,719 --> 00:03:07,955
当我们说可响应时
我们要表达的不仅仅是这些

52
00:03:08,121 --> 00:03:12,759
它还意味着确保一直保持更新

53
00:03:13,293 --> 00:03:14,828
它会考虑

54
00:03:14,895 --> 00:03:18,165
用户在应用内
下一步可能想要做什么操作

55
00:03:18,765 --> 00:03:20,234
让我们看几个例子

56
00:03:20,334 --> 00:03:23,437
关于这些是如何
在watchOS 4中呈现的

57
00:03:28,175 --> 00:03:31,278
去年我们引入了快速启动锻炼功能

58
00:03:31,578 --> 00:03:36,550
可以让你非常迅速地开始日常锻炼

59
00:03:37,284 --> 00:03:40,921
理念是你将反复使用同一种锻炼类型

60
00:03:41,154 --> 00:03:44,157
因此 你也可以使用
之前设定好的同一个目标

61
00:03:44,224 --> 00:03:46,226
在几秒钟内就可以开始

62
00:03:46,627 --> 00:03:48,929
但如果你轮流做一组锻炼

63
00:03:48,996 --> 00:03:50,664
比如一天跑步

64
00:03:50,831 --> 00:03:52,533
但隔天就游泳

65
00:03:52,599 --> 00:03:54,501
再是骑车？

66
00:03:54,601 --> 00:03:57,771
首先 恭喜你
因为你要进行大量的锻炼

67
00:03:58,172 --> 00:04:02,309
但你每次都要进行一个
额外的步骤 就是设定一个目标

68
00:04:03,010 --> 00:04:06,146
因此在watchOS 4中
我们对此进行了简化

69
00:04:06,513 --> 00:04:07,881
每次锻炼都将追踪

70
00:04:07,981 --> 00:04:11,185
你之前为该种锻炼类型所设定的目标

71
00:04:11,552 --> 00:04:14,555
并且如果你没有设定目标
默认情况是要开启一个目标

72
00:04:14,655 --> 00:04:17,891
那意味着每种锻炼类型
都可以作为快速启动的锻炼

73
00:04:18,291 --> 00:04:19,358
这是一个

74
00:04:19,426 --> 00:04:22,462
将用户可能会采取的最常见的操作

75
00:04:22,529 --> 00:04:24,064
变得最简单的不错的例子

76
00:04:25,165 --> 00:04:28,635
它允许他们瞥一眼用户界面
然后就快速开始锻炼

77
00:04:30,304 --> 00:04:32,039
当你处于锻炼界面时

78
00:04:32,139 --> 00:04:34,975
你可以在日常锻炼中
增加第二种锻炼类型

79
00:04:35,108 --> 00:04:38,445
比如我想从高强度的间歇训练开始

80
00:04:38,912 --> 00:04:40,747
并以快跑结束

81
00:04:41,381 --> 00:04:43,450
以前需要好几个步骤

82
00:04:43,517 --> 00:04:45,385
才能完成这次锻炼

83
00:04:45,485 --> 00:04:46,320
保存

84
00:04:46,653 --> 00:04:48,555
返回锻炼列表

85
00:04:48,789 --> 00:04:50,457
找到下一个要进行的锻炼类型

86
00:04:50,524 --> 00:04:53,393
很可能不是快速启动锻炼

87
00:04:53,627 --> 00:04:56,163
我需要设定一个目标然后再继续

88
00:04:56,530 --> 00:05:00,000
现在 只需要一次快速地轻触
就可以添加第二种锻炼类型

89
00:05:00,100 --> 00:05:01,668
再轻触一次就能快速启动它

90
00:05:02,436 --> 00:05:05,772
这是一个创建可响应的
用户体验的不错的例子

91
00:05:06,373 --> 00:05:09,443
不仅是在用户界面中更新数据

92
00:05:09,510 --> 00:05:12,713
也是思考用户在应用内的下一步操作

93
00:05:12,880 --> 00:05:14,414
基于你已经了解的信息

94
00:05:19,186 --> 00:05:23,757
现在 停靠栏是显示来自
应用的精简信息的极好的地方

95
00:05:24,157 --> 00:05:26,894
正如你在主要话题
视频中所看到的那样

96
00:05:26,960 --> 00:05:28,862
我们将停靠栏从横向滚动

97
00:05:28,929 --> 00:05:30,397
改成了垂直滚动

98
00:05:31,131 --> 00:05:34,201
稍后你将在WatchKit的
用户界面更新中看到

99
00:05:34,568 --> 00:05:35,569
应用应分别考虑

100
00:05:35,636 --> 00:05:40,307
哪种导航以及哪种过渡是最自然的

101
00:05:40,407 --> 00:05:42,342
从而可以很简便地在应用内导航

102
00:05:42,409 --> 00:05:45,546
通过滑动或滚动信息

103
00:05:45,612 --> 00:05:47,581
（提醒锻炼）

104
00:05:47,648 --> 00:05:49,650
（户外散步开启目标）

105
00:05:50,918 --> 00:05:54,021
除了改为垂直定向

106
00:05:54,454 --> 00:05:57,124
现在 停靠栏还拥有两种操作模式

107
00:05:57,257 --> 00:05:59,760
分别是收藏夹模式和最近使用模式

108
00:06:00,194 --> 00:06:01,828
我们很熟悉收藏夹模式

109
00:06:01,895 --> 00:06:04,665
它的操作
跟watchOS 3中的一模一样

110
00:06:05,032 --> 00:06:07,234
用户可以选择并添加某个应用

111
00:06:07,301 --> 00:06:10,103
并能定义这些应用
在停靠栏中的显示顺序

112
00:06:10,237 --> 00:06:14,141
以及用户所使用的最后一个
应用中最后一次使用的位置

113
00:06:14,675 --> 00:06:18,745
最近使用模式看起来
就跟iOS上的应用切换器一样

114
00:06:18,812 --> 00:06:22,516
你每天使用应用时
应用会不断进出停靠栏

115
00:06:22,716 --> 00:06:25,652
那意味着你更希望
在一天之中的某个时刻

116
00:06:25,719 --> 00:06:28,522
在用户的停靠栏中
显示你的应用

117
00:06:29,990 --> 00:06:31,992
意思是更新快照

118
00:06:32,059 --> 00:06:33,927
变得更加重要

119
00:06:33,994 --> 00:06:38,098
通过我们去年在watchOS 3中
所引用的后台快照API

120
00:06:38,599 --> 00:06:40,934
我们也增强了这个API的性能

121
00:06:41,068 --> 00:06:46,540
比如 你现在可以
在快照测试时得到一个回调

122
00:06:46,607 --> 00:06:49,843
告诉你快照是否是你所希望得到的

123
00:06:50,110 --> 00:06:52,746
还是自动提供的

124
00:06:52,846 --> 00:06:54,548
但那是由系统触发的

125
00:06:55,582 --> 00:06:59,820
同时请谨记 那些同时打开
或处于停靠栏中的应用

126
00:06:59,887 --> 00:07:03,323
是在后台启动的 是被挂起的
但却存在于内存中

127
00:07:03,390 --> 00:07:05,492
因此打开这些应用的速度很快

128
00:07:07,294 --> 00:07:09,062
接下来的时间

129
00:07:09,129 --> 00:07:12,366
我们将谈谈关于WatchSTK的

130
00:07:12,466 --> 00:07:13,800
三个主要话题

131
00:07:14,801 --> 00:07:17,871
第一个话题是界面灵活性

132
00:07:19,106 --> 00:07:23,143
可以让你有更多的选择
来向用户呈现信息和操作

133
00:07:24,311 --> 00:07:26,113
第二个话题是性能

134
00:07:26,413 --> 00:07:29,383
以便应用会一直尽可能地保持响应

135
00:07:31,652 --> 00:07:33,987
（用户界面的灵活性性能）

136
00:07:34,121 --> 00:07:36,156
最后一个话题是后台处理

137
00:07:36,523 --> 00:07:41,195
以便用户可以参与
超越前台应用体验的活动

138
00:07:41,595 --> 00:07:45,032
无论应用是处于停靠栏中
还是在后台打开

139
00:07:45,299 --> 00:07:47,367
或者是持续进行的任务应用
比如锻炼应用

140
00:07:51,438 --> 00:07:53,540
让我们看一下用户界面的灵活性

141
00:07:53,941 --> 00:07:56,877
WatchKit提供一系列的
用户界面组件

142
00:07:57,144 --> 00:07:59,313
并已针对表屏幕进行了优化

143
00:07:59,546 --> 00:08:01,615
但我们希望它们足够灵活

144
00:08:01,748 --> 00:08:06,253
以便你创建符合你的
应用特色的自定义用户界面

145
00:08:07,688 --> 00:08:10,057
如果你已创建了表应用

146
00:08:10,190 --> 00:08:12,092
或者你是这个平台上的开发新人

147
00:08:12,192 --> 00:08:13,861
你一定会爱上如此简单地

148
00:08:13,927 --> 00:08:17,264
在watchOS 4中使用
新的用户界面功能

149
00:08:17,764 --> 00:08:20,834
如果你是父亲或母亲
我会向你展示如何将

150
00:08:20,901 --> 00:08:23,470
你在家里已经
做了的事情换算成锻炼信息

151
00:08:23,537 --> 00:08:25,072
稍后我们再详细介绍

152
00:08:26,673 --> 00:08:28,876
我家有两个孩子
年龄分别是4岁和1岁

153
00:08:28,976 --> 00:08:32,412
时间总是在工作和带孩子之间逝去

154
00:08:32,513 --> 00:08:35,782
我几乎没有时间进行常规锻炼

155
00:08:36,183 --> 00:08:40,486
但说实话 我现正在做的事
感觉跟锻炼的运动量差不多

156
00:08:40,554 --> 00:08:43,090
无论是用肩膀驮着孩子
还是整理玩具

157
00:08:43,289 --> 00:08:44,858
所以我创建了一个新应用

158
00:08:45,025 --> 00:08:47,928
可以让我追踪
这些非传统意义上的锻炼

159
00:08:48,095 --> 00:08:49,897
我们可以用这个应用做例子

160
00:08:49,963 --> 00:08:53,233
来了解watchOS 4中的
一些新的用户界面功能

161
00:08:55,135 --> 00:08:58,071
那么在这里 我们有一个
简单的锻炼进入界面

162
00:08:58,238 --> 00:09:00,407
屏幕中间显示了一个卡路里计数器

163
00:09:00,474 --> 00:09:03,377
以及一个时间标签
和一个SpriteKit场景

164
00:09:03,443 --> 00:09:05,946
是父母正在追逐孩子

165
00:09:07,181 --> 00:09:10,184
这个界面在watchOS中
是很难实现的

166
00:09:10,250 --> 00:09:12,719
因为你不能叠加界面元素

167
00:09:12,986 --> 00:09:14,955
那么让我们看看这里都有什么功能

168
00:09:15,389 --> 00:09:17,391
（捉迷藏）

169
00:09:21,428 --> 00:09:24,965
在这里 在上层有一个群
包含我刚提到的标签

170
00:09:25,032 --> 00:09:27,100
位于SpriteKit场景的上一层

171
00:09:27,467 --> 00:09:30,904
你可能正在想 我刚说过
你不能叠加界面元素

172
00:09:31,271 --> 00:09:34,174
在watchOS 4中
我们创建了一个新的群布局

173
00:09:34,274 --> 00:09:36,610
可以允许你实现类似这样的效果

174
00:09:36,944 --> 00:09:39,813
让我们看一下界面创建器
看看要如何使用它

175
00:09:42,482 --> 00:09:44,718
针对群添加了一个新选项

176
00:09:44,785 --> 00:09:47,421
除了垂直和横向布局

177
00:09:47,521 --> 00:09:48,989
你现在还可以选择叠加

178
00:09:49,723 --> 00:09:52,759
选择叠加后
叠加的群将不针对每一个

179
00:09:52,826 --> 00:09:54,494
独立的元素计算型值

180
00:09:54,728 --> 00:09:57,865
相反 你可以选择它们各自的布局

181
00:09:57,931 --> 00:10:00,868
比如上、中、下或左、中、右

182
00:10:01,335 --> 00:10:03,437
群内的元素是按

183
00:10:03,504 --> 00:10:05,873
绝对的时尚设计的

184
00:10:07,574 --> 00:10:10,344
并且你还可以让群互相嵌套

185
00:10:10,544 --> 00:10:12,412
就像我用度量群实现的一样

186
00:10:12,513 --> 00:10:15,182
度量群包含我的标签
位于一个垂直群内

187
00:10:15,682 --> 00:10:19,520
你还可以使用[听不清]和间距

188
00:10:19,686 --> 00:10:22,322
来微调群内的布局

189
00:10:23,290 --> 00:10:25,425
你还可以指定c-order

190
00:10:25,526 --> 00:10:28,462
通过元素在大纲视图中出现的顺序

191
00:10:28,562 --> 00:10:29,463
请看这里

192
00:10:30,464 --> 00:10:32,833
这将使创建自定义
用户界面变得更加简单

193
00:10:32,900 --> 00:10:34,968
与之前相比 简直是天壤之别

194
00:10:35,035 --> 00:10:37,137
（锻炼状态场景 锻炼状态）

195
00:10:39,573 --> 00:10:42,376
在我的锻炼控制屏幕中
你可以在第二个屏幕中看到

196
00:10:43,010 --> 00:10:45,245
我已经添加了一个水锁按钮

197
00:10:45,612 --> 00:10:47,181
水锁按钮可以

198
00:10:47,247 --> 00:10:50,884
防止由于水在屏幕上滚动
而造成虚假触摸

199
00:10:51,251 --> 00:10:54,521
那么我家的情况是因为
我女儿会咬我的手表

200
00:10:55,756 --> 00:10:59,660
但之前在第三方的锻炼应用中

201
00:10:59,893 --> 00:11:03,397
要启动水锁得先启动锻炼

202
00:11:03,463 --> 00:11:07,067
然后退出并返回到表盘
向上滑动显示控制中心

203
00:11:07,134 --> 00:11:08,635
然后启动水锁

204
00:11:08,836 --> 00:11:12,739
你下一次抬起手腕时
应用就会出现在屏幕上

205
00:11:13,006 --> 00:11:15,042
我们将在watchOS 4中
简化这个过程

206
00:11:15,108 --> 00:11:19,012
现在你可以在自己的
用户界面中包含一个按钮

207
00:11:19,079 --> 00:11:21,048
使其符合你的应用的特色

208
00:11:22,583 --> 00:11:26,753
现在水锁只能由开发人员启动
永远不能被禁用

209
00:11:27,187 --> 00:11:29,256
用户得能自己实现

210
00:11:30,891 --> 00:11:34,127
当他们与侧边按钮
或数码表冠进行交互时

211
00:11:34,194 --> 00:11:36,897
将出现一个叠加层
就像这里的这个一样

212
00:11:36,964 --> 00:11:39,600
与系统当前所使用的一样

213
00:11:40,334 --> 00:11:42,636
它会告诉他们如何禁用水锁

214
00:11:43,437 --> 00:11:45,405
可以在锻炼应用中启用水锁

215
00:11:45,472 --> 00:11:47,808
在另一个基于会话的活动中
也可以启用水锁

216
00:11:47,875 --> 00:11:50,711
我们可以在简单的显示中实现

217
00:11:51,211 --> 00:11:52,513
原因是

218
00:11:52,613 --> 00:11:55,315
对于不在锻炼会话中的应用来说

219
00:11:55,415 --> 00:11:58,652
一段时间以后 当手腕落下时

220
00:11:58,719 --> 00:12:00,787
应用将会在后台被挂起

221
00:12:00,854 --> 00:12:02,356
当用户抬起手腕时

222
00:12:02,656 --> 00:12:04,358
他们将不再看到那个应用

223
00:12:04,424 --> 00:12:06,994
因为屏幕被锁定了
所以他们不能打开它

224
00:12:07,494 --> 00:12:10,864
但在锻炼应用中
当他们每次抬起手腕时

225
00:12:10,931 --> 00:12:12,466
会一直显示应用

226
00:12:13,433 --> 00:12:15,302
因此当我正在锻炼时

227
00:12:15,369 --> 00:12:17,871
我可以从锻炼应用中
查看更新的信息

228
00:12:18,906 --> 00:12:20,474
即使屏幕是锁定状态

229
00:12:20,941 --> 00:12:23,277
让我们看看如何在代码中实现

230
00:12:28,782 --> 00:12:30,651
非常简单

231
00:12:30,717 --> 00:12:33,387
是对共享扩展对象的一次调用

232
00:12:33,987 --> 00:12:38,892
现在需要注意的最后一点是

233
00:12:38,959 --> 00:12:40,527
只能在当应用处于前台时启用水锁

234
00:12:40,594 --> 00:12:43,263
用户总是能了解正在发生什么

235
00:12:45,632 --> 00:12:48,969
请看 我的应用
给了我一个祝贺性的顶拳

236
00:12:49,102 --> 00:12:51,138
庆祝我找到了一种将锻炼

237
00:12:51,205 --> 00:12:53,140
与父亲的职责结合在一起的方式

238
00:12:53,640 --> 00:12:56,743
这就是我要展示给大家看的东西

239
00:12:57,044 --> 00:12:59,446
但这个仅限于watchOS平台

240
00:12:59,513 --> 00:13:02,216
当我脱掉手表时
我可以保持屏幕开启

241
00:13:02,282 --> 00:13:03,951
我可以通过手势

242
00:13:04,084 --> 00:13:06,520
或把表反过来轻触屏幕实现

243
00:13:06,653 --> 00:13:08,655
但内容就上下颠倒了

244
00:13:09,389 --> 00:13:13,794
在watchOS 4中
我们可以让你开启自动旋转

245
00:13:14,328 --> 00:13:18,165
启用后 手腕的移动将不会关闭屏幕

246
00:13:18,232 --> 00:13:21,969
当你的手腕远离你时
会自动旋转内容

247
00:13:23,070 --> 00:13:25,472
这将不会无限期保持屏幕开启

248
00:13:25,873 --> 00:13:27,941
闲置计时器将休眠显示器

249
00:13:28,008 --> 00:13:29,810
在休止一段时间后

250
00:13:29,877 --> 00:13:31,078
但你有时间

251
00:13:31,144 --> 00:13:33,647
向其他人展示内容

252
00:13:34,681 --> 00:13:36,183
让我们来看看属性

253
00:13:37,584 --> 00:13:39,520
你从这里可以看到一个主题

254
00:13:39,586 --> 00:13:40,787
就是你不必做大量的工作

255
00:13:40,854 --> 00:13:42,789
来利用我们在watchOS 4中

256
00:13:42,856 --> 00:13:44,791
所增加的用户界面功能

257
00:13:46,026 --> 00:13:47,528
这个的应用范围很广

258
00:13:47,594 --> 00:13:49,496
让我们来看几个例子

259
00:13:50,330 --> 00:13:53,634
Proloquo4Text是一个
基于文本的通讯应用

260
00:13:53,967 --> 00:13:56,637
可以让识字的儿童、青少年和成年人

261
00:13:57,404 --> 00:13:59,673
不需要说话就能表达信息

262
00:14:00,374 --> 00:14:03,844
应用允许用户轻触一些
预编的私人化短语

263
00:14:03,911 --> 00:14:08,182
并将手腕展示给其他人
从而通过手腕上的文本进行沟通

264
00:14:08,682 --> 00:14:10,851
我下了一个咖啡订单

265
00:14:11,418 --> 00:14:13,220
通过将手腕展示给收银员看

266
00:14:13,287 --> 00:14:15,856
当手腕远离我时
屏幕会继续显示文本

267
00:14:15,923 --> 00:14:17,558
并且文本的显示方向正确

268
00:14:19,126 --> 00:14:21,762
我可以通过
Starbucks应用付款

269
00:14:23,030 --> 00:14:26,700
Starbucks可以让我打开
来自我银行卡的条形码

270
00:14:26,800 --> 00:14:28,235
并在屏幕上显示

271
00:14:29,303 --> 00:14:32,072
我可以将条形码
展示给收银员的扫描仪

272
00:14:32,372 --> 00:14:34,808
并让它保持在屏幕上
以方便我查看

273
00:14:35,876 --> 00:14:38,078
此外还有许多不同的应用

274
00:14:38,145 --> 00:14:41,448
你应该考虑在你的应用中
可能会适用的内容

275
00:14:43,717 --> 00:14:46,653
接下来 页面视图
有了一个全新的样式

276
00:14:46,720 --> 00:14:47,855
一种垂直页面视图

277
00:14:49,790 --> 00:14:51,859
我本可以将其作为滚动视图来实现

278
00:14:51,925 --> 00:14:54,294
但实际上这是两种不同的页面

279
00:14:54,361 --> 00:14:56,797
并且它们对屏幕的咬合非常棒

280
00:14:56,930 --> 00:14:59,933
并且在数码表冠中的使用也非常自然

281
00:15:00,534 --> 00:15:02,703
页面之间的动画

282
00:15:02,870 --> 00:15:07,407
类似于去年引入的
在主从应用中实施的

283
00:15:07,474 --> 00:15:09,543
表格行之间的换行

284
00:15:10,110 --> 00:15:13,380
但现在你不再需要
导航控制器就能实现

285
00:15:16,416 --> 00:15:18,652
让我们看看如何在界面中实施

286
00:15:20,187 --> 00:15:22,389
我们用一种引入新信息中的
两个关键要素的新方法

287
00:15:22,456 --> 00:15:26,193
替换了重新加载根控制器的方法

288
00:15:26,493 --> 00:15:29,296
第一个要素是设置方向的功能

289
00:15:29,396 --> 00:15:30,597
无论是应用在横向

290
00:15:30,664 --> 00:15:33,200
或是垂直页面视图中

291
00:15:33,267 --> 00:15:34,835
方法都一样

292
00:15:35,802 --> 00:15:39,006
关于第二点 我们得到了很多反馈

293
00:15:39,106 --> 00:15:41,475
很高兴能在watchOS 4中
给大家提供

294
00:15:41,575 --> 00:15:44,444
即设置初始页面索引功能

295
00:15:45,012 --> 00:15:46,947
这对于像锻炼应用
这样的应用来说很棒

296
00:15:47,014 --> 00:15:49,183
因为你想得到一个主界面

297
00:15:51,418 --> 00:15:53,754
我知道我们见过许多雷达

298
00:15:55,088 --> 00:15:56,890
你想在中心偏左的位置
要一个控制屏幕

299
00:15:56,990 --> 00:15:59,860
但你想直接加载到主界面

300
00:16:00,093 --> 00:16:02,563
那么这个功能就允许你
将索引设置到你想要到达的位置

301
00:16:02,629 --> 00:16:04,231
并在那里加载

302
00:16:08,035 --> 00:16:09,603
这是一个历史视图

303
00:16:10,237 --> 00:16:13,774
处理像这样拥有上百条记录的界面时

304
00:16:13,841 --> 00:16:16,009
你需要注意几点要素

305
00:16:16,176 --> 00:16:17,778
第一点是存储

306
00:16:17,945 --> 00:16:22,216
我很可能不想将我在表上
完成的全部锻炼记录存储下来

307
00:16:22,316 --> 00:16:23,584
但我可以加载它们

308
00:16:23,817 --> 00:16:26,887
通过手机或服务器中的表连通性

309
00:16:28,255 --> 00:16:29,556
第二点是性能

310
00:16:30,057 --> 00:16:32,192
一次加载太多表格行

311
00:16:32,326 --> 00:16:35,195
可以导致性能降低

312
00:16:35,262 --> 00:16:36,830
和表加载时间过长

313
00:16:42,336 --> 00:16:45,372
那么在这里
我们现在允许你获得一个回调

314
00:16:45,439 --> 00:16:47,774
当用户滚动到屏幕底部

315
00:16:47,841 --> 00:16:48,942
或屏幕顶部时

316
00:16:49,042 --> 00:16:52,613
因此你可以实现类似这样的功能
我在这儿有一个回调

317
00:16:52,679 --> 00:16:54,982
我把它放在一个加载指示器上

318
00:16:55,048 --> 00:16:57,184
然后我从手机上加载数据

319
00:16:59,319 --> 00:17:02,022
让我们看看如何实现回调

320
00:17:02,089 --> 00:17:04,090
（历史）

321
00:17:06,560 --> 00:17:09,863
首先 这是我在上一个
界面中用过的那个

322
00:17:10,063 --> 00:17:12,065
InterfaceOffsetDidScrollToTop

323
00:17:12,366 --> 00:17:14,568
当动画完成

324
00:17:14,635 --> 00:17:17,604
用户滚动到屏幕底部时会调用它

325
00:17:18,172 --> 00:17:19,839
然后是一个相反的函数

326
00:17:19,906 --> 00:17:21,775
interfaceOffsetDidScrollToTop

327
00:17:22,041 --> 00:17:24,243
当用户滚动到屏幕顶部时调用

328
00:17:24,877 --> 00:17:27,013
最后一个是
interfaceDidScrollToTop

329
00:17:27,079 --> 00:17:29,850
当用户轻触状态栏时调用

330
00:17:29,950 --> 00:17:32,085
这将滚动到界面顶部

331
00:17:32,786 --> 00:17:34,855
我们还包含了一个滚动函数

332
00:17:34,955 --> 00:17:37,958
可以让你传递一个界面元素

333
00:17:38,125 --> 00:17:42,462
并滚动它使它
出现在屏幕顶部、中间或底部

334
00:17:42,829 --> 00:17:46,099
我把它用在历史视图中
用来显示加载指示器

335
00:17:46,500 --> 00:17:48,902
当加载包含动画的群之后

336
00:17:48,969 --> 00:17:50,237
它会给屏幕造成负载

337
00:17:50,304 --> 00:17:52,406
所以我就把它传给滚动方法

338
00:17:52,472 --> 00:17:55,209
并设置为显示屏幕底部

339
00:17:58,312 --> 00:17:59,146
好了

340
00:17:59,213 --> 00:18:03,016
在这里 有一个重新设计的
锻炼之后的屏幕

341
00:18:03,083 --> 00:18:05,986
我们将其重新设计为全屏动画

342
00:18:06,520 --> 00:18:09,857
在watchOS 4的
SpriteKit和SyncIt应用中

343
00:18:09,957 --> 00:18:12,626
你现在可以使用整个显示屏了

344
00:18:13,660 --> 00:18:15,229
但它仍然是块表

345
00:18:15,295 --> 00:18:18,765
所以我们总是会在右上角显示时间

346
00:18:18,832 --> 00:18:22,402
它的背景是一个渐变
所以用户可以读取显示屏

347
00:18:22,469 --> 00:18:24,705
而无论内容是什么颜色的

348
00:18:26,807 --> 00:18:28,976
在watchOS 4中
针对创建用户界面

349
00:18:29,042 --> 00:18:31,645
有许多新变化

350
00:18:32,312 --> 00:18:34,982
你可以稍后参加本周的一场演讲

351
00:18:36,316 --> 00:18:39,453
关于设计一个了不起的表体验

352
00:18:39,586 --> 00:18:42,422
就是规划

353
00:18:42,489 --> 00:18:43,624
你在表上所进行的交互

354
00:18:43,690 --> 00:18:45,859
以及应用的设计

355
00:18:46,727 --> 00:18:49,162
接下来 让我们来看看性能

356
00:18:49,897 --> 00:18:52,399
之前我们所说的表上的交互时间

357
00:18:52,466 --> 00:18:54,234
是短暂的 但可以有许多次交互

358
00:18:54,501 --> 00:18:57,371
我们想确保提前做好准备

359
00:18:57,437 --> 00:18:59,239
但也要尽可能地保持响应

360
00:19:00,874 --> 00:19:01,742
为了这个目的

361
00:19:01,808 --> 00:19:05,746
我们在watchOS 2中
将扩展从手机上

362
00:19:05,812 --> 00:19:07,114
挪到了表上

363
00:19:07,247 --> 00:19:08,916
那的确很有帮助

364
00:19:09,016 --> 00:19:12,286
它意味着你可以在手机
不在身边时运行应用

365
00:19:13,053 --> 00:19:15,722
但也意味着延迟时间长 通讯质量差

366
00:19:16,356 --> 00:19:17,758
但在后台

367
00:19:19,359 --> 00:19:22,496
应用和扩展在各自的进程中运行

368
00:19:22,563 --> 00:19:24,665
你的代码正在尝试进行更新

369
00:19:24,731 --> 00:19:26,166
并且你也正在对事件做出响应

370
00:19:26,266 --> 00:19:28,035
这里存在

371
00:19:28,101 --> 00:19:30,170
两者之间的内部进程通讯延迟

372
00:19:31,138 --> 00:19:33,240
在watchOS 4中
我们用了一点儿魔法

373
00:19:33,307 --> 00:19:36,844
在运行时
我们同时将扩展和应用

374
00:19:36,944 --> 00:19:38,478
加载到同一个进程中

375
00:19:38,946 --> 00:19:42,216
这将使应用的性能得到很大的提升

376
00:19:42,316 --> 00:19:44,885
当与设备交互时 你将发现
比如触摸延迟时间变短

377
00:19:44,952 --> 00:19:46,587
视图加载速度变快

378
00:19:46,653 --> 00:19:49,656
帧频变高

379
00:19:50,224 --> 00:19:52,726
最棒的是你不必做任何事

380
00:19:52,793 --> 00:19:54,595
就能让用户获得此种体验

381
00:19:54,795 --> 00:19:59,533
这对于watchOS 2及以上的全部
应用来说是一种彻底的二进制兼容变更

382
00:19:59,967 --> 00:20:01,668
那意味着无需更新

383
00:20:02,169 --> 00:20:03,403
无需重新编译

384
00:20:04,671 --> 00:20:05,739
全部现存应用

385
00:20:05,806 --> 00:20:08,141
无论是用户设备上的应用
或是App Store中的应用

386
00:20:08,208 --> 00:20:10,978
都将在watchOS 4中
获得此种体验

387
00:20:11,879 --> 00:20:14,982
这将产生很大的影响
我们迫不及待地展示给你们看

388
00:20:16,884 --> 00:20:17,885
我说跑题了

389
00:20:18,485 --> 00:20:21,555
最后让我们来看看后台进程

390
00:20:22,122 --> 00:20:25,692
正如我所说的
当用户抬起手腕看表时

391
00:20:26,093 --> 00:20:28,328
提前准备

392
00:20:28,395 --> 00:20:30,597
并保持应用数据更新非常重要

393
00:20:30,898 --> 00:20:34,168
它的实现是通过结合后台运行模式

394
00:20:34,234 --> 00:20:37,171
表盘控件的使用、快照API

395
00:20:37,271 --> 00:20:39,606
以及今年我们所实现的更新

396
00:20:39,673 --> 00:20:42,142
叫作Frontmost App State

397
00:20:42,409 --> 00:20:44,211
稍后我们会详细讲这个

398
00:20:45,979 --> 00:20:49,583
去年 我们引入了锻炼进程后台模式

399
00:20:49,683 --> 00:20:52,252
允许第三方应用在后台运行

400
00:20:52,352 --> 00:20:55,756
并当用户抬起手腕时 使应用可用

401
00:20:56,356 --> 00:20:59,426
今年我们将继续改善这些API

402
00:20:59,526 --> 00:21:01,295
我们添加了一些新附件

403
00:21:01,862 --> 00:21:05,032
第一个是硬件休止和恢复API

404
00:21:05,432 --> 00:21:08,869
当用户同时按下侧边按钮
和数码表冠时

405
00:21:10,003 --> 00:21:13,340
将生成一个事件
你可以在应用中做出回应

406
00:21:14,508 --> 00:21:16,577
因此你可以根据会话所处的状态

407
00:21:16,643 --> 00:21:18,946
暂停和恢复锻炼

408
00:21:21,448 --> 00:21:23,650
第二个是锻炼片段

409
00:21:23,884 --> 00:21:24,818
这可以允许你…

410
00:21:24,885 --> 00:21:27,921
它是HKWorkout事件…
类的一个新类型

411
00:21:28,288 --> 00:21:31,225
允许你在锻炼应用内

412
00:21:31,291 --> 00:21:32,492
标记重要的时间段

413
00:21:32,893 --> 00:21:35,596
可以用于 比如标记

414
00:21:35,662 --> 00:21:37,631
间歇训练中的不同部分

415
00:21:38,866 --> 00:21:41,368
去年我们就开始通过
Apple Workout应用

416
00:21:41,435 --> 00:21:44,938
追踪指定锻炼类型的锻炼路径

417
00:21:45,506 --> 00:21:49,343
获得用户许可后
你可以读取这些锻炼路径

418
00:21:49,409 --> 00:21:51,078
也可以创建自己的路径

419
00:21:52,079 --> 00:21:55,048
现在 如果你有一个锻炼应用
或者你考虑开发一个锻炼应用

420
00:21:55,382 --> 00:21:58,285
你可以稍后参加
本周的锻炼更新演讲

421
00:21:58,385 --> 00:22:00,487
是关于如何使用API

422
00:22:00,554 --> 00:22:03,757
以及HealthKit中的
其它更新的

423
00:22:05,292 --> 00:22:08,929
我们今年还在WatchKit中
添加了新的背景模式

424
00:22:09,296 --> 00:22:11,665
首先是地理位置背景模式

425
00:22:11,999 --> 00:22:14,668
对于基于地理位置的游戏

426
00:22:14,735 --> 00:22:17,037
和路线规划导航应用来说很有用

427
00:22:17,971 --> 00:22:20,607
比如锻炼应用

428
00:22:20,674 --> 00:22:22,709
总是能在用户抬起手腕时可用

429
00:22:24,144 --> 00:22:26,113
如果你需要警示用户

430
00:22:26,180 --> 00:22:27,714
比如拐错弯了

431
00:22:27,781 --> 00:22:30,184
你可以通过来自后台的音频和力触觉

432
00:22:30,250 --> 00:22:31,718
引起他们的注意

433
00:22:33,754 --> 00:22:34,788
正如我刚提到过的

434
00:22:34,855 --> 00:22:39,159
可以跟水锁同时使用的
另一个基于会话的活动

435
00:22:39,226 --> 00:22:40,994
即地理位置模式

436
00:22:41,061 --> 00:22:44,031
你可以在与水相关的活动中结合使用

437
00:22:45,499 --> 00:22:50,404
然而为了保存电量
后台的CPU是有限的

438
00:22:50,537 --> 00:22:53,140
你需要监控后台要实现哪些功能

439
00:22:53,207 --> 00:22:55,042
以及稍后可以保存哪些数据

440
00:22:57,511 --> 00:23:01,815
最后 你必须从前台
开始地理位置会话

441
00:23:01,882 --> 00:23:03,050
就像锻炼会话一样

442
00:23:03,283 --> 00:23:06,119
因此用户总能了解正在发生什么

443
00:23:06,320 --> 00:23:08,055
当你获取地理位置时

444
00:23:08,155 --> 00:23:10,991
会有一个状态指示器和控制中心

445
00:23:11,091 --> 00:23:13,594
因此用户总能监控他们的隐私权

446
00:23:16,163 --> 00:23:20,234
我们还增加了内嵌音频
录制以及后台模式

447
00:23:21,435 --> 00:23:23,670
录音功能
自watchOS 2起就有了

448
00:23:24,104 --> 00:23:27,875
但只能在模式形式中使用
我们会在用户完成录音后

449
00:23:27,941 --> 00:23:30,110
返回给你一个文件

450
00:23:30,544 --> 00:23:33,614
当用户放下手腕时
你可以继续录音

451
00:23:33,714 --> 00:23:36,183
但在整个过程中
屏幕会一直亮着

452
00:23:36,617 --> 00:23:39,853
在watchOS 4中
我们将提供内嵌音频录制功能

453
00:23:39,920 --> 00:23:41,722
来解决这些问题

454
00:23:43,090 --> 00:23:46,159
首先 不再局限于模式形式

455
00:23:46,226 --> 00:23:48,762
因此你可以创建自己的
自定义U录音控件

456
00:23:48,862 --> 00:23:50,697
匹配你的应用的用户界面

457
00:23:51,465 --> 00:23:53,467
你还可以实现内嵌音频录制功能

458
00:23:53,700 --> 00:23:56,370
因此 如果你想在音频中
寻找某一个信号

459
00:23:56,770 --> 00:24:00,174
或如果你想在表上
实现实时转化 都可以实现

460
00:24:01,608 --> 00:24:04,545
当用户放下手腕时
你可以继续录音

461
00:24:04,645 --> 00:24:06,580
但现在是完全的后台模式

462
00:24:06,680 --> 00:24:09,049
你不需要浪费额外的电量

463
00:24:09,116 --> 00:24:10,484
让屏幕一直亮着

464
00:24:11,418 --> 00:24:13,253
想象一下 走进教室

465
00:24:13,320 --> 00:24:15,989
并通过手腕上的表
给整个讲座录音

466
00:24:17,558 --> 00:24:20,160
跟watchOS上的
其他后台模式类似

467
00:24:20,861 --> 00:24:23,830
当用户抬起手腕时 会显示应用

468
00:24:24,298 --> 00:24:27,267
CPU是受限的 应用必须开始…

469
00:24:27,334 --> 00:24:29,603
会话必须从前台开始

470
00:24:30,070 --> 00:24:32,372
当你录音时

471
00:24:32,472 --> 00:24:34,741
表盘上会显示一个指示器

472
00:24:34,808 --> 00:24:37,411
用户可以轻触返回应用

473
00:24:40,581 --> 00:24:42,950
在watchOS 4中
执行持续任务时

474
00:24:43,016 --> 00:24:45,519
这些模式将起到很大的作用

475
00:24:48,088 --> 00:24:48,922
好了

476
00:24:49,790 --> 00:24:53,594
在watchOS 4中
我们还支持Core Bluetooth

477
00:24:53,827 --> 00:24:54,661
这个…

478
00:24:57,564 --> 00:25:00,968
这意味着你可以
直接将蓝牙设备连接到表上

479
00:25:02,069 --> 00:25:04,404
并获得更新的数据
同时延迟时间也变短了

480
00:25:04,471 --> 00:25:08,475
并且当手机不在身边时
可以继续使用

481
00:25:08,742 --> 00:25:12,379
以前 对于蓝牙设备来说
你必须得先连接到手机

482
00:25:12,479 --> 00:25:15,048
然后再通过表连通性迁移数据

483
00:25:15,249 --> 00:25:17,317
数据更新速度要更快才行

484
00:25:17,584 --> 00:25:21,455
通过表上的Core Bluetooth
你最多可以连接两台外围设备

485
00:25:21,922 --> 00:25:25,292
我们只支持中心模式
意思是你需要…

486
00:25:25,359 --> 00:25:27,194
你可以连接到其它设备

487
00:25:27,261 --> 00:25:30,264
但表自身不能作为外部设备使用

488
00:25:31,565 --> 00:25:33,133
在前台

489
00:25:33,200 --> 00:25:36,603
样本之间有一个最小时间
即30毫秒

490
00:25:36,837 --> 00:25:39,540
当与后台模式同时使用时

491
00:25:39,940 --> 00:25:43,177
那个时间就被限制为120毫秒

492
00:25:45,312 --> 00:25:47,748
当你与后台模式同时使用时

493
00:25:47,981 --> 00:25:50,584
后台运行的应用只能连接不能扫描

494
00:25:50,651 --> 00:25:53,187
当应用处于前台时

495
00:25:53,253 --> 00:25:55,189
你需要进行搜索和配对

496
00:25:58,458 --> 00:26:01,128
现在 当应用被挂起时

497
00:26:01,228 --> 00:26:03,263
外部设备将自动断开连接

498
00:26:03,330 --> 00:26:06,366
即便有公告
我们也不会唤醒应用

499
00:26:06,733 --> 00:26:08,302
如果你需要持续更新

500
00:26:08,368 --> 00:26:10,838
你必须在后台模式中使用

501
00:26:13,040 --> 00:26:14,174
要了解更多信息

502
00:26:14,241 --> 00:26:17,511
稍后请参加本周的
Core Bluetooth演讲

503
00:26:18,045 --> 00:26:21,815
但让我们先来看一个
应用是如何使用这个功能的例子

504
00:26:23,383 --> 00:26:26,019
那么ReSound Smart 3D
是一款应用

505
00:26:26,086 --> 00:26:29,623
可以让你连接到蓝牙耳机

506
00:26:29,723 --> 00:26:33,126
从而根据你所在的环境
变更聆听环境

507
00:26:33,560 --> 00:26:35,829
我可以从户外聆听环境改为

508
00:26:35,896 --> 00:26:39,066
餐厅环境
有不同的音频配置文件

509
00:26:39,233 --> 00:26:40,868
只需要轻触手腕上的表即可

510
00:26:41,301 --> 00:26:45,038
并且通过watchOS 4
它们可以直接连接到耳机

511
00:26:45,172 --> 00:26:49,343
因此可以快速更新
并在手机不在身边时

512
00:26:49,409 --> 00:26:50,911
继续使用设备

513
00:26:52,112 --> 00:26:53,447
这就是Core Bluetooth

514
00:26:59,052 --> 00:27:02,556
我提到过一个
Frontmost App State

515
00:27:02,756 --> 00:27:04,825
对于这个东西
我们感到非常激动

516
00:27:04,892 --> 00:27:08,462
因为它将改变我们思考
创建表应用的方式

517
00:27:09,029 --> 00:27:10,931
使用表应用的体验

518
00:27:10,998 --> 00:27:13,934
与其它平台上的不同

519
00:27:14,234 --> 00:27:17,070
当我使用iPhone应用时
我打开应用

520
00:27:17,137 --> 00:27:20,841
使用一段时间 最后按主键

521
00:27:20,908 --> 00:27:22,476
关闭它

522
00:27:23,443 --> 00:27:26,013
然而在表应用中 我可能只使用

523
00:27:26,079 --> 00:27:27,881
很短的时间

524
00:27:27,948 --> 00:27:29,883
也许只有几秒钟

525
00:27:30,717 --> 00:27:35,622
但我可能会在单一会话中
使用应用数十次或更多次

526
00:27:36,089 --> 00:27:41,028
比如 我可能会在小卖部
买东西时使用提醒应用

527
00:27:41,295 --> 00:27:43,664
在将商品放到购物车中时核对物品

528
00:27:44,064 --> 00:27:47,367
每次将商品放入购物车中时
我就抬起手腕

529
00:27:47,434 --> 00:27:49,603
然后就能看到应用

530
00:27:49,670 --> 00:27:54,174
这使找到要核对的物品变得
非常简单 只需要轻触它

531
00:27:54,708 --> 00:27:56,310
然后就可以继续购物

532
00:27:57,277 --> 00:28:01,181
我们恢复应用而不是表盘的过程

533
00:28:01,582 --> 00:28:03,784
叫作Frontmost App State

534
00:28:05,085 --> 00:28:10,023
在watchOS 3中那段时间是
八分钟 在每次手腕抬起之间

535
00:28:10,891 --> 00:28:13,427
这对于用户来说太久了

536
00:28:13,493 --> 00:28:17,431
并且最后在用户结束使用应用
很久后还会显示同一款应用

537
00:28:17,998 --> 00:28:22,369
所以在watchOS 3.2中
我们将这个限制改成了两分钟

538
00:28:25,105 --> 00:28:27,441
会在每次抬起手腕时发生

539
00:28:27,574 --> 00:28:31,812
那么在大多数情况下
大部分活动都会在使用的

540
00:28:31,879 --> 00:28:33,914
整个时段内保持在前台

541
00:28:36,116 --> 00:28:38,252
但我们知道有时候

542
00:28:38,318 --> 00:28:40,554
每次手腕抬起之间的时间间隔

543
00:28:40,621 --> 00:28:42,022
需要更长

544
00:28:42,756 --> 00:28:47,160
为此 我们允许你指定
何时延伸frontmost时间

545
00:28:48,829 --> 00:28:52,699
那将会把时间从两分钟
重新修改为八分钟

546
00:28:52,766 --> 00:28:55,068
让我们看一下如何用代码实现

547
00:28:56,503 --> 00:28:58,472
跟我们今天所讲的其它东西一样

548
00:28:58,572 --> 00:29:00,541
这是一个共享扩展的调用

549
00:29:00,607 --> 00:29:01,875
是一个简单的属性

550
00:29:01,975 --> 00:29:02,843
你可以设为真

551
00:29:02,910 --> 00:29:05,179
当你需要延伸
frontmost时间时

552
00:29:08,048 --> 00:29:10,017
但你必须做出明智的判断

553
00:29:10,083 --> 00:29:13,153
因为我们不想在用户
结束使用应用很久之后

554
00:29:13,220 --> 00:29:15,722
还继续留在应用中

555
00:29:16,990 --> 00:29:19,993
让我们返回去看
我的提醒购物列表示例

556
00:29:20,727 --> 00:29:23,463
当我打开…当我打开购物列表时

557
00:29:23,530 --> 00:29:26,433
我很可能想开启
延伸frontmost时间

558
00:29:26,667 --> 00:29:31,305
因此 如果两条通道之间
有一项需要2分钟以上的时间

559
00:29:31,371 --> 00:29:34,007
我就不必再返回打开应用了

560
00:29:34,675 --> 00:29:37,878
一旦完成购物列表中的项目

561
00:29:37,945 --> 00:29:41,548
就是关闭
延伸frontmost时间的最好时机

562
00:29:41,648 --> 00:29:44,551
应用将在后台自动关闭

563
00:29:44,618 --> 00:29:46,787
而无需用户进行任何操作

564
00:29:47,921 --> 00:29:52,059
除了在处于前台时
提供更多的灵活性之外

565
00:29:52,159 --> 00:29:55,395
我们还修改了API的某些行为

566
00:29:55,562 --> 00:29:58,498
从而拥有最新的更新信息

567
00:29:58,565 --> 00:30:00,834
并实现用户的预期

568
00:30:04,104 --> 00:30:07,441
你已经可以通过
NSProcessInfo的失效活动

569
00:30:07,608 --> 00:30:11,478
将运行时间延长至30秒了

570
00:30:12,112 --> 00:30:15,382
这是进行网络任务的绝佳时机

571
00:30:15,549 --> 00:30:18,519
我们在watchOS 4中
增加了这个请求的优先级

572
00:30:18,785 --> 00:30:21,722
因此你可以在请求时做更多事

573
00:30:25,025 --> 00:30:29,129
并且当你处于frontmost
状态时 如果表的连通性

574
00:30:29,530 --> 00:30:31,164
或URL会话数据
进入你的应用

575
00:30:31,231 --> 00:30:33,367
我们将立即恢复你的应用

576
00:30:33,500 --> 00:30:37,204
并且在大多数情况下
有效负荷会立即开始下载

577
00:30:39,039 --> 00:30:40,541
当你处于frontmost状态时

578
00:30:40,641 --> 00:30:44,244
如果你注意到
数据中有重要信息

579
00:30:44,311 --> 00:30:48,215
如果你有运行时间
你可以通过力触觉警示用户

580
00:30:49,750 --> 00:30:53,053
如果你在该状态时
有通知进来

581
00:30:53,120 --> 00:30:56,190
你可以通过
用户通知API处理

582
00:30:56,256 --> 00:30:58,659
就像应用处于前台时一样

583
00:30:59,593 --> 00:31:03,463
让我们看一个把这些功能
结合在一起的例子

584
00:31:05,566 --> 00:31:08,001
这是一个简单的拼车应用

585
00:31:08,335 --> 00:31:11,405
它显示我有五分钟的等候时间

586
00:31:12,873 --> 00:31:15,843
这种情况就需要
开启延伸frontmost时间

587
00:31:16,009 --> 00:31:17,778
因为我知道很可能

588
00:31:17,845 --> 00:31:20,814
用户需要的时间
比两分钟的超时时间更长

589
00:31:21,849 --> 00:31:23,083
这需要等候

590
00:31:23,183 --> 00:31:25,919
而且我不想一直抬着手腕

591
00:31:25,986 --> 00:31:29,623
所以我就轻触请求拼车按钮
然后放下手腕

592
00:31:30,757 --> 00:31:33,794
现在屏幕关了
但我绝没有完成使用应用

593
00:31:33,927 --> 00:31:35,662
因为我还在等待拼车

594
00:31:36,196 --> 00:31:39,266
在某一时刻
服务器会发送一个推送通知

595
00:31:39,366 --> 00:31:41,335
并转发到我的手表上

596
00:31:41,835 --> 00:31:44,972
那时 应用会处理通知

597
00:31:45,038 --> 00:31:47,207
识别是否为重要信息

598
00:31:47,307 --> 00:31:49,443
然后通过力触觉警示我

599
00:31:50,310 --> 00:31:53,213
当我抬起手腕时
应用已经更新了

600
00:31:53,280 --> 00:31:56,483
显示出重要信息
比如到达时间

601
00:31:56,550 --> 00:31:59,152
以及司机的姓名和星级评分

602
00:31:59,253 --> 00:32:00,954
我甚至还可以呼叫他

603
00:32:02,523 --> 00:32:05,259
然后我会停止
延伸frontmost时间

604
00:32:05,325 --> 00:32:08,729
因为用户现在很可能
完成了对应用的使用

605
00:32:09,496 --> 00:32:13,567
获得正确的frontmost状态信息
将会使你的应用像是拥有魔法一样

606
00:32:13,901 --> 00:32:16,403
了解用户何时完成使用应用

607
00:32:16,470 --> 00:32:18,805
以及何时需要更长的时间

608
00:32:19,273 --> 00:32:22,209
一定要确保
应用中的数据保持更新

609
00:32:22,276 --> 00:32:24,344
并在用户下一次使用应用时

610
00:32:24,411 --> 00:32:26,580
显示他们想要查看的信息

611
00:32:27,214 --> 00:32:30,584
我特别推荐你们参加
今天稍后的演讲

612
00:32:31,051 --> 00:32:32,786
内容是watchOS应用的生命周期

613
00:32:33,053 --> 00:32:36,690
这场演讲将详细讲述
应用的生命周期事件

614
00:32:36,757 --> 00:32:40,427
frontmost状态、后台模式的利用
更多的是如何通过frontmost

615
00:32:40,494 --> 00:32:42,429
实现更棒的表体验

616
00:32:44,631 --> 00:32:47,467
总结一下
我们在用户界面组件中

617
00:32:47,534 --> 00:32:50,704
添加了一堆新功能
使其灵活地

618
00:32:50,771 --> 00:32:55,075
创建自定义用户界面
如叠加界面控制器

619
00:32:56,276 --> 00:32:58,078
以及自动旋转模式

620
00:33:00,380 --> 00:33:04,551
我们修改了表应用的架构
使其性能更好

621
00:33:04,618 --> 00:33:08,222
通过在运行时将扩展
和应用加载到同一个进程中

622
00:33:09,389 --> 00:33:12,893
我们还增加了新的
背景模式和Core Bluetooth支持

623
00:33:13,227 --> 00:33:16,530
并且我们刚了解了
frontmost应用状态

624
00:33:16,663 --> 00:33:20,334
这些使得保持应用数据更新
变得更加简单

625
00:33:22,002 --> 00:33:25,038
我提到了本周的几场演讲

626
00:33:25,138 --> 00:33:27,741
你可以了解关于
表平台开发的更多信息

627
00:33:28,675 --> 00:33:30,377
如果你想了解更多信息

628
00:33:30,444 --> 00:33:34,081
比如演讲视频链接以及其它资源

629
00:33:34,181 --> 00:33:36,583
请访问 developer.apple.com

630
00:33:37,117 --> 00:33:39,686
感谢大家参加
watchOS 4的更新演讲

631
00:33:39,753 --> 00:33:41,889
我迫不及待地等待大家
创建更棒的应用

