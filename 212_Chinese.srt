1
00:00:21,755 --> 00:00:22,589
大家好

2
00:00:27,561 --> 00:00:28,428
欢迎到来

3
00:00:28,562 --> 00:00:31,632
我的名字叫托尼·帕克
我是Apple Foundation团队的经理

4
00:00:31,698 --> 00:00:34,368
我今天和我的同事迈克尔·乐修
还有毅太·费伯一起

5
00:00:34,434 --> 00:00:36,370
告诉你们有关Foundation的新特性

6
00:00:37,404 --> 00:00:38,705
我们今天有三个主题

7
00:00:38,906 --> 00:00:42,276
首先我们要快速浏览一遍
一些新的API重点

8
00:00:42,342 --> 00:00:44,144
来自于今年Foundation
的发布

9
00:00:44,978 --> 00:00:48,081
在那之后 我们要进入
两个主要主题的第一个

10
00:00:48,248 --> 00:00:51,185
键路径和键值观察API

11
00:00:52,386 --> 00:00:56,056
在那之后 我们将讨论
新的编码和解码API

12
00:00:56,924 --> 00:00:59,660
让我们从那些新的API重点开始吧

13
00:01:02,563 --> 00:01:05,299
首先今年我们强化了
FileProvider API

14
00:01:05,364 --> 00:01:07,467
去年我们作为iOS 10
的一部分所引入的

15
00:01:08,302 --> 00:01:10,370
这增强了你交互的能力

16
00:01:10,437 --> 00:01:14,074
在FileProvider扩展
与其他应用之间

17
00:01:15,676 --> 00:01:18,545
我们已经改进了可用存储空间API

18
00:01:18,712 --> 00:01:22,416
这是一个在MSURL上的新API
它让你不仅能了解

19
00:01:22,482 --> 00:01:25,452
你用户的设备上有多少剩余空间可用

20
00:01:25,519 --> 00:01:27,287
而且可以了解
有多少空间可以被利用

21
00:01:27,354 --> 00:01:31,592
如果我们清除像是缓存或者旧数据
这些不必需的内容

22
00:01:33,594 --> 00:01:37,464
我们在NS range和Swift range中
加入了新的API来帮助转换

23
00:01:37,531 --> 00:01:40,367
NS range中NSString的使用

24
00:01:40,434 --> 00:01:42,636
以及Swift range中
Swift string的使用

25
00:01:43,036 --> 00:01:47,374
这对于像是AttributedString和
RegularExpression的类特别有用

26
00:01:49,243 --> 00:01:53,680
在NSXPCConnection中 我们加入了
对于NSProgress更好的支持

27
00:01:54,081 --> 00:01:56,250
实际上第一个东西真的很有趣

28
00:01:56,316 --> 00:02:01,121
因为在扩展
和应用之间新增强的交流能力

29
00:02:01,188 --> 00:02:05,392
实际上是NSXPCConnection
这是今年首次在iOS上可用

30
00:02:06,059 --> 00:02:08,929
NSURLSession也获得了对于
NSProgress的支持

31
00:02:09,062 --> 00:02:10,931
因为我们希望你们可以使用

32
00:02:10,997 --> 00:02:15,736
所有这些进程功能来使得从下载

33
00:02:15,802 --> 00:02:19,339
到扩展 到应用
到显示给你的用户一气呵成

34
00:02:21,175 --> 00:02:23,110
最后我们还引入了热通知

35
00:02:23,177 --> 00:02:25,012
今年从Mac到iOS上

36
00:02:26,246 --> 00:02:28,582
对于这些主题的更多内容
请参见Cocoa新特性

37
00:02:28,649 --> 00:02:30,150
它是在今天早上
如果你错过了的话

38
00:02:30,217 --> 00:02:33,554
在那场演讲上 我们有相当多
关于Foundation的内容

39
00:02:35,656 --> 00:02:38,625
性能也是我们今年在Foundation上的

40
00:02:38,692 --> 00:02:40,027
一个关键考虑因素

41
00:02:40,260 --> 00:02:43,564
从一个有关NSArray的
新copy-on-write行为开始

42
00:02:43,630 --> 00:02:46,767
以及它的词典 NSSet
还有它们易变的朋友

43
00:02:47,568 --> 00:02:50,771
对于它一个很大的刺激因素是
将桥接引入到Swift

44
00:02:51,104 --> 00:02:55,209
因此当Objective-C API
返回NSArray时

45
00:02:55,275 --> 00:02:57,911
也许是在一个框架里
并且你在Swift中使用它

46
00:02:57,978 --> 00:03:01,048
你接收到了Swift的值类型：
阵列、词典和套

47
00:03:01,448 --> 00:03:03,317
为了保留这些值语义

48
00:03:03,383 --> 00:03:06,486
那些结构在引入类型上调用复制

49
00:03:06,553 --> 00:03:07,821
当它们在做桥接的时候

50
00:03:08,222 --> 00:03:10,858
如果结果恰好是共有子类的一个

51
00:03:10,924 --> 00:03:12,793
那么复制会开销很大

52
00:03:13,227 --> 00:03:17,030
现在我们可以延迟复制的花销
直到其真的改变了

53
00:03:17,097 --> 00:03:18,365
如果真发生的话

54
00:03:18,432 --> 00:03:20,868
这会导致相当大的改进

55
00:03:20,934 --> 00:03:22,269
对于桥接时的性能来说

56
00:03:23,904 --> 00:03:27,174
结构体数据作为
Swift Foundation的一部分

57
00:03:27,241 --> 00:03:29,576
也获得很多性能增强

58
00:03:29,743 --> 00:03:33,046
特别酷的是 我们可以直列

59
00:03:33,113 --> 00:03:36,450
数据行为的关键部分到你的应用里
当你编译的时候

60
00:03:36,850 --> 00:03:40,754
这包括像是在数据里挨个字节编序号

61
00:03:40,821 --> 00:03:44,892
这同样获得相当大的性能改进

62
00:03:46,093 --> 00:03:48,095
NSCalendar获得了
更好的性能表现

63
00:03:48,161 --> 00:03:50,797
在CPU时间以及
更低的峰值内存方面

64
00:03:50,864 --> 00:03:52,900
除此之外 我们还改进了结果

65
00:03:52,966 --> 00:03:55,202
它所给你的 特别是在边界情况上

66
00:03:56,670 --> 00:04:00,374
最后我们改进了桥接NSNumber
发往和来自于Swift的性能表现

67
00:04:00,440 --> 00:04:03,944
我们同样也改进了
其在边界情况的行为

68
00:04:04,011 --> 00:04:07,347
来提供更好的安全性
当你在转换

69
00:04:07,414 --> 00:04:10,517
从NSNumber到Swift数据类型时
像是整型、布尔这些

70
00:04:11,351 --> 00:04:14,755
这种更快的桥接对于像是属性表解析
这类有着很大的影响

71
00:04:15,522 --> 00:04:16,957
有关这些主题的更多内容

72
00:04:17,024 --> 00:04:18,858
请观看“与框架高效互动”

73
00:04:18,926 --> 00:04:20,427
那是在周五下午1：50

74
00:04:21,228 --> 00:04:23,430
现在我将舞台交给我的同事迈克尔

75
00:04:23,497 --> 00:04:25,699
来谈谈键路径和键值观察

76
00:04:34,942 --> 00:04:35,876
谢谢 托尼

77
00:04:36,376 --> 00:04:40,447
嗨 我是来自Foundation团队的迈克尔
我很兴奋可以共享一些改进

78
00:04:40,514 --> 00:04:43,584
有关我们今年对于键路径
和键值观察所做的

79
00:04:43,650 --> 00:04:47,487
我想要从Foundation团队中
有强烈感觉的一些东西谈起

80
00:04:47,855 --> 00:04:48,956
就是键路径

81
00:04:49,022 --> 00:04:51,291
在Cocoa开发中非常重要

82
00:04:51,892 --> 00:04:54,628
因为它让我们推论出类型的结构

83
00:04:54,695 --> 00:04:56,830
除了任何特定情况

84
00:04:56,897 --> 00:04:59,266
以一种比起终结更具限制性的方式

85
00:05:00,234 --> 00:05:02,836
我们觉得这非常重要
因为它们保证了

86
00:05:02,903 --> 00:05:04,805
对于语言本身的特别处理

87
00:05:08,108 --> 00:05:12,713
我们从去年将字符串键路径添加
到Swift 3就开始着手做这个了

88
00:05:13,547 --> 00:05:18,051
其使得Swift获得了能力
在编译时间

89
00:05:18,118 --> 00:05:20,521
保证了一个Objective-C
键路径的正确性

90
00:05:21,154 --> 00:05:22,155
也就是我现在要说的

91
00:05:22,556 --> 00:05:24,024
假设我们有个Kid类

92
00:05:24,091 --> 00:05:25,926
它有一些键值可观察的属性

93
00:05:25,993 --> 00:05:27,761
像是他们的昵称 年龄

94
00:05:27,828 --> 00:05:30,130
当然了 还有他们现在最好的朋友

95
00:05:30,197 --> 00:05:32,065
我们可以继续构造一个实例

96
00:05:32,132 --> 00:05:34,168
在这里例子中 一个叫本基的小男孩

97
00:05:35,235 --> 00:05:38,272
然后形成了一个到孩子昵称属性
的字符串键径

98
00:05:38,505 --> 00:05:40,707
接着 Swift编译器会确认

99
00:05:40,774 --> 00:05:42,910
这对我们来说是合理的

100
00:05:43,810 --> 00:05:46,813
接着我们可以用键值或者键值编码

101
00:05:46,880 --> 00:05:49,783
来读取或者将该变量写回到实例中

102
00:05:51,518 --> 00:05:53,220
现在 我们通过字符串键径

103
00:05:53,287 --> 00:05:56,456
而获得的当前编译时间检查
表达式非常棒

104
00:05:56,823 --> 00:05:59,193
最终它还是会编译到一个字符串

105
00:06:00,093 --> 00:06:03,630
为了让该字符串有用
我们需要使用Objective-C运行时间

106
00:06:03,697 --> 00:06:07,201
之前我看的时候
对于Swift值类型还是不可用的

107
00:06:07,267 --> 00:06:09,703
而且大概短时间内不可能变得可用

108
00:06:10,771 --> 00:06:15,142
最后 字符串键径不携带类型信息

109
00:06:15,209 --> 00:06:16,376
它就是一个字符串

110
00:06:17,678 --> 00:06:20,414
因此所有使用字符串键径
的通用API

111
00:06:20,480 --> 00:06:23,217
无论如何都需要被定义

112
00:06:25,052 --> 00:06:27,821
但这是Swift
我们当然可以做得更好

113
00:06:28,355 --> 00:06:30,257
因为我们考虑 什么可以

114
00:06:30,324 --> 00:06:32,593
键径 它们在Swift中
应该是什么样呢？

115
00:06:33,427 --> 00:06:35,195
首先我们想要能描述属性

116
00:06:35,262 --> 00:06:36,597
这很必要

117
00:06:36,663 --> 00:06:38,398
它们应该是静态类型安全的

118
00:06:39,766 --> 00:06:40,934
它们同样也要很快

119
00:06:41,301 --> 00:06:44,705
并且它们应该可以处理
我们在Swift中所能遇到的所有值

120
00:06:46,340 --> 00:06:49,376
它们应该可以在
Swift所支持的所有平台工作

121
00:06:49,977 --> 00:06:51,211
因此我们考虑了很长时间

122
00:06:51,278 --> 00:06:54,014
如何使得所有这些键径梦想成真

123
00:06:54,348 --> 00:06:56,283
最终跟世界分享我们的点子

124
00:06:56,350 --> 00:06:58,418
通过开源Swift进化过程

125
00:06:58,485 --> 00:07:02,322
还有一份名为
SE-0161智能键径的文档

126
00:07:02,856 --> 00:07:05,692
这就是Swift 4中
新键径字面量看起来是什么样的

127
00:07:07,227 --> 00:07:09,029
从反斜线符号开始

128
00:07:10,597 --> 00:07:12,666
跟着基类型的名字

129
00:07:13,166 --> 00:07:16,603
一个点表明我们是在该基类型里
要做些什么

130
00:07:16,670 --> 00:07:18,172
然后就是属性的名字

131
00:07:19,540 --> 00:07:21,508
这里的反斜线符号很重要

132
00:07:21,575 --> 00:07:24,611
因为它帮助我们消除了
执行属性的歧义

133
00:07:24,678 --> 00:07:27,247
还有属性的提及或者引用

134
00:07:28,148 --> 00:07:33,487
当然了这是Swift
因此当我们推断基类型时

135
00:07:33,554 --> 00:07:35,389
仅通过反斜线符号和点的部分

136
00:07:37,257 --> 00:07:39,059
键径可以依次形成

137
00:07:39,126 --> 00:07:41,862
就像是属性接着属性地调用

138
00:07:42,663 --> 00:07:46,066
很快地 任选链接会像它
对于属性那样工作

139
00:07:49,469 --> 00:07:52,105
我们很快会允许通过下标的间接使用

140
00:07:55,409 --> 00:07:56,877
就像是这样 我也喜欢

141
00:08:00,214 --> 00:08:02,249
键径也可以从一个下标直接开始

142
00:08:02,316 --> 00:08:05,652
这里我们从数据的字节下标开始

143
00:08:05,719 --> 00:08:08,222
这里我们用startIndex表示

144
00:08:09,223 --> 00:08:11,692
当然了 这也可以被推断

145
00:08:11,758 --> 00:08:14,828
通过反斜线符号与点剩余部分
来保持一致性

146
00:08:15,896 --> 00:08:19,967
这些新键径表达式给所有
Swift类型提供了一致的语法

147
00:08:20,033 --> 00:08:23,070
对于支持属性
无论是保存的还是计算的

148
00:08:24,271 --> 00:08:27,808
当然了 生成键径是一回事
但我们如何使用它们呢？

149
00:08:28,342 --> 00:08:30,143
假设我们有一个键径

150
00:08:32,246 --> 00:08:33,780
这里是一个孩子的年龄

151
00:08:34,280 --> 00:08:37,851
使用键径来读取一个属性
就像是调用下标一样简单

152
00:08:40,053 --> 00:08:41,154
这开始像是代码

153
00:08:41,221 --> 00:08:43,423
我现在会高亮句法

154
00:08:44,558 --> 00:08:45,592
好了

155
00:08:46,426 --> 00:08:47,895
这里发生了些什么 我想要谈谈

156
00:08:47,961 --> 00:08:51,598
一些背景动机
为什么它看起来是这个样子

157
00:08:51,798 --> 00:08:55,669
首先我们给键径下标参数一个标签

158
00:08:55,936 --> 00:08:58,438
我们这样做是因为我们想让它
不会与其他下标产生歧义

159
00:08:58,505 --> 00:09:00,007
对于其他类型可以存在的下标

160
00:09:00,307 --> 00:09:02,376
接着 你正在使用的值类型

161
00:09:02,442 --> 00:09:05,979
它在调用下标
需要与键径的基类型相匹配

162
00:09:06,580 --> 00:09:08,549
如果它们匹配 这是合理的事

163
00:09:08,615 --> 00:09:10,484
你的代码就会编译

164
00:09:12,419 --> 00:09:16,623
你也可以用下标来变动一个特定的值

165
00:09:17,257 --> 00:09:20,694
下标非常好 因为它们提供了
一个快速对称的句法

166
00:09:20,761 --> 00:09:21,828
来读取和写入一个值

167
00:09:21,895 --> 00:09:24,064
无论它们是一个值类型还是引用类型

168
00:09:25,065 --> 00:09:27,501
我已经展示了引用类型的情况

169
00:09:27,568 --> 00:09:30,404
现在我想要换成展示
它们如何跟值类型协同运作的

170
00:09:30,637 --> 00:09:32,406
为了这个目的 我们会扩展例子

171
00:09:32,472 --> 00:09:33,974
到我真正想谈的地方

172
00:09:34,041 --> 00:09:35,709
也就是生日派对计划

173
00:09:37,244 --> 00:09:38,879
让我们创建一个派对

174
00:09:39,513 --> 00:09:42,850
看起来本基要举办一个
建造主题的生日派对

175
00:09:42,916 --> 00:09:45,018
通过一个键径来读取值类型

176
00:09:45,085 --> 00:09:48,522
使用了和我们之前看到的
引入类型相同的下标句法

177
00:09:49,122 --> 00:09:53,393
类似地 改动一个派对
也是使用相同的下标句法

178
00:09:53,460 --> 00:09:56,230
这是个常见的主题
句法真的是一致的

179
00:09:56,897 --> 00:10:01,201
然而既然这是Swift
我们知道本的派对是一个生日派对

180
00:10:01,268 --> 00:10:03,403
因此语言可以为我们推断这一点

181
00:10:04,771 --> 00:10:07,875
我刚听说本
又想改他生日派对的主题了

182
00:10:07,941 --> 00:10:09,510
那么我们就在这里改过来吧

183
00:10:10,744 --> 00:10:12,713
这里我高亮了一下句法

184
00:10:12,846 --> 00:10:15,249
像是这样的代码
你只会调用属性

185
00:10:15,315 --> 00:10:19,086
所以让我们看看当你使用这些键径
表达式的时候实际发生了什么吧

186
00:10:21,755 --> 00:10:24,558
键径表达式
实际上生成了真正的值

187
00:10:24,625 --> 00:10:26,527
像是所有的值 它们能被保存

188
00:10:28,095 --> 00:10:29,963
那么 这个变量的类型是什么呢？

189
00:10:30,030 --> 00:10:33,834
让我们假设使用Option加X键
就像是我们在Xcode中所能做的那样

190
00:10:33,901 --> 00:10:37,004
不出意外 我们得到了
一个强类型的键径

191
00:10:37,571 --> 00:10:40,874
其基类型是Kid
属性类型是String

192
00:10:40,941 --> 00:10:42,476
因为昵称是字符串

193
00:10:44,077 --> 00:10:46,880
强类型键径也可以适用于复合键径

194
00:10:46,947 --> 00:10:48,849
这里我们从生日派对开始

195
00:10:48,916 --> 00:10:51,118
一直遍历到庆祝者的年龄

196
00:10:51,418 --> 00:10:54,354
当然了年龄是double类型
因为如果你不认识一个小孩子

197
00:10:54,421 --> 00:10:57,057
小数点后的数字是非常重要的

198
00:10:58,992 --> 00:11:01,929
变量所保存的键径
可以像字面量那样用

199
00:11:06,066 --> 00:11:07,434
因为它们是强类型的

200
00:11:07,501 --> 00:11:09,369
它们是静态被认知拥有正确类型的

201
00:11:09,436 --> 00:11:11,171
这里是如我们所期望的double

202
00:11:12,206 --> 00:11:14,675
假设我们要计划另一个生日派对

203
00:11:14,741 --> 00:11:17,678
这次是米亚的
或者本的妹妹米亚

204
00:11:18,612 --> 00:11:20,047
我们可以使用相同的键径变量

205
00:11:20,113 --> 00:11:22,616
来找出她要庆祝的是哪个生日

206
00:11:22,683 --> 00:11:26,653
通过这种方式 键径某种程度上
作为未执行属性调用来使用

207
00:11:27,754 --> 00:11:30,390
在这个例子中
我直接写入了庆祝者的年龄

208
00:11:30,457 --> 00:11:32,492
但是让我们更进一步泛化一点

209
00:11:33,126 --> 00:11:35,762
如果我想知道
任何跟一个派对有关的人的年龄呢？

210
00:11:36,530 --> 00:11:38,532
我们要定义一个函数

211
00:11:38,632 --> 00:11:41,168
把它叫做
partyPersonsAge函数

212
00:11:41,235 --> 00:11:45,405
它们被给了一个派对和
参与者的键径并将返回他们的年龄

213
00:11:45,672 --> 00:11:47,574
为了达成这个目的
我要展示另一个功能

214
00:11:47,641 --> 00:11:49,810
这些类型安全的键径

215
00:11:49,877 --> 00:11:53,547
可以动态地从其他键径生成新的键径

216
00:11:53,881 --> 00:11:56,283
这里我会把两个键径连到一起

217
00:11:56,350 --> 00:11:59,720
participantPath到孩子的年龄
同样 我们这里推断了是孩子

218
00:11:59,786 --> 00:12:03,290
这就是为什么除了变量名
你都看不到“kid”这个词

219
00:12:03,824 --> 00:12:06,326
如你所料
你会获得一个强类型的键径

220
00:12:06,393 --> 00:12:08,662
从BirthdayParty开始
以Double结尾

221
00:12:09,463 --> 00:12:13,367
用这个键径和存在变量中的
其他键径一样

222
00:12:13,700 --> 00:12:15,369
我们可以在庆祝者中
调用我们的函数

223
00:12:15,435 --> 00:12:18,172
我们可以得到和之前所见
完全相同的结果

224
00:12:19,106 --> 00:12:22,209
当支持下标的时候
我们现在也可以使用这个函数

225
00:12:22,276 --> 00:12:25,012
来找到派对的第一个到场者的年龄

226
00:12:27,080 --> 00:12:30,050
现在我想要谈一些
关于附加键径的规则

227
00:12:30,617 --> 00:12:34,288
当我们把两个键径连到一起时
就像我们把它们加到了一起

228
00:12:35,556 --> 00:12:37,524
为了让这个相加能讲得通

229
00:12:37,591 --> 00:12:40,327
我们需要看看
所涉及的键径的类型

230
00:12:41,028 --> 00:12:44,231
我们需要看每个基类型
和每个属性类型

231
00:12:45,966 --> 00:12:48,202
内部类型需要匹配

232
00:12:48,302 --> 00:12:51,004
如果是这种情况的话
我们可以生成一个键径

233
00:12:51,071 --> 00:12:54,341
从初始基类型到最终属性类型

234
00:12:56,476 --> 00:13:00,080
这样 键径不在乎它们是如何获得

235
00:13:00,147 --> 00:13:01,882
从它们的基类型到属性类型

236
00:13:01,949 --> 00:13:04,618
它们能办到
而且编译器会为我们确保这一点

237
00:13:06,019 --> 00:13:07,955
现在我想看看另一个例子

238
00:13:08,021 --> 00:13:11,225
或者说Swift键径
所提供的类型安全性的另一个方面

239
00:13:13,627 --> 00:13:14,995
以防你们还不是很清楚

240
00:13:16,129 --> 00:13:18,398
假设我们想输出一个我们派对的概要

241
00:13:18,532 --> 00:13:21,068
我们可以在键径中
生成一个label数组

242
00:13:22,402 --> 00:13:25,539
但是我们会期望这个数组
partyPath什么呢

243
00:13:25,606 --> 00:13:27,441
我们期望它的类型是什么呢？

244
00:13:27,508 --> 00:13:29,109
毕竟主题是一个字符串

245
00:13:29,476 --> 00:13:31,211
Attending是一个孩子的数组

246
00:13:31,778 --> 00:13:34,081
celebrant
是对单独一个孩子的引用

247
00:13:35,215 --> 00:13:36,717
这种情况下
我们获得了一个新类型

248
00:13:36,783 --> 00:13:39,686
它是一个关于BirthdayParty的
PartialKeyPath数组

249
00:13:40,220 --> 00:13:43,190
PartialKeyPath部分
是无类型键径

250
00:13:43,557 --> 00:13:44,825
它们知道它们的基类型

251
00:13:44,892 --> 00:13:50,597
但是它们可以指向任何对于
该基类型来说合法的键径

252
00:13:50,664 --> 00:13:53,734
这样我们打印出报告

253
00:13:54,368 --> 00:14:00,874
我们把titles和paths压缩到一起
使用partyPath来获取partyValue

254
00:14:00,941 --> 00:14:02,176
然后打印我们的报告

255
00:14:02,576 --> 00:14:04,578
你可以看到米亚要举办
一个太空主题的

256
00:14:04,645 --> 00:14:06,480
看起来是个家庭生日派对

257
00:14:06,547 --> 00:14:08,682
不过它是太空主题的
应该挺有意思

258
00:14:11,218 --> 00:14:13,487
现在我想往BirthdayParty中
添加一个扩展

259
00:14:13,687 --> 00:14:14,755
我们要添加一个函数

260
00:14:14,821 --> 00:14:16,590
来让孩子们吹灭他们的生日蜡烛

261
00:14:16,657 --> 00:14:17,724
这会和我们之前所做的

262
00:14:17,791 --> 00:14:19,326
有点不一样

263
00:14:19,393 --> 00:14:21,161
因为到目前为止
我们一直在读取键径

264
00:14:21,228 --> 00:14:23,997
现在我想要写入到一个键径
或者使用键径来写入到一个值

265
00:14:25,265 --> 00:14:26,567
我们要加入我们的函数

266
00:14:27,000 --> 00:14:29,236
我想要指出的是
ageKeyPath实际上是一个新的类型

267
00:14:29,303 --> 00:14:32,940
它是一个可写的键径
从BirthdayParty开始 以Double结尾

268
00:14:34,374 --> 00:14:37,544
我们可以像是一般键径
那样来使用可写键径

269
00:14:37,611 --> 00:14:39,913
从我们的值中得到想要的值

270
00:14:40,480 --> 00:14:42,549
我们也可以使用它们来变动我们的值

271
00:14:43,183 --> 00:14:45,352
我们终于要吹灭蜡烛了

272
00:14:45,619 --> 00:14:48,155
除了一个问题
这一切看起来都很好

273
00:14:48,789 --> 00:14:49,723
它不编译

274
00:14:50,290 --> 00:14:51,859
这是个生日灾难

275
00:14:53,861 --> 00:14:56,296
让我们尝试一下
我会现场解决这个问题

276
00:14:56,964 --> 00:14:57,798
排除障碍

277
00:14:58,832 --> 00:15:00,467
编译器告诉我们

278
00:15:00,534 --> 00:15:03,237
“无法分配到不可改变的
表达类型Double”

279
00:15:03,437 --> 00:15:05,372
这是非常Swift的风格

280
00:15:06,173 --> 00:15:07,941
让我们看看能否知道到底是怎么回事

281
00:15:08,041 --> 00:15:11,044
它说不可变的
但我们传的是一个可写的键径

282
00:15:12,045 --> 00:15:13,981
我们确实传的是一个键径

283
00:15:14,047 --> 00:15:17,050
让我们确定这个键径
实际上是个不可变的变量

284
00:15:17,117 --> 00:15:19,586
有时候你应该用的是
var而你用的是let

285
00:15:19,653 --> 00:15:21,255
让我们回到kid的声明

286
00:15:21,321 --> 00:15:24,124
但我们看到的是var
我们的年龄的确是可变的

287
00:15:24,391 --> 00:15:26,693
是var 所以没有问题

288
00:15:27,528 --> 00:15:30,097
也许问题是写入本身

289
00:15:30,163 --> 00:15:31,665
也就是我们用了subscript

290
00:15:31,732 --> 00:15:33,667
我现在告诉你们
subscript是可以工作的

291
00:15:33,734 --> 00:15:35,135
所以不是这个问题

292
00:15:35,402 --> 00:15:37,504
肯定是self有什么问题

293
00:15:38,472 --> 00:15:41,375
self是什么？
self是BirthdayParty的一个扩展

294
00:15:41,441 --> 00:15:43,477
因此现在我们需要回到
BirthdayParty的声明

295
00:15:43,544 --> 00:15:44,711
幸运的是 我们还有余地

296
00:15:46,580 --> 00:15:48,949
我们会发现BirthdayParty
是一个结构体

297
00:15:49,016 --> 00:15:50,417
而结构体是值类型的

298
00:15:50,484 --> 00:15:52,452
因此这里编译器所做的是正确的

299
00:15:52,519 --> 00:15:54,321
它不让我们变动BirthdayParty

300
00:15:54,388 --> 00:15:57,724
因为我们的键径是
固定在BirthdayParty

301
00:15:58,292 --> 00:15:59,526
我们能用的一个技巧就是

302
00:15:59,593 --> 00:16:03,130
我们看看所知道的Swift的技巧
会发现

303
00:16:03,197 --> 00:16:05,999
我们加上mutating就行了
一切都能正常运行了

304
00:16:07,401 --> 00:16:09,203
但是当你这么做的时候
你会要停下来想想

305
00:16:09,269 --> 00:16:11,004
这真的是正确的选择吗？

306
00:16:11,238 --> 00:16:16,343
因为我们不想改动键
或者是BirthdayParty

307
00:16:17,044 --> 00:16:18,111
我们要改动的是庆祝者

308
00:16:18,178 --> 00:16:20,681
我刚检查过
BirthdayParty没有年龄

309
00:16:21,081 --> 00:16:24,218
而庆祝者实际上是一个类
一个引用类型

310
00:16:24,985 --> 00:16:27,321
对于这点 我们实际上有另一类键径

311
00:16:27,387 --> 00:16:31,325
添加引入可变语义到变动中

312
00:16:31,391 --> 00:16:33,527
它叫作引用可写键径

313
00:16:34,695 --> 00:16:36,063
那么让我们使用它

314
00:16:36,129 --> 00:16:37,431
这次编译通过了

315
00:16:37,497 --> 00:16:39,466
我们可以最终声明我们的小男孩本基

316
00:16:39,533 --> 00:16:42,236
大了一岁
尽管我觉得他现在叫本了

317
00:16:43,270 --> 00:16:44,338
我们可以看看区别

318
00:16:44,404 --> 00:16:46,874
在这两种变动键径的方法之间

319
00:16:48,208 --> 00:16:49,977
我们有个
WritableKeyPath

320
00:16:50,043 --> 00:16:53,547
WritableKeyPath
直接写入到它们的值类型base上

321
00:16:53,881 --> 00:16:57,017
因此base或者链式的base
需要是可变动的

322
00:16:58,719 --> 00:17:03,156
然而一个ReferenceWritableKeyPath
会在引用类型上调用一个属性setter

323
00:17:03,557 --> 00:17:06,326
所有这些键径类型
生成了一个继承树

324
00:17:07,794 --> 00:17:09,730
每个都比上一个更详细

325
00:17:10,063 --> 00:17:11,565
这棵树最上面的根

326
00:17:11,632 --> 00:17:13,666
是另一种我没有提到过的键径

327
00:17:13,733 --> 00:17:16,837
叫作AnyKeyPath
这是一种完全无类型的键径

328
00:17:17,003 --> 00:17:18,771
这对于你有键径时很有用

329
00:17:18,839 --> 00:17:21,575
该键径是由多个base到
多个不同属性类型所组成

330
00:17:21,642 --> 00:17:22,809
通常是一个集

331
00:17:24,144 --> 00:17:26,380
如果这一切似乎有一点复杂

332
00:17:26,445 --> 00:17:28,815
我向你保证
有关你想要的这种键径的规则

333
00:17:28,882 --> 00:17:32,286
使用 还有获得
实际上很简单

334
00:17:32,352 --> 00:17:34,421
还符合你已经熟悉的规则

335
00:17:34,488 --> 00:17:37,524
关于Swift值类型和引用类型的

336
00:17:38,725 --> 00:17:41,128
我们先解决一半问题

337
00:17:41,328 --> 00:17:44,665
只读属性总会产生一个键径

338
00:17:44,731 --> 00:17:46,466
（键径）

339
00:17:46,767 --> 00:17:49,603
而可读写属性
事情就有些细微差别了

340
00:17:50,938 --> 00:17:54,041
可变值类型base或者
链式可变值类型base

341
00:17:54,107 --> 00:17:56,310
会生成一个
WritableKeyPath

342
00:17:57,010 --> 00:18:01,515
WritableKeyPath
可以帮你更有效率地写入一个值类型

343
00:18:02,382 --> 00:18:04,418
然而如果其中一个值类型

344
00:18:05,519 --> 00:18:07,754
是不可变的 就像是一个let语句

345
00:18:08,655 --> 00:18:10,190
该属性的可变性就消失了

346
00:18:10,257 --> 00:18:13,026
就好像你使用一般属性的时候

347
00:18:13,227 --> 00:18:14,828
你就剩下了KeyPath

348
00:18:15,796 --> 00:18:17,564
最后讲个最简单的例子

349
00:18:17,631 --> 00:18:19,733
在引入类型base上的可读写属性

350
00:18:19,800 --> 00:18:22,102
总是生成
ReferenceWritableKeyPath

351
00:18:23,704 --> 00:18:27,074
现在我想分享下关于
键径行为的最后一个细节

352
00:18:28,108 --> 00:18:30,210
当我们和subscript一起
使用键径的时候

353
00:18:30,277 --> 00:18:33,547
知道它们的行为和终结
有什么区别很重要

354
00:18:34,648 --> 00:18:36,183
思考下面的例子

355
00:18:36,550 --> 00:18:37,684
这里我要生成一个键径

356
00:18:37,751 --> 00:18:39,686
来自于生日派对的第一个到场者

357
00:18:40,153 --> 00:18:41,622
并且使用它来识别他们的年龄

358
00:18:41,688 --> 00:18:45,692
使用我们前面的partyPersonAge方法
来识别他们的年龄

359
00:18:46,226 --> 00:18:49,029
不出所料 这里我们得到的键径

360
00:18:49,096 --> 00:18:51,732
是我们attendees数组
的第0个元素

361
00:18:53,133 --> 00:18:54,835
假设我把序号变成了1

362
00:18:54,902 --> 00:18:58,205
出于某种原因
我也关心第二个到场者的年龄

363
00:18:59,506 --> 00:19:01,175
你可能会感到惊讶

364
00:19:02,342 --> 00:19:04,978
结果键径没有变化

365
00:19:05,045 --> 00:19:06,980
尽管我把序号改变了

366
00:19:07,481 --> 00:19:10,450
通过这种方式
键径变得和终结不一样

367
00:19:10,851 --> 00:19:12,286
它们由值所捕获

368
00:19:12,452 --> 00:19:14,421
当这个功能变得可用时

369
00:19:14,488 --> 00:19:16,957
我想要今天说以便你不会感到惊讶

370
00:19:17,858 --> 00:19:18,825
我现在说了

371
00:19:20,060 --> 00:19:24,698
到目前为止 我们已看了许多
关于这些类型安全键径的例子

372
00:19:24,765 --> 00:19:29,670
满足了我们快速、类型安全以及
富于表现的属性遍历目标

373
00:19:31,104 --> 00:19:32,906
我想要换个主题了

374
00:19:32,973 --> 00:19:34,341
因为我想谈谈
这些键径是如何

375
00:19:34,408 --> 00:19:37,010
被用来改进
目前Swift已存在的API的

376
00:19:37,744 --> 00:19:39,446
特别是我想谈谈我们如何应用它们

377
00:19:39,513 --> 00:19:40,781
到键值观察上

378
00:19:42,349 --> 00:19:45,619
你们大概知道
KVO是Cocoa允许对象

379
00:19:45,686 --> 00:19:49,022
建立状态变化通知关系的方式

380
00:19:49,590 --> 00:19:52,292
如果你已经试着
用过目前Swift中的KVO

381
00:19:52,359 --> 00:19:56,063
你大概知道它有点偏离预期了

382
00:19:58,799 --> 00:20:00,868
假设我们有个引用

383
00:20:02,536 --> 00:20:04,004
先别鼓掌 过会儿再鼓

384
00:20:05,572 --> 00:20:08,175
假设我们有个对于
Objective-C值的引用

385
00:20:08,242 --> 00:20:10,410
从前面例子里的小孩米亚

386
00:20:10,477 --> 00:20:13,180
我们关心这个孩子的年龄变化

387
00:20:14,348 --> 00:20:18,185
我们认为形成一个观察
应该像这样简单

388
00:20:18,252 --> 00:20:19,119
现在鼓掌吧

389
00:20:25,092 --> 00:20:27,361
我想要说明这个形成过程的一些细节

390
00:20:27,861 --> 00:20:31,164
我们要在值类型上
直接生成我们的observation

391
00:20:31,431 --> 00:20:33,333
使用我们新的类型安全键径

392
00:20:34,067 --> 00:20:35,302
我们得到的是一个类似于

393
00:20:35,369 --> 00:20:38,505
我们Notification Center API的
observation token

394
00:20:38,572 --> 00:20:40,941
这个observation token
做了两件事

395
00:20:41,008 --> 00:20:44,778
第一 它省去了我们
要处理不安全裸指针的麻烦

396
00:20:44,845 --> 00:20:47,648
有着独一无二识别我们
observation的上下文环境

397
00:20:47,881 --> 00:20:51,785
我们的observation直接联系着
我们返回得到的observation

398
00:20:51,985 --> 00:20:54,721
第二 它管理了我们observation
的生命周期

399
00:20:55,022 --> 00:20:57,558
如果我…我不能将它设成nil…

400
00:20:57,624 --> 00:21:00,561
但是如果我把它设成nil
observation就会毁坏

401
00:21:01,094 --> 00:21:03,430
这是个巨大的改进 而不是获得异常

402
00:21:03,497 --> 00:21:06,700
当你忘了去除注册observation时
你的应用会崩溃

403
00:21:07,968 --> 00:21:10,237
最后 这可能是最棒的部分

404
00:21:10,304 --> 00:21:14,808
现在你可以利用终结来掌握
observation的反应

405
00:21:15,108 --> 00:21:18,612
而不是嵌套if语句
来检查和比较字符串

406
00:21:19,112 --> 00:21:22,149
让我们看看这个终结里面的参数

407
00:21:23,050 --> 00:21:25,986
它有两个参数
第一个是被观察的对象本身

408
00:21:26,153 --> 00:21:29,590
这个是相同的引用 米亚
但我们将它作为参数来提供

409
00:21:30,357 --> 00:21:33,694
来帮助你避免意外创建了保持循环

410
00:21:34,862 --> 00:21:37,631
第二个参数是一个change对象

411
00:21:37,698 --> 00:21:40,868
这和现存的KVO API很类似
只不过

412
00:21:40,934 --> 00:21:42,703
如果你用过 如果你熟悉那个API

413
00:21:42,769 --> 00:21:44,571
你就会知道那是个松类型词典

414
00:21:44,638 --> 00:21:46,773
而这里我们提供的是强类型结构体

415
00:21:46,840 --> 00:21:49,109
因为键径 我们知道
observed是Kid 而且我们知道

416
00:21:49,176 --> 00:21:52,212
因为键径 我们知道
变化的年龄是double类型

417
00:21:52,479 --> 00:21:54,448
现在我想让这变得真实一点

418
00:21:54,515 --> 00:21:55,582
我们会举个例子

419
00:21:55,816 --> 00:21:58,552
假设我们有个控制器
检测孩子什么时候长大

420
00:21:58,619 --> 00:22:00,287
叫做KindergartenController

421
00:22:00,354 --> 00:22:03,223
它有一个键值 可观察属性

422
00:22:03,390 --> 00:22:06,059
叫做representedKid
我们要生成一个observation

423
00:22:06,126 --> 00:22:09,329
让我们添加一个var i
给我们的observation

424
00:22:10,230 --> 00:22:12,099
接着我们现在就要生成
observation

425
00:22:12,165 --> 00:22:14,434
给我们的控制器
representedKid.age

426
00:22:14,501 --> 00:22:16,103
我们将其存在var i上

427
00:22:17,037 --> 00:22:19,139
我们加入我们超秘密业务逻辑

428
00:22:19,206 --> 00:22:21,441
如果你看着觉得是错误的

429
00:22:21,508 --> 00:22:23,277
我向你们保证
一旦你准备好去幼儿园

430
00:22:23,343 --> 00:22:26,280
你总是准备好去幼儿园
所以实际上是正确的

431
00:22:27,214 --> 00:22:28,182
就是这样了

432
00:22:28,448 --> 00:22:30,817
这就是我们控制器的整个声明过程

433
00:22:31,818 --> 00:22:33,187
没有必要给一个dnit

434
00:22:33,253 --> 00:22:35,656
我抛弃或者毁坏了我的
observation

435
00:22:35,722 --> 00:22:38,091
因为它联系着observation token
的生命周期

436
00:22:38,158 --> 00:22:39,626
当控制器消失的时候

437
00:22:39,693 --> 00:22:43,330
observation token也会消失
在幻灯片上也合适

438
00:22:43,830 --> 00:22:44,765
接下来让我们

439
00:22:45,732 --> 00:22:47,601
接下来让我们创建控制器

440
00:22:48,702 --> 00:22:50,404
这里我们指向米亚

441
00:22:50,470 --> 00:22:53,674
通过我们之前定义的函数
我们让米亚吹灭蜡烛

442
00:22:53,740 --> 00:22:56,276
最终我们见识到了这些
新类型安全键径的能力

443
00:22:56,343 --> 00:22:58,145
我们的小女孩长大了一岁

444
00:23:00,480 --> 00:23:03,183
目前为止
我已经展示所有想要展示的内容

445
00:23:03,250 --> 00:23:06,486
但我想绕回来再讲一次
字符串键径

446
00:23:07,621 --> 00:23:09,489
这些会一直存在

447
00:23:09,556 --> 00:23:12,192
而且它们对于过期API来说
仍然有用

448
00:23:13,093 --> 00:23:14,895
坚持使用字符串

449
00:23:15,963 --> 00:23:17,698
然而 从Swift 4开始

450
00:23:18,999 --> 00:23:22,436
你可以使用这些新的高性能
类型安全的键径

451
00:23:22,970 --> 00:23:24,137
我们将其引入到语言中

452
00:23:24,204 --> 00:23:26,707
因为我们觉得它非常重要

453
00:23:27,541 --> 00:23:30,344
随着时间发展
它们只会变得更加重要

454
00:23:31,478 --> 00:23:33,847
我想请托尼回到台上来讨论下

455
00:23:33,914 --> 00:23:36,416
我们今年引入到
Swift的另一个重要语言功能

456
00:23:36,483 --> 00:23:37,351
谢谢

457
00:23:43,156 --> 00:23:44,491
谢谢 迈克尔

458
00:23:44,825 --> 00:23:47,528
接下来 我们要谈谈编码和解码

459
00:23:48,762 --> 00:23:51,198
总的来说 编码和解码

460
00:23:51,265 --> 00:23:55,836
是关于你本地和定制
Swift数据结构之间的转换

461
00:23:55,903 --> 00:23:58,772
还有压缩的格式 特别是JSON

462
00:23:59,606 --> 00:24:02,676
你们很多人都告诉我们
关于错误匹配的问题

463
00:24:02,743 --> 00:24:05,979
在强类型语言Swift

464
00:24:06,046 --> 00:24:09,516
和弱类型压缩数据类型
像是JSON之间

465
00:24:10,517 --> 00:24:12,352
我们相信这个挑战的答案

466
00:24:12,419 --> 00:24:15,255
是由语言本身开始

467
00:24:15,556 --> 00:24:17,724
还利用了编译器

468
00:24:17,791 --> 00:24:22,763
标准库 还有Foundation
来使得与JSON交互变得简单

469
00:24:22,829 --> 00:24:26,266
而且给你提供了强大定制化的机会

470
00:24:27,167 --> 00:24:29,436
让我们从一个例子开始

471
00:24:30,904 --> 00:24:33,407
这里有一些来自我们最喜欢的网站之一
GitHub的JSON

472
00:24:33,941 --> 00:24:35,576
这是请求信息的结果

473
00:24:35,642 --> 00:24:37,945
关于一个档案的提交

474
00:24:38,312 --> 00:24:39,680
这是相当标准的JSON

475
00:24:40,080 --> 00:24:43,116
这是个JSON对象或者
我们叫它词典

476
00:24:43,350 --> 00:24:45,752
它支持一个任意数字的键值对

477
00:24:45,819 --> 00:24:48,589
在这里 名称 也就是一个字符串

478
00:24:48,655 --> 00:24:52,326
邮件 也是个字符串
日期 是个字符串

479
00:24:52,693 --> 00:24:55,863
原因当然是
JSON没有原生日期类型

480
00:24:56,263 --> 00:25:01,268
但有很多种将日期编码成
JSON的转换方式

481
00:25:01,335 --> 00:25:03,804
这个显然是ISO8601

482
00:25:04,738 --> 00:25:07,741
如果我们要在Swift中
表示这个JSON

483
00:25:08,008 --> 00:25:09,443
它会看起来非常不一样

484
00:25:10,444 --> 00:25:14,982
例如 我们为它创建一个强类型
可能是叫编写者的结构体

485
00:25:15,849 --> 00:25:18,218
这个结构体有三个属性

486
00:25:18,285 --> 00:25:20,787
名称和邮件还是字符串

487
00:25:20,854 --> 00:25:24,591
但日期如你所见
使用了Foundation的日期类型

488
00:25:25,425 --> 00:25:26,927
这个原因很重要是因为

489
00:25:26,994 --> 00:25:30,631
随着你与其他Cocoa SDK
以及API交互

490
00:25:30,697 --> 00:25:35,469
你会发现日期是一种用来
表示时间里一点的类型

491
00:25:36,236 --> 00:25:38,839
这就是我们遇到的挑战 对吧

492
00:25:39,306 --> 00:25:43,110
我们如何转换顶层弱类型JSON

493
00:25:43,343 --> 00:25:45,679
到底层的强类型Swift类型？

494
00:25:46,480 --> 00:25:49,049
我们认为应该像这样简单

495
00:25:49,149 --> 00:25:51,852
在你的结构体上采用一个协议

496
00:25:51,919 --> 00:25:55,088
让编译器 标准库
还有Foundation

497
00:25:55,155 --> 00:25:57,257
来为你做大部分的工作

498
00:25:59,459 --> 00:26:00,327
谢谢

499
00:26:04,097 --> 00:26:06,200
让我们把幻灯片转到实际代码

500
00:26:06,767 --> 00:26:08,602
首先我要将
JSON转换为一个字符串

501
00:26:08,669 --> 00:26:12,206
用Swift 4中很酷的新文本句法
三重双引号

502
00:26:12,439 --> 00:26:15,042
接着利用UTF-8编码
将这个字符串转换成数据

503
00:26:15,108 --> 00:26:16,743
这对于JSON来说很常见

504
00:26:16,844 --> 00:26:18,779
当然了 结构体编写者保持不变

505
00:26:19,279 --> 00:26:22,249
接下来 我们创建一个解码器
它实际上做了

506
00:26:22,316 --> 00:26:25,719
JSON和Swift结构间的转换

507
00:26:27,287 --> 00:26:31,191
我们告诉解码器这个转换
ISO8601日期

508
00:26:31,425 --> 00:26:33,060
我们后面再说

509
00:26:33,493 --> 00:26:36,663
最后我们请求解码器
来解码一个编写者

510
00:26:36,997 --> 00:26:39,399
结果不是任意的
它不是一个词典

511
00:26:39,466 --> 00:26:42,236
你不需要检查字符串或者键值

512
00:26:42,436 --> 00:26:45,405
它已经是这种情况下
你想要用的类型了

513
00:26:46,773 --> 00:26:47,908
这很简单

514
00:26:48,175 --> 00:26:50,344
让我们把难度提升一点

515
00:26:50,644 --> 00:26:53,013
这个JSON实际上
是更大JSON集合的一部分

516
00:26:53,080 --> 00:26:57,384
伴随着这个请求的结果
包括像是URL

517
00:26:57,451 --> 00:26:59,720
额外的字符串和整型值

518
00:27:00,387 --> 00:27:03,190
Swift中 我们照着做就可以

519
00:27:03,357 --> 00:27:06,793
我要将我的结构体编写者嵌套到
一个叫做Commit的新结构体

520
00:27:06,860 --> 00:27:08,028
也是可编码性

521
00:27:08,595 --> 00:27:11,331
你会发现我可以用
Foundation的URL类型

522
00:27:11,732 --> 00:27:13,066
还有我们的结构体编写者

523
00:27:13,133 --> 00:27:15,402
你会发现我们能递归地向下降类型

524
00:27:15,469 --> 00:27:17,804
如果它们也遵从可编码的规则
来解码它们

525
00:27:18,539 --> 00:27:21,108
信息这个字符串

526
00:27:21,175 --> 00:27:22,643
还有我们的
comment_count属性

527
00:27:23,310 --> 00:27:26,146
要解码这个 只需要一行代码

528
00:27:26,213 --> 00:27:27,881
这次我们要解码一个提交

529
00:27:28,215 --> 00:27:31,351
结果是：我们的强Swift类型
让我们使用

530
00:27:31,418 --> 00:27:33,787
我们知道并且喜欢的
Swift语言功能

531
00:27:33,854 --> 00:27:36,356
来从压缩数据中得到我们想要的值

532
00:27:36,423 --> 00:27:38,358
在这里 就是属性访问

533
00:27:39,893 --> 00:27:41,161
让我们看看发生了什么

534
00:27:41,595 --> 00:27:45,132
首先 可编码协议
实际上不是一个协议 是两个

535
00:27:45,599 --> 00:27:49,903
第一个叫作Encodable
有一个函数encode to encoder

536
00:27:50,637 --> 00:27:54,942
这个函数的目的是
允许类型告诉编码器

537
00:27:55,008 --> 00:27:56,510
它需要的所有信息

538
00:27:56,577 --> 00:27:58,645
以便接下来可以重建自己

539
00:27:59,546 --> 00:28:03,050
相应的协议 可解码性
有一个初始化

540
00:28:03,684 --> 00:28:07,187
初始化的目的是
允许类型来获得其所需要的值

541
00:28:07,254 --> 00:28:09,756
从解码器中 接着使用这些值

542
00:28:09,823 --> 00:28:14,228
来创建一个可供随时使用的
其自身完全初始化的实例

543
00:28:16,496 --> 00:28:18,599
这些API的主要设计点

544
00:28:18,665 --> 00:28:22,336
是使用你可能已经熟悉的
Swift行为

545
00:28:22,402 --> 00:28:24,538
这叫作协议扩展

546
00:28:24,771 --> 00:28:31,144
Swift中 协议不仅可定义接口
还可以藉由扩展

547
00:28:31,211 --> 00:28:34,882
它们可以为该接口
提供一个默认的实现

548
00:28:35,983 --> 00:28:38,886
它们让你给两者之一写你自己的实现

549
00:28:38,952 --> 00:28:41,955
或者给整个协议来定制行为

550
00:28:42,656 --> 00:28:45,225
让我们回到提交看看这是如何运作的

551
00:28:46,126 --> 00:28:47,861
当我采用可编码的协议时

552
00:28:47,928 --> 00:28:51,665
编译器会生成encode to encoder
的一个实现

553
00:28:51,732 --> 00:28:54,368
还有init from decoder完全免费

554
00:28:55,202 --> 00:28:57,571
在这种情况下
我不需要定制关于它们的任何东西

555
00:28:57,638 --> 00:29:00,574
因此我可以从类型中完全移除它们

556
00:29:01,775 --> 00:29:04,178
不过有一个是我想要定制的

557
00:29:04,244 --> 00:29:06,480
就是这个属性的名字

558
00:29:06,813 --> 00:29:09,149
你可以注意到它使用了蛇型连字符

559
00:29:09,216 --> 00:29:10,717
这在JSON中很常见

560
00:29:10,784 --> 00:29:13,153
但是这不符合Swift的命名规范

561
00:29:13,587 --> 00:29:15,622
让我给你们展示下如何修复这个问题

562
00:29:15,822 --> 00:29:18,725
首先 编译器还为我们
生成了一个东西

563
00:29:18,792 --> 00:29:21,662
就是这个叫CodingKeys
的私有枚举

564
00:29:23,363 --> 00:29:27,100
这个枚举由字符串组成
采用了CodingKey协议

565
00:29:27,167 --> 00:29:29,102
同样我们稍后再讲

566
00:29:29,236 --> 00:29:33,040
有趣的是这个枚举
有四个case语句

567
00:29:33,106 --> 00:29:35,709
匹配我的四个属性的名字

568
00:29:36,243 --> 00:29:39,146
为了定制我的属性的名字

569
00:29:39,213 --> 00:29:41,615
我只需要定制case语句的名字

570
00:29:42,015 --> 00:29:43,083
为了实现这个

571
00:29:43,150 --> 00:29:47,387
我要将这个comment_count
从蛇型换成骆驼型

572
00:29:47,888 --> 00:29:52,492
但是如你所见
我仍然对所读的JSON是兼容的

573
00:29:52,559 --> 00:29:54,494
通过将该case的字符串值设置成

574
00:29:54,561 --> 00:29:57,631
我们预期在压缩数据中找到的值

575
00:29:58,232 --> 00:30:03,003
如果这就是我们需要做的所有定制
那么就完成了

576
00:30:04,037 --> 00:30:08,408
你可以不再看了并且离开
但是在这个会议的结尾

577
00:30:08,475 --> 00:30:10,210
我想给你们展示下我们能如何完成

578
00:30:10,277 --> 00:30:12,779
对于这个提交的更多定制

579
00:30:13,380 --> 00:30:15,682
现在我想把舞台交给同事毅太

580
00:30:15,749 --> 00:30:17,784
来给我们实际演示一下这个东西

581
00:30:28,028 --> 00:30:28,862
谢谢 托尼

582
00:30:29,630 --> 00:30:33,567
托尼给你们展示了在你的类型中
采用可编码性是多么简单

583
00:30:33,634 --> 00:30:35,669
不过让我们看看这会是什么样子

584
00:30:35,736 --> 00:30:37,271
在许多你们的实践应用中

585
00:30:38,438 --> 00:30:41,074
我这里有最近一直在做原型的小应用

586
00:30:41,175 --> 00:30:42,776
因为我是Swift的大粉丝

587
00:30:42,843 --> 00:30:44,745
我想要看有趣的git提交

588
00:30:44,811 --> 00:30:46,780
出现在Swift的GitHub repo

589
00:30:47,648 --> 00:30:51,518
这里我写了个小应用
与GitHub的JSON REST API交互

590
00:30:51,585 --> 00:30:54,254
来解析这些提交
并通过一个表格视图来展示给我

591
00:30:54,855 --> 00:30:57,758
让我们快看看把这个应用写完
是多么容易

592
00:30:57,824 --> 00:30:59,326
使用新的可编码性API

593
00:31:01,228 --> 00:31:03,463
如果我们切换到Xcode
你会注意到一些相同的模型

594
00:31:03,530 --> 00:31:06,567
托尼在幻灯片上扩展了一点

595
00:31:07,134 --> 00:31:10,337
我们有相同的提交信息 编写者信息

596
00:31:10,871 --> 00:31:13,006
我们也做了同样的重命名

597
00:31:13,774 --> 00:31:16,243
右侧是GitHub所提供的
JSON信息

598
00:31:16,310 --> 00:31:18,545
不过有些不相关的部分被剪切掉了

599
00:31:18,612 --> 00:31:20,314
如果你注意看右下角

600
00:31:20,380 --> 00:31:23,884
在JSON代码中
有些是我们目前没有解码的信息

601
00:31:24,451 --> 00:31:26,553
这没问题的 因为它会默认被忽略掉

602
00:31:26,620 --> 00:31:28,222
我们接下来再处理它

603
00:31:28,689 --> 00:31:31,959
让我们隐藏掉这个JSON代码
再深入看下我们的文件

604
00:31:32,025 --> 00:31:34,127
来看看我们如何实际使用这些模型

605
00:31:34,661 --> 00:31:37,197
这里我们有
CommitsViewController

606
00:31:37,264 --> 00:31:41,001
这个是实际显示这些提交的
视图控制器在我们的表格视图中

607
00:31:41,335 --> 00:31:43,871
这个视图控制器有我们的表格视图

608
00:31:43,937 --> 00:31:45,572
还有这些提交的数组

609
00:31:45,873 --> 00:31:49,176
注意这里是我们类型的一个数组

610
00:31:49,409 --> 00:31:51,545
不是任何其他或者类似的数组

611
00:31:53,013 --> 00:31:55,482
当我们要显示这个数据时

612
00:31:55,549 --> 00:31:58,852
我们可以从GitHub获取数据
接着利用JSON解码器

613
00:31:58,919 --> 00:32:00,320
就像托尼向你们演示的那样

614
00:32:00,420 --> 00:32:03,924
我们可以请求将这些提交的数组
解码成我们的类型

615
00:32:05,158 --> 00:32:08,462
一旦完成 我们可以重新加载
表格视图并显示它

616
00:32:09,663 --> 00:32:12,566
如果出问题了 我们可以捕捉错误

617
00:32:12,633 --> 00:32:14,735
并且显示一些本地信息给用户

618
00:32:14,801 --> 00:32:16,870
高层面地告诉他们哪里出错了

619
00:32:17,838 --> 00:32:19,706
这就是你如何将数据载入你的应用

620
00:32:19,773 --> 00:32:21,942
让我们看看
它是怎么和我们的UI相关联的

621
00:32:22,176 --> 00:32:24,144
往下一点看文件

622
00:32:24,211 --> 00:32:26,847
我有一个辅助函数
来让我设置表格视图的单元格

623
00:32:26,914 --> 00:32:29,049
在它们显示给用户之前

624
00:32:29,116 --> 00:32:31,718
这里要设置我的定制表格视图单元格

625
00:32:31,785 --> 00:32:34,454
我要从提交数组中抓取出一条提交

626
00:32:34,688 --> 00:32:38,025
接着使用该条提交的强类型属性

627
00:32:38,091 --> 00:32:39,560
我们就可以将其连接到UI

628
00:32:39,660 --> 00:32:41,895
再次注意我们没有向下转换任何

629
00:32:41,962 --> 00:32:44,131
而且没有通过数组或者词典配对

630
00:32:44,198 --> 00:32:47,134
这就是我们写类型的方式
还有我们想要如何使用它

631
00:32:48,669 --> 00:32:50,737
这都挺不错的
不过让我们回到我们的应用

632
00:32:50,804 --> 00:32:53,607
你看这里就会发现
UI这里有一些空间

633
00:32:53,674 --> 00:32:57,144
我留下来连接给
每个提交所对应的哈希值的

634
00:32:57,211 --> 00:32:59,880
但它还没被连接上
让我们现在完成它

635
00:33:02,049 --> 00:33:05,452
如果我们回到模型
重新打开JSON代码

636
00:33:05,552 --> 00:33:10,023
我们会发现在JSON代码中
有个哈希属性

637
00:33:10,090 --> 00:33:11,592
我们一直没有请求

638
00:33:11,758 --> 00:33:13,660
让我们把它加到我们的类型里

639
00:33:13,927 --> 00:33:17,497
接着 如果我构建项目来使用它

640
00:33:17,564 --> 00:33:20,000
你会发现我得到一个构建失败

641
00:33:20,234 --> 00:33:22,002
让我们看看为什么会这样

642
00:33:23,203 --> 00:33:26,607
作为这个类型的一部分
我已创建了一个定制CodingKeys枚举

643
00:33:26,807 --> 00:33:29,209
这个你放进类型里的
CodingKeys枚举

644
00:33:29,276 --> 00:33:32,646
是用来控制编译器生成的强大工具

645
00:33:32,713 --> 00:33:35,516
作为NNCode 2初始的一部分

646
00:33:35,949 --> 00:33:38,118
在这个例子中
我提供了一个CodingKeys枚举

647
00:33:38,185 --> 00:33:42,623
来将我的提交信息属性重命名
以匹配JSON里的内容

648
00:33:43,023 --> 00:33:45,659
但这里 我刚添加的哈希属性

649
00:33:45,726 --> 00:33:47,194
在CodingKeys中找不到

650
00:33:47,794 --> 00:33:49,596
编译器会试着做的是

651
00:33:49,663 --> 00:33:52,966
如果你故意落下一个属性
没有写入CodingKeys枚举

652
00:33:53,033 --> 00:33:57,037
它就会从编码和解码显示中移除出去

653
00:33:57,237 --> 00:33:58,238
这里发生的是

654
00:33:58,305 --> 00:34:01,842
因为这个哈希属性没有一个默认值

655
00:34:01,909 --> 00:34:05,279
如果编译器试图给我们生成
一个初始化

656
00:34:05,345 --> 00:34:08,348
就不会有合理的值初始化给这个属性

657
00:34:08,415 --> 00:34:11,051
因此编译器拒绝这么做
那么我们就会得到构建失败

658
00:34:11,118 --> 00:34:14,021
因为我们的类型实际上
没有遵从可解码性

659
00:34:14,721 --> 00:34:16,590
在这个例子中 我们实际上不想让

660
00:34:16,657 --> 00:34:18,992
这个哈希属性
从我们的编码表示中落下

661
00:34:19,059 --> 00:34:20,127
我们想要解码它

662
00:34:20,226 --> 00:34:22,496
让我们镜像这个相同的属性

663
00:34:22,629 --> 00:34:23,931
在我们的CodingKeys枚举中

664
00:34:24,931 --> 00:34:27,801
让我们再次隐藏JSON代码
去连接这个属性

665
00:34:27,868 --> 00:34:29,101
直接到我们的UI上

666
00:34:29,436 --> 00:34:31,938
在这个单元格设置方法中

667
00:34:32,005 --> 00:34:35,175
我们要加入另一行代码来抓取哈希值

668
00:34:35,242 --> 00:34:38,212
我们将要把它变短一点
让它更加适合我们的UI

669
00:34:38,277 --> 00:34:40,746
就像使用任何东西一样
使用强类型属性

670
00:34:40,813 --> 00:34:42,616
我们可以将其直接连接到我们的UI

671
00:34:43,016 --> 00:34:44,518
让我们回到我们的应用

672
00:34:44,585 --> 00:34:47,387
看一下确保所有东西都连接正确了

673
00:34:49,723 --> 00:34:51,757
这里我们已经重新运行了

674
00:34:51,824 --> 00:34:54,161
我们可以看到所有东西
都连接到了我们的UI

675
00:34:54,228 --> 00:34:57,130
我很高兴 因为这只用了四行代码

676
00:34:57,197 --> 00:34:58,131
加到我们的应用中

677
00:35:02,069 --> 00:35:02,903
谢谢

678
00:35:06,473 --> 00:35:08,208
现在暂时回到代码中

679
00:35:08,275 --> 00:35:11,912
让我们看看当应用出错时
我们都能干些什么

680
00:35:13,013 --> 00:35:15,382
如果我们再一次打开JSON代码

681
00:35:15,449 --> 00:35:16,917
你可能会注意到在右下角

682
00:35:16,984 --> 00:35:19,386
我们还有最后一个
一直没有解码的属性

683
00:35:19,453 --> 00:35:21,221
让我们现在完成它

684
00:35:22,055 --> 00:35:24,658
我们要把URL属性加入到
我们的类型中

685
00:35:24,725 --> 00:35:27,227
并且在CodingKeys枚举中
镜像它

686
00:35:28,161 --> 00:35:31,231
这次让我们给CodingKey
一个值

687
00:35:31,298 --> 00:35:34,368
明显在我们的JSON中是找不到的

688
00:35:35,202 --> 00:35:37,738
当我们试图解码这个值的时候

689
00:35:37,804 --> 00:35:41,341
它不会被找到
因此这会在解码时候变成一个错误

690
00:35:42,109 --> 00:35:45,179
看看我们如何解决这个错误
让我们再把JSON代码隐藏起来

691
00:35:45,245 --> 00:35:47,314
往下找到我们实现解码的地方

692
00:35:48,615 --> 00:35:50,083
为了解决这个错误

693
00:35:50,217 --> 00:35:53,620
我们可以捕捉一个解码错误
keyNotFound错误

694
00:35:53,687 --> 00:35:56,823
这表明了我们试图访问
该键的某些内容

695
00:35:56,890 --> 00:35:58,926
但它不能在加载内容的
任何地方被找到

696
00:35:59,459 --> 00:36:01,595
除了这个
我们获得了一些上下文环境信息

697
00:36:01,662 --> 00:36:03,163
关于什么以及哪里出了错

698
00:36:03,697 --> 00:36:07,134
让我们在这设置一个断点
带着这个有错的键运行应用

699
00:36:07,201 --> 00:36:09,336
看一下以确保我们可以捕捉到
这个错误

700
00:36:09,403 --> 00:36:10,571
并且我们到达了断点

701
00:36:11,805 --> 00:36:13,340
现在我们运行了这个应用

702
00:36:13,407 --> 00:36:15,409
你会注意到我们确实到达了那个断点

703
00:36:15,475 --> 00:36:18,278
如果我们打印这个键
你可以看到事实上

704
00:36:18,345 --> 00:36:20,681
我们给了一个有错误数值的URL键

705
00:36:20,747 --> 00:36:22,716
事实上 它在加载内容里找不到

706
00:36:22,783 --> 00:36:24,051
因此我们得到了这个错误

707
00:36:25,052 --> 00:36:26,820
这里我们如果看上下文环境信息

708
00:36:26,887 --> 00:36:30,390
你可以看到两个有用的功能
来帮助你解决发生的问题

709
00:36:31,091 --> 00:36:33,493
首先是一条排除故障描述
给作为开发者的你

710
00:36:33,560 --> 00:36:36,930
来看看哪里出了问题 还有代码路径

711
00:36:36,997 --> 00:36:40,367
其描述了在加载内容时哪里出了问题
导致这个地方出错

712
00:36:41,602 --> 00:36:43,604
这些都很棒 不过事实上

713
00:36:43,670 --> 00:36:47,040
如果我不是很关心URL

714
00:36:47,107 --> 00:36:48,242
而且我可能不需要它

715
00:36:48,308 --> 00:36:51,044
那么解决这个错误的一个方法
就是让你的URL变为可选

716
00:36:52,312 --> 00:36:54,414
当你默认将这个属性设为可选时

717
00:36:54,481 --> 00:36:56,583
如果键或值没有被找到

718
00:36:56,650 --> 00:36:59,386
它会被初始化设为nil

719
00:36:59,753 --> 00:37:01,788
让我们隐藏我们的UI
重新运行应用

720
00:37:01,855 --> 00:37:03,857
来看看我们是不是还会达到断点

721
00:37:05,058 --> 00:37:07,594
当我们重新运行时
我们不会再达到断点

722
00:37:07,661 --> 00:37:10,864
因为该值被默认设成了nil
这是个不错的习惯

723
00:37:11,865 --> 00:37:13,600
让我们回到代码并看一下

724
00:37:13,667 --> 00:37:16,303
我们还可以捕捉哪些有用的错误

725
00:37:17,137 --> 00:37:20,807
另一个错误像是
DecodingError.valueNotFound

726
00:37:20,874 --> 00:37:23,844
其表明了我们试图解码
该类型的某些东西

727
00:37:23,911 --> 00:37:25,145
但是实际上找到了nil

728
00:37:25,979 --> 00:37:28,715
你还得到了相同的上下文环境信息

729
00:37:28,782 --> 00:37:30,651
来告诉你什么以及哪里出了错

730
00:37:32,386 --> 00:37:35,022
同时 你或许想捕捉类型不匹配

731
00:37:35,255 --> 00:37:38,125
表明了你试图解码该类型的某些东西

732
00:37:38,192 --> 00:37:40,160
但是在加载内容里找到的是别的类型

733
00:37:40,227 --> 00:37:43,797
比如说 你试图解码一个字符串
而找到的是一个数字

734
00:37:44,031 --> 00:37:47,100
同样 你会跟前面一样
得到相同的上下文环境信息

735
00:37:48,101 --> 00:37:50,737
当你想排除故障时 这些错误很有用

736
00:37:50,804 --> 00:37:53,073
当某些东西出错时 不过通常情况下

737
00:37:53,140 --> 00:37:56,043
你不会想要在最高级别
就捕捉这些错误

738
00:37:56,109 --> 00:37:57,744
取而代之 你只想要捕捉通用错误

739
00:37:57,811 --> 00:38:00,247
并显示一些本地的信息
给用户以便他们可以想出

740
00:38:00,314 --> 00:38:02,316
什么出错了或者报告这个漏洞

741
00:38:03,450 --> 00:38:05,552
这些实际上是非常强大的工具

742
00:38:05,619 --> 00:38:07,187
来实现一些更高级的事情

743
00:38:07,487 --> 00:38:10,057
如果你定制你的init from
或者encode to

744
00:38:10,123 --> 00:38:13,160
你可以捕捉类型里的这些错误
来实现强大的功能

745
00:38:13,227 --> 00:38:17,064
像是数据迁移 重命名属性等等

746
00:38:17,331 --> 00:38:19,099
但在我们的应用中
其实无需这么做

747
00:38:19,166 --> 00:38:21,568
因为我已经通过少量代码
得到了我想要的功能

748
00:38:22,002 --> 00:38:24,438
我要将舞台交还给托尼
让他来谈谈

749
00:38:24,505 --> 00:38:27,975
一些更高级的编码和解码主题 谢谢

750
00:38:33,313 --> 00:38:34,147
谢谢 毅太

751
00:38:35,682 --> 00:38:40,254
让我们继续谈谈一些更高级的主题吧

752
00:38:40,320 --> 00:38:41,788
关于编码和解码的

753
00:38:41,855 --> 00:38:44,324
我们要谈谈我称之为三个支柱的

754
00:38:44,391 --> 00:38:46,493
可编码性API设计哲学

755
00:38:46,827 --> 00:38:50,230
首先是我们真的想要内置错误解决

756
00:38:50,297 --> 00:38:51,598
像是你在演示中所看到的

757
00:38:52,566 --> 00:38:54,501
当你在处理压缩数据的时候

758
00:38:54,568 --> 00:38:59,039
处理未预见的输入不是如果的问题
而是什么时候的问题

759
00:38:59,773 --> 00:39:02,976
这可能是数据侵蚀
可能是未预见的API变化

760
00:39:03,043 --> 00:39:06,914
来自你接收数据的地方
或者甚至是恶意的输入

761
00:39:06,980 --> 00:39:09,650
有些人试图探查到你应用的弱点

762
00:39:09,750 --> 00:39:11,952
我们决定不应该有致命性的错误

763
00:39:12,019 --> 00:39:13,987
作为解析不受信任数据的结果

764
00:39:14,454 --> 00:39:17,658
然而我们确实在Swift中
使用致命性错误

765
00:39:17,724 --> 00:39:20,194
若我们检测到这可能是开发者的错误

766
00:39:20,394 --> 00:39:22,229
就会有一个含致命性错误的字符串

767
00:39:22,296 --> 00:39:24,398
在告诉你哪里可能出错了

768
00:39:24,998 --> 00:39:28,535
对于其他情况 我们使用
Swift内置的错误处理机制

769
00:39:28,602 --> 00:39:32,072
这类错误在编码和解码时候
都有可能发生

770
00:39:32,973 --> 00:39:34,374
让我们看看它们是什么样的

771
00:39:35,108 --> 00:39:37,177
首先 编码

772
00:39:37,411 --> 00:39:40,747
只有一种编码的错误 就是非法的值

773
00:39:41,114 --> 00:39:43,650
对于某些像JSON这样的格式

774
00:39:43,717 --> 00:39:47,921
我们想要给予它们灵活性来
处理它们可能没有预见到的输入

775
00:39:47,988 --> 00:39:51,258
而不是报告一个致命性的错误
或是赋给某些默认值

776
00:39:51,592 --> 00:39:55,829
例如在JSON中
非数或者无穷不是合法值

777
00:39:56,063 --> 00:39:58,165
因此在这些情况下 它们能抛出错误

778
00:39:58,232 --> 00:40:01,068
你可能从类型层面上做不了太多

779
00:40:01,134 --> 00:40:02,703
不过你仍然可以在上层捕捉它

780
00:40:02,769 --> 00:40:05,439
并且呈献给你的用户一个错误
或者防止其他种类的错误

781
00:40:05,506 --> 00:40:07,808
或是呈现某种其他类型的恢复机制

782
00:40:08,675 --> 00:40:12,279
对于解码方面 有四种错误
我们在演示中已经看到过三种了

783
00:40:12,346 --> 00:40:14,348
类型不匹配 找不到的键
找不到的值

784
00:40:14,414 --> 00:40:17,417
你可以通过空中处理机制解决

785
00:40:17,484 --> 00:40:19,887
如果它们确实是你类型所必需的部分

786
00:40:19,953 --> 00:40:21,922
或是将这些属性设为可选的

787
00:40:22,656 --> 00:40:24,458
最后我们有数据侵蚀

788
00:40:24,658 --> 00:40:26,360
数据侵蚀就是我们的捕捉所有错误

789
00:40:26,426 --> 00:40:29,263
对于解码过程所能发生的
所有其他错误

790
00:40:29,630 --> 00:40:31,164
为了看看它何处可能会有用

791
00:40:31,231 --> 00:40:34,168
让我们深入看看解码时发生了什么

792
00:40:34,635 --> 00:40:37,171
首先开始的时候
我们所拥有的都是字节码

793
00:40:37,571 --> 00:40:39,072
它可能来自于网络

794
00:40:39,139 --> 00:40:42,176
可能来自于磁盘上的某个文件
或是你应用里的某处

795
00:40:42,242 --> 00:40:45,512
无论从哪来的 在此时
我们真的对于它们什么都不知道

796
00:40:45,579 --> 00:40:49,283
因此第一步就是
将这些字节码转换成结构化的字节码

797
00:40:50,450 --> 00:40:52,186
例如 这个JSON解码器

798
00:40:52,252 --> 00:40:55,389
要验证JSON代码的
特定需求被满足

799
00:40:55,722 --> 00:40:58,091
在压缩数据的开始 个别的字节码

800
00:40:58,158 --> 00:40:59,626
表明了字符串编码

801
00:40:59,893 --> 00:41:05,465
特定的用于字符串分隔符的
字符 数值 数组 词典等等

802
00:41:05,866 --> 00:41:07,267
若其中任何东西看上去有错

803
00:41:07,334 --> 00:41:11,104
JSON解码器就能抛出一个错误
并马上停止解码器的运行

804
00:41:12,506 --> 00:41:16,176
在那之后 我们想要从
JSON数组 词典

805
00:41:16,243 --> 00:41:19,179
以及字符串转换到你的类型
提交和编写者

806
00:41:19,246 --> 00:41:21,849
毕竟这个API就是为此而生的

807
00:41:22,716 --> 00:41:24,685
不过我们还可以做到更多

808
00:41:25,385 --> 00:41:27,588
我们称之为域相关合法性验证

809
00:41:27,988 --> 00:41:31,158
例如 你有个包含整型属性的类型

810
00:41:31,225 --> 00:41:34,628
但是合法的整数只有0到100之间

811
00:41:35,195 --> 00:41:38,131
或者你的类型有两种布尔属性

812
00:41:38,198 --> 00:41:41,268
但是它们有着互斥的关系

813
00:41:41,635 --> 00:41:45,138
这类事情很难通过Swift
的类型系统来表达

814
00:41:45,205 --> 00:41:48,208
但是我们认为
我们有个很棒的工具来处理这些

815
00:41:48,275 --> 00:41:50,277
而这仅需多写点Swift代码
就能实现

816
00:41:50,344 --> 00:41:53,347
我们想要确保提供给你机会来实现

817
00:41:53,413 --> 00:41:55,315
如果你有这类需求的话

818
00:41:56,149 --> 00:41:58,385
最后你还有图形级别合法性验证

819
00:41:58,619 --> 00:41:59,720
这是有关

820
00:41:59,786 --> 00:42:03,056
图中的对象彼此间的关系
或是你应用的另一个部分

821
00:42:04,424 --> 00:42:05,993
让我们将其应用到我们的提交中

822
00:42:06,159 --> 00:42:09,296
此前我们看到了如何定制
commentCount属性

823
00:42:09,363 --> 00:42:11,698
通过定制叫作
CodingKeys的枚举

824
00:42:11,965 --> 00:42:14,067
现在我们将要定制可解码性

825
00:42:14,134 --> 00:42:16,069
通过实现init from decoder

826
00:42:16,870 --> 00:42:19,706
首先 我为解码器请求一个容器

827
00:42:20,207 --> 00:42:22,876
容器就是用来匹配你的键

828
00:42:22,943 --> 00:42:25,712
到你期望在压缩数据中所找到的值

829
00:42:26,813 --> 00:42:30,517
一旦我们有了一个容器
我们就可以向它请求我们所需要的值

830
00:42:30,617 --> 00:42:34,087
在这里 是一个URL
一个字符串 编写者

831
00:42:34,154 --> 00:42:38,625
还有我们的递归降序
以及commentCount的整型数值

832
00:42:39,626 --> 00:42:41,428
比如说现在我有一个额外需求

833
00:42:41,495 --> 00:42:43,764
就是我需要作为技术规格
的一部分进行验证

834
00:42:43,830 --> 00:42:47,067
所有的URL都必须是HTTPS

835
00:42:47,467 --> 00:42:49,636
如果它们不是的话 就会有错误

836
00:42:50,003 --> 00:42:53,574
让我们看看如果实现吧
首先 在幻灯片上腾出更多空间

837
00:42:54,208 --> 00:42:57,711
然后 我会使用我们
已经知道怎么用的URL API

838
00:42:57,778 --> 00:42:59,713
那就是scheme属性

839
00:43:00,614 --> 00:43:03,817
这里我只检查是否等于HTTPS
如果它不相等

840
00:43:03,951 --> 00:43:05,886
我就可以抛出一个解码错误

841
00:43:05,953 --> 00:43:08,689
提供一个排除故障描述
以便你可在调试器里捕捉到它

842
00:43:08,755 --> 00:43:10,357
就如同毅太在演示中所展示的那样

843
00:43:10,657 --> 00:43:14,995
你没注意到的是 这个类型 提交

844
00:43:15,062 --> 00:43:17,064
检查了URL的字符串值

845
00:43:17,698 --> 00:43:19,633
我们可以允许URL解码自己

846
00:43:20,167 --> 00:43:23,036
这也是这个设计如此之棒的部分原因

847
00:43:23,337 --> 00:43:26,006
URL知道某个字符串是不是URL

848
00:43:26,073 --> 00:43:29,109
如果不是的话 它就会抛出一个错误
甚至在我们到这步之前

849
00:43:29,409 --> 00:43:31,612
由于Swift错误处理的设计

850
00:43:31,678 --> 00:43:35,082
可以延迟这个类型到解码提交

851
00:43:35,148 --> 00:43:36,416
或者甚至更高层级

852
00:43:38,719 --> 00:43:40,521
让我们接着看第二个支柱

853
00:43:40,587 --> 00:43:43,257
那就是编码细节的封装

854
00:43:44,358 --> 00:43:48,128
我们觉得保证键和值非常重要

855
00:43:48,195 --> 00:43:51,665
它们是一个类型选择私密的东西
放到压缩数据

856
00:43:52,366 --> 00:43:53,734
原因很重要

857
00:43:53,800 --> 00:43:56,470
因为这减少了我们的工作量

858
00:43:56,537 --> 00:43:58,839
设计某些带有全局知识的

859
00:43:58,906 --> 00:44:01,475
在压缩数据里可能会出现的东西

860
00:44:02,109 --> 00:44:04,878
我们实现这种封装的主要机制

861
00:44:04,945 --> 00:44:07,581
叫作容器 我们有三种

862
00:44:08,115 --> 00:44:10,017
第一种叫作加密容器

863
00:44:10,684 --> 00:44:14,021
加密容器是大多数情况下的优先选择

864
00:44:14,188 --> 00:44:18,358
原因是因为
它们目前是向前向后最兼容的

865
00:44:18,759 --> 00:44:22,196
如果你新版本的应用里
有新的或者变动的数据

866
00:44:22,429 --> 00:44:23,897
你只需要用一个新的密钥

867
00:44:24,498 --> 00:44:26,667
这使得应用的绝大多数版本

868
00:44:26,733 --> 00:44:28,769
与你数据的绝大多数版本相兼容

869
00:44:28,836 --> 00:44:31,104
这对于每个人都是最好的可能结果

870
00:44:32,039 --> 00:44:34,041
让我们看看这些密钥实际上是什么

871
00:44:34,107 --> 00:44:36,076
早些时候
我们谈了CodingKey协议

872
00:44:36,143 --> 00:44:37,144
就是这个

873
00:44:37,444 --> 00:44:41,248
它有两个协议
或者两个属性和两个初始化

874
00:44:41,748 --> 00:44:43,517
属性就是stringValue

875
00:44:43,584 --> 00:44:45,986
例如 你在用JSON时候就很方便

876
00:44:46,053 --> 00:44:48,956
不过你也可以提供一个整型数值
这对于格式很有用

877
00:44:49,022 --> 00:44:51,992
这或许提供了一个
更有效的编码二进制表现

878
00:44:53,060 --> 00:44:56,396
而初始化
我想让你们注意的是它们是可选的

879
00:44:56,463 --> 00:44:57,798
这就意味着解码器

880
00:44:57,865 --> 00:45:01,235
拥有执行额外一层安全性检查的能力

881
00:45:01,368 --> 00:45:03,871
它可以验证你的代码密钥

882
00:45:03,937 --> 00:45:07,808
你在压缩数据中所找到的值
就是你想要的

883
00:45:08,275 --> 00:45:11,345
通常你要在枚举上采用这个协议

884
00:45:11,411 --> 00:45:12,946
就如同我们目前看到的这个

885
00:45:13,280 --> 00:45:15,048
这里所发生的就是

886
00:45:15,115 --> 00:45:16,583
标准库的编译器

887
00:45:16,650 --> 00:45:19,086
提供一个所有这四种需求的实现

888
00:45:19,152 --> 00:45:20,420
完全免费给我们

889
00:45:20,888 --> 00:45:23,957
在这里 因为枚举是由字符串组成的

890
00:45:24,458 --> 00:45:27,027
编译器使用case名
作为字符串的值

891
00:45:27,094 --> 00:45:29,329
同时为了属性还有初始化

892
00:45:29,696 --> 00:45:31,231
不过intValue还是nil

893
00:45:31,298 --> 00:45:33,033
因为在这个枚举中没有足够的信息

894
00:45:33,100 --> 00:45:35,102
来给它分配一个特定值

895
00:45:36,003 --> 00:45:39,406
早前当我们定制case名的时候
你现在可以看到这是如何运作的

896
00:45:39,473 --> 00:45:42,509
我们改变了case的名字
但是值仍然是一样的

897
00:45:42,576 --> 00:45:45,812
因此stringValue仍和
GitHub API保持兼容

898
00:45:47,147 --> 00:45:48,582
如果你在写库的代码

899
00:45:48,649 --> 00:45:52,119
我会鼓励你考虑用整型
来写你的CodingKeys

900
00:45:52,186 --> 00:45:56,323
如果你这么做
你仍会从编译器获得更多免费实现

901
00:45:56,390 --> 00:46:00,060
在这个例子中
一个整型数值 这会对格式很有用

902
00:46:00,127 --> 00:46:01,728
其可能支持整型密钥

903
00:46:03,697 --> 00:46:08,569
我们也支持未加密容器
这些依次编码和解码

904
00:46:09,236 --> 00:46:12,806
对于有序或无边界的数据
使用这些容器 其原因就是

905
00:46:12,873 --> 00:46:14,541
你不需要生成假的密钥

906
00:46:14,608 --> 00:46:16,543
让你的数据进入压缩数据

907
00:46:16,977 --> 00:46:19,213
我们也支持单一值容器

908
00:46:19,279 --> 00:46:22,349
就如这个名字所指的
只保存一个项目

909
00:46:22,883 --> 00:46:24,251
对于主类型使用这些容器

910
00:46:24,318 --> 00:46:26,253
例如 以秒数保存的日期

911
00:46:26,553 --> 00:46:28,155
由于是时间内的一个引用点

912
00:46:28,889 --> 00:46:30,691
当你在其中选择的时候 你应该注意

913
00:46:30,757 --> 00:46:34,728
这些是最不兼容的选择 一定要记住

914
00:46:35,796 --> 00:46:37,898
让我们再一次回到我们的提交

915
00:46:39,066 --> 00:46:41,335
我们可以看到
如何定制了commentCount

916
00:46:41,401 --> 00:46:43,237
还有它的CodingKeys

917
00:46:43,303 --> 00:46:45,539
通过改变init
from decoder来解码

918
00:46:45,806 --> 00:46:49,476
现在让我们看看
encode to encoder的编码

919
00:46:49,776 --> 00:46:52,145
实际上 我在这不需要定制任何东西

920
00:46:52,212 --> 00:46:53,814
不过我仍然想给你们展示看看
它是什么样的

921
00:46:53,881 --> 00:46:55,582
以便你们能理解它是如何运作的

922
00:46:55,649 --> 00:46:59,586
首先 我们有一个容器
并且这个容器如你所见

923
00:46:59,653 --> 00:47:02,756
藉由我们自己的私密
CodingKeys所编码

924
00:47:03,290 --> 00:47:06,193
这个容器就是我如何编码

925
00:47:06,260 --> 00:47:08,562
我想要放入压缩数据的值

926
00:47:08,629 --> 00:47:11,498
我们的URL信息 编写者
递归降序

927
00:47:11,565 --> 00:47:12,666
还有commentCount

928
00:47:13,500 --> 00:47:16,436
我想给你们展示一个如何选择的例子
选择不同种类的容器

929
00:47:16,503 --> 00:47:18,805
比如说我们正在处理
GO JSON代码

930
00:47:18,872 --> 00:47:20,874
其有一个点的概念

931
00:47:21,275 --> 00:47:24,945
点有两个值 它应该在JSON中
是两个数值型元素的数组

932
00:47:25,012 --> 00:47:28,315
为了使其能正常运作
我会采用可编码性

933
00:47:28,382 --> 00:47:32,186
并且使用一个未加密容器
来实现encode to encoder

934
00:47:32,252 --> 00:47:35,622
你会注意到这个容器中没有密钥

935
00:47:35,689 --> 00:47:37,591
当我编码的时候 我没有用密钥

936
00:47:37,658 --> 00:47:40,494
JSON中的结果就像是这样

937
00:47:41,728 --> 00:47:43,630
我们也支持嵌套式的容器

938
00:47:44,398 --> 00:47:46,900
比如说我的词典中的第二个项目

939
00:47:46,967 --> 00:47:48,936
需要包含三个值的一个数组

940
00:47:49,002 --> 00:47:53,207
因此 如你所见 我们支持嵌套
未加密容器和加密容器

941
00:47:53,273 --> 00:47:56,276
或者其他任何加密
未加密和单一值的组合

942
00:47:56,977 --> 00:48:00,080
嵌套式容器的主要用例就是类

943
00:48:00,414 --> 00:48:03,250
到目前为止
我们谈了很多关于结构体的问题

944
00:48:03,317 --> 00:48:06,220
但嵌套式容器给了我们一个自然机制

945
00:48:06,286 --> 00:48:09,890
从我们作为子类的自己数据
用来封装超类数据

946
00:48:09,957 --> 00:48:11,592
也就是一个来自于NSCoding的变化

947
00:48:12,092 --> 00:48:13,126
我们来看一个例子

948
00:48:13,360 --> 00:48:16,263
就是每个人都喜欢的
面向对象的例子 动物

949
00:48:16,330 --> 00:48:18,799
很自然 动物有个legCount

950
00:48:19,566 --> 00:48:21,235
还有它自己的CodingKeys

951
00:48:21,301 --> 00:48:25,005
并且你看到在这个类中
当我实现init from decoder时

952
00:48:25,072 --> 00:48:26,473
它是一个必需的初始化

953
00:48:27,674 --> 00:48:29,176
这里我创建了一个加密容器

954
00:48:29,243 --> 00:48:31,812
使用动物的CodingKeys
并且解码我的腿计数

955
00:48:31,979 --> 00:48:33,780
跟我们目前为止所见过的很类似

956
00:48:34,481 --> 00:48:35,782
让我们创建一个它的子类

957
00:48:36,450 --> 00:48:38,585
狗是有最好朋友的一种动物

958
00:48:38,652 --> 00:48:40,888
也就是我们早前生日派对里的小孩

959
00:48:41,154 --> 00:48:45,192
你会注意到dog也有个叫作
CodingKeys的私有枚举

960
00:48:45,259 --> 00:48:48,529
即使它有着与超类中相同的名字

961
00:48:48,595 --> 00:48:52,900
因为它是私有的
它并不会与动物所使用的相冲突

962
00:48:53,333 --> 00:48:55,836
因此 当我实现dog的
init from decoder时

963
00:48:55,903 --> 00:48:58,672
并且使用它自己的CodingKeys
来获得一个容器

964
00:48:58,739 --> 00:49:02,643
我可以利用对于它来说重要的密钥
以一种类型安全的方式解码

965
00:49:02,709 --> 00:49:03,777
而不是对它的超类重要

966
00:49:04,444 --> 00:49:06,213
现在 我们需要完成那个嵌套

967
00:49:06,446 --> 00:49:08,248
我们可以调用超类

968
00:49:08,315 --> 00:49:11,552
利用我们接收到的解码器
来实现超类的init from decoder

969
00:49:11,919 --> 00:49:17,157
然而 这不会给容器机会
来嵌套该超类数据

970
00:49:17,624 --> 00:49:20,894
因此 最简单的实现方法
就是使用这个方便的API

971
00:49:20,961 --> 00:49:22,095
叫作superDecoder

972
00:49:22,162 --> 00:49:25,098
它会获得一个新的
可以传到我们超类的解码器

973
00:49:25,332 --> 00:49:30,537
通过调用super 我们满足了
Swift的规则来创建一个初始化

974
00:49:30,604 --> 00:49:33,874
其实现了一个随时可用的
最终初始化了的类型

975
00:49:36,910 --> 00:49:38,445
最后是我们的第三个支柱

976
00:49:38,512 --> 00:49:42,382
那就是从这些类型中抽象出编码格式

977
00:49:43,483 --> 00:49:45,452
我们觉得能够重用很重要

978
00:49:45,519 --> 00:49:48,288
就是重用这些协议的实现

979
00:49:49,022 --> 00:49:50,724
我们不想以这种局面结束

980
00:49:50,791 --> 00:49:53,694
就是我们有很多几乎相同的实现

981
00:49:53,760 --> 00:49:57,231
对于可编码性和可解码性
来支持新的格式

982
00:49:57,865 --> 00:50:00,334
因此通过抽象格式

983
00:50:00,400 --> 00:50:03,403
我们可以不改变任何库
就可以允许全新的格式

984
00:50:03,537 --> 00:50:07,508
这些格式可以来自于我们或你们
甚至来自于Swift包

985
00:50:07,574 --> 00:50:10,010
这些格式可以与这些类型一起运作

986
00:50:10,077 --> 00:50:12,880
来自于我们的 来自于你们的
或者来自Swift包的

987
00:50:13,714 --> 00:50:16,083
不过我们也理解 不同的格式

988
00:50:16,149 --> 00:50:19,286
有着不同的基础类型和不同的规范

989
00:50:19,820 --> 00:50:21,588
因为我们保证运作正常的机制

990
00:50:21,655 --> 00:50:23,123
叫作编码战略

991
00:50:23,624 --> 00:50:27,761
这是针对特定类型的
基于编码器和解码器的定制

992
00:50:28,061 --> 00:50:30,564
例如 在JSON中
我们已经看到了关于日期的内容

993
00:50:30,931 --> 00:50:34,935
在我们的GitHub例子中
日期被编码为ISO8601字符串

994
00:50:35,402 --> 00:50:38,105
不过还有其他可能的规范

995
00:50:38,172 --> 00:50:40,841
例如 作为引用日期的秒数

996
00:50:40,908 --> 00:50:43,076
作为引用日期的毫秒数

997
00:50:43,143 --> 00:50:45,746
或者你甚至可以声明
一个完全定制的日期格式器

998
00:50:45,812 --> 00:50:48,015
如果你脑子里有些很专注的东西

999
00:50:48,916 --> 00:50:51,785
JSON编码器和解码器
支持其他种类的战略

1000
00:50:51,852 --> 00:50:53,654
例如 对于数据

1001
00:50:53,854 --> 00:50:56,990
在JSON中 用Base64
编码数据是很常见的

1002
00:50:57,824 --> 00:51:01,061
不过我们也允许你通过选择战略
来定制这个

1003
00:51:01,128 --> 00:51:03,564
也就是作为字节码的数组来编码它

1004
00:51:03,630 --> 00:51:06,200
或者你可以声明某些完全定制的东西
像是这个

1005
00:51:06,266 --> 00:51:09,136
把所有的零变成绵羊
把所有其他的变成狗

1006
00:51:09,403 --> 00:51:13,373
我不知道你为什么要这么做
但是这是可能的 就是这样

1007
00:51:13,907 --> 00:51:17,377
抽象也可以帮助我们利用不同的格式

1008
00:51:17,444 --> 00:51:19,479
如我们所见 今天谈论了
很多关于JSON的东西

1009
00:51:19,546 --> 00:51:23,016
但实际上 我们也引入了
属性表的编码器和解码器

1010
00:51:23,283 --> 00:51:27,721
而属性表 不像是JSON
有对于数据和日期的原生类型

1011
00:51:27,821 --> 00:51:29,756
因此当这些编码器和解码器

1012
00:51:30,090 --> 00:51:32,860
遇到这些对象
无论它正在编码的对象图里

1013
00:51:32,926 --> 00:51:34,995
还是在解压缩的数据里

1014
00:51:35,329 --> 00:51:38,565
我们都可以将它们转换成
对于该格式恰当正确的类型

1015
00:51:39,733 --> 00:51:42,503
由于这些抽象
我们可以采用可编码性协议

1016
00:51:42,569 --> 00:51:45,939
在许多Foundation类型中
包括所有你们在这看到的

1017
00:51:47,708 --> 00:51:49,543
我们已经谈论了许多关于
可编码性API的内容

1018
00:51:49,610 --> 00:51:51,845
我想要给你们一个清晰的概括

1019
00:51:51,912 --> 00:51:54,047
来帮助你们理解全局

1020
00:51:54,114 --> 00:51:56,450
当然了 我们从你的类型开始

1021
00:51:56,517 --> 00:52:00,754
你的类型采用两种协议
他们叫作可编码性和可解码性

1022
00:52:01,822 --> 00:52:03,924
它们有一个函数和一个初始化

1023
00:52:03,991 --> 00:52:07,160
其让你访问编码器和解码器

1024
00:52:08,161 --> 00:52:10,163
这些可供你访问容器

1025
00:52:10,230 --> 00:52:13,133
那也是在压缩数据中
实际保存值的地方

1026
00:52:13,200 --> 00:52:14,868
在加密容器的情况下

1027
00:52:14,935 --> 00:52:18,005
我们使用由你的类型
所定义的CodingKeys

1028
00:52:19,106 --> 00:52:21,475
最后 就是编码器和容器

1029
00:52:21,542 --> 00:52:26,079
提供了对于编码格式的抽象
像是JSON 属性表等等

1030
00:52:28,148 --> 00:52:31,351
我们今天开始时候
介绍了一些新的API

1031
00:52:31,418 --> 00:52:34,321
还有今年新发布的
Foundation所改进的性能表现

1032
00:52:34,388 --> 00:52:37,691
在那之后
我们看了Swift新的强类型键径

1033
00:52:37,758 --> 00:52:42,596
包括一个非常酷的用例 就是全新的
基于终结的KVO API

1034
00:52:43,063 --> 00:52:45,766
最后 我们介绍新的可编码性协议

1035
00:52:45,832 --> 00:52:48,836
其使得与其他格式的集成非常简单
像是JSON

1036
00:52:48,902 --> 00:52:52,306
而且也允许你进行强大的定制

1037
00:52:53,607 --> 00:52:55,542
有关更多信息 请查阅这个链接

1038
00:52:56,009 --> 00:52:58,879
我们有一些与所谈内容相关的演讲

1039
00:53:00,514 --> 00:53:01,448
非常感谢

