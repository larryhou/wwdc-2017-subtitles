1
00:00:22,516 --> 00:00:27,556
[掌声]

2
00:00:28,056 --> 00:00:29,076
>> 大家下午好

3
00:00:29,076 --> 00:00:30,446
欢迎来到

4
00:00:30,446 --> 00:00:31,796
Metal 2 优化和调试

5
00:00:31,796 --> 00:00:34,716
你们已经知道 我们今年

6
00:00:34,716 --> 00:00:35,856
有很多关于 Metal 2 的内容

7
00:00:35,856 --> 00:00:37,116
在一些平台上实现了

8
00:00:37,116 --> 00:00:39,106
一些很好的提升

9
00:00:39,106 --> 00:00:40,966
包括 GP 驱动渲染 机器学习加速

10
00:00:40,966 --> 00:00:43,936
macOS VR 和

11
00:00:43,936 --> 00:00:45,716
外部 GPU 支持

12
00:00:47,106 --> 00:00:48,466
别忘了还有

13
00:00:48,466 --> 00:00:49,636
高级优化工具

14
00:00:50,186 --> 00:00:52,886
所以 今天下午我们

15
00:00:52,886 --> 00:00:54,536
将会讨论一下当前的

16
00:00:54,666 --> 00:00:56,076
Metal 工具

17
00:00:56,376 --> 00:00:57,906
简要概括一下它们

18
00:00:57,906 --> 00:00:59,536
并介绍一些很棒的

19
00:00:59,536 --> 00:01:01,356
针对 Metal 帧调试工具的提升

20
00:01:01,356 --> 00:01:03,136
最后讨论一些

21
00:01:03,136 --> 00:01:04,016
关于 GPU 配置的内容

22
00:01:04,676 --> 00:01:08,016
首先 我们来看看 帧调试工具

23
00:01:10,226 --> 00:01:12,056
我希望你们都

24
00:01:12,056 --> 00:01:12,776
熟悉这个工具

25
00:01:14,076 --> 00:01:15,376
帧调试工具集成在 Xcode 中

26
00:01:15,376 --> 00:01:17,246
功能齐全

27
00:01:17,246 --> 00:01:20,106
让你可以处理你的

28
00:01:20,106 --> 00:01:22,586
Metal 2 作品

29
00:01:22,966 --> 00:01:24,126
让它成为计算机图形

30
00:01:24,126 --> 00:01:25,086
并且可以进一步检查

31
00:01:25,086 --> 00:01:27,086
状态和资源

32
00:01:27,476 --> 00:01:28,186
让你能够调试和优化

33
00:01:29,076 --> 00:01:33,216
提升帧调试

34
00:01:33,216 --> 00:01:34,006
工具的性能

35
00:01:34,006 --> 00:01:34,886
是我们最近几年

36
00:01:34,886 --> 00:01:36,676
的工作中心之一

37
00:01:36,676 --> 00:01:38,316
我们尤其

38
00:01:38,316 --> 00:01:39,386
注意提升

39
00:01:39,676 --> 00:01:40,346
捕获速度

40
00:01:40,346 --> 00:01:43,096
我很开心告诉大家

41
00:01:43,096 --> 00:01:46,436
与 Xcode 8 相比

42
00:01:46,436 --> 00:01:48,586
Xcode 9 现在的捕获速度

43
00:01:49,106 --> 00:01:50,116
可以达到原来的 10 倍

44
00:01:50,116 --> 00:01:51,556
让你从点按 Capture 按钮

45
00:01:51,556 --> 00:01:52,946
到打开调试工具的时间

46
00:01:52,946 --> 00:01:53,256
大大缩短

47
00:01:56,036 --> 00:01:58,466
如你期待的那样

48
00:01:58,466 --> 00:02:00,036
我们全面支持了 Metal 2 的 API

49
00:02:00,036 --> 00:02:02,006
包括光栅顺序组

50
00:02:02,006 --> 00:02:04,346
采样数组  Viewport 数组

51
00:02:04,346 --> 00:02:06,146
以及全新的像素和

52
00:02:06,146 --> 00:02:07,356
顶点数组格式

53
00:02:07,876 --> 00:02:10,856
在 Metal 2 中

54
00:02:10,856 --> 00:02:12,406
我们花了很大精力

55
00:02:12,406 --> 00:02:14,116
来支持全新的

56
00:02:14,116 --> 00:02:15,296
参数缓冲器

57
00:02:15,936 --> 00:02:17,376
有了它 在缓冲查看器中

58
00:02:17,626 --> 00:02:19,386
你可以看到所有的

59
00:02:19,386 --> 00:02:20,546
参数 缓冲参数

60
00:02:20,646 --> 00:02:22,196
都一行行显示出来

61
00:02:22,196 --> 00:02:23,856
你可以点按它们选择是否要

62
00:02:23,856 --> 00:02:26,516
附上你的采样器 缓冲器

63
00:02:26,516 --> 00:02:32,686
或者其他参数缓冲器

64
00:02:32,686 --> 00:02:33,956
此外 随着对 SteamVR 的自动支持

65
00:02:33,956 --> 00:02:35,196
我们今年开始支持

66
00:02:35,196 --> 00:02:36,456
VR 捕获

67
00:02:36,456 --> 00:02:38,316
我们也为你们提供了

68
00:02:38,316 --> 00:02:40,216
让你们可以以立体的形式

69
00:02:40,216 --> 00:02:40,966
查看你们上传的界面的支持

70
00:02:41,446 --> 00:02:43,526
当你们发送 提交

71
00:02:43,526 --> 00:02:44,576
指令的时候 你将会向

72
00:02:44,576 --> 00:02:46,116
VR 混合器发送你的界面

73
00:02:46,406 --> 00:02:47,786
你会同时看到

74
00:02:47,786 --> 00:02:49,556
左右眼的视图

75
00:02:49,556 --> 00:02:51,106
可以帮助你发现其中的差异

76
00:02:51,676 --> 00:02:56,496
今年的另一个工作重心是

77
00:02:56,716 --> 00:02:58,006
为了要针对更复杂的计算任务

78
00:02:58,006 --> 00:02:59,456
进行捕获

79
00:02:59,456 --> 00:03:00,416
我们改进了捕获工作流

80
00:03:00,826 --> 00:03:01,836
所以如果你现在

81
00:03:01,896 --> 00:03:04,036
只在 Metal 里做纯计算任务

82
00:03:04,036 --> 00:03:05,396
或者如果你同时有多个

83
00:03:05,396 --> 00:03:07,516
Metal 命令队列  现在我们就可以

84
00:03:07,516 --> 00:03:08,846
更轻松地  准确捕获到你想要

85
00:03:08,846 --> 00:03:09,396
的那部分内容

86
00:03:10,446 --> 00:03:11,526
我们还添加了轻便型

87
00:03:11,526 --> 00:03:13,576
捕获 API  其中内置了一些新的 Metal

88
00:03:13,576 --> 00:03:15,406
捕获作用域对象  我们可以在新建

89
00:03:15,406 --> 00:03:17,416
项目时创建这些对象  然后后期在

90
00:03:17,416 --> 00:03:19,276
每一帧都可以重复利用  可以用来

91
00:03:19,276 --> 00:03:20,136
包裹住之后想捕获的部分

92
00:03:20,546 --> 00:03:21,656
我们稍后会看到这项的演示

93
00:03:21,656 --> 00:03:22,746
这给我们带来了新的可能性

94
00:03:22,746 --> 00:03:25,346
比如说  现在可以把我们所有的

95
00:03:25,626 --> 00:03:28,006
正常渲染任务都包在一个作用域里

96
00:03:28,006 --> 00:03:29,666
把其他那些异步任务  比如说

97
00:03:29,916 --> 00:03:31,126
重新生成我们的密铺因子缓冲区

98
00:03:31,126 --> 00:03:32,866
这一类的任务  归到另一个

99
00:03:32,866 --> 00:03:33,956
作用域里  这样等我们开始捕获的时候

100
00:03:33,956 --> 00:03:35,456
就可以精准地制定区域  获得想要的

101
00:03:35,456 --> 00:03:35,866
结果

102
00:03:37,416 --> 00:03:38,576
我们现在还支持

103
00:03:38,576 --> 00:03:39,266
在我们的应用程序中

104
00:03:39,266 --> 00:03:40,766
用编程方式触发捕获过程

105
00:03:41,316 --> 00:03:43,026
其实我们在自己的测试应用程序里

106
00:03:43,026 --> 00:03:44,256
也经常使用这一功能  用上之后

107
00:03:44,256 --> 00:03:45,436
比如我们可以立马在设备上做一个

108
00:03:45,436 --> 00:03:46,826
什么手势  然后就可以自动触发

109
00:03:47,216 --> 00:03:48,476
帧捕获  我们就不用再

110
00:03:48,476 --> 00:03:53,046
费力切换回 Xcode 去实现这个功能了

111
00:03:53,546 --> 00:03:55,076
今年要宣布的另一个新功能

112
00:03:55,076 --> 00:03:56,676
是 Xcode 的快速预览(Quick Looks)

113
00:03:57,046 --> 00:03:57,606
功能

114
00:03:58,826 --> 00:04:00,766
现在在 CPU 调试工具里

115
00:04:00,766 --> 00:04:02,286
有了新的轻便型 Metal

116
00:04:02,286 --> 00:04:02,856
调试功能

117
00:04:03,116 --> 00:04:05,276
假设我们现在再遇到断点

118
00:04:05,276 --> 00:04:07,316
如果包含有 Metal 纹理

119
00:04:07,796 --> 00:04:09,206
快速预览就会从 GPU 里

120
00:04:09,206 --> 00:04:11,426
自动提取 Metal 纹理数据

121
00:04:11,426 --> 00:04:12,716
然后给大家提供实时预览

122
00:04:12,916 --> 00:04:14,106
同样的功能  也支持预览缓冲区

123
00:04:14,106 --> 00:04:14,586
和采样器

124
00:04:15,486 --> 00:04:17,375
对于有些不太方便

125
00:04:17,375 --> 00:04:19,796
做完整帧捕获的项目  这个功能

126
00:04:19,796 --> 00:04:21,736
非常有用  举个例子来说

127
00:04:21,736 --> 00:04:22,786
如果我们要调试的是

128
00:04:22,786 --> 00:04:24,156
资源载入  或者一些设置代码

129
00:04:24,156 --> 00:04:24,546
这一类

130
00:04:24,546 --> 00:04:27,506
另外  如果我们要调试一些

131
00:04:27,506 --> 00:04:28,916
计算任务  用这个断点预览

132
00:04:28,916 --> 00:04:32,606
也会非常方便

133
00:04:33,026 --> 00:04:35,156
去年我们介绍了

134
00:04:35,416 --> 00:04:37,056
在帧调试工具里

135
00:04:37,266 --> 00:04:38,606
全局可用的  丰富的过滤功能

136
00:04:38,686 --> 00:04:41,526
我们可以同时过滤

137
00:04:41,526 --> 00:04:42,946
比如  资源属性  这一类东西

138
00:04:43,426 --> 00:04:44,356
但同时  在帧

139
00:04:44,356 --> 00:04:47,156
导航栏里  我们也可以依据

140
00:04:47,156 --> 00:04:49,606
上下文数据进行过滤  这样如果

141
00:04:49,936 --> 00:04:51,146
我们的过滤条件是一个特定绘制指令

142
00:04:51,146 --> 00:04:52,506
所用的资源  过滤结果就会输出

143
00:04:52,506 --> 00:04:53,566
那个特定的绘制指令

144
00:04:53,756 --> 00:04:55,196
我们今年把这一功能进行了改进

145
00:04:55,196 --> 00:04:56,626
能达到的功能更上一层楼了

146
00:04:56,626 --> 00:04:58,136
现在我们还可以支持在整个

147
00:04:58,136 --> 00:04:59,476
捕获帧内进行数据挖掘

148
00:05:00,156 --> 00:05:01,716
所以现在我们一边输入  程序

149
00:05:01,716 --> 00:05:03,626
就会一边自动返回上下文相关的

150
00:05:03,626 --> 00:05:04,866
自动补全建议

151
00:05:05,706 --> 00:05:07,886
而且我们现在还支持复合术语

152
00:05:08,326 --> 00:05:10,236
所以如果现在先限定某个特定的

153
00:05:10,236 --> 00:05:12,506
编码器  然后再限定某个

154
00:05:12,506 --> 00:05:14,696
纹理  我们现在给你显示

155
00:05:14,696 --> 00:05:15,806
出的的自动补全建议  就会是

156
00:05:15,806 --> 00:05:17,026
那个特定编码器里

157
00:05:17,026 --> 00:05:22,346
实际用到的纹理

158
00:05:22,946 --> 00:05:24,386
这几年来  我们收到

159
00:05:24,386 --> 00:05:25,806
请求最多的一项功能就是

160
00:05:25,806 --> 00:05:27,106
像素审查 (Pixel Inspection) 功能

161
00:05:28,386 --> 00:05:29,496
我们现在终于满足了这一需求

162
00:05:30,386 --> 00:05:32,186
所以现在我们可以针对

163
00:05:32,186 --> 00:05:34,886
每一个独立像素  做详细的审查

164
00:05:35,196 --> 00:05:36,706
不管是在纹理  还是

165
00:05:36,706 --> 00:05:37,486
在渲染目标中

166
00:05:38,046 --> 00:05:39,366
而如果你的渲染

167
00:05:39,366 --> 00:05:40,196
目标中  包含有多个附件

168
00:05:40,196 --> 00:05:41,606
我们还会在同一时间

169
00:05:41,656 --> 00:05:43,366
给你显示出每个

170
00:05:43,366 --> 00:05:45,206
附件内部同等位置处的

171
00:05:45,206 --> 00:05:45,866
像素值

172
00:05:45,976 --> 00:05:47,146
所以如果我们要看着附件调试

173
00:05:47,146 --> 00:05:48,836
颜色值啊  同时还要调试

174
00:05:48,836 --> 00:05:50,136
模版啊之类的东西

175
00:05:50,136 --> 00:05:51,036
就会非常方便

176
00:05:51,346 --> 00:05:52,916
这个功能在调试计算任务

177
00:05:52,916 --> 00:05:54,516
的时候  也非常有用

178
00:05:54,516 --> 00:05:55,746
比如你正在处理图片

179
00:05:55,746 --> 00:05:56,996
假设我们的

180
00:05:56,996 --> 00:05:58,236
CNN 正做到一半  但是想测试一下

181
00:05:58,236 --> 00:05:59,686
看看各个缓冲区里面的实际

182
00:05:59,686 --> 00:06:01,036
数值都是多少  就可以用这个来

183
00:06:01,036 --> 00:06:01,306
审查

184
00:06:03,516 --> 00:06:07,546
[掌声]

185
00:06:08,046 --> 00:06:09,026
我们去年介绍的

186
00:06:09,026 --> 00:06:10,556
另一个新功能  就是

187
00:06:10,556 --> 00:06:12,436
顶点属性观察器  在这里

188
00:06:12,436 --> 00:06:14,336
我们可以看到  所有在传入我们的

189
00:06:14,486 --> 00:06:16,376
顶点着色引擎的顶点数据

190
00:06:16,376 --> 00:06:18,246
数据按照每个顶点分开

191
00:06:18,246 --> 00:06:19,856
显示

192
00:06:20,496 --> 00:06:21,446
好了  今年  我们又添加

193
00:06:21,446 --> 00:06:23,626
了新的功能  现在我们也可以看到

194
00:06:23,626 --> 00:06:25,556
顶点着色引擎输出的顶点数据了

195
00:06:25,696 --> 00:06:27,766
我们还会把这个内联

196
00:06:28,076 --> 00:06:29,776
和之前支持的输入时的数据并列显示

197
00:06:30,146 --> 00:06:31,476
所以在这个例子里  我们可以看到

198
00:06:31,476 --> 00:06:33,306
输入的顶点位置数据  和输出的

199
00:06:33,306 --> 00:06:34,596
顶点位置数据  同时显示在

200
00:06:34,596 --> 00:06:35,000
一起

201
00:06:38,046 --> 00:06:38,866
好了  现在该给大家实际

202
00:06:38,866 --> 00:06:40,076
演示一下我说过的这些新功能了

203
00:06:40,076 --> 00:06:41,256
请允许我邀请我的同事

204
00:06:41,486 --> 00:06:42,686
Max 上台  他将会给大家

205
00:06:42,686 --> 00:06:44,106
演示刚刚说过的这些精彩的

206
00:06:44,106 --> 00:06:45,076
新功能

207
00:06:46,516 --> 00:06:49,556
[掌声]

208
00:06:50,056 --> 00:06:51,956
大家好  很高兴今天在这里见到

209
00:06:51,956 --> 00:06:52,386
大家

210
00:06:52,526 --> 00:06:57,706
我希望大家手头工作进展都不错

211
00:06:57,706 --> 00:06:59,776
而你们都和我们一样  对 Metal 充满

212
00:06:59,776 --> 00:07:00,236
激情

213
00:07:00,636 --> 00:07:02,616
Xcode 的 GPU 调试工具可以帮我们

214
00:07:02,616 --> 00:07:04,456
调试我们的 GPU 和 Metal 占用

215
00:07:04,456 --> 00:07:05,146
情况

216
00:07:05,616 --> 00:07:07,356
我叫作 Max  今天我会帮大家

217
00:07:07,356 --> 00:07:08,496
最优化 (maximize) 你们的调试

218
00:07:08,496 --> 00:07:09,886
体验  给大家演示下新的

219
00:07:09,886 --> 00:07:10,246
功能

220
00:07:11,516 --> 00:07:14,696
[掌声]

221
00:07:15,196 --> 00:07:17,106
让我运行一下我的示例程序

222
00:07:19,576 --> 00:07:21,676
这里渲染出来的  是一幅美丽的

223
00:07:21,676 --> 00:07:24,056
风景  显示出来  雪中

224
00:07:24,056 --> 00:07:26,266
的山脉啦  在风中飘动

225
00:07:26,266 --> 00:07:27,936
的草啦  然后为了让效果

226
00:07:27,936 --> 00:07:29,986
看起来更好  我还添加了一些

227
00:07:29,986 --> 00:07:31,846
颗粒  并让它们在空中闪闪

228
00:07:32,606 --> 00:07:33,176
发光

229
00:07:33,216 --> 00:07:35,636
但就像大家看到的那样

230
00:07:35,636 --> 00:07:37,826
草上面的这些颗粒  看起来

231
00:07:37,826 --> 00:07:39,316
渲染得有点问题

232
00:07:39,546 --> 00:07:41,196
所以让我们看看怎么解决一下

233
00:07:41,756 --> 00:07:46,296
作为调试的第一步  让我们先看看

234
00:07:46,296 --> 00:07:47,336
纹理设置对了没有

235
00:07:47,906 --> 00:07:49,436
我们在渲染循环里设置

236
00:07:49,436 --> 00:07:50,656
一个断点  设置在正要

237
00:07:50,716 --> 00:07:52,116
使用这个纹理的时候

238
00:07:53,216 --> 00:07:54,846
把鼠标悬停在一个变量上

239
00:07:54,846 --> 00:07:57,226
我们就可以看到 Xcode 的数据提示

240
00:07:57,566 --> 00:07:59,446
可通过 Xcode 这个提示快速查看该变量的

241
00:07:59,446 --> 00:08:00,196
纹理数据

242
00:08:00,726 --> 00:08:02,296
这个纹理数据  是实时从 GPU

243
00:08:02,296 --> 00:08:03,996
抓取的  可以帮助我们

244
00:08:03,996 --> 00:08:05,576
快速确认  是否绑定上了正确

245
00:08:05,576 --> 00:08:07,466
的资源  当然  这个功能对于

246
00:08:07,466 --> 00:08:09,136
所有的 Metal 资源都可用

247
00:08:09,856 --> 00:08:12,196
我们目前这个变量的纹理看起来

248
00:08:12,196 --> 00:08:12,916
没有错

249
00:08:13,406 --> 00:08:20,006
那么我们还有什么可以检查的

250
00:08:20,276 --> 00:08:21,786
我们下一步  就可以开始捕获帧

251
00:08:21,786 --> 00:08:22,226
了

252
00:08:22,686 --> 00:08:25,336
只需点击调试栏里的这个

253
00:08:25,336 --> 00:08:27,366
小照相机图标  我们就可以捕获

254
00:08:27,366 --> 00:08:29,866
一帧  但如果我们长按这个图标

255
00:08:30,146 --> 00:08:31,556
就会显示出菜单  可以选择捕获

256
00:08:31,556 --> 00:08:33,596
作用域  或者命令队列

257
00:08:33,876 --> 00:08:36,106
捕获作用域是通过渲染通道

258
00:08:36,306 --> 00:08:37,596
完成

259
00:08:37,846 --> 00:08:39,035
就像我的环境图  这个

260
00:08:39,035 --> 00:08:40,395
我每几帧  才更新

261
00:08:40,395 --> 00:08:41,066
一次

262
00:08:41,826 --> 00:08:43,366
但这个例子里  我们想要

263
00:08:43,366 --> 00:08:44,596
捕获的是渲染过程  因为这个

264
00:08:44,596 --> 00:08:45,636
过程里才会真正开始绘制颗粒

265
00:08:46,866 --> 00:08:49,836
所以我们点击  捕获一下

266
00:08:50,046 --> 00:08:50,946
这就捕获好了

267
00:08:51,476 --> 00:08:54,096
对于那些不太熟悉我们的工具

268
00:08:54,096 --> 00:08:55,956
界面的人  我先给大家

269
00:08:55,956 --> 00:08:56,986
快速讲解一下在这个

270
00:08:56,986 --> 00:08:58,186
界面上  都有些什么东西

271
00:08:58,186 --> 00:09:01,726
在界面左侧  我们可以看到

272
00:09:01,726 --> 00:09:02,716
调试工具导航栏

273
00:09:03,186 --> 00:09:04,276
在这里按等级

274
00:09:04,276 --> 00:09:06,396
显示了我们的帧  为了更加

275
00:09:06,396 --> 00:09:08,016
方便大家调试使用  自动

276
00:09:08,016 --> 00:09:10,316
进行了分组  分开了命令缓冲区

277
00:09:10,316 --> 00:09:11,376
和命令编码器

278
00:09:12,346 --> 00:09:13,926
我们的调试组

279
00:09:13,926 --> 00:09:15,936
也显示在这里了  让我们在

280
00:09:15,936 --> 00:09:17,566
微小的层面上也可以掌控调整帧

281
00:09:17,906 --> 00:09:19,856
我们可以选择绘制指令

282
00:09:19,856 --> 00:09:21,526
或者任何其他的 Metal 指令  来审查

283
00:09:21,526 --> 00:09:22,346
其更多细节

284
00:09:23,136 --> 00:09:27,406
位于界面中央的编辑器

285
00:09:27,406 --> 00:09:29,106
向我们展示了绑定的资源

286
00:09:29,496 --> 00:09:30,846
展示了选中的 API 指令中

287
00:09:30,846 --> 00:09:32,986
我们所用到的所有的 Metal 对象

288
00:09:33,986 --> 00:09:35,976
在这里我们也可以看到  为我们的对象

289
00:09:35,976 --> 00:09:37,726
添加标签  可以有效提高调试时的

290
00:09:37,726 --> 00:09:38,536
可读性

291
00:09:38,926 --> 00:09:41,306
我建议大家都养成这个习惯

292
00:09:42,956 --> 00:09:45,026
界面右侧的编辑器

293
00:09:45,026 --> 00:09:46,556
显示的是附件  是最近

294
00:09:46,556 --> 00:09:48,556
一次绘制指令的输出结果

295
00:09:49,136 --> 00:09:50,066
所以不管你什么时候

296
00:09:50,066 --> 00:09:51,416
不管在帧的哪里

297
00:09:51,606 --> 00:09:53,106
都可以马上看到自己在哪一步

298
00:09:53,936 --> 00:09:56,346
在界面最下方  我们有

299
00:09:56,346 --> 00:09:58,166
变量观察器  可以让我们

300
00:09:58,166 --> 00:10:00,156
方便地查看每个 Metal 对象的

301
00:10:00,156 --> 00:10:01,026
状态

302
00:10:01,506 --> 00:10:03,296
好了  我们回到刚刚颗粒的

303
00:10:03,296 --> 00:10:04,366
问题上

304
00:10:04,786 --> 00:10:06,216
现在我们就可以试验一下超强的

305
00:10:06,216 --> 00:10:07,756
过滤功能

306
00:10:08,496 --> 00:10:11,226
好了  现在我知道  那些颗粒

307
00:10:11,226 --> 00:10:12,666
是在正向渲染过程中某处绘制的

308
00:10:13,316 --> 00:10:15,556
所以让我们试着过滤一下

309
00:10:15,866 --> 00:10:17,576
如果对命令编码器进行过滤

310
00:10:17,976 --> 00:10:20,786
那么结果只会显示这个命令编码器

311
00:10:20,786 --> 00:10:21,926
里的 API 指令

312
00:10:21,926 --> 00:10:22,846
比如像这样

313
00:10:23,446 --> 00:10:25,486
但结果还是太多了

314
00:10:26,646 --> 00:10:28,386
所以我们再添加一个额外的过滤

315
00:10:28,386 --> 00:10:28,736
条件

316
00:10:29,086 --> 00:10:30,616
我们知道会用到颗粒

317
00:10:30,616 --> 00:10:31,066
纹理

318
00:10:34,556 --> 00:10:37,186
如果对纹理进行过滤  那么结果

319
00:10:37,186 --> 00:10:39,476
只会显示使用了此纹理的绘制

320
00:10:39,476 --> 00:10:39,896
指令

321
00:10:40,576 --> 00:10:43,656
这就好了  这两个过滤条件

322
00:10:43,656 --> 00:10:46,046
叠加  就能过滤出唯一的 API 指令

323
00:10:46,046 --> 00:10:47,986
而这一指令正是我们希望进一步研究的

324
00:10:48,726 --> 00:10:49,536
我们来看一下

325
00:10:50,016 --> 00:10:53,296
我们先看一下这个指令绑定的

326
00:10:53,296 --> 00:10:54,166
资源

327
00:10:55,046 --> 00:10:57,026
这里  顶点属性中包含了

328
00:10:57,026 --> 00:10:58,456
输入顶点函数的数据  也包含了

329
00:10:58,456 --> 00:11:01,026
离开顶点函数的数据

330
00:11:01,296 --> 00:11:02,616
也许我们就是在这里搞错了

331
00:11:02,616 --> 00:11:05,106
一些几何特征的设定

332
00:11:05,106 --> 00:11:06,196
所以我们看一下  双击

333
00:11:06,196 --> 00:11:06,616
打开

334
00:11:07,626 --> 00:11:09,696
让我们先把这边的附件

335
00:11:09,696 --> 00:11:10,406
隐藏一下

336
00:11:11,626 --> 00:11:13,036
去年  我们给大家展示了

337
00:11:13,036 --> 00:11:14,436
缓冲区一种更好的布局

338
00:11:16,516 --> 00:11:17,836
今年我们还新添加了一些别的东西

339
00:11:18,986 --> 00:11:20,316
在界面眉头  我们可以看到

340
00:11:20,316 --> 00:11:21,746
下方显示的数据是输入还是

341
00:11:21,746 --> 00:11:22,306
输出

342
00:11:23,266 --> 00:11:28,336
如果我们看一下  这边

343
00:11:28,336 --> 00:11:29,626
就是输出的数据  是离开

344
00:11:29,626 --> 00:11:31,106
顶点函数的数据

345
00:11:31,376 --> 00:11:32,966
这些显示了全部颗粒顶点

346
00:11:33,106 --> 00:11:35,776
输出时的位置  我们在这里

347
00:11:35,776 --> 00:11:37,336
可以看到  没有

348
00:11:37,376 --> 00:11:39,286
什么很明显的错误  比如哪个数据

349
00:11:39,286 --> 00:11:41,166
数值过大之类的问题  所以我先

350
00:11:41,166 --> 00:11:42,706
假设这些数据都是正确的

351
00:11:43,446 --> 00:11:45,336
那么我们还可以检查哪里

352
00:11:46,036 --> 00:11:50,386
调试工具导航栏现在还可以让

353
00:11:50,386 --> 00:11:51,836
我们快速定位并进入到当前

354
00:11:51,836 --> 00:11:53,596
绘制指令所相关的所有视图

355
00:11:53,926 --> 00:11:54,846
让我们再切换回

356
00:11:54,846 --> 00:11:55,746
附件看看

357
00:11:56,256 --> 00:12:01,306
我们现在显示了

358
00:12:01,306 --> 00:12:01,506
两种渲染目标

359
00:12:02,436 --> 00:12:04,566
颜色  和深度

360
00:12:05,076 --> 00:12:06,796
让我们再审查一些

361
00:12:06,796 --> 00:12:07,376
像素值吧

362
00:12:07,876 --> 00:12:11,586
我们可以使用位于界面右下方的

363
00:12:11,586 --> 00:12:13,156
审查像素按钮  这就可以

364
00:12:13,226 --> 00:12:16,456
唤出一个新工具

365
00:12:16,556 --> 00:12:20,386
一个环形  这个圆环里显示的

366
00:12:20,386 --> 00:12:22,106
数据  和片元函数输出的

367
00:12:22,106 --> 00:12:23,296
数据完全一致

368
00:12:24,246 --> 00:12:26,256
我们可以用鼠标在渲染目标上

369
00:12:26,256 --> 00:12:27,506
随意移动这个圆环

370
00:12:28,386 --> 00:12:29,796
但我们也可以通过方向键

371
00:12:29,796 --> 00:12:31,796
进行精准到像素级别的控制移动

372
00:12:31,796 --> 00:12:33,186
移动之前甚至都不用放大

373
00:12:34,396 --> 00:12:36,566
我们还可以注意到  在所有的

374
00:12:36,566 --> 00:12:37,806
渲染目标上  圆环的移动都是

375
00:12:37,806 --> 00:12:38,956
完全同步的

376
00:12:39,246 --> 00:12:40,976
可让我们同时查看两边的数值

377
00:12:41,256 --> 00:12:43,306
我们现在就找一个

378
00:12:45,056 --> 00:12:45,136
有趣的像素来看一下

379
00:12:45,356 --> 00:12:46,426
我们长按  就可以

380
00:12:46,426 --> 00:12:47,666
立即移动光标

381
00:12:48,286 --> 00:12:51,686
在这个点上  我们可以看出有些

382
00:12:51,686 --> 00:12:52,576
奇怪

383
00:12:53,466 --> 00:12:55,676
这个颗粒的内部和外部

384
00:12:55,676 --> 00:12:57,586
深度数值不一样

385
00:12:58,076 --> 00:12:59,796
这很奇怪  正常情况下

386
00:12:59,796 --> 00:13:00,946
我们的颗粒不应该写入

387
00:13:00,946 --> 00:13:01,896
深度缓冲区

388
00:13:02,526 --> 00:13:03,896
把这里修好应该很简单

389
00:13:04,316 --> 00:13:05,976
我相信  我们新的 GPU

390
00:13:05,976 --> 00:13:07,536
调试工具也可以帮大家快速地

391
00:13:07,536 --> 00:13:08,886
修好你们 GPU 里的问题

392
00:13:09,906 --> 00:13:11,346
我希望明天早上可以在实验室里

393
00:13:11,346 --> 00:13:13,326
或是在今天的晚些时候

394
00:13:13,326 --> 00:13:14,226
再次看到大家

395
00:13:14,936 --> 00:13:16,296
下面还有请我的同事 Seth

396
00:13:17,516 --> 00:13:23,256
[掌声]

397
00:13:23,756 --> 00:13:26,276
好了  下面我们讲 GPU 性能分析

398
00:13:27,896 --> 00:13:29,796
我们都知道   对于游戏和其他

399
00:13:29,796 --> 00:13:30,896
一些图形应用程序

400
00:13:30,896 --> 00:13:32,596
运行性能至关重要

401
00:13:32,596 --> 00:13:33,966
我们经常需要能够保持

402
00:13:33,966 --> 00:13:35,316
持续稳定的高帧率

403
00:13:36,106 --> 00:13:37,216
但另一方面  我们也

404
00:13:37,216 --> 00:13:38,616
希望能充分利用 GPU

405
00:13:38,616 --> 00:13:40,066
产出图形效果最好的游戏

406
00:13:40,066 --> 00:13:41,756
而同时希望能够提高效率

407
00:13:41,756 --> 00:13:43,106
延长高质量的游戏体验

408
00:13:43,106 --> 00:13:43,846
时间

409
00:13:44,556 --> 00:13:45,726
为了做到以上这些  我们就需要

410
00:13:45,726 --> 00:13:47,206
使用 GPU 性能分析 (Profiling) 工具

411
00:13:47,656 --> 00:13:53,046
我想讲的第一个工具叫作

412
00:13:53,046 --> 00:13:54,546
Metal 系统跟踪 (Metal System Trace)

413
00:13:55,396 --> 00:13:56,236
这个工具可以

414
00:13:56,236 --> 00:13:58,446
用来审查计时问题

415
00:13:58,446 --> 00:14:00,136
我的意思是说  可以审查一些场景

416
00:14:00,136 --> 00:14:02,446
比如有时 CPU 和 GPU 可能

417
00:14:02,446 --> 00:14:04,656
没有在并行运行

418
00:14:04,656 --> 00:14:06,286
而是因为我们错误地

419
00:14:06,286 --> 00:14:07,836
做了一些同步运行  使得

420
00:14:07,836 --> 00:14:08,726
CPU GPU 被迫无法并行

421
00:14:08,726 --> 00:14:09,116
转而连续运行

422
00:14:09,796 --> 00:14:10,586
这个工具还可以

423
00:14:10,586 --> 00:14:12,166
用来审查一些场景  比如

424
00:14:12,396 --> 00:14:13,586
我们大部分的帧都是

425
00:14:13,586 --> 00:14:14,676
我们想要的样子

426
00:14:14,676 --> 00:14:15,976
但偶尔会有卡顿

427
00:14:16,246 --> 00:14:17,126
然后我们需要去搞明白

428
00:14:17,126 --> 00:14:18,306
好了  就在卡顿的那里底

429
00:14:18,306 --> 00:14:19,226
到有什么问题

430
00:14:20,106 --> 00:14:21,676
这个工具可以让我们

431
00:14:21,676 --> 00:14:22,966
沿着系统跟踪 Metal 任务

432
00:14:23,046 --> 00:14:25,436
从 CPU 到 GPU 到显示

433
00:14:27,436 --> 00:14:29,606
今年  我们还增加了对 VR

434
00:14:29,606 --> 00:14:31,296
应用程序的支持

435
00:14:31,296 --> 00:14:33,056
包含具体的 VR 跟踪点

436
00:14:33,056 --> 00:14:35,836
可针对的活动有比如  当我们向

437
00:14:35,836 --> 00:14:38,916
虚拟现实头盔查询数据时

438
00:14:38,916 --> 00:14:40,516
向 VR Compositor 提交面层

439
00:14:40,516 --> 00:14:43,086
的时候  当 Compositor 进行

440
00:14:43,086 --> 00:14:45,196
排版生成的时候  还有

441
00:14:45,196 --> 00:14:46,946
最后显示在头戴设备的

442
00:14:47,106 --> 00:14:48,506
屏幕上的时候

443
00:14:49,576 --> 00:14:51,406
事实上  从运动到图像显示

444
00:14:51,406 --> 00:14:53,366
整个过程我们都可以追踪

445
00:14:55,976 --> 00:14:58,266
我们今年还添加了

446
00:14:58,266 --> 00:14:59,566
对 ProMotion 显示

447
00:14:59,566 --> 00:15:02,076
的支持  大家可以在新

448
00:15:02,076 --> 00:15:04,096
iPad 上找到  就是这周早些时候

449
00:15:04,096 --> 00:15:06,066
发布的新 iPad Pro  我们还在

450
00:15:06,066 --> 00:15:08,046
macOS 上新增了对外部 GPU 的

451
00:15:08,046 --> 00:15:08,666
支持

452
00:15:09,476 --> 00:15:10,776
另外值得注意的  还有

453
00:15:10,776 --> 00:15:11,906
我们对工具集也新做了很多

454
00:15:11,906 --> 00:15:13,846
很棒的改进  让我们可以更加

455
00:15:13,846 --> 00:15:15,616
便捷地查看其他工具集

456
00:15:15,786 --> 00:15:17,646
和 Metal 系统跟踪一起

457
00:15:17,646 --> 00:15:20,386
比以前整合程度更高了

458
00:15:20,816 --> 00:15:22,776
我们另一个性能分析的工具叫作

459
00:15:22,776 --> 00:15:23,806
GPU 着色器分析器 (GPU Shader Profiler)

460
00:15:24,306 --> 00:15:25,726
是分析着色器性能的

461
00:15:25,726 --> 00:15:26,326
不二选择

462
00:15:27,076 --> 00:15:28,316
我们把这个工具整合进了

463
00:15:28,316 --> 00:15:29,626
帧调试工具里  可以让我们

464
00:15:29,626 --> 00:15:31,466
针对每个绘制指令  每个管道

465
00:15:31,466 --> 00:15:33,116
分别查看着色时间

466
00:15:33,686 --> 00:15:37,416
而且  如果在 iOS 或者 Apple tvOS 上

467
00:15:37,416 --> 00:15:39,236
这个工具还可以让我们分

468
00:15:39,236 --> 00:15:39,956
条查看

469
00:15:41,696 --> 00:15:43,136
我们今年第一个全新的工具

470
00:15:43,136 --> 00:15:44,816
专门为了与 GPU 着色分析器

471
00:15:44,816 --> 00:15:46,006
协同工作而

472
00:15:46,006 --> 00:15:46,496
设计

473
00:15:48,636 --> 00:15:50,296
我们管这个工具叫作 Metal 管道

474
00:15:50,296 --> 00:15:51,046
统计工具 (Metal Pipeline Statistics)

475
00:15:53,036 --> 00:15:55,436
Metal 管道统计工具让我们

476
00:15:55,436 --> 00:15:57,456
可以直连 GPU 编译器

477
00:15:57,456 --> 00:15:59,306
编译器根据我们的着色器

478
00:15:59,306 --> 00:16:00,916
生成机器代码  而这个工具可以

479
00:16:00,916 --> 00:16:02,946
让我们查看这些机器代码的质量

480
00:16:03,016 --> 00:16:03,316
优劣

481
00:16:04,066 --> 00:16:05,176
这个工具会输出一系列

482
00:16:05,176 --> 00:16:06,606
丰富的统计数据  比如

483
00:16:06,756 --> 00:16:08,366
指令数啦  指令混合啦

484
00:16:08,366 --> 00:16:10,236
也就是说  统计

485
00:16:10,236 --> 00:16:11,796
像比如 ALU 内存  或者控制流

486
00:16:11,796 --> 00:16:13,396
这类操作所占的相对比例

487
00:16:13,396 --> 00:16:15,826
而在那些相关的

488
00:16:15,826 --> 00:16:17,216
GPU 上  分析输出结果还会

489
00:16:17,216 --> 00:16:18,866
显示寄存器使用和占用情况

490
00:16:19,306 --> 00:16:21,986
对于这部分 GPU 这些

491
00:16:22,016 --> 00:16:23,436
统计信息至关重要

492
00:16:23,436 --> 00:16:25,306
可以帮助我们理解

493
00:16:25,306 --> 00:16:27,766
同时多少个着色器工作的

494
00:16:27,766 --> 00:16:29,496
限制条件都是什么

495
00:16:30,176 --> 00:16:32,486
也就是说同时可以排

496
00:16:32,646 --> 00:16:33,646
多少个着色场景

497
00:16:34,876 --> 00:16:37,976
但更好用的  是新的

498
00:16:37,976 --> 00:16:39,066
编译器评论功能

499
00:16:39,736 --> 00:16:41,636
有个这个  GPU 编译器就可以

500
00:16:41,636 --> 00:16:43,446
针对你着色器的运行性能

501
00:16:43,666 --> 00:16:44,786
给你反馈出直接的  可操作

502
00:16:44,786 --> 00:16:46,506
的指导  还可以告诉我们具体该改进

503
00:16:46,506 --> 00:16:48,556
哪里  可以避免性能迟缓

504
00:16:48,556 --> 00:16:49,956
从比如慢计算使用情况

505
00:16:50,256 --> 00:16:51,776
寄存器溢出  和堆栈使用

506
00:16:51,776 --> 00:16:52,216
情况

507
00:16:52,796 --> 00:16:56,906
这就好像每个 Xcode 都自带了

508
00:16:56,906 --> 00:16:59,636
一位 GPU 编译器工程师

509
00:17:00,736 --> 00:17:02,806
对于每条评论  下面都会展开解释

510
00:17:02,946 --> 00:17:06,246
到底什么意思  我们可以做什么来

511
00:17:06,316 --> 00:17:08,796
提升性能  还会给我们提供一个链接

512
00:17:08,796 --> 00:17:11,006
点击就可以直接定位到需要修改的

513
00:17:11,076 --> 00:17:11,536
地方

514
00:17:12,695 --> 00:17:13,955
好了  为了给大家演示这个新功能

515
00:17:13,955 --> 00:17:15,036
我想请我的同事 Jose

516
00:17:15,256 --> 00:17:16,935
上台  给大家演示一下

517
00:17:16,935 --> 00:17:18,465
Metal 通道

518
00:17:18,465 --> 00:17:19,086
统计工具

519
00:17:20,516 --> 00:17:22,546
[掌声]

520
00:17:23,046 --> 00:17:23,536
>> 大家好

521
00:17:23,685 --> 00:17:24,526
我是 Jose Enrique

522
00:17:24,606 --> 00:17:26,006
我要为大家展示一个新特性

523
00:17:26,006 --> 00:17:27,556
那就是我们的对 GPU 友好的

524
00:17:27,556 --> 00:17:28,946
调试器 它会助你

525
00:17:29,296 --> 00:17:30,466
产出高质量的产品

526
00:17:30,836 --> 00:17:32,416
大家可以看到 我们

527
00:17:32,526 --> 00:17:33,786
正在重放一个在 iOS 上的

528
00:17:33,976 --> 00:17:35,166
捕捉 Metal 的演示

529
00:17:35,996 --> 00:17:37,956
我要做的第一件事

530
00:17:37,956 --> 00:17:39,286
就是把调试导航视图

531
00:17:39,286 --> 00:17:41,196
从按调用检视帧 (view frame

532
00:17:41,196 --> 00:17:42,766
by call） 改成按性能检视帧 (view frame by

533
00:17:42,766 --> 00:17:43,496
performance)

534
00:17:44,026 --> 00:17:46,916
这会给出 这个视图

535
00:17:46,916 --> 00:17:50,216
会给出你所捕捉的所有

536
00:17:50,216 --> 00:17:53,956
通道 按时间分类的

537
00:17:54,146 --> 00:17:56,066
记住 在 Metal 里

538
00:17:56,066 --> 00:17:57,156
着色器永远连接到通道上

539
00:17:57,556 --> 00:17:59,556
因此 这是一个列表

540
00:17:59,556 --> 00:18:00,656
上面是所有

541
00:18:00,656 --> 00:18:01,126
捕捉中可以得到的

542
00:18:01,126 --> 00:18:01,466
发起程序组合

543
00:18:02,486 --> 00:18:04,506
我要看一下

544
00:18:04,506 --> 00:18:05,296
最昂贵的通道

545
00:18:05,296 --> 00:18:06,836
去看看我们是否

546
00:18:06,836 --> 00:18:07,866
能改进着色器

547
00:18:08,436 --> 00:18:12,726
我们可以看到这个视图

548
00:18:12,726 --> 00:18:13,586
有三个部分

549
00:18:13,956 --> 00:18:15,686
最上面的是评价 (remarks)

550
00:18:16,296 --> 00:18:17,626
评价是改进

551
00:18:17,626 --> 00:18:19,246
编译器着色器质量的好办法

552
00:18:19,616 --> 00:18:21,576
它会报告最终编译器

553
00:18:22,116 --> 00:18:23,486
合成时产生的问题

554
00:18:24,646 --> 00:18:26,326
要记住 GPU 会

555
00:18:26,326 --> 00:18:28,206
在每一帧中运行着色器上百万次

556
00:18:28,206 --> 00:18:30,046
因此

557
00:18:30,046 --> 00:18:31,446
你合成的越好

558
00:18:31,446 --> 00:18:33,746
它的性能就会越好

559
00:18:35,096 --> 00:18:36,406
评价还按相关度分类

560
00:18:36,406 --> 00:18:38,766
如果扩张了

561
00:18:38,766 --> 00:18:41,106
它还会告诉你

562
00:18:41,106 --> 00:18:42,986
为什么要上报

563
00:18:42,986 --> 00:18:44,556
再给出建议 该如何预防这种情况

564
00:18:45,456 --> 00:18:45,523
发生

565
00:18:46,226 --> 00:18:47,836
在评价下面

566
00:18:47,836 --> 00:18:49,336
是每个着色器的概况

567
00:18:49,336 --> 00:18:50,496
你可以看到编译器是如何

568
00:18:50,576 --> 00:18:52,986
最终组合

569
00:18:52,986 --> 00:18:54,096
指令比 (instruction

570
00:18:54,166 --> 00:18:54,876
ratio)

571
00:18:56,186 --> 00:18:58,046
最后 我们还有

572
00:18:58,106 --> 00:18:59,306
所用使用这个通道的调回的

573
00:18:59,306 --> 00:18:59,756
列表

574
00:19:00,396 --> 00:19:01,626
这会在我们

575
00:19:01,626 --> 00:19:02,776
迭代我们的着色器时

576
00:19:02,776 --> 00:19:03,396
非常方便

577
00:19:04,426 --> 00:19:06,946
下面让我来展示一个例子

578
00:19:06,946 --> 00:19:08,506
是关于工作流剖析数据的

579
00:19:09,376 --> 00:19:10,976
我们来到最上面的评价部分

580
00:19:11,186 --> 00:19:13,036
寄存器溢出 (Register Spill) 我们可以看到

581
00:19:13,036 --> 00:19:14,846
编译器报告了一个很大的

582
00:19:14,846 --> 00:19:16,946
溢出 有 1040 字节

583
00:19:17,786 --> 00:19:19,246
溢出会导致 GPU

584
00:19:19,246 --> 00:19:21,546
访问内存 这会拖延

585
00:19:21,546 --> 00:19:22,486
你的着色执行

586
00:19:23,856 --> 00:19:24,806
如果能够知道编译器

587
00:19:24,806 --> 00:19:26,326
发生了溢出 并修复它

588
00:19:26,326 --> 00:19:27,376
这会极大地提升你的着色器

589
00:19:27,376 --> 00:19:29,636
性能 但是要找到

590
00:19:29,636 --> 00:19:30,886
编译器在哪里发生溢出

591
00:19:31,296 --> 00:19:32,566
及其原因 这是一个很耗费时间的

592
00:19:32,566 --> 00:19:32,876
事情

593
00:19:33,936 --> 00:19:36,596
但要注意的是第二个和第四个

594
00:19:36,596 --> 00:19:37,106
评价

595
00:19:37,586 --> 00:19:39,156
动态栈存储 (Dynamic Stack Store)

596
00:19:39,156 --> 00:19:39,766
和动态栈读取

597
00:19:40,776 --> 00:19:43,056
如果扩展了 它会给出原因

598
00:19:43,226 --> 00:19:45,046
为什么一个昂贵的栈读取

599
00:19:45,046 --> 00:19:46,716
在本地数组中被反射到

600
00:19:46,716 --> 00:19:47,416
动态偏移上

601
00:19:48,256 --> 00:19:51,096
同时还会给出建议

602
00:19:51,096 --> 00:19:52,256
减少栈访问

603
00:19:52,336 --> 00:19:53,786
消除对于本地数组的

604
00:19:53,786 --> 00:19:54,476
动态访问

605
00:19:55,236 --> 00:19:57,026
这等于在说

606
00:19:57,026 --> 00:19:58,586
在我们的着色器代码中

607
00:19:58,586 --> 00:20:00,116
有一个可变数组在

608
00:20:00,116 --> 00:20:01,936
储存栈 而且我们

609
00:20:01,936 --> 00:20:03,416
在用一些别的可变索引访问它

610
00:20:04,296 --> 00:20:05,996
这在支持 CPU 时

611
00:20:05,996 --> 00:20:07,816
是一个非常常见的模式

612
00:20:07,816 --> 00:20:09,286
但 GPU 不同 我们如果依赖栈的使用

613
00:20:09,286 --> 00:20:11,346
就会造成 GPU 的负担

614
00:20:11,966 --> 00:20:14,726
但要注意建议下面的

615
00:20:14,726 --> 00:20:15,376
话

616
00:20:15,426 --> 00:20:16,916
它有一个准确的行数

617
00:20:17,436 --> 00:20:18,676
这意味着我们选择点击它

618
00:20:18,776 --> 00:20:22,086
就会直接跳转到

619
00:20:22,086 --> 00:20:23,426
着色器代码行

620
00:20:23,426 --> 00:20:25,146
在这里编译器在从

621
00:20:25,146 --> 00:20:26,286
栈数组中读取数据

622
00:20:26,776 --> 00:20:27,896
我们找到编译器溢出了

623
00:20:29,366 --> 00:20:30,656
同时这与我们的共享性能数据

624
00:20:30,656 --> 00:20:31,676
协调得非常好

625
00:20:31,676 --> 00:20:33,116
会让我们知道这一行的高代价

626
00:20:33,116 --> 00:20:34,986
现在我们知道

627
00:20:34,986 --> 00:20:35,666
到底为什么了

628
00:20:37,396 --> 00:20:40,326
着色器执行了两个 pass

629
00:20:41,056 --> 00:20:42,836
第一个 pass 是光线计算

630
00:20:44,166 --> 00:20:46,956
第二个 pass 是

631
00:20:46,956 --> 00:20:47,776
光线积累

632
00:20:48,766 --> 00:20:49,766
这是从 GPU 的角度

633
00:20:49,766 --> 00:20:51,076
与编译器共同工作

634
00:20:51,076 --> 00:20:52,186
来解决问题

635
00:20:52,856 --> 00:20:55,056
我要做的第一件事

636
00:20:55,176 --> 00:20:56,686
是移除栈数组

637
00:20:56,686 --> 00:20:59,756
我要移除它

638
00:20:59,756 --> 00:21:02,366
然后我要

639
00:21:02,366 --> 00:21:03,536
第一个循环里

640
00:21:03,536 --> 00:21:04,896
直接计算

641
00:21:04,896 --> 00:21:06,166
光线积累

642
00:21:09,116 --> 00:21:10,736
然后我要移除

643
00:21:10,736 --> 00:21:12,976
第二个循环

644
00:21:13,996 --> 00:21:14,316
不再这样做了

645
00:21:14,316 --> 00:21:15,916
现在我要点击

646
00:21:15,916 --> 00:21:17,396
更新着色器按键 然后

647
00:21:17,396 --> 00:21:17,916
等待结果

648
00:21:18,516 --> 00:21:19,646
这样做会

649
00:21:19,646 --> 00:21:20,966
让编译器进行一次

650
00:21:20,966 --> 00:21:21,776
完整的循环优化

651
00:21:21,776 --> 00:21:24,376
并重新反复使用同样的

652
00:21:24,376 --> 00:21:26,636
减速器而不是去

653
00:21:26,636 --> 00:21:27,596
依赖那个栈

654
00:21:28,906 --> 00:21:30,356
结果出来之后

655
00:21:30,356 --> 00:21:31,786
我们就能看到

656
00:21:31,786 --> 00:21:33,356
前后的合成中的指令比率

657
00:21:33,356 --> 00:21:35,416
已经变小了

658
00:21:35,416 --> 00:21:36,486
同时 这一更改

659
00:21:36,486 --> 00:21:38,006
对通道中用到的每一个绘制调用

660
00:21:38,006 --> 00:21:39,726
的影响也小了

661
00:21:39,726 --> 00:21:41,296
给了我们整个空间性能

662
00:21:41,296 --> 00:21:41,896
的改进

663
00:21:43,046 --> 00:21:44,226
到这里 关于

664
00:21:44,226 --> 00:21:44,986
这个示例

665
00:21:44,986 --> 00:21:46,246
就结束了

666
00:21:46,466 --> 00:21:47,656
交还给我的同事

667
00:21:47,656 --> 00:21:47,926
Seth

668
00:21:49,516 --> 00:21:54,756
[掌声]

669
00:21:55,256 --> 00:21:56,866
>> 谢谢 Jose

670
00:21:56,966 --> 00:21:59,766
下面讲我们今天要介绍的

671
00:21:59,766 --> 00:22:00,296
最后一样工具

672
00:22:00,726 --> 00:22:02,286
GPU 计数分析 (GPU Counter Profiling)

673
00:22:02,806 --> 00:22:06,196
大家知道 GPU 构建非常复杂

674
00:22:06,196 --> 00:22:08,056
因为有由多个可编程

675
00:22:08,056 --> 00:22:08,986
的固定功能块组成

676
00:22:08,986 --> 00:22:10,366
的通道

677
00:22:10,366 --> 00:22:12,196
在这个通道中

678
00:22:12,196 --> 00:22:13,396
任何地方都可能出现瓶颈

679
00:22:14,216 --> 00:22:15,476
而且常常是

680
00:22:15,546 --> 00:22:16,936
多个地方同时发生

681
00:22:18,386 --> 00:22:20,986
你们作为 Metal 程序员的任务

682
00:22:20,986 --> 00:22:23,026
是让固定功能瓶颈最小化

683
00:22:23,026 --> 00:22:24,366
同时还要有效地

684
00:22:24,366 --> 00:22:25,966
利用可编程块

685
00:22:28,776 --> 00:22:30,586
要实现这一点 我们的

686
00:22:30,586 --> 00:22:33,166
新 GPU 计数分析是个好工具

687
00:22:33,546 --> 00:22:36,106
它不会直接去到

688
00:22:36,106 --> 00:22:38,236
GPU 帧调试器 而是给你

689
00:22:38,236 --> 00:22:40,286
详细的 GPU 硬件

690
00:22:40,286 --> 00:22:42,866
性能数据 在 macOS 上

691
00:22:42,866 --> 00:22:46,496
以每个 draw call 的频率给出

692
00:22:46,496 --> 00:22:49,066
在 iOS 和 Apple tvOS 上以每个编码器的频率给出

693
00:22:50,036 --> 00:22:51,986
它不会给你

694
00:22:51,986 --> 00:22:54,336
一个复杂的计数列表

695
00:22:54,336 --> 00:22:55,906
这种列表为每个 GPU 发生变化

696
00:22:55,906 --> 00:22:57,676
难以理解 常常无法

697
00:22:58,206 --> 00:22:59,216
告诉你你想知道的事

698
00:22:59,216 --> 00:23:01,576
我们定义了一系列

699
00:23:01,576 --> 00:23:03,236
高等级的字符

700
00:23:03,236 --> 00:23:04,936
对每个 GPU 的意义都相同

701
00:23:05,286 --> 00:23:07,296
所以你不需要针对每个 GPU 的

702
00:23:07,296 --> 00:23:08,666
学习曲线了

703
00:23:10,156 --> 00:23:12,606
这就是计数分析

704
00:23:13,146 --> 00:23:16,726
在左边是图像视图

705
00:23:16,726 --> 00:23:19,506
显示出详细的 GPU

706
00:23:19,546 --> 00:23:21,156
计数图 在右边

707
00:23:21,156 --> 00:23:22,886
是细节窗口

708
00:23:23,606 --> 00:23:25,246
我们一样一样说

709
00:23:26,036 --> 00:23:29,866
在图像视图中

710
00:23:30,276 --> 00:23:33,306
显示了每一帧的计数

711
00:23:33,936 --> 00:23:35,706
X 轴代表绘制调用

712
00:23:35,706 --> 00:23:37,836
或者时间上的编码器

713
00:23:39,036 --> 00:23:40,506
在最上面显示的是 GPU 时间

714
00:23:40,826 --> 00:23:43,206
所有的 GPU 计数分析

715
00:23:43,206 --> 00:23:43,996
都有这个

716
00:23:44,746 --> 00:23:45,886
在它下面

717
00:23:45,886 --> 00:23:47,106
是一系列顶级计数

718
00:23:47,106 --> 00:23:48,706
对应 GPU 通道中的每个阶段

719
00:23:48,706 --> 00:23:50,986
以及一些其他的

720
00:23:50,986 --> 00:23:52,386
顶级计数

721
00:23:52,386 --> 00:23:53,996
对应共享执行单元

722
00:23:53,996 --> 00:23:55,816
比如着色器核心

723
00:23:55,816 --> 00:23:56,836
和测试单元

724
00:23:58,616 --> 00:24:00,796
你可以在每一组

725
00:24:00,796 --> 00:24:02,686
深挖到更细节的计数

726
00:24:02,686 --> 00:24:04,726
在每一个阶段中

727
00:24:04,726 --> 00:24:06,966
探索更多数据

728
00:24:06,966 --> 00:24:08,926
这对那些你认为

729
00:24:08,926 --> 00:24:10,616
首当其冲可能是

730
00:24:10,616 --> 00:24:11,816
性能发生问题的

731
00:24:11,976 --> 00:24:13,746
工作流很有用 然后你可以看更多细节

732
00:24:13,746 --> 00:24:14,286
从而发现问题

733
00:24:14,976 --> 00:24:19,586
在细节视图中

734
00:24:19,586 --> 00:24:20,976
我们会向你展示

735
00:24:20,976 --> 00:24:22,306
和计数图像视图中一样的

736
00:24:22,306 --> 00:24:23,706
计数 但是会展示全部的细节

737
00:24:23,706 --> 00:24:24,226
以数值模拟的方式

738
00:24:25,096 --> 00:24:26,546
为了给它一个背景

739
00:24:26,546 --> 00:24:28,656
我们还会展示出

740
00:24:28,656 --> 00:24:29,996
这一帧的中值 最大值

741
00:24:29,996 --> 00:24:30,786
以及总数值

742
00:24:31,016 --> 00:24:34,546
图像视图和

743
00:24:34,546 --> 00:24:35,856
细节视图都支持

744
00:24:35,856 --> 00:24:38,136
全面丰富的过滤选项

745
00:24:38,426 --> 00:24:40,036
我们在帧调试器的其他地方也支持

746
00:24:40,036 --> 00:24:42,226
这种选项 所以如果你想同时

747
00:24:42,226 --> 00:24:44,086
查看某个像素数据

748
00:24:44,216 --> 00:24:45,426
和某个内存数据

749
00:24:45,426 --> 00:24:47,336
你可以把搜索项目合并

750
00:24:47,336 --> 00:24:48,776
然后依次查看

751
00:24:48,776 --> 00:24:49,876
你所需要的所有东西

752
00:24:51,406 --> 00:24:54,696
但我要重点指出

753
00:24:54,696 --> 00:24:56,756
GPU 计数分析是我们

754
00:24:56,756 --> 00:24:58,026
对瓶颈分析的利器

755
00:24:59,016 --> 00:25:00,516
我们用它找出

756
00:25:00,516 --> 00:25:01,896
在每一个绘制调用

757
00:25:01,896 --> 00:25:03,706
或者每一个编码器中

758
00:25:03,706 --> 00:25:05,536
用过的计数

759
00:25:05,536 --> 00:25:07,696
对它进行全面分析

760
00:25:07,696 --> 00:25:10,446
这种分析是跨平台基础上的

761
00:25:10,446 --> 00:25:12,716
也是以每个 GPU 为基础的

762
00:25:12,716 --> 00:25:14,506
从而找出每个调用中的潜在瓶颈

763
00:25:16,446 --> 00:25:19,546
除了这个 我们还给你

764
00:25:19,546 --> 00:25:21,416
很多数据 让你知道

765
00:25:21,416 --> 00:25:22,636
发生了什么

766
00:25:23,006 --> 00:25:24,306
什么导致的

767
00:25:24,306 --> 00:25:26,266
然后是直接导航到

768
00:25:26,266 --> 00:25:28,716
受影响地区的直观工作流

769
00:25:30,346 --> 00:25:32,136
现在 所有的瓶颈

770
00:25:32,136 --> 00:25:34,356
以及所有的计数

771
00:25:34,486 --> 00:25:36,606
都会在 Xcode 文件里

772
00:25:36,866 --> 00:25:38,826
有丰富的细节记录

773
00:25:39,166 --> 00:25:40,716
详细解释每一个计数的意义

774
00:25:40,716 --> 00:25:43,276
为什么它特别高

775
00:25:43,276 --> 00:25:44,636
或者特别低

776
00:25:44,636 --> 00:25:46,626
以及你能

777
00:25:46,626 --> 00:25:47,846
做些什么

778
00:25:47,846 --> 00:25:49,306
要展示这个

779
00:25:49,516 --> 00:25:51,086
很棒的 GPU 计数分析特性

780
00:25:51,086 --> 00:25:52,556
我想再次请上我的同事

781
00:25:52,556 --> 00:25:54,476
Jose 来给大家做

782
00:25:54,476 --> 00:25:56,336
实际应用的演示

783
00:25:57,516 --> 00:25:59,676
[掌声]

784
00:26:00,176 --> 00:26:00,576
>> 谢谢 Seth

785
00:26:01,176 --> 00:26:02,116
我又来了

786
00:26:02,806 --> 00:26:06,066
这次我要展示的是

787
00:26:06,426 --> 00:26:10,266
GPU 计数器 这个工具

788
00:26:10,266 --> 00:26:11,396
会帮助你分析

789
00:26:11,396 --> 00:26:11,996
GPU 的性能

790
00:26:13,036 --> 00:26:14,066
首先 我要再播放一遍

791
00:26:14,066 --> 00:26:15,286
刚才放过的演示

792
00:26:15,286 --> 00:26:17,496
但这次 我们要从性能角度

793
00:26:17,496 --> 00:26:18,636
注意观看

794
00:26:19,766 --> 00:26:21,596
要注意的第一件事是

795
00:26:21,596 --> 00:26:23,656
新的 GPU 测量

796
00:26:23,656 --> 00:26:24,336
就在 FPS 测量下面

797
00:26:25,366 --> 00:26:26,356
点击它 我们就

798
00:26:26,356 --> 00:26:28,796
来到了 GP 计数视图

799
00:26:29,436 --> 00:26:31,316
我们可以看到

800
00:26:31,316 --> 00:26:32,486
这里有很多数据

801
00:26:33,106 --> 00:26:34,306
这在之前是没有过的

802
00:26:34,476 --> 00:26:36,286
有了这个视图 你们就可以

803
00:26:36,356 --> 00:26:38,216
传输文件 在任意捕捉帧中

804
00:26:38,216 --> 00:26:39,316
你所遇到的任何问题

805
00:26:39,316 --> 00:26:40,296
都可以

806
00:26:41,326 --> 00:26:42,796
我来演示一下要怎么

807
00:26:42,796 --> 00:26:43,776
发现性能问题

808
00:26:45,326 --> 00:26:46,696
首先 我们来看图像

809
00:26:46,696 --> 00:26:47,016
视图

810
00:26:50,206 --> 00:26:51,566
我们看到

811
00:26:51,566 --> 00:26:53,076
在一个捕捉的开始

812
00:26:53,076 --> 00:26:54,016
有一个 GPU 时间的高峰

813
00:26:54,526 --> 00:26:56,356
你要做的第一件事

814
00:26:56,356 --> 00:26:58,746
就是放大去看单一的回调

815
00:26:58,826 --> 00:26:59,876
有更多的

816
00:26:59,876 --> 00:27:00,436
offender

817
00:27:00,946 --> 00:27:01,926
要做到这一点 我只需

818
00:27:01,926 --> 00:27:04,596
捏合缩放 这样就

819
00:27:04,596 --> 00:27:04,846
可以了

820
00:27:05,556 --> 00:27:07,216
任何默认系统行为

821
00:27:07,216 --> 00:27:08,356
都会按你的意愿

822
00:27:08,356 --> 00:27:08,696
工作

823
00:27:09,406 --> 00:27:11,546
现在我会看到这里有一个

824
00:27:11,546 --> 00:27:12,266
高峰

825
00:27:12,456 --> 00:27:14,106
你可以通过点击这个

826
00:27:14,106 --> 00:27:15,306
绘制调用

827
00:27:15,436 --> 00:27:17,856
在所有通道中标记这个高峰

828
00:27:17,856 --> 00:27:19,856
在每一行上悬停会给我们

829
00:27:19,856 --> 00:27:21,396
细节信息 让我们知道

830
00:27:21,396 --> 00:27:23,016
它们分别与这个绘制调用

831
00:27:23,016 --> 00:27:23,936
有多大相关

832
00:27:24,856 --> 00:27:26,896
在这个示例中 Vertex Omission

833
00:27:27,026 --> 00:27:28,506
Vertex Shader 和 Primitives

834
00:27:28,936 --> 00:27:30,546
似乎都没有相关的

835
00:27:30,676 --> 00:27:30,876
影响

836
00:27:31,406 --> 00:27:33,096
与之相反 Fragment Shader

837
00:27:33,716 --> 00:27:35,236
和 Pixels Stored 看起来

838
00:27:35,436 --> 00:27:36,316
相当的高

839
00:27:37,106 --> 00:27:38,836
我们先来看一下 Fragment

840
00:27:38,836 --> 00:27:39,436
Shader

841
00:27:40,396 --> 00:27:42,326
如果我们展开这个组

842
00:27:42,326 --> 00:27:43,796
就能够访问大量的

843
00:27:43,796 --> 00:27:45,596
计数数据 这能给我们

844
00:27:45,656 --> 00:27:47,336
细节信息 让我们知道

845
00:27:47,336 --> 00:27:48,806
着色器阶段发生了什么

846
00:27:49,636 --> 00:27:50,646
最后被计数的

847
00:27:50,646 --> 00:27:52,366
我们可以很快看到

848
00:27:52,616 --> 00:27:54,476
延时时间高得出奇

849
00:27:54,476 --> 00:27:56,786
超过了 76%

850
00:27:57,486 --> 00:27:58,936
这意味着我们花在

851
00:27:58,936 --> 00:28:00,116
Fragment Shader 上的

852
00:28:00,116 --> 00:28:01,586
大多数时间实际上是在等待

853
00:28:01,586 --> 00:28:03,366
一些内存或者数据

854
00:28:04,526 --> 00:28:06,776
这是因为你在

855
00:28:06,776 --> 00:28:08,176
从一个缓冲器

856
00:28:08,176 --> 00:28:10,596
或者从一个纹理中取用

857
00:28:10,596 --> 00:28:11,806
但纹理捕捉应该在这个延迟里

858
00:28:12,406 --> 00:28:14,556
所以让我们去到纹理单元 (Texture

859
00:28:14,556 --> 00:28:16,736
Unit) 看看缓存率

860
00:28:16,736 --> 00:28:16,956
是多少

861
00:28:18,746 --> 00:28:20,526
我们可以立即看到

862
00:28:20,526 --> 00:28:22,256
纹理缓存率也出奇的高

863
00:28:22,256 --> 00:28:24,586
几乎到了 60%

864
00:28:25,326 --> 00:28:27,246
这意味着超过一半的

865
00:28:27,246 --> 00:28:28,396
纹理样本

866
00:28:28,396 --> 00:28:29,636
都来自视频内存

867
00:28:29,636 --> 00:28:30,766
而不是纹理缓存

868
00:28:31,966 --> 00:28:33,956
现在我们对于当前的问题

869
00:28:33,956 --> 00:28:34,946
有了更好的了解

870
00:28:34,946 --> 00:28:36,966
就来看一看

871
00:28:36,966 --> 00:28:37,636
辅助编辑器吧

872
00:28:38,196 --> 00:28:41,686
我们可以看到

873
00:28:41,686 --> 00:28:43,406
辅助编辑器提供了

874
00:28:43,506 --> 00:28:45,006
和图像视图一样的

875
00:28:45,006 --> 00:28:46,156
计数信息

876
00:28:46,356 --> 00:28:48,106
这不过这次是以列表视图显示的

877
00:28:48,806 --> 00:28:51,376
但更重要的是 看一下顶部

878
00:28:51,826 --> 00:28:53,286
这是我们的瓶颈访问工具

879
00:28:53,566 --> 00:28:56,406
它会指出我们在

880
00:28:56,406 --> 00:28:58,106
选择的绘制调用内部

881
00:28:58,106 --> 00:29:00,276
分析所有计数时

882
00:29:00,276 --> 00:29:01,736
所考虑到的两个相关问题

883
00:29:01,736 --> 00:29:03,076
并指出了我们认为

884
00:29:03,076 --> 00:29:04,976
值得引起你们注意的

885
00:29:04,976 --> 00:29:05,926
任何相关问题

886
00:29:06,266 --> 00:29:07,356
在这个示例里

887
00:29:07,356 --> 00:29:09,446
标记同样的问题

888
00:29:09,446 --> 00:29:12,776
也就是我们刚才通过检查图表

889
00:29:12,776 --> 00:29:15,646
手动发现的问题 纹理缓存失误率很高

890
00:29:15,876 --> 00:29:17,686
展开之后 它还

891
00:29:17,686 --> 00:29:18,586
给出了建议 告诉我们应该检查

892
00:29:18,586 --> 00:29:18,866
什么

893
00:29:19,636 --> 00:29:21,436
在这个示例里 检查

894
00:29:21,436 --> 00:29:23,446
样本纹理是否有纹理映射

895
00:29:23,486 --> 00:29:25,406
还有关于这个问题的

896
00:29:25,436 --> 00:29:26,786
相关视图的快速导航名称

897
00:29:28,066 --> 00:29:29,656
比如边界资源 (boundary sources)

898
00:29:30,006 --> 00:29:31,266
我们可以立即看到

899
00:29:31,266 --> 00:29:32,886
现在的问题是什么

900
00:29:32,886 --> 00:29:35,866
我们正在获取一个 4 K 乘 4 K 的 RGBA32

901
00:29:35,926 --> 00:29:37,126
浮点纹理

902
00:29:37,126 --> 00:29:38,576
并且这个浮点纹理在 vertex

903
00:29:39,226 --> 00:29:40,126
和 Fragment Shader 里都没有纹理映射

904
00:29:40,476 --> 00:29:43,336
这是一个 256 MB 的纹理

905
00:29:43,336 --> 00:29:44,866
在整个通道里被获取

906
00:29:45,846 --> 00:29:47,816
难怪缓存都被浪费了

907
00:29:48,826 --> 00:29:50,156
想一想我们刚才

908
00:29:50,156 --> 00:29:50,826
做了什么

909
00:29:51,426 --> 00:29:52,486
这是一个非常详细的

910
00:29:52,486 --> 00:29:54,656
关于 GPU 内部工作的视图

911
00:29:55,616 --> 00:29:56,926
你们终于有了能够证明

912
00:29:56,926 --> 00:29:58,216
从纹理中获取

913
00:29:58,216 --> 00:29:59,746
是昂贵的

914
00:29:59,746 --> 00:30:01,226
这件事的数据

915
00:30:01,226 --> 00:30:02,176
但现在你知道为什么了

916
00:30:03,296 --> 00:30:05,076
访问这个纹理

917
00:30:05,076 --> 00:30:06,216
在 Fragment Shader 上是一个开始

918
00:30:06,216 --> 00:30:08,136
因为它必须从

919
00:30:08,136 --> 00:30:09,196
内置内存中获取数据

920
00:30:09,196 --> 00:30:11,426
这些数据现在在缓存里

921
00:30:12,376 --> 00:30:12,576
已经没有了

922
00:30:12,706 --> 00:30:13,656
这种程度的细节

923
00:30:13,656 --> 00:30:14,716
一般在咨询工具之外

924
00:30:14,716 --> 00:30:15,606
很难见到

925
00:30:16,706 --> 00:30:17,896
解决这个问题现在

926
00:30:17,896 --> 00:30:20,566
取决于平衡 性能

927
00:30:21,006 --> 00:30:22,736
质量和正确率

928
00:30:22,736 --> 00:30:23,926
但你已经展示了

929
00:30:23,926 --> 00:30:25,036
要如何运用 GPU 计数和

930
00:30:25,036 --> 00:30:27,376
GPU 帧调试器 来帮助你

931
00:30:27,376 --> 00:30:30,196
调查 分析

932
00:30:30,196 --> 00:30:32,016
分辨任何的捕捉信息

933
00:30:32,016 --> 00:30:34,246
任何在你的捕捉里的

934
00:30:34,246 --> 00:30:35,256
性能信息

935
00:30:35,676 --> 00:30:37,056
现在再请我的同事

936
00:30:37,056 --> 00:30:37,586
Seth 回来

937
00:30:38,516 --> 00:30:43,500
[掌声]

938
00:30:48,386 --> 00:30:48,976
>> 谢谢 Jose

939
00:30:50,696 --> 00:30:52,756
这就是 GPU 计数

940
00:30:52,756 --> 00:30:53,346
分析

941
00:30:53,966 --> 00:30:54,926
和我们今天说过的所有新

942
00:30:54,926 --> 00:30:56,456
特性一样

943
00:30:56,456 --> 00:30:58,676
它是 Xcode Beta 9 里的最大乐趣

944
00:30:59,166 --> 00:31:00,716
它对所有可以使用 Metal 的

945
00:31:00,716 --> 00:31:01,906
GPU 都适用

946
00:31:02,656 --> 00:31:04,356
你们会发现

947
00:31:04,356 --> 00:31:05,586
越新的 GPU 就有越多的计数可用

948
00:31:05,586 --> 00:31:07,676
因为 GPU 更加现代化了

949
00:31:07,986 --> 00:31:10,086
但所有的 GPU

950
00:31:10,086 --> 00:31:11,976
都会有丰富可用的

951
00:31:11,976 --> 00:31:13,616
计数

952
00:31:14,026 --> 00:31:16,616
尽管如此 我们还是非常

953
00:31:16,616 --> 00:31:17,936
期待你们的反馈

954
00:31:17,936 --> 00:31:18,946
如果你们觉得哪个计数

955
00:31:18,946 --> 00:31:19,696
还没有 它又非常

956
00:31:19,696 --> 00:31:22,156
有价值 那么就请

957
00:31:22,426 --> 00:31:24,606
务必光临实验室

958
00:31:24,606 --> 00:31:26,046
我们会很乐意

959
00:31:26,046 --> 00:31:26,956
进行研究

960
00:31:27,386 --> 00:31:28,986
我们今天说了

961
00:31:28,986 --> 00:31:29,226
什么呢

962
00:31:29,486 --> 00:31:30,586
我们讲到了

963
00:31:30,586 --> 00:31:31,906
Metal 帧调试器的一些很好的改进

964
00:31:31,906 --> 00:31:33,676
包括支持像素检查

965
00:31:33,676 --> 00:31:35,846
检查 Vertex

966
00:31:36,246 --> 00:31:39,256
Shader 输出 丰富的过滤

967
00:31:39,776 --> 00:31:42,186
更好的捕捉支持

968
00:31:42,186 --> 00:31:44,196
更好的捕捉性能

969
00:31:44,196 --> 00:31:45,696
和 Xcode Metal Quick Look

970
00:31:46,216 --> 00:31:49,206
我们还讲到了

971
00:31:49,206 --> 00:31:50,586
对 Metal 托盘调试器中

972
00:31:50,586 --> 00:31:53,506
VR 应用的调试和分析的支持

973
00:31:53,506 --> 00:31:54,876
以及 Metal 系统托盘

974
00:31:57,356 --> 00:31:59,986
我们讲到了 Metal

975
00:32:00,056 --> 00:32:01,726
通道数据

976
00:32:01,726 --> 00:32:03,236
让你们直接进入

977
00:32:03,236 --> 00:32:04,316
GPU compiler

978
00:32:04,316 --> 00:32:04,916
获取性能信息

979
00:32:06,696 --> 00:32:08,516
我们还介绍了 GPU 计数分析

980
00:32:08,516 --> 00:32:11,586
它让你们能够

981
00:32:11,586 --> 00:32:13,626
访问 Metal 里的

982
00:32:13,626 --> 00:32:17,346
GPU 性能计数数据

983
00:32:17,626 --> 00:32:19,866
更多信息请访问

984
00:32:19,866 --> 00:32:20,486
网站

985
00:32:22,166 --> 00:32:23,846
编号是 607

986
00:32:23,846 --> 00:32:28,276
我还想推荐

987
00:32:28,276 --> 00:32:29,956
其他的一些演讲

988
00:32:30,316 --> 00:32:31,756
如果你们没有赶上

989
00:32:31,756 --> 00:32:33,946
Introducing Metal 2 或者 VR With

990
00:32:33,946 --> 00:32:35,716
Metal 2 这两场本周早些时候的

991
00:32:35,716 --> 00:32:38,186
演讲 它们非常值得

992
00:32:38,186 --> 00:32:39,896
你通过视频来再次观看

993
00:32:39,896 --> 00:32:41,606
就算你们已经去过

994
00:32:41,606 --> 00:32:42,736
也请在视频中再次看看它们

995
00:32:43,066 --> 00:32:45,246
今天下午晚些时候

996
00:32:45,246 --> 00:32:46,446
还有一场很棒的演讲

997
00:32:46,446 --> 00:32:47,706
关于使用 Metal 2 进行计算

998
00:32:47,706 --> 00:32:49,856
在 A 大厅

999
00:32:49,926 --> 00:32:50,866
4 点 10 分开始

1000
00:32:51,386 --> 00:32:52,996
就到这里

1001
00:32:52,996 --> 00:32:54,216
谢谢大家

1002
00:32:54,556 --> 00:32:56,086
祝你们接下来的

1003
00:32:56,146 --> 00:32:58,436
WWDC 17 有所收获

1004
00:32:58,436 --> 00:32:58,776
谢谢大家

