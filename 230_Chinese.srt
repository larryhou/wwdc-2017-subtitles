1
00:00:21,989 --> 00:00:22,823
大家好

2
00:00:23,257 --> 00:00:25,526
我是Joe Cerra
UIKit团队的一名工程师

3
00:00:26,260 --> 00:00:29,162
欢迎来到UIKit进阶动画演讲

4
00:00:30,864 --> 00:00:32,598
今天我们要讲很多内容

5
00:00:32,900 --> 00:00:35,202
一开始我们会涉及一些基础知识

6
00:00:35,435 --> 00:00:36,703
以及动画运作的流程

7
00:00:36,770 --> 00:00:38,705
还有动画定时的机理

8
00:00:40,107 --> 00:00:42,042
我们会谈到如何运用一些新式的技巧

9
00:00:42,109 --> 00:00:45,479
让动画具有
充分交互性和可中断性的方法

10
00:00:46,813 --> 00:00:48,782
接着我们会讲到

11
00:00:48,849 --> 00:00:50,851
今年在iOS 11里提供的
新应用程序接口

12
00:00:51,952 --> 00:00:53,987
然后我们会将所有这些知识运用起来

13
00:00:54,188 --> 00:00:56,723
我会给你们展示
如何对动画进行调节的方法

14
00:00:57,925 --> 00:01:00,394
最后我们会看一些小窍门和小技巧

15
00:01:00,494 --> 00:01:02,429
以及更多帮助你们

16
00:01:02,496 --> 00:01:04,464
为用户打造精美动画的方法

17
00:01:05,766 --> 00:01:06,800
那么我们就开始吧

18
00:01:08,435 --> 00:01:09,670
基于UIView的动画

19
00:01:09,736 --> 00:01:12,072
其实从iOS诞生以来就一直存在了

20
00:01:12,306 --> 00:01:14,341
我们在这儿快速回顾一下
它们运作的流程

21
00:01:15,442 --> 00:01:17,477
假设我有一个UIView
它显示一个圆圈

22
00:01:17,611 --> 00:01:18,745
我想给它加一个动画

23
00:01:19,046 --> 00:01:21,582
让它从X等于0的位置
移动到X等于100的位置

24
00:01:22,649 --> 00:01:23,917
那么我可能就会

25
00:01:23,984 --> 00:01:26,019
调用
UIView.animate方法

26
00:01:26,553 --> 00:01:29,089
我调用UIView.animate
用到了时长

27
00:01:29,556 --> 00:01:31,892
在动画模块中演示一些动画

28
00:01:31,959 --> 00:01:35,562
在这个例子中
我让圆圈的X值偏移100个单位

29
00:01:36,496 --> 00:01:39,700
我这么做了以后
UIKit会默认地创建动画

30
00:01:39,766 --> 00:01:42,436
将它加入到我们的图层中
生成下面这个动画

31
00:01:44,738 --> 00:01:47,941
不过 去年我们引进了
UIViewPropertyAnimator

32
00:01:48,008 --> 00:01:49,676
它比起它的前身
UIViewAnimate

33
00:01:49,743 --> 00:01:52,713
让我们可以对动画进行更多调控

34
00:01:54,081 --> 00:01:57,317
这包括能够提供自定义的定时函数

35
00:01:57,384 --> 00:01:59,720
还有能够便捷地让你们的动画
具有充分交互性

36
00:01:59,786 --> 00:02:01,722
和可中断性

37
00:02:02,456 --> 00:02:04,191
实际上 通过属性动画生成器

38
00:02:04,525 --> 00:02:06,727
你们可以随意地修改动画

39
00:02:07,895 --> 00:02:09,162
我们再来看看我们的动画

40
00:02:09,229 --> 00:02:11,598
这次我们要用动画生成器来生成动画

41
00:02:12,366 --> 00:02:13,500
我们创建动画生成器

42
00:02:13,567 --> 00:02:15,469
提供时长和定时曲线

43
00:02:15,936 --> 00:02:17,037
提供动画

44
00:02:17,538 --> 00:02:19,072
然后我们调用
startAnimation

45
00:02:19,173 --> 00:02:21,408
它就会运行

46
00:02:21,508 --> 00:02:22,976
生成这个动画的动画模块

47
00:02:26,580 --> 00:02:28,148
在之前的两个例子中

48
00:02:28,215 --> 00:02:31,151
我们用线性定时曲线驱动我们的动画

49
00:02:31,718 --> 00:02:33,086
而定时曲线

50
00:02:33,187 --> 00:02:36,323
本质上就是一个
将时间映射到进度上的函数

51
00:02:36,523 --> 00:02:39,626
或者就是动画已用时间与

52
00:02:39,693 --> 00:02:42,062
动画已有进度的比例

53
00:02:43,130 --> 00:02:45,832
线性定时曲线

54
00:02:46,033 --> 00:02:47,067
其实很有意思

55
00:02:47,134 --> 00:02:49,937
因为已用时间占所有时间的比例
等于已有进度占所有进度的比例

56
00:02:50,237 --> 00:02:52,673
我们一会儿就会明白
这个特性很有意思的地方

57
00:02:54,274 --> 00:02:55,576
当然还有

58
00:02:55,709 --> 00:02:57,344
非线性的定时曲线

59
00:02:57,544 --> 00:03:00,013
比如内置的缓入定时函数

60
00:03:00,080 --> 00:03:02,316
它一开始很慢 然后渐渐加速

61
00:03:02,749 --> 00:03:04,718
还有内置的缓出定时函数

62
00:03:04,785 --> 00:03:06,920
它一开始很快 然后渐渐减速

63
00:03:07,654 --> 00:03:09,122
那么通过运用属性动画生成器

64
00:03:09,223 --> 00:03:11,225
你们可以提供自定义的定时函数

65
00:03:11,291 --> 00:03:12,192
比如这个

66
00:03:12,759 --> 00:03:13,861
你要做的是

67
00:03:13,961 --> 00:03:16,697
提供两个贝塞尔曲线控制点

68
00:03:17,664 --> 00:03:19,166
我们稍后会看到

69
00:03:19,466 --> 00:03:21,502
它对于提供自定义定时函数

70
00:03:21,568 --> 00:03:24,137
真正有用的地方

71
00:03:25,772 --> 00:03:28,275
以上所讲的就是动画运作的流程

72
00:03:29,109 --> 00:03:29,977
现在我想讲的是

73
00:03:30,043 --> 00:03:32,379
如何让动画具有充分交互性的方法

74
00:03:33,714 --> 00:03:36,884
在交互性的动画中 用户的操作

75
00:03:36,950 --> 00:03:39,987
互动性地推进动画的进程

76
00:03:40,654 --> 00:03:41,688
这里有一个你们熟悉的例子

77
00:03:41,755 --> 00:03:44,191
用手势驱动互动性的动画

78
00:03:44,258 --> 00:03:45,893
现在我们用3D Touch

79
00:03:46,093 --> 00:03:47,728
来操控另外一个动画

80
00:03:49,196 --> 00:03:50,230
当然 我们可以

81
00:03:50,364 --> 00:03:53,500
用手势来互动性地关闭
Control Center界面

82
00:03:54,635 --> 00:03:56,703
我们来做一个快速展示

83
00:03:57,271 --> 00:04:00,240
我们要给圆圈加一个
PanGestureRecognizer

84
00:04:01,375 --> 00:04:02,876
我们要生成动画

85
00:04:03,076 --> 00:04:04,578
但我们要用手指

86
00:04:04,645 --> 00:04:05,913
对动画生成器进行摩擦操作

87
00:04:06,146 --> 00:04:08,182
在这里我们要拿起手指

88
00:04:08,248 --> 00:04:10,784
然后让动画继续进行到它的目标位置

89
00:04:12,386 --> 00:04:13,854
以下是实现该效果的代码

90
00:04:14,454 --> 00:04:18,591
我们把属性动画生成器的一个实例

91
00:04:18,692 --> 00:04:20,861
储存在手势识别处理器中

92
00:04:21,128 --> 00:04:22,896
我们就来创建这个动画生成器

93
00:04:22,963 --> 00:04:26,433
用遵循缓出定时函数的动画
对它进行初始化

94
00:04:30,103 --> 00:04:33,073
之后我们立即调用
pauseAnimation

95
00:04:33,140 --> 00:04:34,908
它就会运行这个动画模块

96
00:04:34,975 --> 00:04:36,944
默认地生成这个动画

97
00:04:37,578 --> 00:04:39,012
属性动画生成器的作用

98
00:04:39,079 --> 00:04:42,716
就是将动画的速度设为零

99
00:04:43,350 --> 00:04:44,885
这样我们就可以和它进行互动

100
00:04:45,185 --> 00:04:47,621
我们来对动画生成器完成的部分
进行摩擦操作

101
00:04:47,688 --> 00:04:49,489
这个部分是指我们手指移动的距离

102
00:04:49,556 --> 00:04:52,059
相对于动画总距离的百分比

103
00:04:52,159 --> 00:04:53,627
在这个例子中就是100

104
00:04:53,727 --> 00:04:55,729
因为我们生成的动画是从0到100的

105
00:04:57,664 --> 00:04:58,899
而当我们拿起手指时

106
00:04:58,966 --> 00:05:01,034
我们就调用
continueAnimation

107
00:05:02,536 --> 00:05:03,704
这的确很简单

108
00:05:03,937 --> 00:05:06,139
但在整个过程中

109
00:05:06,206 --> 00:05:07,107
有两个很有意思的时刻

110
00:05:07,241 --> 00:05:09,843
一个是我们暂停动画时
另一个是我们继续运行动画时

111
00:05:09,910 --> 00:05:11,211
我们来仔细看一下

112
00:05:12,346 --> 00:05:13,914
我们刚创建了动画生成器

113
00:05:14,081 --> 00:05:16,583
假设我们准备暂停动画
以便我们可以与其互动

114
00:05:16,650 --> 00:05:21,154
值得注意的是 我们的动画生成器
在创建时使用的是缓出定时函数

115
00:05:21,355 --> 00:05:23,257
我们来调用暂停函数
看看会发生什么

116
00:05:26,226 --> 00:05:27,828
我们的动画生成器进入待命状态

117
00:05:28,028 --> 00:05:32,499
但我们刚已经将定时曲线
自动转成了线性的定时曲线

118
00:05:32,799 --> 00:05:34,535
为何属性动画生成器会这么做呢？

119
00:05:35,235 --> 00:05:38,672
因为这会方便我们对动画进行摩擦操作

120
00:05:38,906 --> 00:05:41,041
而这又源于线性定时函数的性质

121
00:05:41,108 --> 00:05:44,211
即已用时间占所有时间的比例
等于已有进度占所有进度的比例

122
00:05:44,278 --> 00:05:47,114
你们现在就可以对时间和进度
进行均匀的摩擦操作了

123
00:05:48,916 --> 00:05:51,718
我们再来看看当我们继续演示动画时
会发生些什么

124
00:05:52,686 --> 00:05:54,388
这里 我们对动画进行摩擦操作

125
00:05:54,922 --> 00:05:56,089
现在我们把手指抬起来

126
00:05:56,156 --> 00:05:58,025
我们准备调用
continueAnimation

127
00:05:58,192 --> 00:05:59,860
我们来看看这会有什么效果

128
00:06:02,996 --> 00:06:05,632
我们又转换到了之前的缓出定时函数

129
00:06:06,300 --> 00:06:07,734
但同时 有趣的事情发生了

130
00:06:07,801 --> 00:06:09,903
在这个过程中
我们对时间进行了重新映射

131
00:06:10,037 --> 00:06:14,041
完成的部分之前是50%
现在变成了10%

132
00:06:14,474 --> 00:06:18,378
这么做的原因是
当我们转换回之前的定时函数时

133
00:06:18,445 --> 00:06:20,948
我们想保持稳定的进度值

134
00:06:22,816 --> 00:06:25,152
并且我想让你们留意这里的时长系数

135
00:06:25,219 --> 00:06:26,153
它的值为零

136
00:06:26,320 --> 00:06:28,155
这意味着要让我们的属性动画生成器

137
00:06:28,222 --> 00:06:30,524
用完剩下的时间 无论有多少

138
00:06:30,757 --> 00:06:34,394
而在这个例子中就是原本时长的90%

139
00:06:34,695 --> 00:06:38,732
所以假设我们的动画生成器创建时
时长的赋值是两秒

140
00:06:38,932 --> 00:06:41,001
动画就会继续运行1.8秒

141
00:06:42,636 --> 00:06:45,005
以上就是交互性动画运作的原理

142
00:06:45,072 --> 00:06:48,141
我们现在来谈如何让动画
具有充分的可中断性的方法

143
00:06:50,010 --> 00:06:52,546
在一个具有可中断性的动画中
用户的操作

144
00:06:52,613 --> 00:06:55,082
可以中断或者暂停一个正在运行的动画

145
00:06:55,482 --> 00:06:57,851
以下是一个
你们可能熟悉的Safari的例子

146
00:06:57,918 --> 00:06:59,052
当你们用手指快速拨动时

147
00:06:59,119 --> 00:07:01,822
动画会加速 然后它又会有所减速

148
00:07:02,189 --> 00:07:04,925
但如果你们再次触碰屏幕
动画就会被中断

149
00:07:05,192 --> 00:07:06,660
这时你们就可以摩擦操作了

150
00:07:08,795 --> 00:07:10,931
这次 我们要多做一项演示

151
00:07:11,198 --> 00:07:13,166
我们要给圆圈加入

152
00:07:13,233 --> 00:07:14,168
PanGestureRecognizer

153
00:07:14,434 --> 00:07:16,303
但这次 我们要让动画运行一段时间

154
00:07:16,370 --> 00:07:18,238
然后我们再中途截断它

155
00:07:19,239 --> 00:07:20,607
在这里 动画正在运行

156
00:07:20,741 --> 00:07:22,276
我们接着用手指截断它

157
00:07:22,409 --> 00:07:23,744
这时我们就可以摩擦操作了

158
00:07:23,810 --> 00:07:25,345
但我们已看过这个运作的流程

159
00:07:25,445 --> 00:07:26,847
所以取而代之我们提起手指

160
00:07:26,914 --> 00:07:29,383
让动画继续运行到它的目标位置

161
00:07:33,520 --> 00:07:34,621
这里展示的是之前的代码

162
00:07:34,688 --> 00:07:36,290
我们只需进行一些小的改动

163
00:07:36,356 --> 00:07:39,660
来支持既有互动性又有可中断性的动画

164
00:07:40,694 --> 00:07:41,862
我们在此引进一个新方法

165
00:07:41,929 --> 00:07:43,864
叫作animateTransitionIfNeeded

166
00:07:43,931 --> 00:07:45,299
这是一个自定义的方法

167
00:07:46,366 --> 00:07:48,235
比如这并不是UIKit的方法

168
00:07:49,036 --> 00:07:49,970
这个方法会

169
00:07:50,037 --> 00:07:51,305
启动转变过程

170
00:07:51,371 --> 00:07:52,840
如果转变还没开始进行的话

171
00:07:53,440 --> 00:07:55,075
我们还要引进一个新的属性

172
00:07:55,142 --> 00:07:56,877
叫作progressWhenInterrupted

173
00:07:57,010 --> 00:07:58,712
它会在动画被中断之前储存

174
00:07:58,779 --> 00:08:01,181
你的动画生成器达成的任何相对的进度

175
00:08:02,416 --> 00:08:03,483
当我们开始输入手势时

176
00:08:03,550 --> 00:08:04,918
我们就要重新创建属性动画生成器

177
00:08:04,985 --> 00:08:07,454
但这次我们只在转变没有开启的时候
进行重建

178
00:08:07,788 --> 00:08:10,023
然后我们暂停动画
以便我们可以与之互动

179
00:08:10,190 --> 00:08:11,658
我们会在动画中断前储存

180
00:08:11,725 --> 00:08:13,660
动画达成的任何相对进度

181
00:08:15,329 --> 00:08:16,163
当我们的手指移动时

182
00:08:16,230 --> 00:08:18,365
我们会对动画生成器完成的部分
进行摩擦操作

183
00:08:18,432 --> 00:08:19,266
但这次

184
00:08:19,466 --> 00:08:20,734
我们要在动画被中断前

185
00:08:20,801 --> 00:08:22,569
基于我们手指

186
00:08:22,636 --> 00:08:24,771
相对于动画进度所移动的距离

187
00:08:24,838 --> 00:08:26,173
对动画生成器进行摩擦操作

188
00:08:27,641 --> 00:08:29,977
而当我们拿起手指时
我们要继续运行动画

189
00:08:30,944 --> 00:08:31,812
但为了让这个例子

190
00:08:31,879 --> 00:08:32,980
变得稍微更有意思

191
00:08:33,413 --> 00:08:35,448
我们用缓出定时函数来继续演示动画

192
00:08:35,515 --> 00:08:37,183
我们假设动画创建时

193
00:08:37,251 --> 00:08:40,187
用的是缓出定时函数
目的就是为了看看这么做的效果

194
00:08:43,390 --> 00:08:45,526
在这里 我们即将中断动画

195
00:08:45,592 --> 00:08:47,160
完成的部分大约是50%

196
00:08:47,227 --> 00:08:49,363
所以动画运行了大约一半的时长

197
00:08:49,496 --> 00:08:51,031
而进度只有10%左右

198
00:08:51,098 --> 00:08:53,000
因为我们遵循的是缓出定时函数

199
00:08:53,100 --> 00:08:54,835
我们来调用暂停函数看看会发生什么

200
00:08:56,270 --> 00:08:57,371
和之前一样 我们转换到

201
00:08:57,437 --> 00:08:58,438
线性定时函数

202
00:08:58,505 --> 00:08:59,973
以便进行摩擦操作

203
00:09:00,174 --> 00:09:01,975
但我们同时又对时间进行了重新映射

204
00:09:02,042 --> 00:09:03,844
就像之前一样 为了让进度保持稳定

205
00:09:03,911 --> 00:09:05,279
让动画不会出现跳跃式的效果

206
00:09:05,879 --> 00:09:07,814
现在当我们调用
continueAnimation

207
00:09:08,215 --> 00:09:10,651
我们要用到缓出定时函数

208
00:09:10,717 --> 00:09:11,985
同样地 可以看到

209
00:09:12,119 --> 00:09:14,688
我们又转换到新的定时函数

210
00:09:14,755 --> 00:09:16,190
重新对时间进行映射

211
00:09:17,124 --> 00:09:18,926
可以说 这是属性动画生成器

212
00:09:18,992 --> 00:09:20,127
很微妙的一个方面

213
00:09:20,194 --> 00:09:21,461
你们在操控它的时候

214
00:09:21,528 --> 00:09:22,863
了解这个方面尤为重要

215
00:09:26,133 --> 00:09:27,234
以上就是如何让动画具有

216
00:09:27,301 --> 00:09:28,569
充分交互性和可中断性的方法

217
00:09:28,635 --> 00:09:29,970
我们现在来讲一下我们今年提供的

218
00:09:30,037 --> 00:09:31,438
一些新的应用程序接口

219
00:09:33,240 --> 00:09:35,475
在新的iOS 11里
属性动画生成器

220
00:09:35,576 --> 00:09:37,578
有两个新的属性

221
00:09:38,345 --> 00:09:40,814
scrubsLinearly和
pausesOnCompletion

222
00:09:41,381 --> 00:09:43,283
它还有一个新的行为

223
00:09:43,350 --> 00:09:45,018
就是开始的时候是暂停的

224
00:09:45,552 --> 00:09:46,954
我们来详细讲一下

225
00:09:47,988 --> 00:09:49,590
在之前几个例子中

226
00:09:49,690 --> 00:09:51,325
可以看到 当我们暂停动画生成器时

227
00:09:51,391 --> 00:09:52,559
它把定时函数

228
00:09:52,626 --> 00:09:54,695
转换成了线性定时函数
这么做是为了

229
00:09:54,761 --> 00:09:58,198
方便对动画生成器的进度
进行摩擦操作

230
00:09:58,732 --> 00:10:01,001
但有时候
比较实用的一点是让动画生成器

231
00:10:01,068 --> 00:10:03,737
在被互动性地带动时保持其步调

232
00:10:04,171 --> 00:10:06,807
你们可以通过关闭线性摩擦来做到这点

233
00:10:07,407 --> 00:10:08,475
我们很快讲一个例子

234
00:10:08,542 --> 00:10:10,277
在这里 我们线性地摩擦

235
00:10:10,344 --> 00:10:12,446
顶部圆圈的透明度属性

236
00:10:12,713 --> 00:10:14,147
同时我们非线性地摩擦

237
00:10:14,214 --> 00:10:15,983
底部圆圈的透明度属性

238
00:10:16,083 --> 00:10:17,885
基于缓出定时函数

239
00:10:19,086 --> 00:10:20,153
我们稍后就会明白

240
00:10:20,220 --> 00:10:21,655
当我们在协调不同的转变过程时

241
00:10:21,722 --> 00:10:23,323
这对于打造吸引眼球的动画来说

242
00:10:23,390 --> 00:10:27,127
会是很有意思的一件事

243
00:10:28,896 --> 00:10:31,131
现在动画生成器在完成时也可以暂停

244
00:10:32,332 --> 00:10:35,002
所以 当动画生成器的动画结束时

245
00:10:35,068 --> 00:10:37,771
它会自动转变为非待命的状态

246
00:10:38,071 --> 00:10:38,939
当它这么做的时候

247
00:10:39,006 --> 00:10:40,407
它会释放出它之前跟踪的

248
00:10:40,474 --> 00:10:42,075
任何动画

249
00:10:42,142 --> 00:10:43,977
这意味着你们不能操控动画

250
00:10:44,044 --> 00:10:46,280
或者在动画结束后倒退回去

251
00:10:46,914 --> 00:10:49,416
但现在
如果你们在完成值为真值时设定了暂停

252
00:10:49,516 --> 00:10:52,152
动画生成器就会
在100%的完成部分处暂停

253
00:10:52,352 --> 00:10:54,154
这样你就可以在未来任何时候

254
00:10:54,221 --> 00:10:55,589
倒转这些动画

255
00:10:57,858 --> 00:10:59,359
为了让你们有更好的了解

256
00:10:59,426 --> 00:11:01,128
我们把它运用到UIKit的

257
00:11:01,295 --> 00:11:02,129
拖放里

258
00:11:03,197 --> 00:11:05,165
下面是一个抬起的动画

259
00:11:05,232 --> 00:11:06,166
你们可能已经知道

260
00:11:06,233 --> 00:11:08,669
你们可以提供附属的动画

261
00:11:08,735 --> 00:11:10,103
来对其进行自定义设计

262
00:11:10,704 --> 00:11:13,073
而实际上 我们要用属性动画生成器

263
00:11:13,140 --> 00:11:14,408
驱动这些

264
00:11:14,474 --> 00:11:17,010
结束时暂停的UIKit内置动画

265
00:11:17,678 --> 00:11:21,148
因此 我们可以帮你们
在用户抬起手指后的任何时候

266
00:11:21,215 --> 00:11:24,685
便捷地倒转这些动画

267
00:11:24,885 --> 00:11:27,187
即便你们的动画已经结束

268
00:11:31,225 --> 00:11:32,259
我还想提的一点是

269
00:11:32,326 --> 00:11:34,561
当动画在结束时暂停的时候
我们不会调用

270
00:11:34,628 --> 00:11:36,096
动画生成器的完成处理器

271
00:11:36,363 --> 00:11:37,464
但若你们感兴趣 想知道

272
00:11:37,531 --> 00:11:38,699
当这些动画结束时

273
00:11:38,765 --> 00:11:41,001
你们只需观察其running属性

274
00:11:43,337 --> 00:11:45,706
最后 你们可以创建属性动画生成器

275
00:11:45,772 --> 00:11:48,709
在给它提供动画之前启动它

276
00:11:49,209 --> 00:11:50,177
这个会造成的结果是

277
00:11:50,244 --> 00:11:52,546
你们接下来提供的任何动画模块

278
00:11:52,613 --> 00:11:55,148
会立即运行而不是被跳过

279
00:11:55,215 --> 00:11:58,352
如果你们将任何UIView
的动画代码

280
00:11:58,418 --> 00:12:00,254
转成使用属性动画生成器
这就会很有帮助

281
00:12:03,323 --> 00:12:04,992
现在 我想花几分钟

282
00:12:05,058 --> 00:12:06,660
谈谈弹簧动画

283
00:12:06,994 --> 00:12:10,130
弹簧动画在iOS上的UIKit中
很常见

284
00:12:10,297 --> 00:12:12,666
它们会给你的动画添加一种现实感

285
00:12:13,534 --> 00:12:15,969
现在 在UIKit中
我们提供两种弹簧动画

286
00:12:16,170 --> 00:12:18,605
分别是临界阻尼弹簧动画
和欠阻尼弹簧动画

287
00:12:19,506 --> 00:12:20,507
临界阻尼弹簧动画

288
00:12:20,574 --> 00:12:21,875
是迅速地加速

289
00:12:21,942 --> 00:12:23,710
并迅速地减速

290
00:12:23,777 --> 00:12:25,412
悬停在其目标值上

291
00:12:26,246 --> 00:12:27,915
而欠阻尼弹簧动画

292
00:12:27,981 --> 00:12:30,017
是迅速在远离其目标值处加速

293
00:12:30,083 --> 00:12:31,351
然后再震荡

294
00:12:32,819 --> 00:12:34,755
弹簧动画从这方面来说是独一无二的

295
00:12:35,088 --> 00:12:36,523
我们就把弹簧动画

296
00:12:36,590 --> 00:12:38,759
看做是定时曲线一样

297
00:12:39,059 --> 00:12:40,661
但弹簧动画从另一方面来说也是独特的

298
00:12:40,794 --> 00:12:41,995
就是它们总是

299
00:12:42,062 --> 00:12:43,931
从当前所呈现的值处产生动画

300
00:12:44,298 --> 00:12:46,366
我们这么做的原因有很多

301
00:12:47,968 --> 00:12:49,002
那么首先是

302
00:12:49,169 --> 00:12:50,604
它实际上可能是未定义的

303
00:12:50,671 --> 00:12:51,972
用于把弹簧动画

304
00:12:52,039 --> 00:12:53,273
转化成立体动画

305
00:12:53,440 --> 00:12:55,108
这是因为立方定时函数

306
00:12:55,209 --> 00:12:57,110
不会在它们的值周围震荡
或超越它们的值

307
00:12:57,244 --> 00:12:59,680
因为它们受最大和最小值的约束

308
00:13:02,349 --> 00:13:03,450
第二个原因

309
00:13:03,517 --> 00:13:06,119
更有意思 这是…

310
00:13:06,420 --> 00:13:09,089
如果你以二维初始速度

311
00:13:09,156 --> 00:13:11,325
和唯一DX和DY组件执行动画

312
00:13:11,625 --> 00:13:14,528
属性动画器实际上会为你分解它

313
00:13:14,595 --> 00:13:16,530
并创建两个弹簧动画

314
00:13:17,030 --> 00:13:18,432
因为这两个弹簧动画

315
00:13:18,498 --> 00:13:20,100
速度不一样

316
00:13:20,167 --> 00:13:21,235
它们是不同步的

317
00:13:21,301 --> 00:13:24,304
所以我们就不能把这两个弹簧动画
转换成一个立体动画

318
00:13:27,007 --> 00:13:28,976
那么如果你不得不中断弹簧动画

319
00:13:29,042 --> 00:13:30,811
这是一些最佳范例

320
00:13:31,645 --> 00:13:32,613
那么你要做的第一件事

321
00:13:32,713 --> 00:13:34,348
就是考虑停止你的弹簧动画

322
00:13:34,414 --> 00:13:36,617
并把当前所呈现的值提升为模型值

323
00:13:36,817 --> 00:13:38,752
然后创建一个全新的动画

324
00:13:40,521 --> 00:13:41,755
你要做的第二件事

325
00:13:41,855 --> 00:13:43,724
是考虑使用一个没有初始速度的

326
00:13:43,790 --> 00:13:44,791
临界阻尼弹簧动画

327
00:13:44,858 --> 00:13:47,327
因为这些不会超越或震荡

328
00:13:48,428 --> 00:13:49,563
那么最后

329
00:13:49,663 --> 00:13:52,199
如果你以二维初始速度

330
00:13:52,266 --> 00:13:54,168
和唯一的X和Y组件执行动画

331
00:13:54,735 --> 00:13:57,004
你可以考虑自己分解它

332
00:13:57,171 --> 00:13:59,940
并用一个动画器驱动X动画

333
00:14:00,007 --> 00:14:01,842
用另一个动画器驱动Y动画

334
00:14:04,711 --> 00:14:07,114
那么这是属性动画的运作方式

335
00:14:07,681 --> 00:14:08,549
现在让我们谈谈

336
00:14:08,615 --> 00:14:09,750
如何利用这些知识

337
00:14:09,816 --> 00:14:11,652
协调动画

338
00:14:12,419 --> 00:14:13,987
那么在这部分我们要创建

339
00:14:14,054 --> 00:14:15,022
一个完全交互性的

340
00:14:15,088 --> 00:14:16,924
可中断的动画转换

341
00:14:17,124 --> 00:14:20,727
在多个唯一的定时动画之间进行协调

342
00:14:22,362 --> 00:14:23,664
假如说我们有一款应用

343
00:14:23,730 --> 00:14:25,399
在屏幕底部

344
00:14:25,699 --> 00:14:27,100
显示一些内容

345
00:14:27,167 --> 00:14:28,202
有一个评论按钮

346
00:14:28,335 --> 00:14:29,169
当我们轻触它时

347
00:14:29,236 --> 00:14:31,405
它会展开并显示我们的评论视图

348
00:14:32,372 --> 00:14:33,440
现在我们可能通过

349
00:14:33,507 --> 00:14:36,677
比如UIView控制器动画转换实现

350
00:14:37,277 --> 00:14:40,113
但我们想让这个变得完全交互和可中断

351
00:14:40,214 --> 00:14:41,682
所以我想给你演示如何实现

352
00:14:43,183 --> 00:14:44,484
那么我们要做的第一件事

353
00:14:44,551 --> 00:14:46,186
就是增加两个手势识别器

354
00:14:46,253 --> 00:14:48,889
一个轻触手势识别器
以便我们可以轻触它并让它展开

355
00:14:48,956 --> 00:14:50,791
再次轻触它 它会折叠起来

356
00:14:51,024 --> 00:14:52,426
我们还希望

357
00:14:52,492 --> 00:14:53,560
当动画运行时轻触它

358
00:14:53,627 --> 00:14:54,895
从而使它可被撤销

359
00:14:55,662 --> 00:14:58,498
且我们要添加一个拖拽手势识别器
以便我们可以与它交互

360
00:14:58,999 --> 00:15:00,400
这是我们之前的代码格式

361
00:15:00,901 --> 00:15:03,237
我们要对它进行一些修改

362
00:15:03,337 --> 00:15:04,505
来创建这个基础结构

363
00:15:04,571 --> 00:15:05,772
从而在这上边创建动画

364
00:15:06,507 --> 00:15:07,708
我们要做的第一件事

365
00:15:07,841 --> 00:15:08,876
就是替换

366
00:15:08,942 --> 00:15:10,777
我们的属性动画器的实例

367
00:15:10,878 --> 00:15:13,447
用运行属性动画器的一个集合替换它

368
00:15:14,982 --> 00:15:16,316
对于那个

369
00:15:16,383 --> 00:15:18,352
运行属性动画器的集合

370
00:15:18,685 --> 00:15:20,187
如果我们创建过属性动画器

371
00:15:20,254 --> 00:15:21,622
我们只需要把它添加到那个集合中即可

372
00:15:21,688 --> 00:15:23,891
让我们假设当这些动画完成时

373
00:15:23,957 --> 00:15:25,292
它会被自动移除

374
00:15:26,560 --> 00:15:27,794
接下来我们要重新引入

375
00:15:27,861 --> 00:15:29,530
我们的animateTransition
IfNeeded方法

376
00:15:29,596 --> 00:15:30,797
它将会获取

377
00:15:30,864 --> 00:15:32,699
一个动画的目标状态

378
00:15:32,966 --> 00:15:34,101
如果我们看一下这个

379
00:15:35,636 --> 00:15:37,237
如果我们的
runningAnimators.isEmpty

380
00:15:37,304 --> 00:15:39,239
那意味着当前没有任何运行的转换

381
00:15:39,406 --> 00:15:42,176
那么如果是这种情况的话
我们要发起一个转换

382
00:15:42,242 --> 00:15:45,078
并且我们要通过给我们的帧
创建一个新属性动画器来实现

383
00:15:45,145 --> 00:15:47,014
我们将在临界阻尼弹簧动画中使用它

384
00:15:47,648 --> 00:15:49,249
然后我们要执行我们的动画

385
00:15:49,449 --> 00:15:51,084
并启动那个动画器

386
00:15:51,151 --> 00:15:53,086
将其添加到那个运行动画器的集合中

387
00:15:56,657 --> 00:15:58,692
接下来
在我们的轻触手势识别器处理器中

388
00:15:58,759 --> 00:15:59,793
我们要调用这个方法

389
00:16:00,127 --> 00:16:03,463
这将会对我们的运行的转换
执行动画或倒转

390
00:16:03,730 --> 00:16:05,766
那么如果我们的转换没有在运行

391
00:16:05,832 --> 00:16:07,768
我们只需要发起我们的转换即可

392
00:16:08,135 --> 00:16:11,772
否则我们将在所有
运行属性动画器之间进行迭代

393
00:16:11,839 --> 00:16:12,840
并倒转它们

394
00:16:16,944 --> 00:16:18,312
现在对于接下来的三个方法

395
00:16:18,378 --> 00:16:19,279
我们只需要从之前的代码中提取

396
00:16:19,346 --> 00:16:22,950
我们的拖拽手势识别器处理代码即可

397
00:16:23,050 --> 00:16:25,052
我要快速总结这些是做什么用的

398
00:16:25,419 --> 00:16:27,120
对于
startInteractiveTransition

399
00:16:27,187 --> 00:16:29,056
当你的手势开始时调用

400
00:16:29,223 --> 00:16:31,592
如果转换没有运行 它会发起转换

401
00:16:31,658 --> 00:16:33,994
一律暂停全部动画

402
00:16:34,127 --> 00:16:36,563
并保存其产生的任何相对进度

403
00:16:38,432 --> 00:16:39,600
UpdateInteractiveTransition

404
00:16:39,666 --> 00:16:42,469
将一致地拖动你的动画

405
00:16:42,703 --> 00:16:45,138
相对于你手指移动的距离

406
00:16:45,205 --> 00:16:47,407
你的动画之前所做出的任何进展

407
00:16:47,474 --> 00:16:48,775
将被中断

408
00:16:49,476 --> 00:16:50,878
然后最终当你的手指抬起时

409
00:16:50,944 --> 00:16:52,179
我们会调用继续动画

410
00:16:52,246 --> 00:16:54,381
在你的全部动画器上 酌情倒转它们

411
00:16:54,448 --> 00:16:56,416
基于你手指的移动方向

412
00:16:57,918 --> 00:16:58,952
让我们来检验一下

413
00:17:00,521 --> 00:17:02,122
我们可以非交互式地驱动动画

414
00:17:02,222 --> 00:17:03,857
通过轻触

415
00:17:04,223 --> 00:17:05,858
我们还可以交互式地驱动它

416
00:17:06,560 --> 00:17:08,095
通过向上或向下推

417
00:17:09,530 --> 00:17:12,031
当它运行时 我们可以再次轻触它

418
00:17:12,098 --> 00:17:13,666
来中断它或倒转它

419
00:17:14,468 --> 00:17:17,003
当它运行时我们还可以捕捉动画

420
00:17:17,069 --> 00:17:18,638
就在我们拖动它的那一点上进行捕捉

421
00:17:19,940 --> 00:17:22,209
那么现在我们已创建了这个基础结构

422
00:17:22,643 --> 00:17:24,377
现在我们有了一个帧动画

423
00:17:24,444 --> 00:17:25,444
看起来没什么意思

424
00:17:25,512 --> 00:17:27,414
那么让我们把它变得更有意思一点儿

425
00:17:29,049 --> 00:17:29,883
那么我们要做的第一件事

426
00:17:29,950 --> 00:17:31,552
就是要添加一个交互式模糊

427
00:17:33,287 --> 00:17:36,723
现在我们在iOS 8中引入了
UIVisualEffectView

428
00:17:36,890 --> 00:17:37,991
允许我们添加模糊和活力

429
00:17:38,058 --> 00:17:39,893
给我们的视图层级

430
00:17:40,427 --> 00:17:41,595
原来

431
00:17:41,828 --> 00:17:43,730
VisualEffectsView
的效果属性

432
00:17:43,797 --> 00:17:46,466
是一个可动画属性 那么这很棒

433
00:17:47,134 --> 00:17:48,435
那么我们在这里要做的是

434
00:17:48,502 --> 00:17:50,237
我们要修改的唯一一处代码

435
00:17:50,304 --> 00:17:52,239
是修改动画转换 如果需要的话

436
00:17:52,873 --> 00:17:55,442
我们只需要给模糊创建一个新动画器

437
00:17:55,709 --> 00:17:58,278
那将会使用一个临界阻尼弹簧动画
至少目前是这样

438
00:17:58,912 --> 00:18:00,781
然后我们要在这里执行我们的动画

439
00:18:00,848 --> 00:18:02,683
无论是否设置了模糊效果

440
00:18:02,983 --> 00:18:04,184
启动我们的模糊动画器

441
00:18:04,251 --> 00:18:05,552
并将其添加到那个集合中

442
00:18:06,019 --> 00:18:07,154
这就是我们所得到的

443
00:18:13,227 --> 00:18:15,696
那么我们现在有了一个
交互式的模糊动画

444
00:18:17,664 --> 00:18:22,803
但让我们以慢动作再看一次

445
00:18:22,870 --> 00:18:25,105
因为我必须要对你们实事求是

446
00:18:25,239 --> 00:18:26,340
我不知道

447
00:18:26,406 --> 00:18:27,774
这个模糊动画是否真的搞对了

448
00:18:28,542 --> 00:18:29,576
我感觉它动得

449
00:18:29,676 --> 00:18:31,712
可能有点儿太快了

450
00:18:32,513 --> 00:18:34,848
现在让我们驱动这个并查看一下

451
00:18:35,315 --> 00:18:36,316
也许看起来好点了

452
00:18:36,583 --> 00:18:38,385
但看起来仍然不对劲儿

453
00:18:39,253 --> 00:18:40,888
可能有几种原因导致了这种情况

454
00:18:41,788 --> 00:18:44,224
首先是因为
我们使用了临界阻尼弹簧动画

455
00:18:44,291 --> 00:18:46,360
我们的模糊在临界阻尼弹簧中
动得太快了

456
00:18:47,227 --> 00:18:48,929
因为我们的属性动画器

457
00:18:48,996 --> 00:18:50,597
将会线性地拖动它

458
00:18:50,764 --> 00:18:51,999
我们的模糊仍然

459
00:18:52,065 --> 00:18:53,000
动得有点太快了

460
00:18:53,066 --> 00:18:55,035
并且它停止动画的速度太慢了

461
00:18:55,736 --> 00:18:57,938
那么为了修复这个 我们实际上要提供

462
00:18:58,005 --> 00:18:59,706
我们自己的自定义定时曲线

463
00:18:59,773 --> 00:19:01,275
我们的自定义缓缓进入函数

464
00:19:01,341 --> 00:19:03,477
所以我们的模糊动地非常慢

465
00:19:03,544 --> 00:19:04,945
而自定义减缓了定时函数

466
00:19:05,012 --> 00:19:06,980
所以它结束地非常快

467
00:19:07,481 --> 00:19:09,716
因为它们是相互的倒置

468
00:19:09,783 --> 00:19:11,518
我们要获取对称节奏

469
00:19:11,685 --> 00:19:14,087
意思是动画在退出时的节奏

470
00:19:14,154 --> 00:19:16,123
要与其进入一半时的节奏相匹配

471
00:19:17,391 --> 00:19:18,425
那么这是代码

472
00:19:18,492 --> 00:19:20,060
我们只是创建了立体定时参数

473
00:19:20,127 --> 00:19:21,528
根据目标状态

474
00:19:21,862 --> 00:19:23,764
然后我们要在这里禁用线性拖动

475
00:19:23,830 --> 00:19:25,766
从而使我们的动画器保持其节奏

476
00:19:25,832 --> 00:19:27,634
当我们交互式地驱动它时

477
00:19:28,468 --> 00:19:29,703
那么让我们再次检验一下

478
00:19:33,640 --> 00:19:34,775
好多了

479
00:19:34,842 --> 00:19:36,009
非常微妙

480
00:19:36,076 --> 00:19:37,444
但这次好多了

481
00:19:37,511 --> 00:19:38,879
让我们再

482
00:19:38,946 --> 00:19:39,813
慢一点

483
00:19:39,880 --> 00:19:40,914
那么你实际上了解了

484
00:19:40,981 --> 00:19:41,982
它是什么样子的

485
00:19:46,453 --> 00:19:47,888
同时让我们交互式驱动那个

486
00:19:47,955 --> 00:19:50,524
所以你可以看到它真的保持了它的节奏

487
00:19:50,591 --> 00:19:52,092
当你交互式地驱动它时

488
00:19:55,629 --> 00:19:58,799
很酷 那么现在我们有两个属性驱动器

489
00:19:58,866 --> 00:20:00,567
带有唯一定时特性

490
00:20:00,634 --> 00:20:02,536
可应用于我们的整个转换

491
00:20:03,203 --> 00:20:05,072
当让我们把它变得再有意思一点

492
00:20:05,138 --> 00:20:06,373
我现在想演示

493
00:20:06,440 --> 00:20:08,475
一个技巧 我要调用视图变形

494
00:20:09,243 --> 00:20:10,611
那么假设我有一个标签

495
00:20:10,777 --> 00:20:12,613
在本例中我们有一个标签…

496
00:20:12,679 --> 00:20:14,448
它是蓝色的 有点小

497
00:20:14,515 --> 00:20:15,749
它是常规字体

498
00:20:16,016 --> 00:20:18,185
我们想把它变得比现在大许多
也许换个颜色

499
00:20:18,252 --> 00:20:19,620
也许换个粗点的字体

500
00:20:20,053 --> 00:20:21,788
那么那个转换是什么样的呢？

501
00:20:22,890 --> 00:20:25,225
嗯 这是视图变形

502
00:20:25,292 --> 00:20:26,627
它是一种两个视图的比例转化

503
00:20:26,693 --> 00:20:28,996
和不透明度的混合

504
00:20:29,329 --> 00:20:31,265
那么在本例中
我们要使用UILabels

505
00:20:31,331 --> 00:20:34,468
但这种技巧通常可应用于
任意视图或视图层级；

506
00:20:34,535 --> 00:20:35,702
而不只是标签

507
00:20:37,104 --> 00:20:37,971
那么在我们的应用中

508
00:20:38,238 --> 00:20:39,439
我们要获取评论标签

509
00:20:39,506 --> 00:20:40,541
我们要把它变成蓝色

510
00:20:40,607 --> 00:20:41,441
当它展开时

511
00:20:41,508 --> 00:20:43,010
我们想让它变成这样

512
00:20:43,076 --> 00:20:44,344
请注意它的颜色暗多了

513
00:20:44,411 --> 00:20:45,746
但还是稍微嵌入了

514
00:20:45,812 --> 00:20:47,347
其父视图的顶部

515
00:20:48,482 --> 00:20:49,383
我们要实现的是

516
00:20:49,449 --> 00:20:51,518
让它像这样动起来

517
00:20:59,159 --> 00:21:00,594
我们要如何创建这个呢？

518
00:21:00,994 --> 00:21:03,463
嗯 UILabels不会曝光
任何可动画属性

519
00:21:03,530 --> 00:21:04,798
但这没问题 因为正如我所提到过的

520
00:21:04,865 --> 00:21:08,035
这通常可应用于任意视图或视图层级
而不只是标签

521
00:21:08,836 --> 00:21:10,337
我们要做的是使用

522
00:21:10,404 --> 00:21:11,605
UIView经常被忽略的转换属性

523
00:21:13,340 --> 00:21:15,409
并且我们要计算

524
00:21:15,475 --> 00:21:16,743
两个标签的比例转换

525
00:21:16,810 --> 00:21:18,912
从而我们可以把它们相互混合在一起

526
00:21:19,179 --> 00:21:21,548
我们要推动它们的不透明度

527
00:21:21,615 --> 00:21:23,250
从而可以把它们混合在一起

528
00:21:24,852 --> 00:21:25,686
我们要做的第一件事

529
00:21:25,752 --> 00:21:26,920
就是计算比例

530
00:21:27,654 --> 00:21:29,790
看起来这非常容易

531
00:21:29,857 --> 00:21:31,325
只是一个简单的尺寸比例

532
00:21:31,391 --> 00:21:32,593
基于目标尺寸

533
00:21:32,659 --> 00:21:33,861
和当前尺寸

534
00:21:34,094 --> 00:21:36,196
并且事实上 一旦你计算了其中一个

535
00:21:36,296 --> 00:21:37,664
你基本上就免费得到了另一个

536
00:21:37,731 --> 00:21:39,032
通过取倒数就可以

537
00:21:40,667 --> 00:21:41,869
现在计算转换

538
00:21:41,935 --> 00:21:43,170
变得稍微有意思点了

539
00:21:43,403 --> 00:21:46,006
这是因为我们推动了我们的比例

540
00:21:46,073 --> 00:21:48,509
那会影响转换过程中的边界

541
00:21:48,742 --> 00:21:49,710
所以我们不能仅仅简单地

542
00:21:49,776 --> 00:21:51,211
获取Y偏移

543
00:21:51,445 --> 00:21:52,613
但我们可以做的是

544
00:21:52,679 --> 00:21:55,282
预应用那个转换比例

545
00:21:55,349 --> 00:21:57,751
以获取Y偏移的新值

546
00:21:57,818 --> 00:21:59,553
并且我们可以用于转换中

547
00:22:00,954 --> 00:22:02,289
现在我们要驱动这个

548
00:22:02,356 --> 00:22:03,724
通过三个动画器

549
00:22:03,790 --> 00:22:05,125
用一个临界阻尼弹簧

550
00:22:05,192 --> 00:22:06,159
来驱动我们的转换

551
00:22:06,226 --> 00:22:09,029
从而使它遵守转换的整个路径

552
00:22:09,296 --> 00:22:11,198
然后缓入和缓出动画

553
00:22:11,265 --> 00:22:12,866
以执行不透明度混合

554
00:22:12,933 --> 00:22:14,368
这两者都将是

555
00:22:14,434 --> 00:22:15,435
非线性的拖动

556
00:22:16,904 --> 00:22:17,838
这是代码

557
00:22:17,905 --> 00:22:19,006
我还省略了

558
00:22:19,072 --> 00:22:20,507
有些重复的步骤

559
00:22:20,574 --> 00:22:22,075
那么我们创建了转换动画器

560
00:22:22,142 --> 00:22:24,278
我们推动了两个标签的转换

561
00:22:24,411 --> 00:22:27,147
即将使用的标签得到了身份转换

562
00:22:27,214 --> 00:22:30,551
那是因为它已经被预调整和转换了

563
00:22:30,617 --> 00:22:33,420
以匹配即将弃用的标签的边界值

564
00:22:33,987 --> 00:22:37,257
并且即将弃用的标签
以那样的方式进行转换 它匹配

565
00:22:37,324 --> 00:22:38,258
即将使用的标签的边界值

566
00:22:38,425 --> 00:22:39,726
在被推动之前

567
00:22:40,861 --> 00:22:42,696
我们在这里创建了两个属性动画器

568
00:22:42,763 --> 00:22:43,630
来混合我们的阿尔法值

569
00:22:43,697 --> 00:22:45,098
我们在这里禁用了线性拖动

570
00:22:45,165 --> 00:22:46,533
以便它们保持它们的节奏

571
00:22:47,501 --> 00:22:49,136
让我们看看那给我们带来了什么

572
00:22:51,572 --> 00:22:53,307
那么再一次

573
00:22:53,373 --> 00:22:55,943
我们可以非交互式地推动这种转换

574
00:22:57,277 --> 00:22:59,313
但我们还可以交互式地推动它

575
00:22:59,379 --> 00:23:00,314
看起来很不错

576
00:23:02,683 --> 00:23:03,884
我们甚至可以推动它

577
00:23:03,951 --> 00:23:05,018
然后再中断它

578
00:23:05,185 --> 00:23:06,453
就这样起作用了

579
00:23:08,889 --> 00:23:10,057
我认为这很酷…

580
00:23:15,729 --> 00:23:17,431
我认为很酷的是

581
00:23:17,564 --> 00:23:20,000
我们现在有一个黏着的动画转化

582
00:23:20,067 --> 00:23:23,203
是由六个不同的属性动画器驱动的

583
00:23:23,270 --> 00:23:26,073
其中五个有自己的定时特性

584
00:23:26,573 --> 00:23:27,574
现在我们可以

585
00:23:27,641 --> 00:23:28,976
在属性动画器之前实现

586
00:23:29,042 --> 00:23:30,978
属性动画器需要大量代码并且也很复杂

587
00:23:31,411 --> 00:23:33,380
但现在通过这个基础结构
我们设置好了

588
00:23:33,547 --> 00:23:34,648
我们可使用属性动画器

589
00:23:34,715 --> 00:23:36,116
简便地实现这些效果

590
00:23:36,183 --> 00:23:38,218
只需要声明我们的定时特性

591
00:23:38,285 --> 00:23:39,286
和拖动行为即可

592
00:23:41,622 --> 00:23:43,357
那么这就是如何协调动画

593
00:23:44,057 --> 00:23:46,527
现在让我们谈一些技巧、秘诀
以及一些额外技术

594
00:23:46,593 --> 00:23:49,329
当你为用户创建动画时可以用得上

595
00:23:50,998 --> 00:23:52,266
那么以前是不是有人

596
00:23:52,332 --> 00:23:53,433
曾尝试让

597
00:23:53,500 --> 00:23:54,768
圆角半径动起来？

598
00:23:55,369 --> 00:23:56,904
我想也许你们中有人做过

599
00:23:57,738 --> 00:23:58,839
为了实现这个功能

600
00:23:58,906 --> 00:24:00,107
你几乎必须得手动设置

601
00:24:00,174 --> 00:24:01,942
你的圆角半径或若你想让它动起来

602
00:24:02,009 --> 00:24:03,777
你就必须创建一个CA基础动画

603
00:24:03,844 --> 00:24:05,412
并将其设置它的来去值

604
00:24:06,613 --> 00:24:07,948
我们要做的是

605
00:24:08,182 --> 00:24:09,416
让我们的圆角半径动起来

606
00:24:09,483 --> 00:24:11,285
那样它会变成交互式

607
00:24:12,252 --> 00:24:13,587
那么我们该如何实现呢？

608
00:24:16,123 --> 00:24:17,624
现在我很高兴地要告诉你们

609
00:24:17,691 --> 00:24:21,061
现在那个圆角半径在UIKit中
是一个完全可动画属性了

610
00:24:27,935 --> 00:24:28,869
现在因为UIView

611
00:24:28,936 --> 00:24:31,071
没有暴露圆角半径属性

612
00:24:31,205 --> 00:24:33,540
你实际上需要进入视图背层

613
00:24:33,607 --> 00:24:35,075
修改圆角半径

614
00:24:35,175 --> 00:24:37,144
但只要你在一个动画代码块中那样做

615
00:24:37,211 --> 00:24:39,646
我们就会隐含地为你创建那个动画

616
00:24:39,713 --> 00:24:41,648
并且它会是完全可追踪和可拖动的动画

617
00:24:41,915 --> 00:24:43,050
事实上 你甚至可以

618
00:24:43,116 --> 00:24:44,685
从UIView动画方法中实现

619
00:24:45,919 --> 00:24:48,555
那会处理我们的交互式圆角半径动画

620
00:24:48,689 --> 00:24:50,424
现在这两个家伙怎么办呢

621
00:24:50,824 --> 00:24:51,692
我们只想让

622
00:24:51,758 --> 00:24:53,193
左上角和右上角动起来

623
00:24:53,260 --> 00:24:54,394
我们又该如何实现呢？

624
00:24:55,829 --> 00:24:59,233
我也非常高兴地告诉你们说
我们给CALayer添加了新属性

625
00:24:59,299 --> 00:25:00,400
即maskedCorners

626
00:25:05,472 --> 00:25:07,207
现在这个属性允许我们有选择地选择

627
00:25:07,274 --> 00:25:09,910
要给哪个圆角半径应用遮罩

628
00:25:09,977 --> 00:25:13,046
在我们本例中是左上角和右上角

629
00:25:14,915 --> 00:25:15,749
现在最终

630
00:25:15,816 --> 00:25:17,117
这就是实现代码

631
00:25:17,184 --> 00:25:18,719
省略了一些重复步骤

632
00:25:18,785 --> 00:25:20,988
那么我们只是
在这里创建了一个新动画器

633
00:25:21,054 --> 00:25:22,723
我们要使用一个线性定时函数

634
00:25:22,789 --> 00:25:25,025
并且我们要执行我们的圆角半径动画

635
00:25:25,125 --> 00:25:26,693
这就是我们所需要做的全部

636
00:25:27,160 --> 00:25:29,229
那让我们实现了如下动画

637
00:25:33,901 --> 00:25:36,370
它很微妙 但我们的确是交互式地拖动

638
00:25:36,436 --> 00:25:38,005
那里的圆角半径 这很酷

639
00:25:42,442 --> 00:25:43,410
迄今为止

640
00:25:43,510 --> 00:25:45,779
有一个潜在的信息

641
00:25:46,313 --> 00:25:47,915
非常重要

642
00:25:47,981 --> 00:25:48,949
即你的全部动画

643
00:25:49,016 --> 00:25:50,817
要共享同一个延时单位

644
00:25:51,151 --> 00:25:52,986
这就使得拖动变得非常简单

645
00:25:53,053 --> 00:25:53,954
同时也让

646
00:25:54,021 --> 00:25:55,489
一致地拖动它们变得有可能

647
00:25:56,623 --> 00:25:59,092
但你知道的 有时候

648
00:25:59,159 --> 00:26:00,994
有一个稍早一点完成的动画

649
00:26:01,061 --> 00:26:03,030
比一个延迟开始的动画要有好处

650
00:26:03,764 --> 00:26:05,232
有一个例子

651
00:26:05,399 --> 00:26:07,568
请看如下动画

652
00:26:07,634 --> 00:26:09,770
请注意这里的详情按钮

653
00:26:09,837 --> 00:26:11,772
它在开启时

654
00:26:12,306 --> 00:26:13,473
就已经占据了半个屏幕

655
00:26:13,674 --> 00:26:14,908
并且它完全停下来

656
00:26:14,975 --> 00:26:16,577
也是围绕同一个点

657
00:26:18,212 --> 00:26:19,346
若我们尝试把它变成交互式的

658
00:26:19,413 --> 00:26:20,247
你可以看到它是这样的

659
00:26:20,314 --> 00:26:22,816
它从这个点开始动画

660
00:26:24,051 --> 00:26:25,719
然后动画完成

661
00:26:25,853 --> 00:26:26,954
也是围绕那个点

662
00:26:27,754 --> 00:26:29,323
如果你看一下UIKit

663
00:26:29,389 --> 00:26:31,892
你其实可以看到我们可以
在很多地方应用这个功能

664
00:26:31,992 --> 00:26:33,794
事实上
UINavigationBar

665
00:26:33,861 --> 00:26:35,896
自iOS 7以来已经有了这个效果了

666
00:26:35,963 --> 00:26:38,532
当你交互式地驱动那个动画时

667
00:26:40,100 --> 00:26:41,335
那么我们可以创建一个

668
00:26:41,401 --> 00:26:42,936
时长缩短的动画器

669
00:26:43,003 --> 00:26:44,671
或我们能使用这里的这个延迟因子

670
00:26:44,838 --> 00:26:46,006
但这实际上会让

671
00:26:46,073 --> 00:26:47,007
我们的拖动代码变得更复杂

672
00:26:47,508 --> 00:26:49,476
看起来这里有更简洁的方案

673
00:26:49,543 --> 00:26:52,079
也就是使用keyframe动画

674
00:26:53,280 --> 00:26:54,515
如果我们看一下UIView标头

675
00:26:54,581 --> 00:26:56,583
我们可以看到
以下两个keyframe方法

676
00:26:56,950 --> 00:26:58,118
我想让你们注意一下

677
00:26:58,185 --> 00:26:59,486
RelativeStartTime

678
00:26:59,553 --> 00:27:00,721
和RelativeDuration

679
00:27:01,154 --> 00:27:02,823
那么为了创建这种效果

680
00:27:03,457 --> 00:27:04,992
我们需要在属性动画器内

681
00:27:05,058 --> 00:27:06,894
执行一个keyframe动画

682
00:27:07,327 --> 00:27:09,463
所以我们要调用
UIView.animateKeyframes

683
00:27:09,530 --> 00:27:11,465
其相对时长为零

684
00:27:11,765 --> 00:27:13,600
这意味着我们的
keyframe动画

685
00:27:13,667 --> 00:27:16,637
将继承其外部属性动画器的时长

686
00:27:17,137 --> 00:27:19,706
事实上 如果你像这样嵌入动画

687
00:27:19,773 --> 00:27:21,775
你将免费获得这种继承行为

688
00:27:21,842 --> 00:27:22,809
那么这非常有帮助

689
00:27:22,876 --> 00:27:24,645
如果你不适用属性动画器的话

690
00:27:26,280 --> 00:27:28,148
现在当我们扩展我们的评论视图时

691
00:27:28,215 --> 00:27:29,449
我们希望动画能晚些开始

692
00:27:29,516 --> 00:27:32,152
我们要使用的相对开始时间为0.5

693
00:27:32,352 --> 00:27:35,589
并且我们要通过使用
相对时长为0.5对其进行补偿

694
00:27:35,989 --> 00:27:37,357
当我们折叠它时

695
00:27:37,424 --> 00:27:38,959
我们要使用的相对开始时间为零

696
00:27:39,026 --> 00:27:40,761
因为我们希望它立即开始

697
00:27:40,894 --> 00:27:43,297
或我们使用相对时长为0.5

698
00:27:43,463 --> 00:27:45,098
以便它可以早一些结束

699
00:27:45,699 --> 00:27:46,700
我想让你们注意

700
00:27:46,767 --> 00:27:48,435
这里的这两个参数

701
00:27:48,769 --> 00:27:49,703
那么你不想使用

702
00:27:49,770 --> 00:27:50,771
线性定时函数

703
00:27:50,838 --> 00:27:52,239
给你的keyframe动画

704
00:27:52,372 --> 00:27:54,308
你可以使用你想要使用的任意定时函数

705
00:27:54,374 --> 00:27:56,944
包括你自己的自定义定时函数

706
00:27:57,311 --> 00:27:59,780
并且如果你有多个keyframe
而我们没有

707
00:28:00,080 --> 00:28:01,615
你实际上可以插入它们

708
00:28:01,682 --> 00:28:03,217
使用选项参数

709
00:28:03,984 --> 00:28:05,686
或控制它们的插入方式

710
00:28:05,752 --> 00:28:07,187
使用选项参数

711
00:28:10,757 --> 00:28:13,260
现在最后 我想稍微谈谈

712
00:28:13,327 --> 00:28:15,028
附加动画

713
00:28:16,363 --> 00:28:17,264
那么附加动画

714
00:28:17,331 --> 00:28:18,398
非常强大

715
00:28:18,732 --> 00:28:20,267
我觉得它们很有意思

716
00:28:20,334 --> 00:28:21,468
因为它们可以允许我们

717
00:28:21,535 --> 00:28:23,170
修改或推动

718
00:28:23,237 --> 00:28:24,872
视图的单一属性

719
00:28:25,038 --> 00:28:27,875
为多个同时运行的动画

720
00:28:29,309 --> 00:28:30,811
现在为了演示

721
00:28:32,579 --> 00:28:33,814
它其中的要点

722
00:28:33,881 --> 00:28:35,349
我想演示

723
00:28:35,415 --> 00:28:37,351
如何更附加地进行思考

724
00:28:37,417 --> 00:28:39,553
当我们设计和创建我们的动画时

725
00:28:39,820 --> 00:28:41,088
假如我们有一个正方形

726
00:28:41,455 --> 00:28:42,890
假设我们想让它动起来

727
00:28:42,956 --> 00:28:44,992
10毫秒转360度

728
00:28:45,125 --> 00:28:47,094
那个动画看起来可能是这样的

729
00:28:50,497 --> 00:28:51,532
现在你可能在想

730
00:28:51,598 --> 00:28:52,766
嗯 那就跟

731
00:28:52,833 --> 00:28:55,135
推动转换一样简单

732
00:28:55,936 --> 00:28:57,437
你其实是不会出错的

733
00:28:58,405 --> 00:28:59,540
但像这样的代码

734
00:28:59,606 --> 00:29:00,607
推动我们的视图

735
00:29:00,674 --> 00:29:02,209
以20π弧度

736
00:29:02,509 --> 00:29:04,278
并不会生成那种动画

737
00:29:04,912 --> 00:29:07,147
它实际上会生成这种动画

738
00:29:10,117 --> 00:29:10,984
你看到了吧？

739
00:29:13,487 --> 00:29:14,922
它实际上不会动

740
00:29:14,988 --> 00:29:16,990
并且有一个非常好的理由

741
00:29:17,658 --> 00:29:18,959
那是因为
Core Animation

742
00:29:19,026 --> 00:29:20,727
只关心总位移

743
00:29:20,794 --> 00:29:22,729
当你推动视图的转换时

744
00:29:23,230 --> 00:29:24,231
那么在本例中

745
00:29:24,364 --> 00:29:25,699
目标旋转值

746
00:29:25,766 --> 00:29:27,067
为20π弧度

747
00:29:27,134 --> 00:29:28,368
与当前旋转值的

748
00:29:28,435 --> 00:29:30,504
方向相同

749
00:29:30,871 --> 00:29:32,039
那么总位移

750
00:29:32,105 --> 00:29:33,106
实际上是零

751
00:29:34,508 --> 00:29:35,342
现在Core Animation

752
00:29:35,409 --> 00:29:37,411
将为你创建一个动画

753
00:29:37,477 --> 00:29:38,545
但它的来去值

754
00:29:38,612 --> 00:29:39,947
是一样的

755
00:29:41,048 --> 00:29:42,783
你知道的 类似的问题存在于

756
00:29:42,950 --> 00:29:43,917
如果你尝试以180度逆时针方向

757
00:29:43,984 --> 00:29:46,186
旋转视图

758
00:29:46,253 --> 00:29:48,422
通过指定负π弧度

759
00:29:49,056 --> 00:29:51,291
那是因为
Core Animation

760
00:29:51,391 --> 00:29:53,427
因为它只关心总位移

761
00:29:53,794 --> 00:29:55,295
并寻找最短路径

762
00:29:55,362 --> 00:29:56,196
当不明确时

763
00:29:56,263 --> 00:29:58,665
也就是这里的情况
将会变为顺时针方向

764
00:30:00,567 --> 00:30:01,869
那么我们要如何实现呢？

765
00:30:02,102 --> 00:30:03,604
我们可以使用一个核心动画

766
00:30:03,670 --> 00:30:05,706
并创建我们自己的CA基础动画

767
00:30:05,806 --> 00:30:07,341
然后手动设置我们的来去值

768
00:30:07,407 --> 00:30:09,076
这样就完美了 没问题了

769
00:30:09,443 --> 00:30:12,379
但我们不会获取追踪和拖动行为

770
00:30:12,446 --> 00:30:13,780
从属性动画器中

771
00:30:14,314 --> 00:30:15,949
并且它还会让这个例子

772
00:30:16,016 --> 00:30:17,150
变得没那么有意思

773
00:30:18,352 --> 00:30:19,686
我们可以做的是

774
00:30:19,786 --> 00:30:21,221
我们可以把它分解为

775
00:30:21,288 --> 00:30:24,658
一系列的小附加旋转动画

776
00:30:24,725 --> 00:30:25,792
并同时推动它们

777
00:30:25,859 --> 00:30:27,361
创建我们想要的效果

778
00:30:28,362 --> 00:30:31,765
那么看起来转换是一个
附加可动画属性

779
00:30:32,032 --> 00:30:33,166
只要它仿射

780
00:30:33,267 --> 00:30:35,869
与帧、边界、中心和位置一起

781
00:30:37,604 --> 00:30:38,972
那么在我们的方案中

782
00:30:39,339 --> 00:30:40,307
我们实际上要创建

783
00:30:40,374 --> 00:30:43,143
总共20个动画

784
00:30:43,443 --> 00:30:44,945
并且每个动画将推动

785
00:30:45,012 --> 00:30:46,413
180度

786
00:30:46,480 --> 00:30:49,149
然后它们会共同

787
00:30:49,216 --> 00:30:50,484
生成这个动画

788
00:30:51,885 --> 00:30:52,819
现在很酷的是

789
00:30:52,886 --> 00:30:55,055
我们实际上有20个动画

790
00:30:55,189 --> 00:30:56,924
同时在这里运行

791
00:30:57,658 --> 00:31:00,360
我其实不建议说这是个很好的主意

792
00:31:01,862 --> 00:31:03,564
但它的确帮助我们

793
00:31:03,630 --> 00:31:05,465
更附加地思考更多东西

794
00:31:05,566 --> 00:31:07,734
当我们设计、编写

795
00:31:07,801 --> 00:31:09,002
和创建我们的动画时

796
00:31:09,102 --> 00:31:10,137
那么重点是

797
00:31:10,204 --> 00:31:11,238
要考虑

798
00:31:11,305 --> 00:31:13,707
如何把许多动画连在一起

799
00:31:13,774 --> 00:31:15,209
或编写到一起

800
00:31:15,275 --> 00:31:17,244
来创建有意思的转换

801
00:31:19,947 --> 00:31:20,848
那么今天我们了解了

802
00:31:20,914 --> 00:31:22,049
如何制造

803
00:31:22,115 --> 00:31:23,550
完全交互和可中断的动画

804
00:31:23,617 --> 00:31:25,185
使用一些现代技巧

805
00:31:25,686 --> 00:31:27,187
我们还谈了如何协调

806
00:31:27,254 --> 00:31:28,589
一系列的动画

807
00:31:28,655 --> 00:31:29,823
每个动画都有唯一的

808
00:31:29,923 --> 00:31:31,091
定时函数

809
00:31:31,458 --> 00:31:33,160
我们还看了一些技巧

810
00:31:33,227 --> 00:31:34,528
以帮助我们

811
00:31:34,595 --> 00:31:35,863
为我们的用户

812
00:31:35,929 --> 00:31:36,897
创建一些很棒的动画

813
00:31:37,264 --> 00:31:40,234
我希望你们从这场演讲回去之后

814
00:31:40,434 --> 00:31:41,969
就开始考虑

815
00:31:42,035 --> 00:31:43,103
让你的动画转化

816
00:31:43,170 --> 00:31:44,872
变得完全交互和可中断

817
00:31:46,406 --> 00:31:47,908
那么我们有一些相关演讲

818
00:31:47,975 --> 00:31:49,243
如果你错过了其中一场

819
00:31:49,309 --> 00:31:51,044
我鼓励你在线观看它们

820
00:31:51,578 --> 00:31:53,614
还有前几年的一些

821
00:31:53,680 --> 00:31:54,982
有意思的演讲

822
00:31:55,048 --> 00:31:56,583
那么如果你对动画有兴趣

823
00:31:56,650 --> 00:31:57,551
我强烈建议你

824
00:31:57,618 --> 00:31:58,552
查看这些演讲的相关资料

825
00:31:58,819 --> 00:32:02,222
尤其是去年的这场演讲 我们介绍了
UIViewPropertyAnimator

826
00:32:02,756 --> 00:32:03,757
要获取更多信息

827
00:32:03,824 --> 00:32:05,826
请访问以下URL

828
00:32:06,126 --> 00:32:07,928
非常感谢

