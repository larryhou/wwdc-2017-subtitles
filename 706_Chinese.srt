1
00:00:22,356 --> 00:00:23,524
早上好 欢迎参加

2
00:00:23,590 --> 00:00:26,360
现代化中心调度GCD用法演讲

3
00:00:26,426 --> 00:00:28,595
我是Daniel Chimene
来自Core Darwin团队

4
00:00:28,862 --> 00:00:31,698
我和我的同事们今天要跟大家谈谈

5
00:00:31,765 --> 00:00:34,234
如何利用中心调度

6
00:00:34,468 --> 00:00:36,103
在你的应用中获得最佳性能

7
00:00:37,471 --> 00:00:38,438
作为应用开发人员

8
00:00:38,772 --> 00:00:40,974
你会花成百上千个小时

9
00:00:41,041 --> 00:00:43,410
为你的用户打造出色体验

10
00:00:43,477 --> 00:00:45,612
利用你强大的设备

11
00:00:46,613 --> 00:00:49,349
你想让你的用户拥有出色的体验

12
00:00:49,583 --> 00:00:50,684
不仅是在一台设备上

13
00:00:51,218 --> 00:00:53,854
而是在Apple的各种设备上

14
00:00:56,723 --> 00:01:00,394
GCD的目的是帮助你动态地
调整你应用的代码

15
00:01:00,460 --> 00:01:03,697
从单核的Apple Watch
一直到迷你核的Mac

16
00:01:04,431 --> 00:01:06,033
你不必太过担心

17
00:01:06,099 --> 00:01:08,569
你的用户运行的是哪种硬件

18
00:01:09,036 --> 00:01:10,737
但会出现不确定的模式

19
00:01:10,804 --> 00:01:14,241
可能会影响你代码的可扩展性和效率

20
00:01:14,308 --> 00:01:16,310
无论是高端还是低端都一样

21
00:01:17,177 --> 00:01:18,879
这也是我们今天要谈的内容

22
00:01:19,313 --> 00:01:20,647
我们要帮助你确保

23
00:01:20,714 --> 00:01:22,649
你放到应用中的代码

24
00:01:22,716 --> 00:01:24,818
会给用户打造一种出色的体验

25
00:01:25,485 --> 00:01:27,387
可以在各种设备间进行转换

26
00:01:28,989 --> 00:01:32,392
你可能用过GCD API
比如异步调度

27
00:01:32,926 --> 00:01:35,696
还有其它创建提示
以及给系统调度工作的API

28
00:01:36,230 --> 00:01:39,433
这些只是并发性技术的一些接口

29
00:01:39,499 --> 00:01:41,235
我们叫作中心调度GCD

30
00:01:41,668 --> 00:01:44,805
今天我们要看看GCD底层的东西

31
00:01:45,405 --> 00:01:48,041
这是一场充斥着各种信息的高级演讲

32
00:01:48,342 --> 00:01:51,245
那么让我们立即开始吧
先看一下我们的硬件

33
00:01:52,012 --> 00:01:53,680
我们的设备中出色的芯片

34
00:01:53,747 --> 00:01:55,983
随着时间的推移速度变得越来越快

35
00:01:56,250 --> 00:01:57,384
然而 速度快

36
00:01:57,451 --> 00:02:00,220
并不只是因为芯片自身变快了

37
00:02:00,287 --> 00:02:03,090
还因为它们在运行你的代码方面
变得越来越智能了

38
00:02:03,156 --> 00:02:04,224
并且它们

39
00:02:04,291 --> 00:02:07,160
随着时间的过去也在学习你代码的作用
以便更有效地运作

40
00:02:10,430 --> 00:02:14,067
然而如果你的代码远离了内核
因为它完成了它的任务

41
00:02:14,701 --> 00:02:16,570
那么它将不再利用

42
00:02:16,637 --> 00:02:18,906
那个内核所创建的历史

43
00:02:18,972 --> 00:02:22,509
你可能会把性能丢开
当你返回到内核上时

44
00:02:23,243 --> 00:02:25,712
我们在我们自己的框架中
看到过这样的例子

45
00:02:25,779 --> 00:02:27,681
当我们应用一些优化技巧时

46
00:02:27,748 --> 00:02:29,550
我们今天也要讨论这些优化技巧

47
00:02:29,616 --> 00:02:34,655
我们看到简单的变更就会很大程度上
加快速度 从而避免这些不确定的模式

48
00:02:34,721 --> 00:02:36,790
（速度快了1.3倍
结合队列等级）

49
00:02:36,857 --> 00:02:38,525
那么通过这些技巧

50
00:02:38,592 --> 00:02:41,962
你可以用更少量的工作
给更多的用户带来高性能应用

51
00:02:42,663 --> 00:02:44,932
今天我们要深入研究

52
00:02:44,998 --> 00:02:48,068
我们系统底层是如何运作你的代码的

53
00:02:48,135 --> 00:02:50,470
那么你可以调整你的代码以最好地利用

54
00:02:50,537 --> 00:02:51,905
GCD所提供的功能

55
00:02:52,639 --> 00:02:54,308
我们今天要讨论一些东西

56
00:02:55,075 --> 00:02:57,611
首先我们要讨论如何最好地表达

57
00:02:57,945 --> 00:02:59,379
并行和并发

58
00:03:00,013 --> 00:03:02,049
如何选择最佳方式

59
00:03:02,115 --> 00:03:04,651
向GCD表达并发

60
00:03:05,519 --> 00:03:07,721
我们要介绍一下统一队列身份

61
00:03:07,788 --> 00:03:09,823
这是GCD底层的一个重要改进

62
00:03:09,890 --> 00:03:11,592
是我们今年发布的

63
00:03:11,658 --> 00:03:14,061
我们最后要给你们演示
如何发现代码中的问题点

64
00:03:14,127 --> 00:03:15,662
通过仪表

65
00:03:16,630 --> 00:03:19,433
那么让我们先讨论并行和并发

66
00:03:20,400 --> 00:03:21,268
那么…

67
00:03:23,637 --> 00:03:25,138
为了演讲的目的

68
00:03:25,205 --> 00:03:28,675
我们要谈谈平行
就是关于你的代码如何

69
00:03:29,309 --> 00:03:32,346
同时在多个不同的内核上并行执行

70
00:03:32,713 --> 00:03:35,048
并发是关于你如何构造

71
00:03:35,115 --> 00:03:38,352
你应用的独立组件使其同时运行

72
00:03:39,119 --> 00:03:41,121
那么区分这两个概念有一个简单的方式

73
00:03:41,188 --> 00:03:42,089
就是明白

74
00:03:42,155 --> 00:03:44,758
并行通常需要多内核

75
00:03:44,825 --> 00:03:46,560
你想同时使用全部的内核

76
00:03:46,627 --> 00:03:49,463
而并发甚至可以在单核系统中实现

77
00:03:49,530 --> 00:03:51,532
它是关于你如何介入

78
00:03:51,865 --> 00:03:53,867
作为应用的一部分的不同任务

79
00:03:53,934 --> 00:03:55,869
那么让我们从并行开始谈

80
00:03:56,303 --> 00:03:58,839
以及当你在写应用时如何使用它

81
00:03:59,673 --> 00:04:00,607
那么

82
00:04:00,941 --> 00:04:04,545
让我们想象一下你正在开发一款应用
而它会处理大量图片

83
00:04:04,845 --> 00:04:07,881
你希望能利用Mac Pro上的多核

84
00:04:07,948 --> 00:04:09,716
来更快地处理这些图片

85
00:04:10,350 --> 00:04:12,719
于是你就把图片分别放到组块中

86
00:04:13,520 --> 00:04:15,789
并且让每个内核

87
00:04:17,558 --> 00:04:18,492
并行地处理这些组块

88
00:04:19,392 --> 00:04:20,527
这就提升了你的速度

89
00:04:20,594 --> 00:04:22,629
因为多核同时

90
00:04:22,696 --> 00:04:24,331
处理图片的不同部分

91
00:04:25,332 --> 00:04:27,534
那么你要如何实施呢？嗯 首先

92
00:04:28,802 --> 00:04:30,237
你应该停下来思考

93
00:04:30,437 --> 00:04:32,606
你是否可以利用我们系统框架

94
00:04:33,407 --> 00:04:36,443
比如Accelerate框架有内嵌支持

95
00:04:36,743 --> 00:04:39,313
可以支持高级图片算法的并行执行

96
00:04:40,013 --> 00:04:44,218
Metal和Core图片
可以利用强大的GPU

97
00:04:45,853 --> 00:04:48,722
嗯 假如说你已经决定自己实施

98
00:04:48,789 --> 00:04:52,159
GCD会给你提供一个工具
可以让你轻松地表达这个模式

99
00:04:52,960 --> 00:04:56,897
你向GCD表达并行的模式是使用一个
叫作concurrentPerform的API

100
00:04:57,231 --> 00:04:59,733
它会让框架优化并行

101
00:04:59,967 --> 00:05:01,101
因为它知道你正在尝试

102
00:05:01,168 --> 00:05:03,637
利用所有内核实现并行计算

103
00:05:04,571 --> 00:05:07,574
concurrentPerform是一个循环并行

104
00:05:07,641 --> 00:05:10,644
会自动负载平衡系统中
所有内核的计算任务

105
00:05:11,211 --> 00:05:14,481
Swift 当你与Swift一起用时
它会自动选择

106
00:05:14,548 --> 00:05:17,050
运行你所有计算的正确情境

107
00:05:17,117 --> 00:05:18,886
今年 我们把同样的功能

108
00:05:18,952 --> 00:05:21,121
引入了Objective C的接口

109
00:05:21,755 --> 00:05:23,557
通过调度应用自动关键字来调度应用

110
00:05:24,324 --> 00:05:25,826
这替换了Q参数

111
00:05:26,426 --> 00:05:28,028
允许系统

112
00:05:28,095 --> 00:05:30,397
自动选择运行你代码的正确情境

113
00:05:31,331 --> 00:05:33,367
那么现在让我们看一下另一个参数

114
00:05:33,433 --> 00:05:34,868
即重复技术

115
00:05:35,202 --> 00:05:38,505
这是在系统中
并行调用你的代码块的次数

116
00:05:39,339 --> 00:05:41,041
在这里你要如何选择一个适当的值呢？

117
00:05:41,775 --> 00:05:45,212
你可能认为适当的值应该是内核的数量

118
00:05:45,279 --> 00:05:46,146
让我们想象一下

119
00:05:47,047 --> 00:05:49,850
我们正在一个三核系统中
执行我们的工作

120
00:05:50,017 --> 00:05:51,685
在这里你可以看到理想情况

121
00:05:52,119 --> 00:05:54,388
也就是三个代码块在全部
三个内核上并行运行

122
00:05:55,022 --> 00:05:57,157
但现实世界总是不会这么完美

123
00:05:57,791 --> 00:05:59,393
如果第三个内核

124
00:05:59,459 --> 00:06:01,128
被占用执行UI渲染会发生什么呢？

125
00:06:03,297 --> 00:06:04,765
嗯 情况就会变成这样

126
00:06:04,831 --> 00:06:08,569
负载平衡器必须得把那第三个代码块
挪到第一个内核上

127
00:06:08,936 --> 00:06:11,438
以便执行第三个代码块
因为第三个内核被占用了

128
00:06:11,905 --> 00:06:13,874
我们的CPU闲置

129
00:06:13,941 --> 00:06:17,778
我们可以利用这段时间
来执行更多的并行工作

130
00:06:18,145 --> 00:06:20,080
那么相反 我们的工作花的时间更长

131
00:06:21,281 --> 00:06:22,482
那么如何修复呢？

132
00:06:22,549 --> 00:06:25,118
嗯 我们可以增加重复计数

133
00:06:26,486 --> 00:06:28,622
并给负载平衡器提供更多的灵活性

134
00:06:29,723 --> 00:06:31,325
看起来不错 堵上那个窟窿了

135
00:06:31,859 --> 00:06:35,662
但其实这里还有一个窟窿
就是在第三个内核上

136
00:06:36,196 --> 00:06:37,998
我们也可以利用那段时间

137
00:06:39,766 --> 00:06:44,004
那么正如提姆在周一的演讲上所说的
让我们把重复次数增加 增加到11

138
00:06:46,740 --> 00:06:50,110
然后我们就填上这个窟窿了
我们的执行也更有效率了

139
00:06:50,410 --> 00:06:53,113
我们用了系统上全部可用的资源
直到我们完成

140
00:06:53,614 --> 00:06:56,049
这是一个非常简单的例子

141
00:06:56,717 --> 00:06:58,151
要处理实际的复杂性

142
00:06:58,552 --> 00:07:00,521
你得使用更大的量级

143
00:07:00,854 --> 00:07:02,022
比如1000

144
00:07:03,123 --> 00:07:04,825
你可以使用足够大的重复计数

145
00:07:05,092 --> 00:07:07,961
以便负载平衡器可以灵活地
填补系统中的空白

146
00:07:08,028 --> 00:07:10,797
并最大限度地利用

147
00:07:10,864 --> 00:07:12,366
系统中可用的资源

148
00:07:13,100 --> 00:07:16,637
然而你应该确保平衡
负载平衡器的消耗

149
00:07:16,703 --> 00:07:20,674
相对于并行循环中每个代码块
做执行的有效工作

150
00:07:21,708 --> 00:07:24,311
请记住每个CPU并不总是全部可用

151
00:07:24,478 --> 00:07:27,247
系统中同时还运行着许多任务

152
00:07:28,248 --> 00:07:31,485
此外 并不是每个辅助线程
都能取得同等的进度

153
00:07:32,452 --> 00:07:35,255
那么回顾一下 如果你有并行问题

154
00:07:35,956 --> 00:07:38,559
确保利用一切可用的系统框架

155
00:07:38,625 --> 00:07:40,994
你可以用它们的能力来解决你的问题

156
00:07:42,062 --> 00:07:44,631
此外 确保利用自动负载平衡

157
00:07:44,698 --> 00:07:46,300
位于concurrentPerform内

158
00:07:46,366 --> 00:07:48,735
给它提供一定的灵活性以最好地利用它

159
00:07:50,003 --> 00:07:51,638
那么这是关于并行的讨论

160
00:07:51,939 --> 00:07:55,242
现在让我们回到主话题上 即并发

161
00:07:56,610 --> 00:07:58,445
那么并发

162
00:07:59,580 --> 00:08:01,782
让我们想象一下
你正在写一个简单的新闻应用

163
00:08:02,883 --> 00:08:05,853
你会如何构造它？嗯 你从把它拆解到

164
00:08:05,919 --> 00:08:08,555
组成应用的独立子系统中开始

165
00:08:09,223 --> 00:08:11,058
思考一下如何把新闻应用拆解

166
00:08:11,358 --> 00:08:14,628
到其独立的子系统中
你可能有一个UI组件

167
00:08:14,695 --> 00:08:16,630
是渲染UI的 这就是主线程

168
00:08:16,697 --> 00:08:20,200
你可能有一个存储这些文章的数据库

169
00:08:20,734 --> 00:08:22,369
且你可能还有一个联网的子系统

170
00:08:22,436 --> 00:08:24,137
从网络上获取这些文章

171
00:08:24,738 --> 00:08:26,406
为了给你一个更好的描述
关于这个应用是如何运作

172
00:08:26,473 --> 00:08:28,842
以及如何拆解到子系统中

173
00:08:29,243 --> 00:08:32,980
让我们在一个现代化系统上
形象化一下那是如何同时执行的

174
00:08:33,413 --> 00:08:39,019
那么假如这个时间轴
在CPU轨道的顶部显示

175
00:08:39,086 --> 00:08:40,988
让我们想象一下
我们只剩下了一个CPU

176
00:08:41,054 --> 00:08:44,658
其它CPU都忙于其它任务
我们只有一个可用的内核

177
00:08:44,925 --> 00:08:47,694
无论什么时候只能有一个线程
运行在那个CPU上

178
00:08:48,529 --> 00:08:50,731
那么当用户在新闻应用中点击按钮

179
00:08:51,031 --> 00:08:53,534
并刷新文章列表时会发生什么？

180
00:08:54,134 --> 00:08:56,870
嗯 这些界面会渲染对那个按钮的响应

181
00:08:56,937 --> 00:08:59,406
然后给数据库发送异步指令

182
00:09:00,140 --> 00:09:02,910
然后数据库就决定它需要刷新文章

183
00:09:02,976 --> 00:09:06,013
它会对联网子系统选择另一个命令

184
00:09:06,880 --> 00:09:09,616
然而在这点上 用户再次触摸应用

185
00:09:09,917 --> 00:09:13,854
因为数据库脱离应用的主线程
完成了执行

186
00:09:14,288 --> 00:09:17,457
OS可以立即切换CPU处理UI线程

187
00:09:17,791 --> 00:09:19,560
它可以立即响应用户

188
00:09:19,626 --> 00:09:22,462
而无需等待数据库线程执行完成

189
00:09:23,630 --> 00:09:26,400
这就是把工作从主线程上脱离的好处

190
00:09:28,468 --> 00:09:30,537
当用户界面完成响应时

191
00:09:30,971 --> 00:09:33,574
CPU就可以切换回数据库线程

192
00:09:33,740 --> 00:09:35,876
然后完成联网任务

193
00:09:36,510 --> 00:09:38,745
像这样利用并发

194
00:09:39,112 --> 00:09:40,948
可以让你创建响应性的应用

195
00:09:41,215 --> 00:09:43,851
主线程总是响应用户的行动

196
00:09:44,084 --> 00:09:47,487
而无需等待应用的其它部分完成

197
00:09:48,155 --> 00:09:50,591
那么让我们看看对于CPU来说
是什么样的

198
00:09:51,425 --> 00:09:52,826
上边的这些白线

199
00:09:52,893 --> 00:09:55,195
显示的是子系统之间的内容切换

200
00:09:55,963 --> 00:09:58,031
接触开关是当CPU

201
00:09:58,098 --> 00:10:01,335
在不同的子系统之间
或组成你应用的线程之间进行切换时

202
00:10:01,902 --> 00:10:05,072
如果你想这在你的应用中是什么样的

203
00:10:05,138 --> 00:10:06,940
你可以使用仪表系统进行追踪

204
00:10:07,007 --> 00:10:09,643
可以给你显示CPU和线程正在做什么

205
00:10:09,710 --> 00:10:11,178
当它们在你的应用中运行时

206
00:10:11,678 --> 00:10:13,380
如果你想了解更多信息

207
00:10:13,447 --> 00:10:15,616
你可以参看去年的
“深度解析系统追踪”演讲

208
00:10:15,682 --> 00:10:18,385
仪表团队描述了你该如何使用系统追踪

209
00:10:19,286 --> 00:10:23,557
那么这个情境切换的概念是
并发的能力来自哪里

210
00:10:24,024 --> 00:10:26,660
让我们看看何时会发生这些情境切换

211
00:10:26,727 --> 00:10:27,861
以及导致情境切换的原因

212
00:10:28,362 --> 00:10:29,229
嗯

213
00:10:29,596 --> 00:10:31,965
当高优先级线程需要CPU时会发生

214
00:10:32,032 --> 00:10:33,100
正如我们之前看到过的

215
00:10:33,166 --> 00:10:35,402
UI线程会先于数据库线程

216
00:10:35,969 --> 00:10:38,805
当线程结束当前任务时

217
00:10:39,306 --> 00:10:41,341
或等待取得资源时

218
00:10:41,742 --> 00:10:44,178
或等待异步请求完成时也会发生

219
00:10:44,845 --> 00:10:47,147
然而 通过并发的强大力量

220
00:10:47,481 --> 00:10:49,550
也会伴随着强大的责任

221
00:10:49,616 --> 00:10:51,585
你拥有太多好东西了

222
00:10:52,886 --> 00:10:56,323
假如说你正在网络
和数据库线程之间切换

223
00:10:56,890 --> 00:10:57,824
在你的CPU上

224
00:10:58,392 --> 00:10:59,560
切换几个情境没问题

225
00:10:59,626 --> 00:11:02,062
这就是并发的能力所在
你可以在不同的任务之前切换

226
00:11:02,629 --> 00:11:05,132
然而如果你要做上千次切换

227
00:11:05,199 --> 00:11:08,202
连续迅速切换 你就有大麻烦啦

228
00:11:08,268 --> 00:11:09,670
你就开始丢失性能

229
00:11:09,937 --> 00:11:12,673
因为这里的每一条白线
都是一个情境切换

230
00:11:13,073 --> 00:11:14,641
情境切换的消耗也增加了

231
00:11:14,708 --> 00:11:17,144
并不只是说执行情境切换的时间

232
00:11:17,477 --> 00:11:19,313
还有内核所创建的历史

233
00:11:19,379 --> 00:11:21,548
它必须得在每次情境切换后
恢复那个历史

234
00:11:23,550 --> 00:11:25,485
你可能还会有其它影响因素

235
00:11:25,552 --> 00:11:29,489
比如可能还有其它线程
正在排队等待获取CPU

236
00:11:30,490 --> 00:11:33,126
每次切换情境时

237
00:11:33,193 --> 00:11:34,962
剩余的线程队列都必须等待疏通

238
00:11:35,028 --> 00:11:38,932
那么你可能会被队列中的其它线程
超越而导致延迟

239
00:11:39,600 --> 00:11:42,736
那么让我们看看
导致情境切换次数过多的原因

240
00:11:43,637 --> 00:11:46,607
那么今天我们要讲的是三个主要原因

241
00:11:46,907 --> 00:11:50,577
第一是反复等待独占资源

242
00:11:50,844 --> 00:11:53,614
在独立的运作之间反复切换

243
00:11:53,680 --> 00:11:56,216
并且在线程间反复跳过某个运作

244
00:11:56,950 --> 00:11:59,820
你注意到我反复几次提到了反复这个词

245
00:12:00,587 --> 00:12:01,555
我是刻意这么说的

246
00:12:03,257 --> 00:12:05,225
情境切换几次是没问题的

247
00:12:05,559 --> 00:12:08,395
这就是并发的作用
也是我们赋予你们的能力

248
00:12:08,662 --> 00:12:12,065
然而当你重复切换太多次时
消耗就开始增加了

249
00:12:13,400 --> 00:12:15,402
那么让我们来看第一种情况

250
00:12:15,469 --> 00:12:17,838
也就是独占资源

251
00:12:18,672 --> 00:12:19,873
什么时候会发生这种情况？

252
00:12:20,407 --> 00:12:24,845
嗯 这种发生的主要情况是
当你有一个锁定

253
00:12:24,912 --> 00:12:28,182
而大量线程都尝试获取那个锁定时

254
00:12:29,483 --> 00:12:31,818
那么如何了解你的应用中
是否有这种情况发生？

255
00:12:31,885 --> 00:12:33,787
嗯 我们可以返回到系统追踪

256
00:12:34,354 --> 00:12:36,857
我们可以在仪表中
形象化具体是怎么样的

257
00:12:37,191 --> 00:12:39,726
那么假如说它显示我们有许多线程

258
00:12:39,793 --> 00:12:41,228
只运行很短的时间

259
00:12:41,295 --> 00:12:43,363
并且它们会在一个小串联中相互转换

260
00:12:44,264 --> 00:12:46,767
让我们主要关注第一个线程
看看它会告诉我们哪些东西

261
00:12:47,835 --> 00:12:51,839
我们有这个蓝色线
它表示的是线程在CPU上的时间

262
00:12:52,539 --> 00:12:55,042
而红色线表示执行系统调用的时间

263
00:12:55,108 --> 00:12:57,477
在本例中
它会执行一个无声文本系统调用

264
00:12:58,579 --> 00:13:00,214
这显示出它绝大部分时间

265
00:13:00,280 --> 00:13:02,883
都在等待无声文本变为可用

266
00:13:02,950 --> 00:13:06,220
在内核上的时间很短 只有10毫秒

267
00:13:06,987 --> 00:13:09,857
系统中有大量情境切换

268
00:13:09,923 --> 00:13:11,825
通过顶部的情境切换条显示

269
00:13:13,794 --> 00:13:15,629
那么是什么原因导致了这样的情况？

270
00:13:15,863 --> 00:13:17,865
让我们返回去看那个简单的时间轴

271
00:13:18,298 --> 00:13:21,168
了解如何…如何获取情境[听不清]…

272
00:13:22,135 --> 00:13:24,471
如何用完过度的负债

273
00:13:25,239 --> 00:13:27,708
那么你可以及时了解到这种阶梯式模式

274
00:13:28,008 --> 00:13:29,776
每个线程都只运行很短的时间

275
00:13:29,843 --> 00:13:31,545
然后就把CPU让给下一个线程

276
00:13:31,612 --> 00:13:33,180
以此类推 然后等待很长时间

277
00:13:33,914 --> 00:13:35,816
你想让你的应用看起来像这样

278
00:13:36,683 --> 00:13:39,419
你必须 CPU每次只能专注于一件事

279
00:13:39,620 --> 00:13:41,355
完成它 然后再执行下一个任务

280
00:13:42,322 --> 00:13:44,525
那么这里发生了什么
才导致了那种阶梯？

281
00:13:44,691 --> 00:13:46,560
让我们放大其中一个阶梯

282
00:13:47,628 --> 00:13:51,231
那么在这里我们正在专注两个线程
绿色线程和蓝色线程

283
00:13:51,765 --> 00:13:53,534
并且顶部有CPU

284
00:13:54,234 --> 00:13:55,836
我们在这里添加了一个新的锁定追踪

285
00:13:55,969 --> 00:13:58,105
表明了锁定的状态以及哪个线程拥有它

286
00:13:58,305 --> 00:13:59,339
在本例中

287
00:13:59,406 --> 00:14:02,543
蓝色线程拥有这个锁定
而绿色线程正在等待

288
00:14:03,443 --> 00:14:05,379
那么当蓝色线程解锁时

289
00:14:05,445 --> 00:14:07,447
那个锁定的所有权就转给了绿色线程

290
00:14:07,514 --> 00:14:08,615
因为它是队列中的下一个

291
00:14:09,449 --> 00:14:13,587
然而当蓝色线程转回来再次获取锁定时

292
00:14:13,654 --> 00:14:16,590
它不会成功 因为绿色线程预定了锁定

293
00:14:16,657 --> 00:14:20,093
它强制进行情境切换
因为我们现在必须做其它事

294
00:14:20,494 --> 00:14:23,497
我们切换到了绿色线程
那么CPU就可以

295
00:14:24,097 --> 00:14:25,933
结束锁定 我们可以反复这个过程

296
00:14:27,034 --> 00:14:28,202
有时候很有帮助

297
00:14:28,268 --> 00:14:29,903
你希望等待锁定的每一个线程

298
00:14:29,970 --> 00:14:31,872
都有机会获取资源

299
00:14:32,606 --> 00:14:35,742
然而如果锁定的工作方式
不一样会发生什么呢？

300
00:14:36,543 --> 00:14:39,880
让我们再从开始做
通过查看一个不公平的锁定会做什么

301
00:14:40,881 --> 00:14:45,385
那么这一次当蓝色线程解锁时
锁定并没有被预定

302
00:14:45,853 --> 00:14:47,621
锁定的所有权被公开拍卖了

303
00:14:48,622 --> 00:14:51,992
蓝色线程可以再次获取锁定
并且它可以立即重新获取

304
00:14:52,059 --> 00:14:54,795
并保留在CPU上
而不需要强制进行情景切换

305
00:14:55,495 --> 00:14:56,697
那可能会导致绿色线程很难

306
00:14:56,763 --> 00:14:59,366
有机会获取锁定

307
00:14:59,433 --> 00:15:02,803
但它减少了强制情景切换的次数…

308
00:15:02,870 --> 00:15:06,640
是蓝色线程为了重新获取锁定
而发起的强制切换

309
00:15:08,008 --> 00:15:09,843
那么回顾一下当我们谈到锁定竞争时

310
00:15:10,143 --> 00:15:13,547
你实际上是想确保
衡量你的应用和系统追踪

311
00:15:13,847 --> 00:15:15,349
了解是否存在问题

312
00:15:15,415 --> 00:15:20,254
如果你这么做了 这种不公平的锁定
通常适用于对象、属性

313
00:15:20,320 --> 00:15:21,822
或全局状态 你的应用

314
00:15:21,889 --> 00:15:24,124
可能会发生的锁定会跌很多很多次

315
00:15:25,526 --> 00:15:27,728
当提到锁定时 我还想谈另外一件事

316
00:15:27,995 --> 00:15:29,096
就是锁定的所有权

317
00:15:29,863 --> 00:15:31,832
那么请记住我们之前的锁定追踪

318
00:15:32,499 --> 00:15:35,135
运行时间知道接下来是哪个线程
会解锁锁定

319
00:15:36,003 --> 00:15:37,638
我们可以利用那种能力

320
00:15:37,704 --> 00:15:40,440
自动计算你应用中的优先级反转

321
00:15:40,507 --> 00:15:42,342
在等待锁定的线程
和拥有锁定的线程之间

322
00:15:43,043 --> 00:15:44,978
甚至启用其它优化

323
00:15:45,045 --> 00:15:47,347
比如让CPU转到拥有锁定的线程上

324
00:15:47,748 --> 00:15:49,816
稍后Pierre会跟大家讨论这个话题

325
00:15:49,883 --> 00:15:51,151
当我们谈同步调度时

326
00:15:52,186 --> 00:15:53,487
我们通常会有这个问题

327
00:15:53,987 --> 00:15:56,557
哪些基元有这种能力而哪些没有呢？

328
00:15:57,457 --> 00:16:00,494
让我们看看哪些低等级基元可以实现

329
00:16:01,495 --> 00:16:04,531
那么拥有单一
已知所有者的基元有这种能力

330
00:16:04,932 --> 00:16:07,100
比如连续队列和OS的不公平锁定

331
00:16:08,202 --> 00:16:10,504
然而不对称基元

332
00:16:10,571 --> 00:16:13,807
比如调度信号和调度群就没有这种能力

333
00:16:13,974 --> 00:16:17,311
因为运行时间不知道哪个线程
会单一化子基元

334
00:16:18,612 --> 00:16:21,381
最终 拥有多个所有者的基元

335
00:16:21,448 --> 00:16:23,851
比如私人化的并发队列和读或写锁定

336
00:16:24,251 --> 00:16:25,719
系统就不用利用那些

337
00:16:25,786 --> 00:16:27,521
因为它们不是只有一个所有者

338
00:16:28,488 --> 00:16:31,959
当你选择基元时 要考虑你是否

339
00:16:32,025 --> 00:16:34,228
涉及多基元的线程交互

340
00:16:35,095 --> 00:16:38,599
比如拥有较低优先级
后台线程的高级UI线程

341
00:16:39,800 --> 00:16:42,970
如果是这样的话
你可能想利用基元的所有权

342
00:16:43,370 --> 00:16:45,472
确保你的UI线程

343
00:16:45,539 --> 00:16:47,941
不会因为等待
较低优先级的后台线程而延迟

344
00:16:49,810 --> 00:16:50,844
那么总的来说

345
00:16:50,911 --> 00:16:54,114
这些效率低的行为
通常会出现在你应用的属性中

346
00:16:54,481 --> 00:16:57,317
仅仅通过看代码是很难发现这些问题的

347
00:16:57,818 --> 00:17:00,320
你应该在仪表系统追踪中进行观察

348
00:17:00,721 --> 00:17:02,990
形象化应用的真实行为

349
00:17:03,357 --> 00:17:05,759
以便你可以利用正确的锁定执行任务

350
00:17:06,527 --> 00:17:08,295
那么我刚才谈了

351
00:17:08,362 --> 00:17:11,231
情境切换列表中的第一个原因
也就是独占资源

352
00:17:12,566 --> 00:17:13,733
要谈

353
00:17:13,800 --> 00:17:15,935
应用可能会拥有过度情境
切换的其它方式

354
00:17:16,170 --> 00:17:18,505
让我们欢迎我的同事
Daniel Steffen上台

355
00:17:18,571 --> 00:17:22,608
跟大家谈谈如何通过GDC管理并发

356
00:17:22,675 --> 00:17:23,877
以避免这些陷阱

357
00:17:31,618 --> 00:17:33,020
好的 谢谢Daniel

358
00:17:33,086 --> 00:17:34,254
（使用GCD处理并发）

359
00:17:34,321 --> 00:17:37,090
那么我们今天要讲很多内容
所以我不会

360
00:17:37,157 --> 00:17:39,860
讲太多GCD的基本原理

361
00:17:40,394 --> 00:17:43,697
如果你刚接触这个技术
或者需要回顾一些知识

362
00:17:43,764 --> 00:17:46,567
这里有一些WWDC之前发布的演讲

363
00:17:47,034 --> 00:17:50,103
是前几年我们做的演讲
详细介绍了GCD及其改进

364
00:17:50,671 --> 00:17:52,806
那么我鼓励你查看这些视频

365
00:17:53,941 --> 00:17:56,944
我们还会涉及GCD的一些基本概念

366
00:17:57,010 --> 00:17:59,580
让我们从调度连续队列开始讲

367
00:18:00,581 --> 00:18:04,218
这真的是GCD中基本的同步基元

368
00:18:04,818 --> 00:18:07,988
它提供互斥以及FIFO排序

369
00:18:08,055 --> 00:18:11,792
这是刚才Daniel提到的其中一个
有序的和公平的基元

370
00:18:13,293 --> 00:18:15,829
它在队列运作中有一个并发原子

371
00:18:15,896 --> 00:18:17,231
所以多线程

372
00:18:17,297 --> 00:18:19,566
排队同时处理队列是没问题的

373
00:18:19,867 --> 00:18:22,536
以及系统提供的单一DQS线程

374
00:18:22,603 --> 00:18:24,671
在队列之外执行异步运作也是没问题的

375
00:18:25,405 --> 00:18:27,508
那么让我们实际看个例子

376
00:18:28,442 --> 00:18:31,778
在这里我们创建了一个串行序列
通过调用调度队列构造器

377
00:18:32,346 --> 00:18:34,448
它会给你留下一个印象

378
00:18:34,615 --> 00:18:38,051
只要你还没有用它
它就会存在于你的应用中

379
00:18:38,785 --> 00:18:39,887
现在想象一下有两个线程

380
00:18:39,953 --> 00:18:42,422
同时出现并调用queue.async方法

381
00:18:42,656 --> 00:18:44,725
来向这个队列提交一些异步任务

382
00:18:45,392 --> 00:18:47,327
我们刚提到过
它寻找能实现此功能的多线程

383
00:18:47,394 --> 00:18:50,731
而项会进入队列 以便它们能出现

384
00:18:52,299 --> 00:18:54,101
因为这是个异步方法

385
00:18:54,168 --> 00:18:58,505
这个方法会返回并且线程可以继续

386
00:18:58,572 --> 00:19:01,375
那么也许这第一个线程
最终会调用queue.sync

387
00:19:01,975 --> 00:19:03,944
这就是你与队列同步交互的方式

388
00:19:04,311 --> 00:19:06,180
因为这是个有序基元

389
00:19:06,246 --> 00:19:08,982
它的作用是它将作为
队列中的一个队列占位符

390
00:19:09,550 --> 00:19:13,487
以便线程可以等待直到轮到它

391
00:19:14,555 --> 00:19:18,759
现在有了这个自动辅助线程

392
00:19:19,092 --> 00:19:21,195
它可以执行异步工作

393
00:19:21,261 --> 00:19:23,664
直到你排到那个占位符那儿

394
00:19:23,730 --> 00:19:25,966
那时候队列的所有者将会转交给线程

395
00:19:26,033 --> 00:19:29,069
在queue.sync中等待
以便可以执行自己的代码块

396
00:19:31,238 --> 00:19:34,875
那么下一个概念是调度源

397
00:19:35,042 --> 00:19:37,411
这是GCD中的事件监控基元

398
00:19:37,778 --> 00:19:38,979
在这里我们设置了一个

399
00:19:39,313 --> 00:19:41,348
用于监控一个默认基元的可读性

400
00:19:41,682 --> 00:19:43,450
如果你有读取资源构造器的话

401
00:19:44,251 --> 00:19:46,987
你在队列中传递它 就是源的目标队列

402
00:19:47,321 --> 00:19:50,123
也是我们执行源的事件处理的地方

403
00:19:50,457 --> 00:19:52,259
在这里只需要从默认描述符中读取

404
00:19:53,026 --> 00:19:55,162
这个目标队列还是你可能会放置

405
00:19:55,229 --> 00:19:57,531
应该与这个运作
一起序列化的任务的地方

406
00:19:57,598 --> 00:19:59,600
比如处理所读取的数据

407
00:20:00,667 --> 00:20:02,736
那么我们给源设置了取消处理器

408
00:20:02,936 --> 00:20:06,340
是源如何将它们
实施为无效模式的方式

409
00:20:07,040 --> 00:20:08,375
最终当一切都设置好之后

410
00:20:08,442 --> 00:20:10,577
你需要调用源并激活以开始监控

411
00:20:11,645 --> 00:20:14,047
那么值得注意的是源只是

412
00:20:14,348 --> 00:20:17,518
OS中一个更通用的模式的实例

413
00:20:17,684 --> 00:20:21,655
其中包括可以按照你指定的目标队列
向你提交事件的对象

414
00:20:22,055 --> 00:20:23,590
那么如果你熟悉XPC

415
00:20:23,657 --> 00:20:26,660
那可以作为
那个XPC连接的另一个例子

416
00:20:27,995 --> 00:20:31,298
并且值得注意的是我们今天
告诉你们的与源有关的全部内容

417
00:20:31,365 --> 00:20:34,334
一般来说都可以应用到全部这种对象上

418
00:20:36,270 --> 00:20:38,305
那么把这两个概念结合到一起

419
00:20:38,372 --> 00:20:40,607
我们就得到了一个目标队列等级

420
00:20:44,945 --> 00:20:47,581
那么在这里我们有两个源
及其相关联的目标队列

421
00:20:47,648 --> 00:20:50,651
S1、S2 队列是Q1和Q2

422
00:20:50,884 --> 00:20:53,187
我们构造一个小的树形结构
解决这种情况

423
00:20:53,253 --> 00:20:55,155
通过添加另一个连续队列

424
00:20:55,455 --> 00:20:58,692
通过在底部添加互斥队列EQ

425
00:20:59,326 --> 00:21:02,462
我们的实现方式是通过把可选目标参数

426
00:21:02,529 --> 00:21:04,164
传给调度队列构造器

427
00:21:05,232 --> 00:21:09,102
那么这就为整个树形结构
提供了一个共享单一互斥情境

428
00:21:09,503 --> 00:21:13,807
每次只能执行其中一个源
或队列中的一项

429
00:21:14,441 --> 00:21:17,277
但它为队列1和队列2

430
00:21:17,344 --> 00:21:18,679
保持了独立的单项队列顺序

431
00:21:19,179 --> 00:21:20,914
那么让我们具体来看看我所表达的意思

432
00:21:22,649 --> 00:21:24,952
在这里我有两个队列
队列1和队列2

433
00:21:25,018 --> 00:21:27,354
它们以指定顺序排列

434
00:21:27,754 --> 00:21:30,090
因为我们底部有这个额外的连续队列

435
00:21:30,157 --> 00:21:33,260
还有执行 那么它们将在EQ中执行

436
00:21:33,627 --> 00:21:35,996
并且会有一个单一辅助线程执行这些

437
00:21:36,063 --> 00:21:39,900
为你提供互斥属性的项
每次只能执行一项

438
00:21:40,167 --> 00:21:43,504
但正如你所看到的
两个队列中的项可以穿插执行

439
00:21:43,904 --> 00:21:47,040
并保留各自在原始队列中的顺序

440
00:21:49,443 --> 00:21:54,114
那么我们今天涉及到的最后一个
概念就是服务质量

441
00:21:55,282 --> 00:21:58,752
这其实是以前详细谈过的一个概念

442
00:21:58,819 --> 00:22:03,857
尤其是在2014年的能力性能
和诊断演讲上

443
00:22:04,224 --> 00:22:07,661
那么如果这对于你来说不熟悉
我建议你参看那场演讲的资料

444
00:22:08,462 --> 00:22:11,565
但我们今天要讲的主要是

445
00:22:11,832 --> 00:22:13,534
优先级的抽象概念

446
00:22:14,701 --> 00:22:17,137
我们会用到术语QOS和优先级

447
00:22:17,204 --> 00:22:20,140
在接下来的演讲中会交替出现

448
00:22:21,275 --> 00:22:23,677
我们的系统上的服务级别有四种质量

449
00:22:23,744 --> 00:22:26,380
最高的是用户交互性UI、

450
00:22:26,547 --> 00:22:32,953
到用户发起（或IN）、效用（UT）
到后台（BG） 最低优先级

451
00:22:33,954 --> 00:22:37,424
那么让我们看看要如何结合服务质量

452
00:22:37,491 --> 00:22:39,826
通过我们刚看过的目标队列等级

453
00:22:40,294 --> 00:22:42,095
在这个等级中 树结构中的每个节点

454
00:22:42,162 --> 00:22:44,998
其实都可以有一个与之
相关联的服务标签质量

455
00:22:45,732 --> 00:22:48,802
那么比如说源2可能与用户界面相关

456
00:22:49,102 --> 00:22:50,437
它可能会针对事件被监控

457
00:22:50,504 --> 00:22:52,906
一旦触发事件
我们就应该更新它们的UI

458
00:22:52,973 --> 00:22:57,044
那么有可能我们想把这个UI标签
放到源上

459
00:22:57,911 --> 00:22:59,646
另一个常见的用例是

460
00:22:59,913 --> 00:23:04,451
把标签放在互斥队列中
以提供一系列的执行

461
00:23:04,618 --> 00:23:08,722
从而树形结构中的全部都能在这个
等级下执行 那么本例中就是UT

462
00:23:10,357 --> 00:23:14,261
现在如果这个队列中的任意其它项
被触发 比如源1

463
00:23:14,528 --> 00:23:17,331
我们将使用这个属性结构的等级

464
00:23:17,397 --> 00:23:19,700
如果它没有
与自己相关联的服务质量的话

465
00:23:21,435 --> 00:23:26,673
源触发其实就像
从内核中执行的异步运作

466
00:23:26,874 --> 00:23:29,910
在发生之前也一样
我们会排在源处理器队列的最后

467
00:23:30,143 --> 00:23:32,679
最终进入互斥队列执行

468
00:23:34,181 --> 00:23:37,184
对于用户空间的异步运作
你的服务质量

469
00:23:37,251 --> 00:23:39,753
通常是由那个
叫作queue.async的线程决定的

470
00:23:40,120 --> 00:23:44,625
现在我们有一个用户发起的线程
把项提交

471
00:23:44,691 --> 00:23:47,661
到队列中 并最终执行到E队列中

472
00:23:48,295 --> 00:23:50,531
现在也许我们有源2

473
00:23:50,597 --> 00:23:53,634
与这个高优先级的UI相关事件一起

474
00:23:53,700 --> 00:23:57,204
源2执行其事件处理器
并把它的事件处理器排到了EQ中

475
00:23:58,205 --> 00:24:01,575
那么现在你会注意到我们
处于优先级倒置的情况中

476
00:24:01,642 --> 00:24:04,778
我们的队列中有三个项
最后一个项的优先级很高

477
00:24:04,945 --> 00:24:08,849
前边是一些低优先级项
并且必须要按顺序执行

478
00:24:09,616 --> 00:24:12,819
系统为你解决了这种倒置
通过一个拉动一个

479
00:24:13,120 --> 00:24:16,690
比当前队列中所有项都高的
最高优先级辅助线程

480
00:24:17,891 --> 00:24:20,827
我们一定要记住右边的这个树形图

481
00:24:20,894 --> 00:24:23,130
因为稍后它会再次出现

482
00:24:26,934 --> 00:24:29,837
让我们继续我们的主话题

483
00:24:29,903 --> 00:24:34,174
即如何使用我们刚学到的知识
来向GCD表达优良的并发间隔

484
00:24:35,943 --> 00:24:38,579
让我们返回去看Daniel
刚刚介绍过的新闻应用

485
00:24:38,745 --> 00:24:41,381
稍微多关注一点联网子系统

486
00:24:43,016 --> 00:24:45,719
在联网子系统中 你必须监控

487
00:24:45,786 --> 00:24:47,421
内核中的一些网络连接

488
00:24:47,921 --> 00:24:49,957
有了GCD 你可以用调度源

489
00:24:50,023 --> 00:24:51,859
和调度队列实现
就像你刚看到的那样

490
00:24:52,192 --> 00:24:54,161
但当然了在任何网络子系统中

491
00:24:54,228 --> 00:24:57,097
你通常不仅仅有一个网络连接
你会有许多网络连接

492
00:24:57,698 --> 00:24:59,867
它们会复制同样的设置

493
00:25:00,701 --> 00:25:03,871
那么让我们主要关注右边的这三个连接

494
00:25:04,037 --> 00:25:05,472
看看它们是如何执行的

495
00:25:06,940 --> 00:25:08,509
如果触发了第一个连接

496
00:25:08,809 --> 00:25:10,978
跟我们刚看到的一样

497
00:25:11,044 --> 00:25:14,581
我们会排在那个源的事件处理器的最后
并将其排入目标队列

498
00:25:15,115 --> 00:25:17,651
当然如果同时触发了其它两个连接

499
00:25:17,718 --> 00:25:19,786
它们仍会复制
然后你将结束这三个队列

500
00:25:20,020 --> 00:25:21,288
而事件处理器排在最后

501
00:25:22,022 --> 00:25:25,259
因为你在底部有这三个独立的连续队列

502
00:25:25,425 --> 00:25:27,160
你其实已经请求系统给你提供

503
00:25:27,227 --> 00:25:29,196
三个独立的并发情境

504
00:25:29,663 --> 00:25:33,200
如果全部三个同时被激活
系统将强制创建

505
00:25:33,367 --> 00:25:35,502
三个线程用于执行时间处理器

506
00:25:36,603 --> 00:25:39,740
现在这也许就是你想要的
也许正是你所要追寻的效果

507
00:25:40,140 --> 00:25:45,012
但常见的情况是这些事件处理器很小
而且只能

508
00:25:45,078 --> 00:25:48,115
从网络中读取一些数据
并把它排入一个常见的数据结构中

509
00:25:48,682 --> 00:25:51,552
此外正如我们之前所看到的
你并不只是有三个连接

510
00:25:51,618 --> 00:25:53,153
你可能有很多很多连接

511
00:25:53,220 --> 00:25:56,323
如果你的子系统中有许多网络连接的话

512
00:25:57,157 --> 00:25:59,860
那么这可能会导致这种

513
00:26:00,027 --> 00:26:03,463
情境切换模式的出现
就是Daniel刚谈过的过度的情境切换

514
00:26:03,530 --> 00:26:05,432
就是你执行少量工作

515
00:26:05,499 --> 00:26:08,569
情境切换到另一个线程
再执行少量工作 如此反复

516
00:26:09,436 --> 00:26:12,706
那么我们该如何改善
这个例子中的这种情况呢？

517
00:26:13,273 --> 00:26:17,044
我们可以应用我们刚谈到的那个
单一互斥情境的概念

518
00:26:17,444 --> 00:26:20,414
只需要在底部放一个额外的连续队列

519
00:26:20,480 --> 00:26:24,718
并形成一个等级即可 你可以获得

520
00:26:24,785 --> 00:26:26,253
全部这些连接的单一互斥情境

521
00:26:26,720 --> 00:26:29,823
如果它们同时被触发
将会发生跟以前一模一样的情况

522
00:26:29,890 --> 00:26:32,426
事件处理器将会排在目标队列的最后

523
00:26:32,492 --> 00:26:34,995
但因为底部有了这个额外的连续队列

524
00:26:35,062 --> 00:26:37,264
它是单一线程
它会按顺序执行这些事件处理器

525
00:26:37,331 --> 00:26:40,200
而不是由我们之前的那个多线程来执行

526
00:26:41,134 --> 00:26:45,205
那么看起来像是个非常简单的修改
但这种修改却

527
00:26:45,272 --> 00:26:48,709
将我们自己某些代码的性能
提升了1.3倍

528
00:26:49,009 --> 00:26:51,712
正如Daniel之前提到过的一样

529
00:26:55,516 --> 00:26:59,186
那么这是如何避免问题模式的一个例子

530
00:26:59,253 --> 00:27:01,522
关于在独立运作之间反复切换的问题

531
00:27:02,422 --> 00:27:05,025
但它却归入了一个通用标题
叫作在应用中避免

532
00:27:05,092 --> 00:27:08,028
多余的和不受控制的并发

533
00:27:09,329 --> 00:27:13,100
解决办法之一就是同时激活许多队列

534
00:27:13,367 --> 00:27:14,568
其中一个例子是

535
00:27:14,635 --> 00:27:17,971
我们刚才看到的那个需要独立的源模式

536
00:27:18,038 --> 00:27:21,275
如果你有独立或对象队列也可以解决

537
00:27:21,542 --> 00:27:24,178
如果你的应用中许多对象
都有自己的连续队列

538
00:27:24,244 --> 00:27:26,747
并且你同时给赋予它们异步运作

539
00:27:26,813 --> 00:27:29,216
你就可以得到一模一样的效果

540
00:27:31,018 --> 00:27:33,453
如果你有许多工作项

541
00:27:33,520 --> 00:27:35,656
同时提交到全局并发队列 也可以解决

542
00:27:36,356 --> 00:27:38,192
特别是如果有工作项阻塞时

543
00:27:38,725 --> 00:27:42,129
全局并发队列的运作方式是
它会纠正更多的线程

544
00:27:42,396 --> 00:27:43,697
当现有线程阻塞了

545
00:27:43,764 --> 00:27:46,700
给你提供并发的持续性良好等级

546
00:27:47,034 --> 00:27:48,869
但如果这些线程再次阻塞

547
00:27:49,036 --> 00:27:51,839
你可以用一个叫作线程爆炸的东西

548
00:27:52,873 --> 00:27:54,875
在这个话题中 我们要接触到一些细节

549
00:27:54,942 --> 00:27:59,146
在2015年的“用GCD创建响应性
和高效率应用”演讲中有详细介绍

550
00:27:59,646 --> 00:28:01,515
那么如果你不熟悉这些

551
00:28:01,582 --> 00:28:03,550
我建议你参看那场演讲的视频

552
00:28:04,785 --> 00:28:06,787
那么如何选择适当数量的并发

553
00:28:06,854 --> 00:28:09,489
以避免这些问题模式呢？

554
00:28:10,290 --> 00:28:12,326
以前我们推荐给你的一个方法是

555
00:28:12,392 --> 00:28:14,661
给子系统使用一个队列

556
00:28:16,129 --> 00:28:17,898
那么返回到我们的新闻应用

557
00:28:17,965 --> 00:28:20,567
我们用户界面已经有了一个队列
就是主队列

558
00:28:20,634 --> 00:28:23,103
我们可以给网络连接选择一个连续队列

559
00:28:23,170 --> 00:28:26,006
并另外给数据库子系统选择一个
连续队列

560
00:28:27,007 --> 00:28:29,810
但我们今天学了另一种
思考这种情况的新方式

561
00:28:29,877 --> 00:28:32,579
其实就是给每个子系统
使用一个队列等级

562
00:28:35,916 --> 00:28:38,752
这就给子系统提供了一个互斥情境

563
00:28:38,819 --> 00:28:43,223
你可以让队列中余下的事件
单独进行子构建和拥有子系统

564
00:28:43,290 --> 00:28:47,060
只把那个网络队列
或数据库队列作为目标

565
00:28:47,127 --> 00:28:49,930
就是位于队列等级底部的那个队列

566
00:28:54,735 --> 00:28:57,538
但那可能是一个太过简单的模式

567
00:28:57,604 --> 00:28:59,773
对于复杂应用或复杂子系统来说

568
00:29:00,174 --> 00:29:01,842
这里的重点是

569
00:29:02,009 --> 00:29:04,144
在应用中拥有固定数量的连续队列等级

570
00:29:04,611 --> 00:29:06,813
拥有额外队列等级对于
复杂的子系统来说很有必要

571
00:29:07,047 --> 00:29:10,217
比如第二队列等级
用于处理较慢的工作

572
00:29:10,284 --> 00:29:12,486
或较大的工作项 那么第一个队列等级

573
00:29:12,553 --> 00:29:14,821
就是主要的队列等级
可以保持子系统响应

574
00:29:14,888 --> 00:29:16,490
外面进来的请求

575
00:29:18,425 --> 00:29:21,128
这个情境中需要思考的另一个重点

576
00:29:21,428 --> 00:29:24,731
是提交给那些子系统的工作的间隔

577
00:29:25,766 --> 00:29:28,969
你想使用相当大的工作项
当你在子系统中移动

578
00:29:29,236 --> 00:29:31,972
以实现我们之前看到过的那种情况

579
00:29:32,039 --> 00:29:35,809
也就是CP有足够长的时间
执行你的子系统

580
00:29:36,143 --> 00:29:38,512
以达到一种高效的性能状态

581
00:29:39,980 --> 00:29:42,916
一旦你处于子系统内部
比如这里的网络子系统

582
00:29:43,250 --> 00:29:47,354
就有必要把子系统细分为
更小的组块项了

583
00:29:47,421 --> 00:29:51,158
并且用更精细的间隔来改善
那个子系统的响应能力

584
00:29:51,592 --> 00:29:54,661
比如你可以拆分你的工作并重新异步

585
00:29:54,728 --> 00:29:56,663
到你队列等级中的另一个队列

586
00:29:56,730 --> 00:29:58,198
那并不会导致情境切换

587
00:29:58,265 --> 00:30:00,033
因为你已经在那个子系统中了

588
00:30:03,437 --> 00:30:05,973
那么总的来说我们在这部分
学到了什么？

589
00:30:06,940 --> 00:30:10,878
我们了解了如何把队列和源
组织到连续队列等级中

590
00:30:11,245 --> 00:30:13,714
如何使用固定数量的连续队列等级

591
00:30:13,780 --> 00:30:16,216
使GCD获得一个不错的并发间隔

592
00:30:16,683 --> 00:30:20,921
以及如何合适地拆分你的工作项

593
00:30:20,988 --> 00:30:24,157
用于之前讲的并行工作
和这里的并发工作

594
00:30:24,224 --> 00:30:27,094
在子系统内以及子系统之间

595
00:30:28,028 --> 00:30:30,531
好的 我要把舞台交给Pierre

596
00:30:30,597 --> 00:30:33,100
他会深入探讨我们对GCD的改进
使其总是

597
00:30:33,166 --> 00:30:36,136
在单一线程上执行队列等级
以及如何现代化你的代码

598
00:30:36,370 --> 00:30:38,005
来利用这个改进

599
00:30:44,378 --> 00:30:45,412
谢谢Daniel

600
00:30:47,047 --> 00:30:51,618
那么的确我们今年
彻底改造了GCD的内部构件

601
00:30:51,685 --> 00:30:54,521
以剔除某些多余的情境切换

602
00:30:54,588 --> 00:30:56,657
并执行单一队列等级

603
00:30:56,723 --> 00:30:59,593
就像Daniel在单一线程上
所展示的那个例子一样

604
00:31:00,460 --> 00:31:04,598
为此我们创建了一个新概念

605
00:31:04,665 --> 00:31:07,267
我们叫作统一队列身份
让我们来实践一下

606
00:31:07,334 --> 00:31:09,403
我们会逐步带你认识它是如何工作的

607
00:31:11,471 --> 00:31:14,107
那么其实这部分内容…

608
00:31:14,708 --> 00:31:18,312
开始…将主要关注单一队列等级

609
00:31:18,378 --> 00:31:20,180
比如Daniel刚展示的那几个

610
00:31:20,514 --> 00:31:24,518
然而我们会处理一些简化的
单一队列等级 它们的顶部有源

611
00:31:24,785 --> 00:31:27,421
底部有互斥情境

612
00:31:27,487 --> 00:31:31,692
GCD内部的注释并不是为了
那部分演讲而准备的

613
00:31:34,027 --> 00:31:35,696
那么当你创建[听不清]情境时

614
00:31:35,762 --> 00:31:37,564
你通常会调度队列构造器

615
00:31:38,332 --> 00:31:41,869
那只会给你的应用留下一个印象
表明那是一个注释

616
00:31:42,302 --> 00:31:44,137
你可能要做的第一件事

617
00:31:44,304 --> 00:31:46,940
就是给它调度最近编码的项

618
00:31:48,141 --> 00:31:51,044
那么你的应用中将有代码会在这里

619
00:31:51,612 --> 00:31:54,515
并在队列中[听不清]排队

620
00:31:55,649 --> 00:31:58,352
以前当那种情况发生时
我们通常会请求

621
00:31:58,418 --> 00:32:01,455
给系统调度一个匿名线程

622
00:32:01,622 --> 00:32:04,825
并且那个匿名线程必须要做的决心

623
00:32:04,892 --> 00:32:06,927
稍后会在你应用内部发生

624
00:32:08,262 --> 00:32:12,933
在这种情况下 我们进行了修改
我们要做的是创建我们的计数器对象

625
00:32:13,100 --> 00:32:16,136
绑定到你的队列的统一队列身份

626
00:32:16,336 --> 00:32:19,173
恰好要在内核中代表你的队列

627
00:32:20,073 --> 00:32:22,676
我们可以给那个对象绑定
执行工作所需要的等级

628
00:32:22,743 --> 00:32:24,678
那么在这里就是备份

629
00:32:25,746 --> 00:32:28,182
那会导致系统请求线程

630
00:32:28,849 --> 00:32:32,386
线程请求 就是幻灯片上的虚线

631
00:32:32,586 --> 00:32:36,990
有时可能不会实现
因为这里有一个后台线程

632
00:32:37,224 --> 00:32:38,692
也许系统已加载了足够多

633
00:32:38,759 --> 00:32:41,195
甚至不值得再提供给你一个线程

634
00:32:43,897 --> 00:32:45,933
稍后你应用的其它路径

635
00:32:46,099 --> 00:32:49,269
可能实际上会尝试让更多工作排队

636
00:32:49,336 --> 00:32:52,472
这里有一个UT[听不清]项
优先级稍高

637
00:32:54,007 --> 00:32:57,845
我们可以使用队列身份
内核中的统一身份

638
00:32:57,911 --> 00:32:59,279
来查看和解决优先级倒置问题

639
00:32:59,346 --> 00:33:01,381
并利用那个线程请求的优先级

640
00:33:01,915 --> 00:33:05,586
也许那就是系统所需要的小的推进

641
00:33:05,652 --> 00:33:07,421
要在此给你一个线程来执行你的工作

642
00:33:08,021 --> 00:33:11,525
但这个线程是排程器中的队列
目前并不是听候调用 也不会执行

643
00:33:11,925 --> 00:33:14,962
原因是你的应用中有另一个线程

644
00:33:15,028 --> 00:33:17,464
与队列交互并同步工作

645
00:33:17,531 --> 00:33:19,733
以较高的优先级 甚至通常会被遮住

646
00:33:21,768 --> 00:33:24,538
现在我们有了那个统一队列身份
我们实际上可以

647
00:33:24,738 --> 00:33:27,674
因为那个线程必须阻塞占位符的排队

648
00:33:27,741 --> 00:33:33,547
这是Daniel之前刚跟你们谈过的
我们可以阻塞

649
00:33:33,614 --> 00:33:35,649
那个线程在统一队列身份上的同步执行

650
00:33:35,716 --> 00:33:37,651
对于异步工作我们采取了同样的方式

651
00:33:37,718 --> 00:33:39,319
[听不清]

652
00:33:39,486 --> 00:33:41,822
但现在我们以单一身份
统一了队列的异步

653
00:33:41,889 --> 00:33:45,459
和同步部分

654
00:33:45,626 --> 00:33:48,962
我们可以应用一个优化 并直接切换

655
00:33:49,029 --> 00:33:51,865
阻塞你通过排程器队列的线程

656
00:33:51,932 --> 00:33:55,002
并注册队列延迟 就是Daniel在最开始

657
00:33:55,068 --> 00:33:57,237
讲到排程器时跟大家介绍的

658
00:33:58,105 --> 00:34:00,073
那么这就是统一队列身份

659
00:34:00,140 --> 00:34:02,910
处理异步和同步工作项的方式

660
00:34:05,412 --> 00:34:09,049
现在我们如何把它用在事件上？
为什么有用呢？

661
00:34:09,850 --> 00:34:12,886
那么这是我们一直在用的小树形图

662
00:34:13,320 --> 00:34:16,056
让我们看看这些源的创建

663
00:34:17,357 --> 00:34:20,092
当你用makeResource工厂按钮
创建源时

664
00:34:20,726 --> 00:34:24,031
你就设置了一堆事件
分别有适当的处理器和属性

665
00:34:24,464 --> 00:34:27,634
但有意思的是当你激活对象时
会发生什么

666
00:34:29,770 --> 00:34:34,641
就在那时我们才意识到
那个效用就是QOS

667
00:34:34,708 --> 00:34:37,277
你的源将在那个QOS上
一直执行处理器

668
00:34:37,511 --> 00:34:39,545
因为它是从你的队列等级中继承来的

669
00:34:40,112 --> 00:34:43,217
我们现在还知道通过新系统

670
00:34:43,449 --> 00:34:46,286
处理器最终会

671
00:34:46,353 --> 00:34:49,922
在队列执行互斥情境中执行

672
00:34:50,824 --> 00:34:53,726
现在将会在前端注册源

673
00:34:53,793 --> 00:34:57,531
通过我稍早之前谈到过的同步统一身份

674
00:34:59,600 --> 00:35:04,638
如果我们看一下树形图上
较高等级的UI QOS源

675
00:35:05,138 --> 00:35:08,308
我们的创建方式与第一个十分相似

676
00:35:08,809 --> 00:35:11,044
除了当你设置处理器时

677
00:35:11,111 --> 00:35:14,414
要指定你想要的QOS

678
00:35:15,382 --> 00:35:18,085
有意思的是在激活状态时
所发生的情况

679
00:35:18,151 --> 00:35:20,187
这是我们在快照中时

680
00:35:20,354 --> 00:35:24,157
和以前一样 当我们从你的等级
获取统一QOS之后

681
00:35:24,424 --> 00:35:26,126
在这里我们从你的暗示中获取它

682
00:35:26,793 --> 00:35:30,030
我们回想一下 它们将在

683
00:35:30,097 --> 00:35:31,765
同一个执行情境中执行两个源

684
00:35:31,832 --> 00:35:34,468
并将第二个源再次注册到最前面

685
00:35:34,635 --> 00:35:36,770
第二个源在内核中有统一身份

686
00:35:39,506 --> 00:35:45,045
那么我们尝试要做的是
通过非常复杂的身份解决

687
00:35:45,279 --> 00:35:49,016
的是一个我们在OS之前的阶段
存在的一个问题

688
00:35:49,216 --> 00:35:53,453
相关运作会脱离老线程

689
00:35:53,620 --> 00:35:55,355
让我们看看它通常是如何运作的

690
00:35:56,089 --> 00:35:59,159
那么请记住这是我们的队列等级

691
00:36:00,394 --> 00:36:01,929
让我们打开你在本次演讲中

692
00:36:01,995 --> 00:36:05,132
多次看到过的时间轴

693
00:36:05,632 --> 00:36:08,402
顶部是CPU 但现在有一个新追踪

694
00:36:08,468 --> 00:36:12,439
执行队列卡将表示

695
00:36:12,506 --> 00:36:14,608
在任意时刻该队列上正在执行什么

696
00:36:16,109 --> 00:36:18,712
那么这是运行时间真正的运作方式

697
00:36:18,779 --> 00:36:22,349
在我们进入macOS Sierra
和iOS 10之前的阶段

698
00:36:23,016 --> 00:36:25,953
那么让我们看看如果第一个源
失败了会发生什么

699
00:36:26,620 --> 00:36:29,323
正如我所说的 之前线程请求是异步的

700
00:36:29,389 --> 00:36:32,459
我们会请求一个异步线程
在线程上提交事件

701
00:36:32,626 --> 00:36:34,127
然后我们会查看事件

702
00:36:35,395 --> 00:36:38,031
当我们在应用内查看事件时

703
00:36:38,098 --> 00:36:42,536
我们才会意识到这个事件
必须要在队列上运行

704
00:36:42,603 --> 00:36:44,271
然后我们会在让事件处理器排队

705
00:36:46,039 --> 00:36:47,574
但因为队列是未经声明的队列

706
00:36:47,641 --> 00:36:50,511
线程实际上可以变成那个队列

707
00:36:50,577 --> 00:36:53,680
并开始为那个源执行指定的处理器

708
00:36:54,314 --> 00:36:55,249
我们会这么做

709
00:36:55,849 --> 00:36:57,551
现在有意思的是

710
00:36:57,618 --> 00:36:59,887
当触发优先级较高的第二个源时
会怎么样？

711
00:37:00,721 --> 00:37:01,622
实际上情况一模一样

712
00:37:02,122 --> 00:37:03,724
因为它在这里是一个等级QOS

713
00:37:03,891 --> 00:37:06,226
优先级较高 这就是你现在正在执行的

714
00:37:07,427 --> 00:37:09,396
我们会打开一个新的异步线程

715
00:37:09,463 --> 00:37:11,431
在线程上提交那个优先级较高的事件

716
00:37:13,200 --> 00:37:14,968
并查看那个事件是什么意思

717
00:37:15,035 --> 00:37:18,105
直到那时我们才注意到
那是同一个一模一样的队列等级

718
00:37:18,172 --> 00:37:20,941
然后把处理器排在我们
预先占用的处理器之后

719
00:37:21,608 --> 00:37:24,178
正如你所看到的
我们关闭了第一个情境切换

720
00:37:24,711 --> 00:37:26,547
就是那个优先级较高的事件的情境

721
00:37:27,147 --> 00:37:30,017
但我们不能促进进展
因为跟第一次不同

722
00:37:30,083 --> 00:37:31,952
第二个线程不能接受

723
00:37:32,019 --> 00:37:33,887
已经与某个线程相关联的队列

724
00:37:33,954 --> 00:37:34,922
我们不能接受它

725
00:37:35,489 --> 00:37:36,456
那么线程就结束了

726
00:37:36,523 --> 00:37:40,227
正如Daniel所阐述过的
这就是你再次切换情境的原因之一

727
00:37:40,761 --> 00:37:43,030
这是我们所做的工作
我们把情境切换回第一个线程

728
00:37:43,096 --> 00:37:44,831
就是实际上取得进展的那个

729
00:37:44,898 --> 00:37:48,869
我们执行第一个处理器余下的部分
并最终执行第二个处理器

730
00:37:50,504 --> 00:37:51,738
那么正如你所看到的

731
00:37:51,805 --> 00:37:54,208
我们使用两个线程和两次情境切换

732
00:37:54,274 --> 00:37:57,110
你实际上不想针对一个
单一执行情境这样做

733
00:37:58,679 --> 00:38:04,818
我们在macOS High Sierra和iOS 11中
用统一身份修复了那个问题

734
00:38:05,819 --> 00:38:07,154
我们摆脱了那个线程

735
00:38:08,622 --> 00:38:09,523
[听不清]

736
00:38:10,157 --> 00:38:15,262
当然了 我们还摆脱了
以前的那两次情境切换

737
00:38:15,329 --> 00:38:16,663
那是多余的

738
00:38:17,664 --> 00:38:19,299
这当然很重要 因为

739
00:38:19,733 --> 00:38:22,069
跟Daniel通过那个触摸事件给你展示

740
00:38:22,135 --> 00:38:25,539
占先及优先级时所发生的不一样

741
00:38:26,106 --> 00:38:30,344
我们可以利用
我们实际有两个线程的事实

742
00:38:30,410 --> 00:38:33,347
相对独立并且响应性更强

743
00:38:33,614 --> 00:38:36,283
在这里我们没有从任何情境切换中受益

744
00:38:36,550 --> 00:38:41,054
因为这些事件处理器
不管怎样S1和M2必须得按顺序执行

745
00:38:41,121 --> 00:38:43,490
那么提前知道那个事件
并不会有什么帮助

746
00:38:44,858 --> 00:38:48,695
如果你看一下…今天的流程

747
00:38:48,762 --> 00:38:49,963
看起来更应该是这样的

748
00:38:52,199 --> 00:38:53,500
这里发生了什么？

749
00:38:55,202 --> 00:38:57,104
那个流程中最重要的事

750
00:38:57,171 --> 00:39:00,307
就是现在如果你查看线程 它叫作EQ

751
00:39:00,374 --> 00:39:02,442
因为它是统一身份的一个部分

752
00:39:02,509 --> 00:39:04,978
线程和EQ从根本上说是同一个对象

753
00:39:05,312 --> 00:39:08,182
而内核知道它其实正在执行队列

754
00:39:08,248 --> 00:39:10,851
在CPU标签上反映出来了
你再也看不到事件了

755
00:39:10,918 --> 00:39:12,286
那就会运行你的队列

756
00:39:14,488 --> 00:39:19,393
然而你可能会问
我们该如何设法提交事件呢

757
00:39:19,459 --> 00:39:21,795
提交第二个事件而不需要帮手

758
00:39:21,862 --> 00:39:23,363
这是个好问题

759
00:39:25,432 --> 00:39:28,702
当事件被触发时
现在我们知道它会在哪儿执行

760
00:39:28,769 --> 00:39:29,937
你会在哪儿处理它

761
00:39:30,337 --> 00:39:31,672
我们只需要标记线程

762
00:39:32,472 --> 00:39:33,407
不需要帮手

763
00:39:34,241 --> 00:39:38,278
在第一个可能的时间

764
00:39:38,979 --> 00:39:42,349
我们就会注意到那个线程被你标记了
有待定的事件

765
00:39:42,950 --> 00:39:45,652
当我们让事件出列时需要隐藏时间

766
00:39:46,153 --> 00:39:48,255
藏在第一个处理器结束之后

767
00:39:48,689 --> 00:39:51,191
我们可以从内核中获取事件并查看

768
00:39:51,258 --> 00:39:53,827
然后把它们的处理器
排在你的等级队列中

769
00:39:55,829 --> 00:39:59,032
那么我们为什么
要给出这么复杂的解释呢？

770
00:39:59,867 --> 00:40:01,301
原因是你

771
00:40:01,635 --> 00:40:06,573
这样可以理解如何最好地利用
运行时间行为 因为很清楚

772
00:40:06,640 --> 00:40:09,843
运行时间使用了
你提供给我们的每一个可能的暗示

773
00:40:09,910 --> 00:40:12,012
在你的应用中优化行为

774
00:40:13,213 --> 00:40:15,482
并且进入按钮知道如何暗示

775
00:40:15,549 --> 00:40:19,887
以及何时正确地暗示运行时间
因此我们就做除了正确的决策

776
00:40:21,955 --> 00:40:25,993
这就导致我今天跟大家讲
你们应该如何处理现有代码基

777
00:40:26,059 --> 00:40:29,997
以最大限度地利用
我们重新创建的内核技术

778
00:40:33,166 --> 00:40:35,369
现在实际上只需要两个步骤

779
00:40:35,802 --> 00:40:38,872
就可以充分利用那个技术了

780
00:40:38,939 --> 00:40:42,142
第一个步骤是在激活后没有变化

781
00:40:42,676 --> 00:40:45,279
第二个步骤是特别关注

782
00:40:45,345 --> 00:40:48,115
目标队列等级

783
00:40:49,116 --> 00:40:50,117
那么这是什么意思？

784
00:40:51,251 --> 00:40:53,887
没有变化越过激活其实是说

785
00:40:53,954 --> 00:40:57,724
当你在调度对象上有任意属性时
你可以发送它们

786
00:40:57,791 --> 00:41:01,161
一旦你激活对象
你就应该停止改变它们

787
00:41:01,628 --> 00:41:02,796
第二个例子

788
00:41:04,398 --> 00:41:07,634
这是我们在本场演讲中
看到过多次的源

789
00:41:08,335 --> 00:41:10,671
那个[听不清]能力

790
00:41:11,772 --> 00:41:14,074
并且你会设置一堆属性、处理器；

791
00:41:14,141 --> 00:41:17,544
事件处理器、同意处理器
你可能还有注册处理器

792
00:41:18,178 --> 00:41:21,481
你甚至可以修改几次 这没问题
你可以改变主意

793
00:41:22,983 --> 00:41:24,351
当你激活源时

794
00:41:26,353 --> 00:41:29,556
这里的联系是你应该停止改变你的对象

795
00:41:30,257 --> 00:41:31,391
诱惑力很大

796
00:41:31,692 --> 00:41:34,294
事后 比如说修改源的目标队列

797
00:41:34,361 --> 00:41:35,462
那将会导致问题

798
00:41:35,796 --> 00:41:38,732
原因就是我早些时候所展示过的

799
00:41:38,799 --> 00:41:42,603
在激活时
我们会给你对象的属性生成快照

800
00:41:42,669 --> 00:41:45,606
将来我们将按照那个快照做出决策

801
00:41:46,907 --> 00:41:50,377
如果你在事后修改了目标队列等级

802
00:41:50,444 --> 00:41:53,447
它会阻碍那个快照 使其失效

803
00:41:53,514 --> 00:41:56,250
那将会导致一些列非常重要的优化失败

804
00:41:56,316 --> 00:41:59,653
比如优先级倒置避免[听不清]GCD

805
00:41:59,720 --> 00:42:02,556
我之前展示的

806
00:42:02,623 --> 00:42:04,024
同步调度的直接切换

807
00:42:04,091 --> 00:42:08,061
这些都是我们刚刚看过的防御型
和可交付的优化

808
00:42:10,564 --> 00:42:11,398
我会坚持

809
00:42:11,465 --> 00:42:14,635
Daniel之前的观点

810
00:42:15,235 --> 00:42:19,139
就是你们中有许多人可能从来不需要
在你们的应用中创建一个调度源

811
00:42:19,206 --> 00:42:21,408
这没问题 这就是它的运作方式

812
00:42:22,242 --> 00:42:26,413
你实际上很可能在系统框架中
大量使用它们

813
00:42:26,480 --> 00:42:30,484
每次你有框架时 你就会调度队列
因为

814
00:42:30,551 --> 00:42:34,655
它们会以你的名义在队列上
异步处理一些通知

815
00:42:34,721 --> 00:42:36,890
在底层 它们拥有其中一个源

816
00:42:37,224 --> 00:42:40,694
那么如果你修改了系统的假设
你实际上也会打断

817
00:42:41,562 --> 00:42:43,463
全部这些

818
00:42:43,530 --> 00:42:44,364
优化

819
00:42:46,533 --> 00:42:50,804
那么我希望很清楚地表达了一点
把你的等级作为目标

820
00:42:50,871 --> 00:42:53,373
非常重要 你必须保护它

821
00:42:54,641 --> 00:42:57,511
这是什么意思？需要怎么做？

822
00:42:58,745 --> 00:43:00,848
第一种方式是一个很简单的建议

823
00:43:00,914 --> 00:43:02,583
就是当你创建等级时

824
00:43:03,250 --> 00:43:06,186
从底部开始往顶部创建

825
00:43:07,487 --> 00:43:11,959
当你看到幻灯片上的这个树形图
创建好之后 正如你所看到的

826
00:43:12,025 --> 00:43:15,529
那儿有一些很宽的窟窿
那就是你的目标队列关系

827
00:43:15,762 --> 00:43:18,398
如果你按那个顺序创建
哪个也不会被改变

828
00:43:20,467 --> 00:43:21,368
然而

829
00:43:21,435 --> 00:43:25,005
当你有一个很大的应用或当你隐藏框架

830
00:43:25,072 --> 00:43:28,242
并把其中一个队列传给

831
00:43:29,209 --> 00:43:33,881
你们公司的另一个团队时
你可能更希望得到较多的保证

832
00:43:34,248 --> 00:43:36,083
你可能想锁定这些关系

833
00:43:36,149 --> 00:43:38,619
以便没有任何人可以在事后改变它们

834
00:43:40,787 --> 00:43:42,389
实际上你可以

835
00:43:42,456 --> 00:43:45,359
通过我们的一种叫作
设置队列等级的技术实现

836
00:43:45,425 --> 00:43:49,730
我们去年引入了这种技术
实际上如果你正在使用Swift 3

837
00:43:49,796 --> 00:43:51,164
你就可以停下来听我讲

838
00:43:51,231 --> 00:43:54,067
因为你已经在那种形式中了
那是你正在生存的唯一的世界

839
00:43:55,602 --> 00:43:58,939
然而如果你有一个现有的基于云的应用
或你用的是Swift的较老版本

840
00:43:59,006 --> 00:44:02,609
你需要一些额外的步骤

841
00:44:05,812 --> 00:44:08,815
那么让我们重点看一下
Q1和EQ之间的关系

842
00:44:09,783 --> 00:44:15,022
当你用Objective-C创建时
你的代码很可能会是这样的

843
00:44:15,422 --> 00:44:18,158
你创建你的队列 然后第二步

844
00:44:18,225 --> 00:44:21,528
把Q1的目标队列设置为EQ

845
00:44:22,162 --> 00:44:24,498
这并不会保护你的队列等级

846
00:44:24,565 --> 00:44:27,467
任何人都可以再次调用调度目标队列

847
00:44:27,534 --> 00:44:28,836
并打乱你的全部假设

848
00:44:29,069 --> 00:44:30,137
这可不妙

849
00:44:30,904 --> 00:44:32,940
有一个简单的步骤可以

850
00:44:33,006 --> 00:44:34,908
修复那段代码让它变得安全

851
00:44:35,309 --> 00:44:38,612
就是采用我们去年引入的一个新API

852
00:44:38,679 --> 00:44:40,981
即用调度目标队列的创建

853
00:44:41,048 --> 00:44:43,283
这是一个单一的自动化步骤

854
00:44:43,350 --> 00:44:48,121
将创建队列
设置队列等级高度并保护它

855
00:44:49,823 --> 00:44:51,491
就是这样 这就是这两个步骤

856
00:44:51,558 --> 00:44:53,427
通过这两个步骤你可以

857
00:44:53,493 --> 00:44:55,395
很好地[听不清] 非常简单

858
00:44:56,897 --> 00:45:01,535
另外 与Daniel刚才给你们演示的
那个突变的例子有点类似

859
00:45:01,835 --> 00:45:04,671
寻找何时做出了错误的决定

860
00:45:04,738 --> 00:45:07,574
非常具有挑战性
尤其是在大的基于云的应用上

861
00:45:07,641 --> 00:45:11,445
我们发现在现有的基于云的应用中
检验全部代码是非常困难的

862
00:45:12,346 --> 00:45:16,450
这也就是我们为什么
创建一个新GCD性能仪表工具

863
00:45:16,517 --> 00:45:19,419
来寻找现有应用中的问题点的原因

864
00:45:19,987 --> 00:45:22,523
我将把舞台交换给Daniel
他会给你们做演示

865
00:45:29,363 --> 00:45:30,197
谢谢Pierre

866
00:45:31,665 --> 00:45:32,766
好的 让我们开始吧

867
00:45:32,833 --> 00:45:35,969
请注意我们即将看到的这个
GCD性能仪表

868
00:45:36,036 --> 00:45:38,672
目前Xcode 9中还没有

869
00:45:38,739 --> 00:45:42,176
但你们很快就能用了
我们即将发布Xcode 9的种子

870
00:45:43,277 --> 00:45:44,244
那么对于这个演示

871
00:45:44,311 --> 00:45:47,714
让我们具体分析一下
我们的示例新闻应用的执行

872
00:45:48,582 --> 00:45:50,584
如果你点击底部的这个
连接按钮会发生什么呢

873
00:45:50,651 --> 00:45:54,388
这个应用会向服务器
创建若干网络连接吗

874
00:45:54,454 --> 00:45:57,224
以便读取URL列表

875
00:45:57,291 --> 00:46:00,394
然后就显示在WebViews中
无论何时点击刷新按钮时

876
00:46:01,161 --> 00:46:04,565
那么让我们深入Xcode查看
我们是如何设置这些网络连接的

877
00:46:06,133 --> 00:46:10,971
那么这是Xcode中的创建连接方法

878
00:46:11,371 --> 00:46:13,140
非常简单 我们有一个循环

879
00:46:13,207 --> 00:46:16,543
也许只是创建一些套接口
并把它们连接到我们的服务器

880
00:46:17,277 --> 00:46:21,281
我们通过其中一个调度读取
源监控那个套接口的可读性

881
00:46:21,348 --> 00:46:23,450
就是我们在本场演讲中
多次见到的那个源

882
00:46:23,784 --> 00:46:25,686
在这里查看API是受信任的

883
00:46:26,553 --> 00:46:30,290
然后我们可以为那个调度源
设置事件处理器代码块

884
00:46:30,357 --> 00:46:33,227
当套接口可读时 我们就从中读取

885
00:46:33,293 --> 00:46:36,029
通过读取系统调用 直到没有可用数据

886
00:46:36,763 --> 00:46:40,567
一旦我们有了数据
我们就把它传给我们的数据库子系统

887
00:46:40,634 --> 00:46:42,569
通过这个process 0方法

888
00:46:43,670 --> 00:46:45,873
那么让我们创建并运行
并执行这个应用的系统追踪

889
00:46:45,939 --> 00:46:48,242
了解它是如何执行的

890
00:46:51,044 --> 00:46:53,413
那么我们在仪表中
在系统追踪中

891
00:46:53,480 --> 00:46:55,315
除了系统追踪中的常见追踪

892
00:46:55,382 --> 00:46:57,684
我们还添加了这个新的GCD性能仪表

893
00:46:58,085 --> 00:47:00,954
当我们点击它时
我们可以看到许多性能事件

894
00:47:01,021 --> 00:47:03,357
被报告为有性能问题

895
00:47:03,757 --> 00:47:06,159
其中一个就是这个激活事件后改变

896
00:47:06,226 --> 00:47:08,996
我们还可以看到随着时间轴
何时数量众多

897
00:47:09,329 --> 00:47:11,498
你还可以点击这里的一个事件

898
00:47:11,565 --> 00:47:13,834
比如在激活事件之后点击这个改变目标

899
00:47:14,501 --> 00:47:18,138
这个列表将会把我们直接带到那儿
如果你想获取更多详细信息

900
00:47:18,205 --> 00:47:21,642
我们可以公开仪表右侧的向后追踪

901
00:47:21,708 --> 00:47:24,745
那将会给我们显示这个事件
具体发生在你应用中的哪个位置

902
00:47:25,179 --> 00:47:28,215
那么在这里比如说是
在我们的创建连接方法中

903
00:47:29,550 --> 00:47:33,053
如果我们双击这个框架
仪表将会直接给我们显示

904
00:47:33,120 --> 00:47:34,821
问题所在的代码行

905
00:47:35,389 --> 00:47:38,959
这是几上是一个目标队列调用
是在激活事件之后发生的

906
00:47:39,426 --> 00:47:41,528
就像刚跟你说过的这个模式

907
00:47:41,795 --> 00:47:44,031
要修复这个问题
我们可以直接进入Xcode

908
00:47:44,097 --> 00:47:46,200
用在Xcode中打开文件快捷按钮
打开文件

909
00:47:47,167 --> 00:47:49,736
那么在这里
我们是在调度目标队列代码行

910
00:47:49,803 --> 00:47:53,140
的确是在这行 在事件处理器有调度源

911
00:47:53,207 --> 00:47:54,942
设置发生在激活之后

912
00:47:55,475 --> 00:47:57,678
那么在这个例子中 非常容易修复

913
00:47:57,744 --> 00:48:01,648
我们只需要把这两行往下挪
然后就修复了问题

914
00:48:01,715 --> 00:48:04,852
我们在设置源之后激活而不是之前

915
00:48:05,519 --> 00:48:07,254
那么让我们返回仪表并查看

916
00:48:07,321 --> 00:48:09,556
我们现在能在系统追踪中看到什么

917
00:48:09,857 --> 00:48:13,193
看起来跟以前一样
除了当你点击GCD性能追踪时

918
00:48:13,260 --> 00:48:16,496
你将看到没有检测到
任何严重的性能问题了

919
00:48:16,797 --> 00:48:18,765
如果你用了这个仪表
你应该会看到这个结果

920
00:48:19,566 --> 00:48:22,669
那么当然这对于这个应用来说很简单
你可能需要做一些工作

921
00:48:24,571 --> 00:48:26,840
那么让我们重点看一下
应用中的点追踪

922
00:48:26,907 --> 00:48:29,376
这会给我们显示许多网络事件处理器

923
00:48:29,810 --> 00:48:32,179
这些是我们应用中的源事件处理器

924
00:48:32,679 --> 00:48:35,015
那么你要如何设法
在仪表中显示这些呢？

925
00:48:35,616 --> 00:48:37,184
实际上理解起来很有意思

926
00:48:37,251 --> 00:48:39,720
因为这是你可以应用到
你自己的代码中的东西

927
00:48:39,786 --> 00:48:42,256
以在仪表中了解它是如何执行的

928
00:48:43,790 --> 00:48:47,060
嗯 让我们返回到Xcode
中的创建连接方法

929
00:48:47,127 --> 00:48:50,163
当我们设置源及其源事件处理器时

930
00:48:50,230 --> 00:48:53,000
我们就对那个
事件处理器的执行感兴趣了

931
00:48:53,066 --> 00:48:55,102
并尝试了解它的时间安排

932
00:48:55,502 --> 00:48:56,737
为了在仪表中看到它

933
00:48:56,803 --> 00:48:59,806
我们增加了
kdebug signpost start函数

934
00:48:59,873 --> 00:49:01,408
放在处理器的开始

935
00:49:01,475 --> 00:49:04,111
以及kdebug signpost end函数
放在处理器的末端

936
00:49:04,378 --> 00:49:06,713
这就是它所需要做的工作 让这段代码

937
00:49:06,780 --> 00:49:10,217
突出显示在仪表系统追踪的点追踪中

938
00:49:10,951 --> 00:49:12,719
那么如果你切换回仪表

939
00:49:12,786 --> 00:49:15,756
就是点追踪顶部的这些红点

940
00:49:15,822 --> 00:49:19,293
我们可以看到在向后追踪中
它把我们的事件处理器

941
00:49:19,359 --> 00:49:20,661
与其中一个事件相匹配了

942
00:49:21,562 --> 00:49:25,599
如果你放大点追踪中的一个
有意思的查看区域

943
00:49:25,666 --> 00:49:28,335
你可以看到有许多事件处理器

944
00:49:28,402 --> 00:49:30,938
非常紧凑地发生

945
00:49:31,104 --> 00:49:33,640
鼠标悬浮在其中一个处理器上
我们实际上可以看到

946
00:49:33,707 --> 00:49:36,009
它们只执行了非常短的一段时间

947
00:49:36,343 --> 00:49:39,813
弹出会告诉我们它所执行的时间长度

948
00:49:39,880 --> 00:49:42,716
我们甚至可以看到
有时会有重叠的事件处理器

949
00:49:42,783 --> 00:49:45,619
同时并发执行

950
00:49:46,386 --> 00:49:48,121
那么这是我们应用中的

951
00:49:48,188 --> 00:49:50,290
其中一个潜在的不利并行

952
00:49:50,357 --> 00:49:52,326
是看起来

953
00:49:52,392 --> 00:49:54,328
不会在代码中导致并行的东西

954
00:49:54,394 --> 00:49:57,998
但实际上却以并发方式
运行或多线程运行

955
00:49:58,065 --> 00:50:00,067
并导致了潜在的额外情境切换

956
00:50:01,468 --> 00:50:05,239
那么为了更好地理解
让我们在仪表中拉动线程

957
00:50:05,439 --> 00:50:07,674
以及执行这段代码的系统追踪

958
00:50:12,579 --> 00:50:14,448
在这里我已经突出了三个辅助线程

959
00:50:14,515 --> 00:50:16,149
就是执行这些事件处理器的辅助线程

960
00:50:16,483 --> 00:50:20,387
我们之前可以看到
它们在这段时间待命执行

961
00:50:20,921 --> 00:50:22,556
这也是它们运行的时间

962
00:50:22,823 --> 00:50:24,892
但在这里我们可以看到它们再一次

963
00:50:24,958 --> 00:50:27,761
在这个区域运行了很短的时间

964
00:50:27,928 --> 00:50:31,565
并且我们可以识别它们
正在发起这些读取系统调用

965
00:50:31,632 --> 00:50:33,534
是我们之前在事件处理器中看到的

966
00:50:34,134 --> 00:50:37,070
我们可以通过再一次查看
向后追踪获取更多信息

967
00:50:37,137 --> 00:50:40,240
并查看 是的就是我们在
调用那个读取系统调用

968
00:50:40,307 --> 00:50:42,376
且它从我们的套接口中
读取了97个字节

969
00:50:44,144 --> 00:50:46,613
查看其它线程 重复了同一种模式

970
00:50:46,680 --> 00:50:49,049
你可以看到那里发生的是
同一个读取系统调用

971
00:50:49,116 --> 00:50:50,851
或多或少都在同一个时间框架中

972
00:50:50,918 --> 00:50:53,820
那么也就是在第二个线程上
或第一个线程上

973
00:50:53,987 --> 00:50:56,790
它们实际上做的是同样的事 重叠了

974
00:50:57,858 --> 00:51:01,161
如果这些事在单一线程上执行

975
00:51:01,228 --> 00:51:02,496
对于我们的程序来说会更棒

976
00:51:02,563 --> 00:51:05,199
在这里我们并没有真正从并发中受益

977
00:51:05,265 --> 00:51:07,534
因为我们执行的是这种很短的代码

978
00:51:07,901 --> 00:51:10,304
很可能坏处大于益处

979
00:51:10,370 --> 00:51:12,206
从添加这些额外情境切换的角度来说

980
00:51:13,040 --> 00:51:15,108
那么让我们应用我们之前看到的模式

981
00:51:15,175 --> 00:51:17,344
来修复这个示例应用中的这个问题

982
00:51:17,811 --> 00:51:19,146
返回到Xcode

983
00:51:19,213 --> 00:51:21,849
让我们看看我们要如何
为我们的那个源设置目标队列

984
00:51:23,050 --> 00:51:25,285
那么当你在这个函数框架顶部
创建这个队列时

985
00:51:25,352 --> 00:51:28,155
正如你所看到的

986
00:51:28,222 --> 00:51:30,691
我们很简单地就实现了
通过正确地调用这个调度队列

987
00:51:31,458 --> 00:51:33,560
那会创建一个独立的连续队列

988
00:51:33,627 --> 00:51:36,196
并不会连接到我们应用中的任何东西

989
00:51:36,563 --> 00:51:38,465
这根我们之前看到的例子一模一样

990
00:51:38,532 --> 00:51:40,934
就是那个联网子系统的例子

991
00:51:41,635 --> 00:51:44,404
那么让我们修复这个问题

992
00:51:44,471 --> 00:51:47,241
通过在所有队列的底部为全部
连接添加一个互斥情境

993
00:51:47,608 --> 00:51:49,843
我们通过添加 或通过切换到

994
00:51:49,910 --> 00:51:52,579
调度队列 调度队列是通过

995
00:51:52,646 --> 00:51:54,248
之前给你介绍的这个目标函数创建的

996
00:51:57,684 --> 00:51:59,920
在这里我们添加了调度队列
创建了这个目标

997
00:52:00,220 --> 00:52:03,991
并且我们将单一互斥队列
作为全部队列的目标队列

998
00:52:04,191 --> 00:52:06,693
并且这个连续队列是我们
在其它地方创建的

999
00:52:07,427 --> 00:52:10,664
然后我们再次创建并运行
并再次查看系统追踪

1000
00:52:11,565 --> 00:52:12,833
现在看起来很不一样了

1001
00:52:14,434 --> 00:52:17,905
在这里我们仍然有同样的点追踪
我们仍然能看到同样的网络事件发生

1002
00:52:17,971 --> 00:52:21,808
但正如你所看到的
那个追踪中不再有重叠事件了

1003
00:52:21,875 --> 00:52:24,778
并且有一个单一辅助线程
执行这段代码

1004
00:52:25,245 --> 00:52:27,014
如果我们放大其中一个集群

1005
00:52:27,080 --> 00:52:30,083
我们可以看到这实际上是
那个事件处理器的许多实例

1006
00:52:30,150 --> 00:52:33,887
接连不断地执行
这正是我们所期待的结果

1007
00:52:34,221 --> 00:52:36,790
当你再放大其中某个事件时

1008
00:52:36,857 --> 00:52:40,260
你可以看到它仍然执行
相当短的一段时间

1009
00:52:40,327 --> 00:52:42,296
并做出了同样的读取系统调用

1010
00:52:42,729 --> 00:52:44,598
但现在问题小多了

1011
00:52:44,665 --> 00:52:46,567
因为这全部发生在一个单线程上

1012
00:52:49,870 --> 00:52:50,704
（找到问题点）

1013
00:52:50,771 --> 00:52:53,373
那么这看起来可能像是一个很简单、
很微小的修改

1014
00:52:53,440 --> 00:52:54,474
但值得注意的是

1015
00:52:54,541 --> 00:52:58,812
正是这种小的调整导致

1016
00:52:58,879 --> 00:53:01,381
我们自己的某些框架代码的性能
提升了1.3倍

1017
00:53:01,448 --> 00:53:03,150
这正是Daniel在演讲
一开始就指出来的

1018
00:53:03,417 --> 00:53:06,019
那么像这样的很小的修改
可以导致很大的不同

1019
00:53:10,891 --> 00:53:13,360
好了 让我们回顾一下
我们今天演讲的内容

1020
00:53:14,094 --> 00:53:16,063
Daniel在一开始就跟大家具体谈了

1021
00:53:16,129 --> 00:53:20,601
在不必要的情况下不离开内核的方式
永远比现代化的CPU要重要

1022
00:53:20,667 --> 00:53:22,836
从而它可以达到最高效的性能状态

1023
00:53:23,504 --> 00:53:27,474
我们看了调整能力
工作负载的劳动力的重要性

1024
00:53:27,541 --> 00:53:30,143
以及在应用中的子系统之间

1025
00:53:30,210 --> 00:53:32,446
以及这些子系统内部的工作转移

1026
00:53:33,113 --> 00:53:36,683
我们还谈了如何通过GCD
选择不错的并发间隔

1027
00:53:36,750 --> 00:53:39,720
通过在应用中使用固定数量的连续队列

1028
00:53:40,087 --> 00:53:43,156
并且Pierre跟你们一起演示了
如何现代化你的GCD使用

1029
00:53:43,223 --> 00:53:46,827
以充分地利用OS中对硬件的改进

1030
00:53:47,628 --> 00:53:49,663
最后我们了解了如何使用仪表

1031
00:53:49,730 --> 00:53:53,033
在我们的应用中发现问题点
以及如何修复它们

1032
00:53:55,169 --> 00:53:58,772
要获取更多关于本场演讲的信息
请参看这个URL

1033
00:53:58,839 --> 00:54:03,477
这里有GCD的文档链接以及演讲视频

1034
00:54:03,544 --> 00:54:07,681
本周还有一些相关演讲
可能值得一去

1035
00:54:07,748 --> 00:54:11,185
已经结束了的有Core ML介绍
另外两场

1036
00:54:11,251 --> 00:54:14,321
会帮助你处理并行
和计算[听不清]任务

1037
00:54:14,388 --> 00:54:16,390
在你的应用中
正如我们在一开始所谈到的那样

1038
00:54:16,957 --> 00:54:20,827
最后两场可以帮助你处理
更多的性能分析

1039
00:54:20,894 --> 00:54:23,230
和改善应用的不同方面

1040
00:54:24,064 --> 00:54:26,066
就这样了 我想谢谢大家的参与

1041
00:54:26,133 --> 00:54:28,502
如果你有任何疑问
欢迎来我们的实验室咨询

