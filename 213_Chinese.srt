1
00:00:22,222 --> 00:00:23,056
上午好

2
00:00:25,092 --> 00:00:26,326
很高兴见到你们

3
00:00:26,393 --> 00:00:27,227
我是罗布

4
00:00:27,294 --> 00:00:28,996
另外还有我的同事
文森和汤姆

5
00:00:29,062 --> 00:00:30,964
今天我将与大家一起深入探讨

6
00:00:31,031 --> 00:00:34,668
八个新拖放API
这是我们在iOS 11中推出

7
00:00:35,135 --> 00:00:37,371
我们推出了一系列的新API

8
00:00:37,437 --> 00:00:39,206
但是不要被吓倒了

9
00:00:39,273 --> 00:00:41,108
我们将会讲解
许多的基础知识

10
00:00:41,475 --> 00:00:43,644
让你们逐步接受这些API

11
00:00:43,710 --> 00:00:44,678
事实上

12
00:00:44,745 --> 00:00:47,915
如果你们使用
集合视图或表格视图

13
00:00:47,981 --> 00:00:50,584
可以参加
明天在2号大厅举行的

14
00:00:51,185 --> 00:00:52,586
专门演讲

15
00:00:52,653 --> 00:00:55,722
然后接下来还有一个
NSItemProvider演讲

16
00:00:55,789 --> 00:00:59,626
如果你想知道UDI中的U
代表什么 请不要错过此演讲

17
00:00:59,826 --> 00:01:03,330
本演讲分为两个部分

18
00:01:03,397 --> 00:01:05,399
首先 我们将讨论拖动操作

19
00:01:05,465 --> 00:01:07,835
包括拖动交互委托

20
00:01:07,901 --> 00:01:10,137
会话、相关拖放项目和预览

21
00:01:10,204 --> 00:01:12,206
然后 汤姆将负责
第二部分的演讲

22
00:01:12,272 --> 00:01:14,308
介绍放入操作

23
00:01:14,374 --> 00:01:17,277
今天的内容有很多

24
00:01:17,344 --> 00:01:20,314
首先 我们将介绍
高级拖动交互

25
00:01:21,148 --> 00:01:22,316
你们已经知道

26
00:01:23,617 --> 00:01:26,653
iOS中的拖动与放入操作不仅
用于在应用之间共享数据

27
00:01:26,720 --> 00:01:28,822
而且是一种流畅的用户交互

28
00:01:28,889 --> 00:01:32,759
这些复杂的用户交互

29
00:01:32,826 --> 00:01:34,127
要求我们必须确保一致性

30
00:01:34,194 --> 00:01:37,130
你可以使用UIDragInteraction
来实现这种一致性

31
00:01:37,197 --> 00:01:39,833
你可以使用它们
在任何视图中安装它们

32
00:01:39,900 --> 00:01:41,869
你不必自己编写子类

33
00:01:41,935 --> 00:01:45,405
更不必进入和更改
自定义视图的现有超类

34
00:01:45,472 --> 00:01:49,042
只需要安装其中一个
它将会为你完成必要的手势记录

35
00:01:49,109 --> 00:01:50,310
但是你必须

36
00:01:50,377 --> 00:01:52,913
自己实现
UIDragInteractionDelegate

37
00:01:53,447 --> 00:01:55,782
至少返回一个UIDragItem

38
00:01:55,849 --> 00:01:59,786
你可以 [听不清]
获得一系列的生命周期通知

39
00:01:59,853 --> 00:02:03,423
进行一些动画显示
后面我们将会讨论这些内容

40
00:02:03,857 --> 00:02:06,860
如果你不明白这些内容
我建议你们观看

41
00:02:06,927 --> 00:02:09,696
昨天已经举行的
“拖动与放入操作简介”演讲

42
00:02:09,763 --> 00:02:13,200
如果你们没有参加此演讲
就只能看视频

43
00:02:13,800 --> 00:02:15,602
那个演讲介绍一些基础知识

44
00:02:15,669 --> 00:02:19,039
但是这些基础知识不够全面
所以你们还需要参加本演讲

45
00:02:19,106 --> 00:02:24,344
让我们来看iOS 11中的
一些应用使用的行为

46
00:02:24,411 --> 00:02:27,447
以及用户将会期望
你的应用如何做出响应

47
00:02:28,482 --> 00:02:31,151
在Mail应用中
你可以看到

48
00:02:31,218 --> 00:02:33,754
当我长时期按住邮件
开始拖动时

49
00:02:33,820 --> 00:02:36,056
我可以轻按后面的邮件

50
00:02:36,123 --> 00:02:40,327
它们将会加入
我正在进行的拖动

51
00:02:40,394 --> 00:02:42,829
加入拖动的邮件
数量在增加

52
00:02:42,896 --> 00:02:45,165
这种功能并不是唾手可得的

53
00:02:45,232 --> 00:02:47,935
但也不是很难实现
让我演示给你们看

54
00:02:48,669 --> 00:02:49,570
在本例中

55
00:02:49,636 --> 00:02:52,139
我已经实现
UIDragInteractionDelegate

56
00:02:52,439 --> 00:02:56,877
尤其是必要的方法 dragInteraction
itemsForBeginning session

57
00:02:56,944 --> 00:03:01,281
在其中 我为想要拖动的邮件
创建一个NSItemProvider

58
00:03:01,949 --> 00:03:05,419
然后利用前面的itemProvider
创建一个UIDragItem

59
00:03:05,619 --> 00:03:07,521
将localObject设置为该邮件

60
00:03:07,588 --> 00:03:10,457
稍后 我可以
引用这个邮件

61
00:03:10,524 --> 00:03:12,526
然后 我返回放入数组

62
00:03:13,227 --> 00:03:14,328
现在 你可以使用

63
00:03:14,394 --> 00:03:17,664
dragInteraction itemsForAddingTo
session withTouchAt point

64
00:03:17,731 --> 00:03:18,832
使用同样的实现

65
00:03:18,899 --> 00:03:20,067
这是可行的

66
00:03:20,367 --> 00:03:23,170
但是 你们需要一些边界例子

67
00:03:23,237 --> 00:03:26,039
当你实现这种方法
来实现群组拖动时

68
00:03:26,773 --> 00:03:28,575
首先 如果实现这个方法

69
00:03:28,642 --> 00:03:30,077
你的拖动交互可能

70
00:03:30,143 --> 00:03:33,080
与应用中的
其它拖动交互组合在一起

71
00:03:33,146 --> 00:03:34,781
而不会与其它应用中的
拖动交互组合在一起

72
00:03:34,848 --> 00:03:37,518
因此我们目前不允许跨应用组合

73
00:03:37,584 --> 00:03:38,819
但是鲍勃在其它部门

74
00:03:38,886 --> 00:03:40,988
实现的dragInteractionDelegate

75
00:03:41,622 --> 00:03:44,224
支持这种组合
你应该认识到这一点

76
00:03:44,291 --> 00:03:47,194
在本例中 我决定
只组合我的邮件

77
00:03:47,261 --> 00:03:50,531
和其它邮件

78
00:03:50,597 --> 00:03:53,000
因此 我迭代此会话中的所有项目

79
00:03:53,066 --> 00:03:56,937
如果任何项目没有
一个NSItemProvider

80
00:03:57,004 --> 00:04:00,073
并且含有符合此类型的UDI
在本例中

81
00:04:00,140 --> 00:04:01,408
它是private.example.mail

82
00:04:01,475 --> 00:04:03,710
我将取消返回空数组

83
00:04:03,777 --> 00:04:06,980
这将提供其它手势识别
以识别

84
00:04:07,047 --> 00:04:09,449
触发这种组合的点击操作

85
00:04:09,516 --> 00:04:10,484
同样地

86
00:04:11,118 --> 00:04:13,820
默认情况下 相同的拖动交互

87
00:04:13,887 --> 00:04:16,390
相同的UI视图
可以组合多个项目

88
00:04:16,456 --> 00:04:19,993
我们不知道
这对你的应用是否有意义

89
00:04:20,060 --> 00:04:22,763
或者视图内的不同区域

90
00:04:22,829 --> 00:04:25,566
对于不同的拖动项目
因此你必须告诉我们

91
00:04:25,632 --> 00:04:27,534
在本例中
我检查会话中

92
00:04:27,601 --> 00:04:30,103
任何其它项目的
本地对象

93
00:04:30,170 --> 00:04:32,439
是否对应于想要选中的邮件

94
00:04:32,506 --> 00:04:33,640
如果是

95
00:04:33,707 --> 00:04:35,576
我也会使用空数组来终止

96
00:04:35,943 --> 00:04:37,578
你可以这样进行组合

97
00:04:38,779 --> 00:04:42,749
Mail的另一个行为是这样的

98
00:04:42,816 --> 00:04:45,886
如果我长时间按住一个邮件线索
而不是移动

99
00:04:45,953 --> 00:04:48,388
代表邮件线索的一个项目

100
00:04:48,522 --> 00:04:53,026
我移动三个邮件线索
每个都含有一份邮件

101
00:04:53,093 --> 00:04:55,295
用这个蓝色的泡泡表示

102
00:04:57,130 --> 00:04:58,532
我们已经看到

103
00:04:58,832 --> 00:05:00,534
UIDragInteractionDelegates

104
00:05:00,601 --> 00:05:03,036
拖动项目itemsForBeginning
会话返回一个数组

105
00:05:03,103 --> 00:05:06,273
在这里可以返回多个项目

106
00:05:06,340 --> 00:05:08,742
这正是我想要的

107
00:05:08,809 --> 00:05:12,312
因此我获得邮件线索中的所有邮件

108
00:05:12,779 --> 00:05:14,848
我对它们进行排序
稍后将会解释为什么这样做

109
00:05:14,915 --> 00:05:18,652
然后 为每个邮件返回一个UIDragItem

110
00:05:18,719 --> 00:05:20,754
这与前面的做法完全相同

111
00:05:20,821 --> 00:05:21,889
我对它们排序的原因是

112
00:05:21,955 --> 00:05:24,992
这里返回的数组的顺序很重要

113
00:05:25,058 --> 00:05:27,294
因为数组中的最后一个项目

114
00:05:27,361 --> 00:05:29,530
将成为你提升的
最上方对象

115
00:05:29,596 --> 00:05:31,465
由于我想最先获取最新的邮件

116
00:05:31,532 --> 00:05:35,002
因此我对它们进行排序
使最旧邮件成为数组中的第一个项目

117
00:05:35,335 --> 00:05:36,170
这行得通

118
00:05:36,236 --> 00:05:38,472
但是 如果我们这样实现

119
00:05:39,606 --> 00:05:42,809
所有项目都会提升
并且具有相同的预览

120
00:05:43,177 --> 00:05:45,179
这意味着
它们将具有相同的视觉表示

121
00:05:45,245 --> 00:05:47,714
默认情况下 我们创建的预览

122
00:05:47,781 --> 00:05:50,417
基于已经设定交互模式的视图

123
00:05:50,484 --> 00:05:53,153
这意味着
所有三份邮件使用线索

124
00:05:53,220 --> 00:05:54,788
作为它们的视觉表示

125
00:05:54,855 --> 00:05:56,023
这并不是我想要的

126
00:05:56,089 --> 00:05:59,760
我实现可选的dragInteraction
previewForLifting项目会话

127
00:05:59,826 --> 00:06:01,862
返回我自己的拖动预览

128
00:06:02,095 --> 00:06:03,630
因此 我所做的事情是

129
00:06:03,697 --> 00:06:07,801
首先我尝试找到
与项目关联的邮件

130
00:06:08,368 --> 00:06:09,403
如果找到

131
00:06:09,469 --> 00:06:11,505
我通过它的helper方法

132
00:06:11,572 --> 00:06:13,373
获取它的相关邮件视图

133
00:06:13,440 --> 00:06:16,476
然后使用它初始化
我的UITargetedDragPreview

134
00:06:16,543 --> 00:06:20,214
这意味着
我提升的所有邮件

135
00:06:20,280 --> 00:06:21,882
将具有它自己的表示

136
00:06:21,949 --> 00:06:24,117
这些表示基于
它们自己的邮件视图

137
00:06:24,918 --> 00:06:25,786
最后这点也很重要

138
00:06:25,853 --> 00:06:30,090
Mail还具有另外一项微妙的功能

139
00:06:30,958 --> 00:06:34,361
你可以看到 我将照片
从Photos拖到Mail

140
00:06:34,428 --> 00:06:35,996
如果你注意

141
00:06:36,063 --> 00:06:41,201
你会发现
被拖动照片的大小发生变化

142
00:06:41,268 --> 00:06:43,737
以适应正文撰写表单的宽度

143
00:06:43,804 --> 00:06:47,040
那么 Mail如何已经知道
应该为照片留出多大空间

144
00:06:47,107 --> 00:06:48,675
并在何处显示预览？

145
00:06:48,742 --> 00:06:51,445
还是因为
数据非常快速地到达？

146
00:06:51,512 --> 00:06:54,114
不是 你不应该进行任何推测

147
00:06:54,181 --> 00:06:57,417
在我的演示中
数据及时到达

148
00:06:57,484 --> 00:06:59,553
但在用户的实际应用中
情况可能并非如此

149
00:06:59,620 --> 00:07:02,122
有更好的方法
来处理这种情况

150
00:07:02,189 --> 00:07:04,558
我们发现NSItemProvider

151
00:07:05,092 --> 00:07:08,095
有一个属性 名为
preferredPresentationSize

152
00:07:08,161 --> 00:07:11,532
允许你告知
你想要显示的内容的大小

153
00:07:11,598 --> 00:07:13,634
这类似于管道方法

154
00:07:13,700 --> 00:07:16,803
在这里 即使我使用文件
初始化NSItemProvider

155
00:07:16,870 --> 00:07:18,005
我也知道大小

156
00:07:18,071 --> 00:07:20,707
因此 我可以相应地设置它的
preferredPresentationSize

157
00:07:20,774 --> 00:07:23,377
然后Mail能够在后台读取它

158
00:07:23,443 --> 00:07:25,345
其余的工作是相同的

159
00:07:25,612 --> 00:07:28,215
我可以向你们保证

160
00:07:28,282 --> 00:07:30,417
这个方法完全可行

161
00:07:30,484 --> 00:07:33,954
现在文森将会为大家演示

162
00:07:42,129 --> 00:07:43,664
谢谢 罗布

163
00:07:48,035 --> 00:07:49,570
在进行演示之前

164
00:07:49,636 --> 00:07:51,638
我要讲一些事情

165
00:07:51,705 --> 00:07:54,041
我演示的所有代码

166
00:07:54,107 --> 00:07:55,809
都可以从网上下载

167
00:07:55,876 --> 00:07:57,978
建议你去查看

168
00:07:58,045 --> 00:07:58,879
其次

169
00:07:58,946 --> 00:08:01,915
今天我们将会演示两个应用
而不是一个

170
00:08:01,982 --> 00:08:03,450
第一个应用名称为Drag Source

171
00:08:03,517 --> 00:08:05,552
其重点是拖动交互

172
00:08:05,619 --> 00:08:07,321
第二个是Drop Destination

173
00:08:07,387 --> 00:08:10,257
其重点是放入操作

174
00:08:10,457 --> 00:08:14,294
让我们来看
第一个演示应用

175
00:08:15,495 --> 00:08:20,701
在这里 我们看到四组图片

176
00:08:20,767 --> 00:08:25,772
我们已经实现
一些基本拖动与放入操作

177
00:08:25,839 --> 00:08:30,043
可以拖动每个
图片组中的单张图片

178
00:08:30,110 --> 00:08:31,311
看上去还不错

179
00:08:31,545 --> 00:08:35,682
如果我们能够
将整组图片

180
00:08:35,749 --> 00:08:38,352
作为单个项目拖动就更好了

181
00:08:38,751 --> 00:08:41,221
让我们来看代码
弄清楚应该怎么做

182
00:08:41,922 --> 00:08:44,324
请看这个代码

183
00:08:44,391 --> 00:08:49,429
这是上张图像视图
使用它创建一个新拖动项目

184
00:08:49,496 --> 00:08:51,164
使用上张图像视图

185
00:08:51,431 --> 00:08:53,534
一个简单的方法是

186
00:08:54,168 --> 00:08:56,904
枚举所有的可用图片视图

187
00:08:57,504 --> 00:08:59,573
然后为每个视图返回拖动项目

188
00:08:59,973 --> 00:09:01,341
我们将这样做

189
00:09:01,408 --> 00:09:03,477
让我们来看它的行为

190
00:09:04,511 --> 00:09:08,315
请观察 当我拖动第二组图片时
将会发生什么

191
00:09:09,383 --> 00:09:11,885
你会注意到
这次显示一个计数图标 上面显示3

192
00:09:11,952 --> 00:09:14,221
这表示
我们拖动三个项目

193
00:09:14,288 --> 00:09:16,523
对应于图片组中的
三幅图片

194
00:09:16,823 --> 00:09:19,259
我在右侧调出Photos

195
00:09:19,927 --> 00:09:25,165
你会注意到 我可以
将这三幅图片拖入Photos

196
00:09:25,232 --> 00:09:28,669
像保存单幅图片一样保存它们

197
00:09:29,269 --> 00:09:30,304
在Photos中

198
00:09:30,370 --> 00:09:32,072
让我展示另一个操作

199
00:09:33,307 --> 00:09:35,542
我已经对其中
一幅图片进行拖动

200
00:09:35,609 --> 00:09:38,412
如果我点击
另外两幅图片

201
00:09:38,478 --> 00:09:41,815
你会看到 它们
也被加入到现有拖动会话之中

202
00:09:42,282 --> 00:09:45,252
罗布前面说过
这样的行为需要编码实现

203
00:09:45,452 --> 00:09:48,422
幸运的是 这很容易实现
让我展示给你们看

204
00:09:48,956 --> 00:09:50,324
我们回到代码之中

205
00:09:50,958 --> 00:09:53,694
我需要实现
itemsForAddingTo session

206
00:09:54,494 --> 00:09:56,330
在这里 需要注意的是

207
00:09:56,396 --> 00:09:58,332
我们可以在
itemsForAddingTo session中

208
00:09:58,732 --> 00:10:01,768
使用与itemsForBeginning session中
相同的逻辑

209
00:10:01,835 --> 00:10:03,837
来构建拖动项目

210
00:10:03,904 --> 00:10:06,473
这可以简化工作

211
00:10:06,540 --> 00:10:10,010
我们只需调用 在itemsForBeginning
session中使用的逻辑

212
00:10:10,077 --> 00:10:11,979
然后引入新helper方法

213
00:10:12,045 --> 00:10:14,114
我调用这个
dragItems for session

214
00:10:15,782 --> 00:10:19,653
在两个位置中 当我们添加
现有会话 在这里

215
00:10:20,854 --> 00:10:25,492
当我们在itemsForBeginning
session中创建一个新会话时

216
00:10:25,559 --> 00:10:27,928
我们只需要调用
这个新helper方法

217
00:10:29,997 --> 00:10:31,932
这让我们能够

218
00:10:31,999 --> 00:10:36,003
添加更多图片
到现有拖动会话中

219
00:10:36,069 --> 00:10:36,937
你可以看到

220
00:10:37,004 --> 00:10:39,206
当我点击其它三个
视图中的任何一个时

221
00:10:39,740 --> 00:10:43,777
我们能够
将所有10张图片添加到拖动会话

222
00:10:43,944 --> 00:10:47,214
这工作正常
但是需要注意

223
00:10:47,281 --> 00:10:51,051
在这里 我要开始
拖动第一组图片

224
00:10:51,118 --> 00:10:53,587
我保持点击
第一组图片

225
00:10:54,188 --> 00:10:57,591
你可以看到 我能够
任意地添加所有图片

226
00:10:57,658 --> 00:10:59,459
而有些图片应该是不能添加的

227
00:10:59,526 --> 00:11:01,128
这看起来像是一个漏洞

228
00:11:01,195 --> 00:11:04,364
现在拖动会话中
已经有26张图片

229
00:11:04,431 --> 00:11:07,100
让我们来看应该如何解决

230
00:11:07,701 --> 00:11:10,470
这是刚才介绍的helper

231
00:11:11,371 --> 00:11:12,406
我们能做的事情是

232
00:11:12,472 --> 00:11:14,908
我们不使用所有
imageViews来创建拖动项目

233
00:11:14,975 --> 00:11:16,877
我们每次点击时

234
00:11:16,944 --> 00:11:18,846
我们要做的是
过滤出imageView

235
00:11:18,912 --> 00:11:22,482
我们不使用一个imageView
来创建多个dragItem

236
00:11:24,251 --> 00:11:26,386
因此 使用这三行代码

237
00:11:26,453 --> 00:11:29,456
让我返回应用
看看其运行效果

238
00:11:31,091 --> 00:11:34,595
现在 我开始拖动
第一组图片

239
00:11:34,661 --> 00:11:36,463
然后我点击
第三组图片

240
00:11:36,530 --> 00:11:39,299
请看 当我尝试添加更多项目时
将会发生什么

241
00:11:40,067 --> 00:11:41,435
漏洞似乎不见了

242
00:11:41,502 --> 00:11:44,438
我不再能够添加多余的项目
到拖动会话

243
00:11:44,905 --> 00:11:47,341
这是一些基本的拖动操作

244
00:11:47,407 --> 00:11:49,276
它们通过委托来完成

245
00:11:49,376 --> 00:11:51,178
接下来 罗布将会为我们介绍

246
00:11:51,245 --> 00:11:53,947
一些更高级的技术

247
00:11:54,014 --> 00:11:56,817
例如 自定义动画效果
和拖动预览

248
00:12:04,958 --> 00:12:08,095
让我们为预览增加一些效果

249
00:12:09,129 --> 00:12:10,964
一种常见的情况是

250
00:12:11,031 --> 00:12:13,534
你想要移动的视图

251
00:12:13,600 --> 00:12:15,569
并不支持特殊效果

252
00:12:15,636 --> 00:12:17,371
你可能需要一些突出显示状态

253
00:12:17,437 --> 00:12:19,806
或者需要覆盖层淡出效果

254
00:12:19,873 --> 00:12:22,442
拖动操作可以很好地
实现这些效果

255
00:12:22,509 --> 00:12:25,512
因为在拖动过程中
视图仍然处于活动状态

256
00:12:25,579 --> 00:12:27,714
你在视图中
进行的任何更改

257
00:12:27,781 --> 00:12:30,817
在动画期间将会反映出来

258
00:12:30,884 --> 00:12:34,521
当用户开始移动手指时

259
00:12:34,588 --> 00:12:35,923
才会开始这些效果

260
00:12:35,989 --> 00:12:39,626
在拖动交互的过程中
将会保持这些效果

261
00:12:41,128 --> 00:12:46,033
拖动过程中的动画效果
就是这样的

262
00:12:46,266 --> 00:12:47,634
这里有一个委托方法选项

263
00:12:47,701 --> 00:12:50,737
dragInteraction willAnimateLiftWith
animator session

264
00:12:50,804 --> 00:12:53,907
你将得到一个动画器对象

265
00:12:53,974 --> 00:12:58,011
我要抓取所有邮件

266
00:12:58,078 --> 00:12:59,613
我已经把它设置为拖动项目

267
00:12:59,680 --> 00:13:01,315
然后找到它们的相关messageView

268
00:13:01,381 --> 00:13:03,750
现在我有一个messageView数组

269
00:13:03,817 --> 00:13:04,985
对于其中的每个元素

270
00:13:05,519 --> 00:13:08,188
我将一个动画
添加到动画生成器

271
00:13:08,255 --> 00:13:11,558
我将alpha设置为0
实现覆盖层淡出效果

272
00:13:11,625 --> 00:13:15,162
在completion代码块
我将alpha重新设置为1

273
00:13:15,229 --> 00:13:18,332
其效果是
当视图移动时

274
00:13:18,398 --> 00:13:19,566
覆盖层将会淡出

275
00:13:19,633 --> 00:13:22,402
如果用户让其继续
视图将会归位

276
00:13:22,469 --> 00:13:23,403
覆盖层将会淡入

277
00:13:23,470 --> 00:13:26,974
因为动画器能够自动反转动画效果

278
00:13:27,040 --> 00:13:29,977
当拖动开始时
将开始视图的动画效果

279
00:13:30,043 --> 00:13:32,312
在此之后
将会调用completion代码块

280
00:13:32,379 --> 00:13:35,916
覆盖层将会恢复原状

281
00:13:35,983 --> 00:13:38,485
这意味着 在动画过程中
将不会有覆盖层

282
00:13:38,552 --> 00:13:41,121
但是在视图中
它仍然保留在应用中

283
00:13:41,555 --> 00:13:43,957
如果移动的视图

284
00:13:44,458 --> 00:13:47,661
进行交互操作的视图
不是已经设置交互的视图

285
00:13:47,728 --> 00:13:51,899
或者视图不是方形的
我们应该怎么做？

286
00:13:51,965 --> 00:13:55,202
我们已经看到
可以使用视图初始化UIDragPreview

287
00:13:55,269 --> 00:13:56,670
但是这里有另外两个参数

288
00:13:56,737 --> 00:13:59,072
让我们来逐个研究

289
00:13:59,139 --> 00:14:03,443
第一个参数对象
让你能够自定义外观

290
00:14:03,510 --> 00:14:05,846
第二个是用于定位的对象

291
00:14:06,480 --> 00:14:07,981
首先来看参数

292
00:14:08,048 --> 00:14:10,484
它是
UIDragPreviewParameters的一个实例

293
00:14:10,551 --> 00:14:11,685
有两个属性

294
00:14:11,985 --> 00:14:14,254
第一个是color
是位于你的视图背后的

295
00:14:14,321 --> 00:14:16,890
视图的背景颜色

296
00:14:16,957 --> 00:14:18,625
由于许多视图
并不是完全不透明的

297
00:14:18,692 --> 00:14:22,596
如果我们按照原样进行移动
可能效果并不会好

298
00:14:22,663 --> 00:14:25,699
但是 你可以
自定义想要的颜色

299
00:14:25,766 --> 00:14:29,903
可以设置为黑色或透明

300
00:14:29,970 --> 00:14:32,172
第二个属性
更复杂一些

301
00:14:32,239 --> 00:14:35,542
它是UIBezierPath 让我们知道

302
00:14:35,609 --> 00:14:38,812
视图的可见区域是什么

303
00:14:38,879 --> 00:14:40,547
如果你的视图不是方形

304
00:14:40,614 --> 00:14:42,816
可以设置成圆角矩形

305
00:14:42,883 --> 00:14:45,152
但是 我们必须知道

306
00:14:45,219 --> 00:14:48,222
默认情况下 并不提供
拖动预览参数

307
00:14:48,288 --> 00:14:52,759
如果你不为拖动预览参数
设置一个路径

308
00:14:52,826 --> 00:14:54,161
将会移动整个视图

309
00:14:54,228 --> 00:14:56,897
如果你想要裁剪出小矩形

310
00:14:56,964 --> 00:14:59,633
在本例中
圆角矩形中有一个小孩

311
00:14:59,700 --> 00:15:01,235
可以提供一个Bezier路径

312
00:15:01,301 --> 00:15:03,537
将会得到这样的结果

313
00:15:03,604 --> 00:15:05,305
但是很重要的一点是

314
00:15:05,372 --> 00:15:08,275
你提供的Bezier路径

315
00:15:08,342 --> 00:15:10,744
必须在视图的坐标空间
具有意义

316
00:15:10,811 --> 00:15:14,047
在本例中 用于初始化
圆角矩形的边界

317
00:15:14,114 --> 00:15:17,784
具有一个原点
它相对于容器的原点

318
00:15:17,851 --> 00:15:19,686
用灰色显示

319
00:15:19,753 --> 00:15:22,389
视图的原点
用灰色显示

320
00:15:22,456 --> 00:15:24,124
那是左上角

321
00:15:24,525 --> 00:15:26,727
你还想要标记中点

322
00:15:26,793 --> 00:15:28,462
因为它是可见路径的中点

323
00:15:28,529 --> 00:15:31,665
将用于定位

324
00:15:31,965 --> 00:15:35,202
这种预览的原理
就是这样的

325
00:15:35,636 --> 00:15:39,540
设置的路径不仅
可以小于视图

326
00:15:39,606 --> 00:15:41,608
也可以设置更大的路径

327
00:15:41,675 --> 00:15:44,344
在本例中
原点是负值

328
00:15:44,411 --> 00:15:46,680
它在视图中的
工作[听不清]

329
00:15:46,747 --> 00:15:49,483
从而形成
这样的相框效果

330
00:15:49,550 --> 00:15:50,751
你在这里看到的颜色

331
00:15:50,817 --> 00:15:53,020
实际上是背景颜色
默认为白色

332
00:15:53,320 --> 00:15:55,989
如果你想要
实现自己的文本呈现效果

333
00:15:56,056 --> 00:16:00,527
可以使用一些
专用的样式

334
00:16:00,594 --> 00:16:02,629
实现同样出色的文本移动效果

335
00:16:02,696 --> 00:16:05,465
你可以参考
这方面的文档

336
00:16:06,300 --> 00:16:07,401
再来看target

337
00:16:07,467 --> 00:16:10,871
target 用于定位
过渡视图

338
00:16:10,938 --> 00:16:14,208
我们用它在视图层次结构中
执行动画效果

339
00:16:14,274 --> 00:16:16,043
如果你不提供target

340
00:16:16,109 --> 00:16:18,812
将会根据你提供的
视图的超类进行推算

341
00:16:18,879 --> 00:16:23,050
这意味着
你提供的视图

342
00:16:23,116 --> 00:16:25,252
与目标直接预览相同

343
00:16:25,919 --> 00:16:29,323
如果视图不在视图层次结构中
则必须提供target

344
00:16:29,389 --> 00:16:30,591
否则将会推算target

345
00:16:30,657 --> 00:16:34,361
这个UIDragPreviewTarget
有三个参数

346
00:16:34,428 --> 00:16:35,329
第一个是container

347
00:16:35,429 --> 00:16:36,763
我们在这个容器中
载入视图

348
00:16:36,830 --> 00:16:41,134
因此你需要知道
该容器中的任何添加或复查子视图调用

349
00:16:42,069 --> 00:16:44,538
第二个参数是position
第三个参数是transform

350
00:16:44,605 --> 00:16:46,006
transform仅用于放入操作

351
00:16:46,073 --> 00:16:49,610
它允许旋转或
比例缩放

352
00:16:49,676 --> 00:16:51,712
position参数
有一点复杂

353
00:16:52,079 --> 00:16:53,580
前面我说过

354
00:16:53,981 --> 00:16:56,817
它是容器中的一个点
用灰色表示

355
00:16:56,884 --> 00:17:00,888
默认情况下 视图的中心
位于此位置

356
00:17:01,255 --> 00:17:04,657
如果你不提供可视路径
看上去将会是这样的

357
00:17:04,790 --> 00:17:08,095
但是 如果你提供
一个可视路径

358
00:17:08,228 --> 00:17:12,766
此路径的边界的中点
将是这个位置

359
00:17:12,833 --> 00:17:14,701
因此 它不再是
视图的中点

360
00:17:14,768 --> 00:17:16,770
它是可见路径的中点

361
00:17:16,837 --> 00:17:19,772
这意味着 如果你的
路径比较复杂

362
00:17:19,839 --> 00:17:21,208
比如像这个

363
00:17:21,275 --> 00:17:24,077
我将两个圆角矩形
联合在一起

364
00:17:24,144 --> 00:17:27,481
中点甚至不在
两个矩形之中

365
00:17:27,548 --> 00:17:30,851
它是这些形状的
封闭边界的中点

366
00:17:31,852 --> 00:17:34,521
在iOS 11中

367
00:17:34,588 --> 00:17:37,257
你会注意到
系统中的许多应用

368
00:17:37,324 --> 00:17:40,194
在移动之后
能够更新预览

369
00:17:40,260 --> 00:17:41,361
在Maps中可以看到

370
00:17:41,428 --> 00:17:46,033
当我移动这个
Apple Park单元格时

371
00:17:46,099 --> 00:17:49,937
它会被这个小地图块代替

372
00:17:50,003 --> 00:17:51,104
我们如何做到这一点？

373
00:17:51,171 --> 00:17:54,141
系统中的有一个
第二预览类

374
00:17:54,208 --> 00:17:57,878
除了 UITargetedDragPreview之外
还有UIDragPreview

375
00:17:57,945 --> 00:18:01,181
与你们的预料一样
它类似于UITargetedDragPreview

376
00:18:01,248 --> 00:18:02,549
但是没有target

377
00:18:02,950 --> 00:18:05,018
其它的语义是相同的

378
00:18:05,085 --> 00:18:08,488
用于初始化这个预览的视图

379
00:18:08,555 --> 00:18:11,825
可能位于视图层次结构中
也可能不是 但这并不重要

380
00:18:12,693 --> 00:18:14,695
那么如何更新这个预览呢？

381
00:18:15,128 --> 00:18:19,900
首先 应该在会话生命周期中
中找到一个合适的点

382
00:18:19,967 --> 00:18:22,135
在本例中 我选择sessionDidMove

383
00:18:22,202 --> 00:18:23,837
在这里 我要做的是

384
00:18:23,904 --> 00:18:28,308
当用户在我的Mail程序中
移出列表视图时

385
00:18:28,375 --> 00:18:31,512
我想使用一个信封图片
代替他们正在拖动的内容

386
00:18:31,578 --> 00:18:34,748
首先 我进行点击检查
查看焦点是否仍然在列表视图中

387
00:18:34,815 --> 00:18:37,284
如果是 就取消操作
不返回任何内容

388
00:18:38,118 --> 00:18:43,323
然后 我迭代所有项目
这些项目将邮件作为它们的本地对象

389
00:18:44,324 --> 00:18:46,326
我检查是否
已经更新此项目

390
00:18:46,393 --> 00:18:47,628
因为这项操作会占用资源

391
00:18:47,694 --> 00:18:50,864
可能会频繁调用sessionDidMove

392
00:18:50,931 --> 00:18:52,232
如果没有更新

393
00:18:52,299 --> 00:18:54,468
我将设置previewProvider

394
00:18:54,535 --> 00:18:57,638
后面我将会调用这个代码块
以更新视图

395
00:18:57,704 --> 00:19:00,974
在代码块内 我首先
使用我喜欢的图片创建一个图像视图

396
00:19:01,441 --> 00:19:03,810
然后用它初始化
一个新的拖动预览

397
00:19:03,877 --> 00:19:07,681
很重要的一点是 应该认识到
我们可能不会调用这个代码块

398
00:19:07,748 --> 00:19:11,151
因此 如果要移动许多邮件

399
00:19:11,218 --> 00:19:12,886
我们可能会决定
不显示所有邮件

400
00:19:12,953 --> 00:19:14,821
对于不会在屏幕上
显示的视图

401
00:19:14,888 --> 00:19:16,790
不需要调用它们的预览代码块

402
00:19:17,524 --> 00:19:19,593
最后这点也很重要
我必须进行一些记录

403
00:19:19,660 --> 00:19:22,329
实践比理论更重要

404
00:19:22,396 --> 00:19:23,864
文森将为大家
进行另外一项演示

405
00:19:23,931 --> 00:19:25,465
稍后再见 谢谢

406
00:19:30,938 --> 00:19:32,739
谢谢 罗布

407
00:19:32,806 --> 00:19:35,843
我们来看第二个例子

408
00:19:35,909 --> 00:19:37,711
接下来的例子是Drag Source

409
00:19:38,545 --> 00:19:39,613
请看

410
00:19:40,314 --> 00:19:43,016
当我拖动这张含有两个二维码的图片时

411
00:19:43,083 --> 00:19:45,853
我们获得一个拖动会话
它含有两个项目

412
00:19:45,919 --> 00:19:48,422
这两个项目是什么？
如果我把它放入Photos

413
00:19:48,488 --> 00:19:51,124
我们看到 它实际是
二维码的裁剪图片

414
00:19:51,191 --> 00:19:54,895
然后 我检查到
二维码在图片中的位置

415
00:19:55,362 --> 00:19:58,732
我们可以修饰
这个拖动预览

416
00:19:58,799 --> 00:20:00,567
我们还没有进行任何自定义

417
00:20:00,634 --> 00:20:04,238
默认情况下
我们使用整个图像视图

418
00:20:04,304 --> 00:20:07,641
展示项目或二维码

419
00:20:07,708 --> 00:20:11,411
实际上 我们两次看到整个图像视图

420
00:20:11,478 --> 00:20:13,413
两个项目互相重叠

421
00:20:13,480 --> 00:20:16,717
这是一个不错的做法
如果在提升和拖动时

422
00:20:16,783 --> 00:20:20,521
能够将二维码
作为拖动预览

423
00:20:21,088 --> 00:20:24,258
让我们来看应该怎么做

424
00:20:25,125 --> 00:20:28,328
首先我们要做的是
实现previewForLifting item

425
00:20:28,529 --> 00:20:31,665
在这里 我们需要获取
二维码的一些信息

426
00:20:31,732 --> 00:20:33,834
主要是二维码的裁剪图像

427
00:20:33,901 --> 00:20:36,904
以及一些几何信息
描述其在图片中的位置

428
00:20:36,970 --> 00:20:39,573
我们使用这些信息
创建一个新UIImageView

429
00:20:40,374 --> 00:20:42,743
然后创建DragPreviewTarget

430
00:20:42,910 --> 00:20:44,545
和DragPreviewParameters

431
00:20:44,611 --> 00:20:46,780
请注意 在这里
我们将visiblePath

432
00:20:46,847 --> 00:20:49,049
设置为新UIBezierPath
它是一个roundedRect

433
00:20:49,116 --> 00:20:51,285
这将提供一个
美观的圆角预览

434
00:20:51,552 --> 00:20:52,819
然后我们将这些信息

435
00:20:52,886 --> 00:20:54,888
组合到新的
targeted drag preview之中

436
00:20:55,522 --> 00:20:56,757
进行这些修改之后

437
00:20:57,691 --> 00:21:01,862
当我们移动时
可以看到更美观的拖动预览

438
00:21:02,462 --> 00:21:04,765
现在来看 当我进行移动时
会发生什么

439
00:21:04,965 --> 00:21:07,467
这次并没有弹出
整个图片

440
00:21:07,534 --> 00:21:12,673
我们看到两个二维码的
矩形图像被提升

441
00:21:12,739 --> 00:21:13,707
当我进行拖动时

442
00:21:13,774 --> 00:21:17,978
可以看到两个二维码
随之移动

443
00:21:18,045 --> 00:21:19,479
看上去很不错

444
00:21:19,546 --> 00:21:22,182
有一个地方看上去比较奇怪
让我展示给你们看

445
00:21:22,249 --> 00:21:24,985
当我放开二维码时
请看会发生什么

446
00:21:25,052 --> 00:21:27,421
没有地方接受放入操作

447
00:21:27,487 --> 00:21:29,189
因此 我们需要做一个取消动画

448
00:21:29,256 --> 00:21:31,959
问题在于
我们实际上并没有告诉UIKit

449
00:21:32,025 --> 00:21:35,329
当我们取消拖动时
拖动预览动画应该显示到何处

450
00:21:35,395 --> 00:21:36,797
让我们来解决这个问题

451
00:21:37,464 --> 00:21:40,801
为此 我们实现
previewForCancelling item

452
00:21:41,168 --> 00:21:44,071
它看上去很像 previewForLifting
item 而且工作原理相似

453
00:21:44,137 --> 00:21:45,639
我们希望

454
00:21:45,706 --> 00:21:48,008
二维码返回其初始位置

455
00:21:48,075 --> 00:21:49,376
我们所做的工作

456
00:21:49,443 --> 00:21:51,311
与第一个例子相以

457
00:21:51,378 --> 00:21:55,015
调用
previewForLifting item中使用的代码

458
00:21:55,082 --> 00:21:57,184
把它放入单独的helper

459
00:21:57,251 --> 00:21:59,419
我们将它命名为
dragPreview for item

460
00:21:59,486 --> 00:22:00,954
它所做的工作是

461
00:22:01,688 --> 00:22:06,093
返回二维码的初始位置

462
00:22:06,527 --> 00:22:10,564
也就是我们开始移动时的位置
当取消移动时

463
00:22:11,164 --> 00:22:14,902
将会在这两个位置
调用helper 速度很快

464
00:22:15,202 --> 00:22:18,972
然后返回程序

465
00:22:21,241 --> 00:22:23,777
当我们来看 当取消移动时
会发生什么

466
00:22:24,444 --> 00:22:27,848
可以看到 它们快速地
回到初始位置

467
00:22:28,348 --> 00:22:30,350
看上去比刚才好多了

468
00:22:30,417 --> 00:22:32,319
但是还有另外一个问题

469
00:22:32,619 --> 00:22:37,591
我们想要跳转到右侧
也就是Photos所在的位置

470
00:22:37,858 --> 00:22:40,327
你会注意到
当我拖动图片时

471
00:22:40,394 --> 00:22:42,763
图像视图的背景会淡出

472
00:22:42,829 --> 00:22:46,300
以指示我们当前正在
从那个视图拖动一张图片

473
00:22:46,700 --> 00:22:49,036
系统中的很多应用
都会这样做

474
00:22:49,102 --> 00:22:52,072
我们的演示应用
也具有这样的效果

475
00:22:53,073 --> 00:22:54,208
让我展示给你们看

476
00:22:55,943 --> 00:22:59,079
我们要做的是
实现一些伴随动画

477
00:22:59,146 --> 00:23:00,647
我们为提升设置动画效果

478
00:23:00,714 --> 00:23:04,818
得到这个动画器对象
可以将它关联到伴随动画

479
00:23:04,885 --> 00:23:08,522
我们添加这个新代码块
将alpha设置为0.5

480
00:23:08,689 --> 00:23:11,825
此alpha值成为
总体图像视图的alpha值

481
00:23:12,025 --> 00:23:14,528
当进行提升时
图像视图将会淡出

482
00:23:14,595 --> 00:23:18,232
当取消拖动预览时

483
00:23:18,298 --> 00:23:21,902
会将alpha还原为1
然后视图重新淡入

484
00:23:22,236 --> 00:23:24,004
如果alpha值始终是0.5

485
00:23:24,071 --> 00:23:27,007
效果并不好

486
00:23:27,074 --> 00:23:28,475
当拖动会话结束时

487
00:23:28,542 --> 00:23:31,879
我们应该小心地
将alpha还原为1

488
00:23:31,945 --> 00:23:35,249
确保拖动结束时
还原为完全不透明状态

489
00:23:37,184 --> 00:23:39,453
进行这些修改之后

490
00:23:39,520 --> 00:23:40,854
我返回应用

491
00:23:41,588 --> 00:23:43,590
注意到 当我开始提升时
会发生什么

492
00:23:44,224 --> 00:23:47,561
可以看到 这很好地显示出
二维码所在的位置

493
00:23:47,628 --> 00:23:49,563
图像视图的其余部分淡出

494
00:23:50,430 --> 00:23:51,932
当我取消时

495
00:23:51,999 --> 00:23:55,068
图像视图的其余部分
平滑地淡入

496
00:23:56,303 --> 00:23:59,173
看上去很不错
让我们来看第三个例子

497
00:23:59,339 --> 00:24:01,074
这是可拖动位置图像视图

498
00:24:01,508 --> 00:24:05,212
在这里 比较复杂的是

499
00:24:05,279 --> 00:24:08,248
当我们开始拖动时
不仅要将图像

500
00:24:08,315 --> 00:24:10,250
作为表示
添加到项目提供器

501
00:24:10,317 --> 00:24:12,753
而且还要添加位置

502
00:24:13,854 --> 00:24:17,191
这意味着 我能够将内容放入
接受位置的应用

503
00:24:17,257 --> 00:24:18,525
比如Maps

504
00:24:18,926 --> 00:24:20,227
而且将会为我导航

505
00:24:20,294 --> 00:24:23,430
并在地图上标记
照片的拍摄位置

506
00:24:23,497 --> 00:24:25,432
很明显 这个位置是
金门大桥

507
00:24:25,499 --> 00:24:28,135
看上去很漂亮
有一点除外

508
00:24:29,002 --> 00:24:29,903
当我开始拖动时

509
00:24:29,970 --> 00:24:32,472
还没有对拖动预览
进行任何自定义

510
00:24:32,539 --> 00:24:35,475
因此这个默认拖动预览
也就是整个图像视图

511
00:24:35,542 --> 00:24:36,743
并不能表明

512
00:24:36,810 --> 00:24:40,848
我们有一个位置
而不仅是一张图片

513
00:24:40,914 --> 00:24:43,083
现在看起来
我们只是在拖动一张图片

514
00:24:43,483 --> 00:24:44,852
让我们来解决这个问题

515
00:24:45,085 --> 00:24:47,120
我们进入
可拖动位置图像视图

516
00:24:47,187 --> 00:24:48,789
这是将要执行的逻辑

517
00:24:49,189 --> 00:24:51,625
我们将要实现
sessionWillBegin

518
00:24:51,692 --> 00:24:54,761
那么 当这个会话开始时
我们想要做什么呢？

519
00:24:55,329 --> 00:24:57,798
我们想要获取
已创建的拖动项目

520
00:24:57,865 --> 00:24:59,900
我们需要
将previewProvider属性设置为

521
00:24:59,967 --> 00:25:01,168
新代码块

522
00:25:01,235 --> 00:25:04,505
在这个代码块中
我们创建一个新LocationPlatterView

523
00:25:04,571 --> 00:25:07,908
这是我编写的一个自定义视图
它知道如何表示图像

524
00:25:07,975 --> 00:25:11,812
和图像位置描述文本

525
00:25:11,879 --> 00:25:15,949
我要使用这些信息
创建新的UIDragPreview

526
00:25:18,018 --> 00:25:18,886
好了

527
00:25:19,086 --> 00:25:20,187
在进行这些修改之后

528
00:25:20,254 --> 00:25:22,356
应该能够看到

529
00:25:22,422 --> 00:25:25,192
更美观的
拖动预览表示

530
00:25:25,859 --> 00:25:27,761
请观看 当我提升时
会发生什么

531
00:25:27,995 --> 00:25:31,098
有意思的是
实际上并没有什么区别

532
00:25:31,331 --> 00:25:34,701
原因是我们将逻辑
放入了sessionWillBegin

533
00:25:34,768 --> 00:25:39,072
当我移动手指时
会话才开始

534
00:25:39,273 --> 00:25:41,975
我开始移动 请看

535
00:25:42,042 --> 00:25:45,112
拖动预览变成了
这个唱片图案

536
00:25:45,179 --> 00:25:47,014
显示图像…

537
00:25:50,117 --> 00:25:52,386
显示图像和位置

538
00:25:52,452 --> 00:25:54,188
我可以将它放入Maps

539
00:25:54,254 --> 00:25:56,757
将为我导航 在这里进行标记

540
00:25:57,157 --> 00:25:59,960
我们已经讨论
关于一些拖动操作的

541
00:26:00,027 --> 00:26:02,296
高级技术

542
00:26:02,362 --> 00:26:04,898
接下来 我想要
把讲台交给我的同事汤姆

543
00:26:04,965 --> 00:26:11,638
他讨论一些用于
自定义放入交互的API

544
00:26:15,509 --> 00:26:19,079
谢谢 文森
把我拖进来

545
00:26:19,479 --> 00:26:20,881
很高兴来到这里

546
00:26:22,282 --> 00:26:24,284
现在我们来讨论放入

547
00:26:24,451 --> 00:26:26,987
让我们来深入了解

548
00:26:27,754 --> 00:26:30,090
首先讨论放入会话

549
00:26:30,157 --> 00:26:32,993
然后 我将进行放入操作演示

550
00:26:33,961 --> 00:26:36,830
那么 什么是放入会话？
它是拖动会话的对应部分

551
00:26:36,897 --> 00:26:39,466
让你访问
与放入相关的所有内容

552
00:26:39,800 --> 00:26:41,902
可以访问拖动位置

553
00:26:41,969 --> 00:26:44,438
用户将在视图内进行拖动

554
00:26:44,838 --> 00:26:47,174
让你访问视图中的项目

555
00:26:47,541 --> 00:26:51,378
查看数据类型
放入他们的数据

556
00:26:51,845 --> 00:26:55,382
也可以访问配置
以进行适当的设置

557
00:26:55,849 --> 00:26:58,218
最后 还可以访问
拖动会话本身

558
00:26:58,285 --> 00:27:00,988
当你进行拖动时
另外还有更多功能

559
00:27:04,791 --> 00:27:07,060
关于放入操作
应该记住的一点是

560
00:27:07,127 --> 00:27:10,831
在同一时间
只有一个交互

561
00:27:10,898 --> 00:27:12,099
处理一个活跃的放入会话

562
00:27:12,799 --> 00:27:16,837
原因是什么？
因为这适用于大多数应用情况

563
00:27:17,070 --> 00:27:19,873
这意味着
当用户进行拖动

564
00:27:19,940 --> 00:27:21,675
进入交互之后

565
00:27:21,808 --> 00:27:23,677
任何其它会话

566
00:27:23,744 --> 00:27:27,014
并尝试进入交互的其它会话
将不会被拾取

567
00:27:27,748 --> 00:27:31,118
记住 你可以
同时使用多根手指进行拖动

568
00:27:31,818 --> 00:27:33,220
如果你不想要这样的行为

569
00:27:33,287 --> 00:27:37,257
而且不需要同时
在视图上有多个活跃会话

570
00:27:37,324 --> 00:27:38,358
也可以使用其它的方案

571
00:27:38,825 --> 00:27:40,160
可以添加多个交互

572
00:27:40,227 --> 00:27:41,728
并添加更多的放入交互

573
00:27:41,795 --> 00:27:44,031
同时处理所有这些交互

574
00:27:44,097 --> 00:27:46,834
它们可以具有相同的逻辑
或不同的逻辑

575
00:27:46,900 --> 00:27:48,001
这并不重要

576
00:27:48,402 --> 00:27:50,404
可以设置交互属性

577
00:27:50,470 --> 00:27:52,673
此属性名称为
allowSimultaneousDropSessions

578
00:27:52,840 --> 00:27:53,841
将它设置为真

579
00:27:53,907 --> 00:27:59,546
将可以同时处理多个会话

580
00:27:59,613 --> 00:28:02,416
但是 你的委托必须进行正确的处理

581
00:28:04,017 --> 00:28:05,786
让我们来看放入是如何工作的

582
00:28:05,853 --> 00:28:07,955
昨天的演讲简要地谈到了这一点

583
00:28:08,021 --> 00:28:09,623
让我们来看看

584
00:28:09,823 --> 00:28:12,726
用户拖动一个对象
它接近你的视图

585
00:28:13,126 --> 00:28:14,261
在进行任何处理

586
00:28:14,328 --> 00:28:17,931
我们在你的交互委托上
调用canHandle session

587
00:28:18,098 --> 00:28:21,068
根据你返回的内容
这将触发

588
00:28:21,134 --> 00:28:23,537
允许处理会话
或禁止处理会话

589
00:28:23,604 --> 00:28:25,005
如果返回假

590
00:28:25,072 --> 00:28:27,608
视图将不会响应放入会话

591
00:28:27,674 --> 00:28:28,976
什么也不会发生

592
00:28:29,610 --> 00:28:31,345
如果返回真
或实现这个 方法

593
00:28:31,411 --> 00:28:33,180
将会继续并调用sessionDidEnter

594
00:28:33,247 --> 00:28:36,750
表示拖动操作
已经进入你的视图

595
00:28:37,951 --> 00:28:41,955
然后用户移动手指
这时会反复调用sessionDidUpdate

596
00:28:42,222 --> 00:28:44,057
你必须返回一个DropProposal

597
00:28:44,124 --> 00:28:47,528
请记住
它将会被多次调用

598
00:28:47,594 --> 00:28:50,197
因此应该减少这里的工作量

599
00:28:50,264 --> 00:28:51,198
不要加入过多操作

600
00:28:51,265 --> 00:28:54,568
这将会降低帧率
用户可能会不满

601
00:28:56,170 --> 00:28:58,438
当用户抬起手指时
将会执行放入

602
00:28:58,505 --> 00:29:00,007
这里有很多的细节

603
00:29:00,140 --> 00:29:04,111
最后 将会调用sessionDidEnd
表示会话已经结束

604
00:29:04,178 --> 00:29:08,515
默认情况下 你的交互
准备再次接受新会话

605
00:29:09,183 --> 00:29:14,655
现在 假设用户没有抬起手指
而是把手指收回去

606
00:29:15,322 --> 00:29:16,390
如果移出视图之外

607
00:29:16,456 --> 00:29:20,360
将会调用sessionDidExit
会话已经离开视图

608
00:29:20,427 --> 00:29:22,963
这并不意味着
会话已经结束

609
00:29:23,030 --> 00:29:27,501
会话仍然继续
如果用户没有在你的视图之外抬起手指

610
00:29:27,568 --> 00:29:31,538
将会再次调用sessionDidEnd
表明会话确实已经结束

611
00:29:32,639 --> 00:29:35,509
现在 我们假设
没有抬起手指

612
00:29:35,576 --> 00:29:36,777
而又重新移回

613
00:29:37,110 --> 00:29:39,580
从视图之外
重新移回视图

614
00:29:39,646 --> 00:29:43,417
将再次调用sessionDidEnter
并开始调用sessionDidUpdate

615
00:29:43,483 --> 00:29:46,286
更新会话
获取一个DropProposal

616
00:29:47,187 --> 00:29:50,824
假设用户的手指
停留在视图之外

617
00:29:50,891 --> 00:29:52,626
不能接受放入的位置

618
00:29:52,693 --> 00:29:56,096
将会返回操作取消或禁止

619
00:29:56,363 --> 00:29:58,465
如果用户抬起手指

620
00:29:59,666 --> 00:30:01,235
将会立即调用sessionDidEnd

621
00:30:01,301 --> 00:30:05,072
什么也不发生 不会执行放入
而是取消放入

622
00:30:06,840 --> 00:30:09,042
让我们来看DropProposal

623
00:30:09,610 --> 00:30:11,311
我不重复讨论

624
00:30:11,378 --> 00:30:13,847
昨天的演讲已经介绍放入操作

625
00:30:13,914 --> 00:30:16,416
让我们来看一些更有趣的属性

626
00:30:16,483 --> 00:30:17,885
第一个是精度模式

627
00:30:18,151 --> 00:30:21,688
如果你设置精度模式
将setting isPrecise设置为真

628
00:30:21,855 --> 00:30:27,361
视图的点击测试区域
将略高于用户触摸位置

629
00:30:27,427 --> 00:30:30,130
因此 视图中的实际点击测试位置

630
00:30:30,197 --> 00:30:33,467
不是在用户手指下方
而是略高的位置

631
00:30:33,667 --> 00:30:36,637
这能够在视图中
进入更精确的放入

632
00:30:36,703 --> 00:30:39,806
因为用户可以清楚地
看到他们的放入位置

633
00:30:39,873 --> 00:30:42,075
一个典型的例子是这个文本控件

634
00:30:42,142 --> 00:30:44,711
这些控件使用精确模式
显示插入点

635
00:30:44,778 --> 00:30:48,515
便于用户将内容放入文本视图

636
00:30:49,249 --> 00:30:52,553
这里可以看到 插入点
位于用户的屏幕触摸点

637
00:30:52,619 --> 00:30:54,087
的上方位置

638
00:30:54,588 --> 00:30:57,157
如果不这样做
插入点将位于手指正下方

639
00:30:57,224 --> 00:31:02,863
这样就比较不容易
精确地放入文本中的特定位置点

640
00:31:02,930 --> 00:31:04,932
因此 如果实现精确模式

641
00:31:04,998 --> 00:31:08,569
请在放入点显示一些UI元素

642
00:31:08,869 --> 00:31:12,372
向用户指示放入位置

643
00:31:14,041 --> 00:31:16,643
接下来是prefersFullSizePreview

644
00:31:17,744 --> 00:31:19,213
此属性提供预览缩放功能

645
00:31:19,279 --> 00:31:22,382
在使用iOS11时
你可能注意到

646
00:31:22,449 --> 00:31:24,952
如果拖动项目
项目将会缩小

647
00:31:25,018 --> 00:31:27,287
系统始终会缩小项目

648
00:31:27,487 --> 00:31:29,723
我们为什么要这样做呢？
因为屏幕和你的UI上显示

649
00:31:29,790 --> 00:31:34,194
较大的预览并没有意义
因为UI是交互性的

650
00:31:34,361 --> 00:31:37,431
如果用过大的预览
遮盖屏幕

651
00:31:37,497 --> 00:31:40,467
将难以进行导航
因此我们进行比例缩小

652
00:31:41,068 --> 00:31:42,569
但是在某些情况下

653
00:31:42,636 --> 00:31:45,939
可能需要全尺寸预览

654
00:31:46,006 --> 00:31:49,343
比如 你有一个列表
可以重新排序这个列表

655
00:31:49,409 --> 00:31:51,979
如果拾取某个项目
尝试移动它

656
00:31:52,079 --> 00:31:54,948
缩小整个项目将没有意义

657
00:31:55,015 --> 00:31:58,285
在这里 可以添加
prefersFullSizePreviews

658
00:31:58,452 --> 00:31:59,653
这有两种方法

659
00:31:59,720 --> 00:32:03,924
在拖动位置 有一个拖动DragInteraction
prefersFullSizePreviewsFor session

660
00:32:04,191 --> 00:32:08,395
这里返回真
将保持全尺寸预览

661
00:32:08,462 --> 00:32:12,499
在放入位置
可以在DropProposal上将标记设置为真

662
00:32:13,367 --> 00:32:15,469
请注意这是一个偏好项

663
00:32:15,869 --> 00:32:20,841
可以缩放 也可以不缩放

664
00:32:20,908 --> 00:32:24,545
在有些情况下
系统始终会进行缩小

665
00:32:25,312 --> 00:32:29,850
一种情况是组合拖动
如果添加多个项目以进行拖动

666
00:32:29,917 --> 00:32:34,087
将始终会缩小这些项目
即使你选择全尺寸

667
00:32:35,088 --> 00:32:40,827
对于单预览 如果拖动项目
并将它拖到你的应用之外

668
00:32:40,894 --> 00:32:42,963
也始终会进行缩小

669
00:32:43,964 --> 00:32:45,999
最后 项目缩小之后

670
00:32:46,066 --> 00:32:47,434
将不会还原比例

671
00:32:47,501 --> 00:32:48,368
因此请注意

672
00:32:48,435 --> 00:32:51,371
它是一个偏好项
但并不是始终不变的

673
00:32:52,406 --> 00:32:54,174
让我们来进行放入

674
00:32:54,241 --> 00:32:57,177
当开始执行放入时
用户抬起手指

675
00:32:57,244 --> 00:33:01,348
此时必须开始载入数据

676
00:33:01,415 --> 00:33:03,784
事实上 只有在此时

677
00:33:03,851 --> 00:33:08,188
才能请求数据 并进行放入

678
00:33:08,255 --> 00:33:11,158
因为如果在任何其它
生命周期调用中

679
00:33:11,225 --> 00:33:13,126
尝试这样做 都将会失败

680
00:33:13,193 --> 00:33:16,196
只有在performDrop中
才能获取数据

681
00:33:16,363 --> 00:33:17,898
需要在另一侧合作

682
00:33:17,965 --> 00:33:19,800
因此我说
只有一个机会

683
00:33:19,867 --> 00:33:22,102
但是通常你会获得一些数据

684
00:33:22,302 --> 00:33:25,539
数据加载始终是异步的
因此请不要阻止

685
00:33:25,606 --> 00:33:28,108
如果阻止过长时间
就不会知道

686
00:33:28,175 --> 00:33:31,478
数据需要多长时间才会到达

687
00:33:31,545 --> 00:33:34,948
系统可能终止你的应用
这会极大地影响用户体验

688
00:33:35,015 --> 00:33:36,350
因此请不要这样做

689
00:33:37,684 --> 00:33:41,054
在后台加载数据
将会导致在你的视图中动画显示项目

690
00:33:41,121 --> 00:33:42,956
因此用户看到进行放入

691
00:33:43,023 --> 00:33:45,859
最后 调用concludeDrop
指示动画已经结束

692
00:33:45,926 --> 00:33:48,829
在用户注意到时
放入已经结束

693
00:33:51,698 --> 00:33:53,901
但是这并不意味着
数据已经到达

694
00:33:53,967 --> 00:33:56,703
你可以看到
这里的第一个调用仍然在继续

695
00:33:56,770 --> 00:33:58,172
后面我们将会讲到

696
00:33:58,906 --> 00:34:03,644
如何加载数据？
有一个非常有用的调用方法

697
00:34:03,710 --> 00:34:06,146
名为loadObjects
of class completion

698
00:34:06,213 --> 00:34:07,748
十分适合调用同类数据

699
00:34:07,814 --> 00:34:11,284
如果你只拖动
或放入图片

700
00:34:11,351 --> 00:34:14,821
而且只接受图片
请使用URImage类

701
00:34:14,888 --> 00:34:18,792
将提供一个数组
其排序

702
00:34:18,859 --> 00:34:20,561
与会话项目数组中的排序相同

703
00:34:20,627 --> 00:34:23,030
我们将展示给你看

704
00:34:23,096 --> 00:34:24,598
由于没有在后面进行提升操作

705
00:34:24,665 --> 00:34:26,132
因此将会返回一个数组

706
00:34:26,199 --> 00:34:28,502
将会对主队列
调用Completion代码块

707
00:34:28,569 --> 00:34:30,670
因此可以立即更新URI

708
00:34:31,271 --> 00:34:34,507
如果有更多的混合数据
或者想要进行更多的控制

709
00:34:34,574 --> 00:34:36,844
可以迭代会话项目

710
00:34:36,909 --> 00:34:39,213
可以单独加载每个项目

711
00:34:39,279 --> 00:34:41,849
在ItemProvider上
使用Use loadObject

712
00:34:41,915 --> 00:34:45,252
或loadDataRepresentation
loadFileRepresentation

713
00:34:45,319 --> 00:34:48,554
让你能够更精细地控制
想要加载的内容

714
00:34:48,621 --> 00:34:53,060
甚至允许你为每个项目
加载多个文件表示

715
00:34:53,126 --> 00:34:54,393
如果你选择这样做

716
00:34:54,962 --> 00:34:57,664
请注意 将在后台队列上
调用这个completion代码块

717
00:34:58,298 --> 00:35:02,236
如果想要执行URI 工作
分发到主队列

718
00:35:03,604 --> 00:35:05,138
现在我把讲台交回给文森

719
00:35:05,205 --> 00:35:07,841
为大家展示
实际运用范例

720
00:35:13,947 --> 00:35:15,682
谢谢 汤姆

721
00:35:15,883 --> 00:35:19,152
现在我想介绍第二部分演示

722
00:35:19,419 --> 00:35:23,423
这是第二个演示应用
名称为Drop Destination

723
00:35:23,490 --> 00:35:24,858
在这里 我们要做的是

724
00:35:24,925 --> 00:35:27,561
创建一个类似于Photos的
照片展示程序

725
00:35:27,628 --> 00:35:31,965
放入照片将会在
这个区域增加更多图像视图

726
00:35:32,065 --> 00:35:34,735
这个流程应该正常工作

727
00:35:34,801 --> 00:35:36,203
我应该能在这里放入

728
00:35:36,270 --> 00:35:38,739
应该看到更多图像视图

729
00:35:38,805 --> 00:35:40,174
但是事与愿违

730
00:35:40,240 --> 00:35:43,343
让我们进入代码
弄清楚为什么会这样

731
00:35:43,911 --> 00:35:45,946
这是我们的逻辑执行代码

732
00:35:46,013 --> 00:35:47,848
Droppable Image Preview Controller

733
00:35:47,915 --> 00:35:51,451
这里可以看到
我们只实现sessionDidUpdate

734
00:35:51,652 --> 00:35:53,387
因此无法进行放入

735
00:35:53,453 --> 00:35:56,423
因为我们还没有实现
任何放入处理功能

736
00:35:56,590 --> 00:35:58,659
在这里 我要实现
performDrop

737
00:35:58,725 --> 00:36:00,561
在这个方法中

738
00:36:00,627 --> 00:36:03,864
将会迭代会话中的所有项目

739
00:36:03,931 --> 00:36:06,733
对于每个项目
如果能够加载一个UI图像

740
00:36:06,800 --> 00:36:10,237
将会插入一个
新图像视图到层次结构中

741
00:36:10,304 --> 00:36:12,806
然后通过itemProvider进行加载

742
00:36:12,940 --> 00:36:14,441
当itemProvider完成加载时

743
00:36:14,508 --> 00:36:16,143
将会回调主队列

744
00:36:16,210 --> 00:36:19,079
将刚才插入的
图像视图的图像

745
00:36:19,146 --> 00:36:21,949
设置为ItemProvider返回的
这个新图像

746
00:36:22,850 --> 00:36:23,851
在进行这些修改之后

747
00:36:23,917 --> 00:36:27,154
我们应该能够
让这个基本流程顺利工作

748
00:36:30,224 --> 00:36:31,625
让我们来看将会发生什么

749
00:36:32,759 --> 00:36:35,495
现在 你注意到的第一件事是
这里有一个绿色的+3图标

750
00:36:35,562 --> 00:36:38,732
这表示有一个操作即将执行

751
00:36:38,799 --> 00:36:43,370
显然 这个操作是插入新图像

752
00:36:43,437 --> 00:36:44,671
这很简单

753
00:36:45,472 --> 00:36:48,208
让我们来看另外一个特性

754
00:36:48,375 --> 00:36:50,878
你可能注意到 底部这个区域显示

755
00:36:50,944 --> 00:36:53,013
放入这里以删除照片

756
00:36:53,280 --> 00:36:54,381
的确是这样的

757
00:36:55,015 --> 00:36:57,484
当我把照片放入这里
上面的照片就被删除了

758
00:36:57,551 --> 00:36:58,652
看上去还不错

759
00:36:58,719 --> 00:37:02,122
但问题是 我们并没有对
放入预览进行任何自定义

760
00:37:02,189 --> 00:37:03,090
默认情况下

761
00:37:03,156 --> 00:37:06,226
照片移动到中间 然后淡出

762
00:37:06,493 --> 00:37:10,464
现在请汤姆上来
为我们进行优化

763
00:37:16,003 --> 00:37:19,439
我们发现 并不需要
许多代码来执行放入

764
00:37:19,940 --> 00:37:22,876
让我们来讨论放入预览
和它们的动画效果

765
00:37:23,911 --> 00:37:25,379
让我们调出这个图表

766
00:37:25,445 --> 00:37:29,516
它看上去比较简单

767
00:37:29,583 --> 00:37:33,487
让我们把这个concludeDrop放到一边

768
00:37:33,554 --> 00:37:36,156
看看这个中间过程会发生什么

769
00:37:36,790 --> 00:37:38,325
开始加载我们的数据

770
00:37:38,659 --> 00:37:41,028
在执行Complete代码后

771
00:37:41,094 --> 00:37:43,864
请求预览项目放入

772
00:37:43,931 --> 00:37:46,533
使用defaultPreview
调用previewForDropping

773
00:37:46,600 --> 00:37:48,235
提供一个默认预览

774
00:37:48,302 --> 00:37:52,639
这里可以返回一个新预览
或返回默认预览或nil

775
00:37:52,706 --> 00:37:53,774
这取决于你的需要

776
00:37:53,841 --> 00:37:55,275
后面会详细解释

777
00:37:56,643 --> 00:37:57,978
我们获得的预览

778
00:37:58,045 --> 00:37:59,646
或默认预览

779
00:37:59,913 --> 00:38:03,016
我们将会使用它们
在视图中使用动画效果显示它们

780
00:38:03,283 --> 00:38:05,419
这样用户就能够
看到有内容放入

781
00:38:06,086 --> 00:38:09,623
在此过程中
将执行willDropWith动画器

782
00:38:09,690 --> 00:38:11,758
显示伴随动画效果

783
00:38:12,359 --> 00:38:14,294
前面罗布说过

784
00:38:14,661 --> 00:38:17,831
与提升操作一样
放下操作也是实时的

785
00:38:17,898 --> 00:38:20,200
当你拖动时
会有动画效果

786
00:38:20,267 --> 00:38:23,370
当你放下
取消或提升时 视图也实时更新

787
00:38:23,437 --> 00:38:26,240
因此 可以更新视图

788
00:38:26,540 --> 00:38:29,343
或者与其它UI一起
进行动画显示

789
00:38:31,979 --> 00:38:33,547
这些动画结束时

790
00:38:33,680 --> 00:38:37,484
将调用concludeDrop
指示放入已经结束

791
00:38:37,551 --> 00:38:41,388
然后用户可以继续他们的操作

792
00:38:41,955 --> 00:38:43,123
现在

793
00:38:44,658 --> 00:38:48,462
同样地 这也不意味着
数据已经到达

794
00:38:48,795 --> 00:38:51,064
这里有两个例子

795
00:38:51,131 --> 00:38:55,335
有一个很长的加载对象调用
在concludeDrop之后继续运行

796
00:38:55,402 --> 00:38:59,706
另外一个例子在willAnimate
与previewForDropping之间结束

797
00:38:59,773 --> 00:39:03,177
预览的动画持续时间
也可能不相同

798
00:39:03,243 --> 00:39:05,946
这是因为
根据你所提供的目标位置

799
00:39:06,013 --> 00:39:08,382
它们可能需要移动更远的距离

800
00:39:08,782 --> 00:39:10,450
距离手指更远的项目

801
00:39:10,517 --> 00:39:13,921
所花的时间长于
距离手指近的项目

802
00:39:14,121 --> 00:39:15,189
因此请注意

803
00:39:15,255 --> 00:39:19,026
各动画的时间并不相同
可能略有区别

804
00:39:22,462 --> 00:39:23,630
这样我们获得放入预览

805
00:39:23,697 --> 00:39:26,834
文森已经演示
我们也获得取消预览

806
00:39:26,900 --> 00:39:30,737
它们看起来很相似
原理与提升预览相同

807
00:39:30,804 --> 00:39:33,674
它们的方法相同
但是位置不同

808
00:39:34,641 --> 00:39:36,043
文森的预览演示表明

809
00:39:36,109 --> 00:39:39,746
实现previewForCanceling
item效果更好

810
00:39:39,813 --> 00:39:41,715
因为它提供更好的用户体验

811
00:39:41,782 --> 00:39:43,383
项目可以返回初始位置

812
00:39:43,817 --> 00:39:47,054
更新UI时
用户可以导航

813
00:39:47,120 --> 00:39:51,758
因此UI可能发生很大的变化

814
00:39:51,825 --> 00:39:53,427
请记住这一点

815
00:39:56,363 --> 00:39:58,198
另外willAnimateDropWith动画器

816
00:39:58,265 --> 00:40:01,101
非常类似于
willAnimateCancelWith动画器

817
00:40:01,168 --> 00:40:05,305
虽然情况不同
但是原理相同

818
00:40:05,472 --> 00:40:10,444
UIDragAnimating规则
与UIViewPropertyAnimator十分相似

819
00:40:10,511 --> 00:40:12,880
因此你应该感到很适应

820
00:40:13,981 --> 00:40:15,949
让我们来看
这个默认预览

821
00:40:16,016 --> 00:40:17,851
我们为什么要把它提供给你？

822
00:40:17,918 --> 00:40:19,319
你可以返回它

823
00:40:20,787 --> 00:40:21,955
也可以获取它

824
00:40:22,022 --> 00:40:26,260
这都没有问题
但是这不是我们把它提供给你的原因

825
00:40:26,326 --> 00:40:30,130
如果你想要默认预览
如果想要默认动画

826
00:40:30,197 --> 00:40:31,465
只需返回nil即可

827
00:40:31,532 --> 00:40:34,668
它告诉系统
你接受默认行为

828
00:40:34,735 --> 00:40:38,305
系统可以使用任何动画效果

829
00:40:38,372 --> 00:40:39,673
和表示方式

830
00:40:40,240 --> 00:40:42,009
那么 我们为什么
提供默认预览呢？

831
00:40:42,976 --> 00:40:44,411
你可以重新设置目标位置

832
00:40:44,478 --> 00:40:46,813
我们希望你这样做

833
00:40:46,880 --> 00:40:49,850
如果重新设置目标位置
你就知道默认预览在视图中的位置

834
00:40:49,917 --> 00:40:52,819
我们将会使用动画效果
移动到你指定的目标位置

835
00:40:52,886 --> 00:40:55,022
这会改善使用体验

836
00:40:55,556 --> 00:40:58,292
当然 你需要知道目标位置

837
00:40:58,358 --> 00:41:00,961
如果不知道位置
就不能重新设置

838
00:41:02,329 --> 00:41:03,330
最后

839
00:41:03,664 --> 00:41:07,367
你可以创建自定义预览
设置自己的UI

840
00:41:07,434 --> 00:41:09,002
可以自己决定

841
00:41:09,503 --> 00:41:13,473
你创建的预览
将会动画移动到你指定的位置

842
00:41:14,608 --> 00:41:17,444
这里有几个限制
如果组合中的项目较少

843
00:41:17,511 --> 00:41:20,280
我们将要求你预览每个项目

844
00:41:20,347 --> 00:41:23,116
并且为每个项目提供伴随动画

845
00:41:23,183 --> 00:41:27,688
根据项目数量
你可以使用这些功能

846
00:41:27,754 --> 00:41:31,425
如果组合或会话中有很多项目

847
00:41:32,492 --> 00:41:36,163
我们将默认预览用于所有项目

848
00:41:36,230 --> 00:41:38,699
因此不会要求你创建预览

849
00:41:39,032 --> 00:41:41,368
我们提供伴随动画

850
00:41:41,435 --> 00:41:44,738
以伴随所有项目的动画效果

851
00:41:46,073 --> 00:41:47,007
请不要信以为真

852
00:41:47,074 --> 00:41:49,877
文森将展示应该怎么做

853
00:41:54,715 --> 00:41:55,849
谢谢 汤姆

854
00:41:56,283 --> 00:41:57,818
回顾一下

855
00:41:57,885 --> 00:42:00,654
前面我们讲了如何
修饰这个放入动画

856
00:42:01,421 --> 00:42:02,689
让我们来看应该怎么做

857
00:42:03,557 --> 00:42:05,792
这是Droppable Delete View

858
00:42:06,026 --> 00:42:07,861
在这里
我们首先要做的是

859
00:42:08,195 --> 00:42:10,063
实现previewForDropping

860
00:42:11,064 --> 00:42:11,965
然后 对于项目

861
00:42:12,032 --> 00:42:14,201
我们将创建这个拖动预览目标

862
00:42:14,868 --> 00:42:17,638
看上去与我们前面做的事情很相似

863
00:42:17,704 --> 00:42:20,407
只是这一次
我们显式设置transform

864
00:42:20,474 --> 00:42:24,811
它所做的事情是
动画显示默认预览

865
00:42:24,878 --> 00:42:27,314
其宽度和长度将变化
为原始值的十分之一

866
00:42:27,581 --> 00:42:29,049
因此 你指定一个变换效果

867
00:42:29,116 --> 00:42:31,752
我们把中心设置为
iconView中心

868
00:42:31,818 --> 00:42:34,721
如果返回应用

869
00:42:34,788 --> 00:42:37,191
这个小垃圾桶位于左下角

870
00:42:38,625 --> 00:42:40,527
因此我们通过动画显示到那里

871
00:42:40,594 --> 00:42:42,696
我们将会使用这个target

872
00:42:42,763 --> 00:42:44,831
重新定位默认预览到这个位置

873
00:42:45,365 --> 00:42:46,600
但是 还不止于此

874
00:42:47,100 --> 00:42:50,370
我们还可以进行更多修饰

875
00:42:50,637 --> 00:42:53,207
让我们为放入添加一个伴随动画

876
00:42:53,273 --> 00:42:57,411
我们为iconView添加一个变换

877
00:42:57,477 --> 00:42:58,979
当放入时 变为垃圾桶

878
00:42:59,046 --> 00:43:01,915
因此 将变换到1.25倍比例

879
00:43:01,982 --> 00:43:05,052
显示将会变大25%

880
00:43:05,719 --> 00:43:09,523
并不需要始终保持125%比例

881
00:43:09,590 --> 00:43:11,959
当放入完成之后

882
00:43:12,025 --> 00:43:13,360
应该变换回原来的大小

883
00:43:14,895 --> 00:43:16,230
利用这些修饰

884
00:43:17,297 --> 00:43:20,334
效果应该更加美观

885
00:43:20,834 --> 00:43:24,004
我返回应用
在这里拖动一些照片

886
00:43:24,071 --> 00:43:27,474
请注意 当我放下时
将会发生什么

887
00:43:27,875 --> 00:43:31,111
可以看到 照片进入
垃圾桶 然后消失了

888
00:43:31,178 --> 00:43:32,813
说到垃圾桶

889
00:43:32,913 --> 00:43:34,781
也会看到 它会变大

890
00:43:34,848 --> 00:43:37,718
放入结束后会缩小

891
00:43:38,418 --> 00:43:40,420
看上去比以前好多了

892
00:43:44,691 --> 00:43:47,661
现在来看一些不太好的地方

893
00:43:48,362 --> 00:43:52,366
在本例中
这是Drag Source最后一个面板

894
00:43:52,432 --> 00:43:53,867
有一个Slow Draggable Image View

895
00:43:53,934 --> 00:43:56,904
它们被称为slow 是因为
它们是来自于远程服务器的

896
00:43:56,970 --> 00:43:59,406
模拟项目

897
00:44:00,174 --> 00:44:02,543
如果我把这四张照片放到这里

898
00:44:02,843 --> 00:44:05,045
将需要很长时间进行加载

899
00:44:05,112 --> 00:44:06,280
事实上 由于时间太长

900
00:44:06,680 --> 00:44:09,249
将开始显示这个应用对话框

901
00:44:09,316 --> 00:44:11,251
让用户能够取消

902
00:44:12,152 --> 00:44:14,621
但是 从本演示的目的出发

903
00:44:14,688 --> 00:44:16,690
我们也希望对它进行自定义

904
00:44:16,757 --> 00:44:19,793
让我交回给汤姆
让他告诉我们应该怎么做

905
00:44:25,065 --> 00:44:28,468
那么我们如何处理
缓慢的数据交付呢？

906
00:44:29,803 --> 00:44:33,574
前面我说过
数据加载始终是异步 的

907
00:44:33,841 --> 00:44:35,909
这里有两个
非连续的时间线

908
00:44:35,976 --> 00:44:37,778
一个是数据加载

909
00:44:37,845 --> 00:44:41,415
另一个是放入预览动画显示
它们并不同步

910
00:44:42,015 --> 00:44:42,883
我们回到这张图中

911
00:44:42,950 --> 00:44:48,121
可以清晰地看到
这里的线条并不是一样长

912
00:44:48,488 --> 00:44:50,524
loadObject调用占用不同的时间

913
00:44:50,591 --> 00:44:52,860
预览动画占用不同的时间

914
00:44:53,126 --> 00:44:57,231
可以看到
现在我们还没有获得

915
00:44:57,297 --> 00:44:58,966
想要预览的数据

916
00:45:01,134 --> 00:45:04,071
可能会遇到的一个用例是

917
00:45:04,137 --> 00:45:07,074
从Photos拖动
照片到电子邮件

918
00:45:07,241 --> 00:45:09,243
但是这些照片可能
存储在iCloud上

919
00:45:09,309 --> 00:45:11,578
因为我们想要节省设备空间

920
00:45:12,112 --> 00:45:15,949
进行拖动时
将会显示这个应用模态界面

921
00:45:16,517 --> 00:45:20,354
向用户显示进度
并且让用户能够取消

922
00:45:21,788 --> 00:45:23,657
这是一个贴合实际的用例

923
00:45:24,791 --> 00:45:26,727
这里有一个“取消”按钮

924
00:45:26,793 --> 00:45:29,696
因为我们不想要用户永远等待

925
00:45:29,763 --> 00:45:33,133
我们不知道数据何时才会到达

926
00:45:33,233 --> 00:45:35,002
也许两秒 也许两分钟

927
00:45:35,068 --> 00:45:37,371
因此 我们为用户提供取消选项

928
00:45:37,437 --> 00:45:38,472
如果用户取消

929
00:45:38,539 --> 00:45:40,841
我们将使用nil数据调用
Completion代码块

930
00:45:40,908 --> 00:45:43,076
将会设置一个错误
让你能够发现错误

931
00:45:43,944 --> 00:45:45,012
此外

932
00:45:45,245 --> 00:45:48,248
会话和Item Providers
都提供ProgressReporting

933
00:45:48,315 --> 00:45:51,685
会话是ProgressReporting
因此可以观察其进度

934
00:45:52,319 --> 00:45:54,221
ItemProvider load方法

935
00:45:54,288 --> 00:45:57,357
返回一个进度对象
你可以使用这个对象

936
00:45:59,826 --> 00:46:01,161
进度具有取消处理程序

937
00:46:01,228 --> 00:46:04,131
用于处理取消操作

938
00:46:04,498 --> 00:46:07,334
在那里添加代码
以处理进入的任何项目

939
00:46:07,501 --> 00:46:12,005
和未进入的项目
你可以从模态界面中删除它们

940
00:46:13,440 --> 00:46:17,744
因此 我们可以自定义进度
正如文森前面所说的那样

941
00:46:18,579 --> 00:46:20,314
如果你不需要这种应用模态UI

942
00:46:20,380 --> 00:46:23,183
可以将session
progressIndicatorStyle

943
00:46:23,250 --> 00:46:26,553
设置为无 关闭它
就不会显示这样的UI

944
00:46:26,820 --> 00:46:31,225
这意味着 你需要自己
为用户进行这些处理

945
00:46:31,291 --> 00:46:33,393
为此 你可以观察进度

946
00:46:33,460 --> 00:46:34,828
会话有一个进度

947
00:46:34,895 --> 00:46:37,764
另外ItemProvider
返回每个项目的进度

948
00:46:38,465 --> 00:46:43,604
如果这样做 可以使用此进度信息
显示一些UI向用户告知进度情况

949
00:46:43,670 --> 00:46:46,874
可以看到
每个项目

950
00:46:46,940 --> 00:46:48,542
是否在加载数据

951
00:46:48,609 --> 00:46:51,144
但是应该允许用户
取消或导航到其它位置

952
00:46:51,211 --> 00:46:53,680
以避免用户
始终停留在你的视图上

953
00:46:56,283 --> 00:46:57,417
但是仍然存在一个大问题

954
00:46:57,484 --> 00:47:00,187
如果没有任何数据
如何生成预览呢？

955
00:47:00,254 --> 00:47:02,656
我想创建这个自定义预览
但是它并不起作用

956
00:47:02,723 --> 00:47:04,424
你们也不会成功

957
00:47:04,491 --> 00:47:08,195
如果没有数据
就不能创建新视图

958
00:47:08,695 --> 00:47:10,063
可以使用默认预览

959
00:47:10,130 --> 00:47:13,834
它准确地表示
项目中的实际内容

960
00:47:14,334 --> 00:47:15,969
是在拖动侧设置的

961
00:47:16,036 --> 00:47:18,872
因此可以用它来显示动画效果

962
00:47:19,039 --> 00:47:23,343
我们设置目标位置 添加变换效果
可以根据需要进行更改

963
00:47:25,812 --> 00:47:29,082
也可以设置一个占位符进度视图

964
00:47:29,183 --> 00:47:33,086
如果你想要显示某个内容
比如显示旋转图标

965
00:47:33,153 --> 00:47:37,324
只要适合你的UI
就是不错的主意

966
00:47:37,591 --> 00:47:39,226
一个好处是

967
00:47:39,293 --> 00:47:42,396
集合视图和表格视图
支持此特性

968
00:47:42,462 --> 00:47:44,231
因此你不必担心

969
00:47:44,531 --> 00:47:46,233
这很容易启用

970
00:47:46,600 --> 00:47:49,603
我知道明天早上9点

971
00:47:50,304 --> 00:47:53,106
WWDC第四天
有个演讲会讨论这些视图 请大家参加

972
00:47:53,173 --> 00:47:54,575
值得你们去听讲

973
00:47:56,276 --> 00:47:58,679
因此 不要推测数据将会到达

974
00:47:59,012 --> 00:48:01,048
这是我给你们的建议

975
00:48:01,682 --> 00:48:03,250
即使你在进行测试…

976
00:48:04,351 --> 00:48:07,354
在本地测试时
数据可能会立即到达

977
00:48:07,421 --> 00:48:09,323
但是对于用户来说可能并非如此

978
00:48:09,389 --> 00:48:11,992
你不知道数据
何时会到达

979
00:48:12,793 --> 00:48:15,095
请始终考虑到最坏的情况

980
00:48:15,162 --> 00:48:18,232
这是最好的做法
如果数据很快到达 当然好了

981
00:48:18,298 --> 00:48:20,534
但是也应该想到
可能会花费一定时间

982
00:48:21,835 --> 00:48:24,905
如果正确地进行实现
结果可能是这样的

983
00:48:34,047 --> 00:48:38,519
你可以看到
自定义进度条没有被阻止

984
00:48:40,220 --> 00:48:43,524
最后 让我们来讨论
如何通过添加拖拉

985
00:48:43,590 --> 00:48:45,292
来改善应用使用体验

986
00:48:45,359 --> 00:48:48,962
你可以在应用之间
进行拖放

987
00:48:49,029 --> 00:48:51,932
也可以利用拖放操作
改善你的应用

988
00:48:52,232 --> 00:48:55,802
在此方面
我们提供一些有用的API

989
00:48:55,869 --> 00:48:58,839
第一个是localDragSession:
UIDropSession

990
00:48:59,106 --> 00:49:02,242
这让你能够访问拖动会话
正如我前面实现的那样

991
00:49:02,876 --> 00:49:05,512
可以访问拖动会话中的
任何类型的数据

992
00:49:05,579 --> 00:49:09,383
你在任何阶段设置的项目
都是可用的

993
00:49:09,750 --> 00:49:11,852
这仅适用于应用内拖动

994
00:49:11,919 --> 00:49:13,287
如果拖动到应用之外

995
00:49:13,353 --> 00:49:16,757
拖动会话将不会有
相应的本地拖动会话

996
00:49:18,559 --> 00:49:22,563
另外 罗布前面演示过
有一个localObject on UIDragItem

997
00:49:23,330 --> 00:49:26,700
这是一个很好的本地数据容器

998
00:49:26,767 --> 00:49:32,139
可以使用它设置
itemsForBeginning会话中的状态

999
00:49:32,206 --> 00:49:35,676
并将这个状态
用于提升预览

1000
00:49:35,742 --> 00:49:39,713
也可以使用它将数据
从拖动位置传输到放入位置

1001
00:49:39,780 --> 00:49:45,018
相比之下 构建 itemProvider
在应用之外传输数据更复杂一些

1002
00:49:45,219 --> 00:49:47,120
如果允许拖动到应用之外

1003
00:49:47,187 --> 00:49:49,122
也应该这样做

1004
00:49:50,591 --> 00:49:54,628
最后还有 localContext
for UIDragSession允许你

1005
00:49:54,695 --> 00:50:00,000
在本地保留拖动会话
和放入会话的状态

1006
00:50:00,067 --> 00:50:02,903
而不必访问应用全局状态

1007
00:50:03,470 --> 00:50:05,839
这可以简化工作

1008
00:50:08,809 --> 00:50:10,944
如何将拖动保持在应用之内？

1009
00:50:11,011 --> 00:50:13,447
这需要
在dragInteraction delegate

1010
00:50:13,514 --> 00:50:17,684
sessionIsRestrictedTo
DraggingApplication上实现一个方法

1011
00:50:17,751 --> 00:50:19,152
在这里 如果返回真

1012
00:50:19,219 --> 00:50:21,622
就只能在应用内拖动

1013
00:50:21,688 --> 00:50:25,259
当然 用户也可以拖动到
你的应用之外

1014
00:50:25,325 --> 00:50:30,230
但是应用之外的任何放入会话
将会无视这个拖动

1015
00:50:30,297 --> 00:50:34,568
外观上并没有什么不同
但是不会接受任何放入

1016
00:50:34,635 --> 00:50:36,036
除非在应用之内

1017
00:50:36,603 --> 00:50:40,107
你可以在拖动和放入会话中
检查这个属性

1018
00:50:43,010 --> 00:50:46,380
最后一件事情
iPhone的本地拖放

1019
00:50:46,446 --> 00:50:48,415
默认情况下是禁止的

1020
00:50:48,482 --> 00:50:51,151
在iPad上 默认是启用的

1021
00:50:51,218 --> 00:50:56,256
因为你希望你的应用
根据大小类别进行运作

1022
00:50:56,323 --> 00:50:58,692
如果有一个边栏应用
将不会有问题

1023
00:50:58,759 --> 00:51:01,728
在iPad上
你可以拖入到其它应用

1024
00:51:01,795 --> 00:51:05,332
但是同样大小的应用
在iPhone就行不通

1025
00:51:05,399 --> 00:51:07,267
如果你想要
支持应用内的拖动与放入

1026
00:51:07,334 --> 00:51:09,169
而且也在iPhone上支持此功能

1027
00:51:09,236 --> 00:51:14,308
必须将拖动交互的
isEnabled属性设置为真

1028
00:51:14,374 --> 00:51:18,045
从而支持iPhone上的交互

1029
00:51:20,414 --> 00:51:23,083
接下来
文森将进行最后的演示

1030
00:51:28,622 --> 00:51:29,723
再次感谢汤姆

1031
00:51:29,790 --> 00:51:32,526
现在 我们利用学过的所有知识

1032
00:51:32,593 --> 00:51:35,662
来实现一个自定义进度UI

1033
00:51:35,729 --> 00:51:37,197
让我们来看代码

1034
00:51:37,264 --> 00:51:38,398
我们回过头来

1035
00:51:38,465 --> 00:51:41,101
重新访问 Droppable Image
Grid View Controller

1036
00:51:41,268 --> 00:51:44,605
这里有一个
我们前面实现的函数 用于执行放入

1037
00:51:44,671 --> 00:51:47,574
我们在这里添加几行代码

1038
00:51:48,275 --> 00:51:50,077
看上去是这样的

1039
00:51:53,714 --> 00:51:57,684
首先 我们将
progressIndicatorStyle设置为无

1040
00:51:57,751 --> 00:52:01,421
这命令UIKit
不显示模态对话框

1041
00:52:02,656 --> 00:52:04,491
然后 我们要记住
拖动项目的状态是

1042
00:52:04,558 --> 00:52:06,960
将要放入

1043
00:52:07,661 --> 00:52:09,596
接下来的重要一点是
我们要记住

1044
00:52:09,663 --> 00:52:13,166
我们插入网格的视图层次结构中的视图

1045
00:52:13,300 --> 00:52:17,471
以及当我们在ItemProvider上
加载对象时返回的进度

1046
00:52:18,172 --> 00:52:21,408
实现previewForDropping后
就很简单了

1047
00:52:23,277 --> 00:52:24,645
在这里 我们首先要做的是

1048
00:52:24,711 --> 00:52:28,515
从项目状态字典中读取一个状态

1049
00:52:28,582 --> 00:52:32,986
这个状态描述
被放入的项目的相关信息

1050
00:52:33,053 --> 00:52:36,223
它允许我们创建
一个新的进度旋转图标视图

1051
00:52:36,323 --> 00:52:40,194
这是一个自定义视图
用于显示旋转图标

1052
00:52:40,694 --> 00:52:42,729
以表示加载进度

1053
00:52:43,530 --> 00:52:45,165
在这里 我们创建了
这个自定义视图

1054
00:52:45,232 --> 00:52:47,901
其余部分与前面的内容相似
我们创建一个目标位置

1055
00:52:47,968 --> 00:52:51,772
并使用这个目标位置和参数
创建拖动预览

1056
00:52:52,739 --> 00:52:54,074
请思考这个问题

1057
00:52:54,341 --> 00:52:57,544
如果图像加载非常快
将会发生什么？

1058
00:52:58,111 --> 00:53:00,981
你会看到
当拖动动画还在显示时

1059
00:53:01,081 --> 00:53:04,418
目标位置已经有内容出现
我们看到这个拖动预览

1060
00:53:04,484 --> 00:53:06,854
飞到已经有内容的目标位置

1061
00:53:06,920 --> 00:53:09,790
而且放入预览会显示旋转加载图标

1062
00:53:09,857 --> 00:53:11,191
这看上去很奇怪

1063
00:53:11,425 --> 00:53:14,261
这将会处理边界情况

1064
00:53:14,328 --> 00:53:17,364
我们要做的是
将目的地视图的alpha参数设置为0

1065
00:53:17,431 --> 00:53:19,933
因此 在进行放入时
我们将隐藏

1066
00:53:20,000 --> 00:53:22,035
在目的地显示的任何内容

1067
00:53:22,302 --> 00:53:25,038
当放入结束时
将alpha参数设置回1

1068
00:53:25,105 --> 00:53:27,941
然后 目的地的放入预览

1069
00:53:28,008 --> 00:53:33,013
将会淡出 显示下方的实际目的地视图

1070
00:53:33,080 --> 00:53:35,482
这次我们将alpha设置为1

1071
00:53:35,782 --> 00:53:37,150
因此这将会满足我们的要求

1072
00:53:37,317 --> 00:53:39,620
还有最后一件事情

1073
00:53:40,320 --> 00:53:41,755
也就是实现concludeDrop

1074
00:53:41,822 --> 00:53:42,956
当放入完成时

1075
00:53:43,023 --> 00:53:45,058
我们需要进行良好的收尾工作

1076
00:53:45,125 --> 00:53:48,829
移除项目状态字典中

1077
00:53:48,896 --> 00:53:50,731
所有不再需要的项目

1078
00:53:51,532 --> 00:53:53,834
修改的地方很多

1079
00:53:54,768 --> 00:53:55,969
让我们来看执行效果

1080
00:54:00,908 --> 00:54:04,411
我要使用 Slow Draggable Image View
重复同样的方案

1081
00:54:04,478 --> 00:54:05,646
请看会发生什么

1082
00:54:06,380 --> 00:54:10,517
现在 每次进行放入时
每个被放入的项目

1083
00:54:10,584 --> 00:54:12,052
都有一个不同的进度UI

1084
00:54:12,686 --> 00:54:16,990
这很不错 因为这让我们
能够进行这样的操作

1085
00:54:17,457 --> 00:54:19,760
如果我重复相同的程序

1086
00:54:19,826 --> 00:54:22,496
可以看到 我可以
这样做 比如滚动图像视图

1087
00:54:22,563 --> 00:54:23,463
对不起 是网格视图

1088
00:54:23,530 --> 00:54:27,868
而且在进入加载时
与多个不同的项目进行交互

1089
00:54:32,706 --> 00:54:34,208
这是很不错的功能

1090
00:54:34,274 --> 00:54:36,210
今天的演讲讨论了很多内容

1091
00:54:36,443 --> 00:54:39,379
现在我想让汤姆
为我们进行简要回顾

1092
00:54:39,880 --> 00:54:40,714
实验室再见

1093
00:54:47,221 --> 00:54:49,556
看上去真不错

1094
00:54:50,490 --> 00:54:51,325
让我们进行回顾

1095
00:54:52,025 --> 00:54:53,927
我们讨论了
拖动和放入操作如何成为

1096
00:54:53,994 --> 00:54:57,798
应用中非常有用、
用户主导的输入输出机制

1097
00:54:58,932 --> 00:55:01,568
你可以创建自定义
和精彩美观的视觉效果

1098
00:55:01,635 --> 00:55:04,972
在右侧 在放入侧
以及当你取消时

1099
00:55:05,706 --> 00:55:07,040
可以呈现许多动画效果

1100
00:55:07,574 --> 00:55:11,778
我们讨论了如何处理
异步数据和慢速加载数据

1101
00:55:12,246 --> 00:55:15,616
最后 我们讲述
如何在应用内使用拖动和放入

1102
00:55:15,682 --> 00:55:17,351
来提升使用体验

1103
00:55:19,586 --> 00:55:22,256
这里有一些参考演讲
你们可以重新观看视频

1104
00:55:22,322 --> 00:55:27,261
希望你们没有错过这些演讲

1105
00:55:27,928 --> 00:55:31,632
还有一些相关的演讲
包括昨天的“拖动与放入简介”

1106
00:55:32,199 --> 00:55:35,469
请观看此视频
里面的内容很丰富

1107
00:55:35,802 --> 00:55:40,174
另外 明天还有两个演讲
“集合视图与表格视图”

1108
00:55:40,240 --> 00:55:43,577
和“数据交付”
在2号厅依次进行

1109
00:55:43,944 --> 00:55:46,747
感谢参加本演讲
请关注WWDC的其余部分

1110
00:55:46,813 --> 00:55:47,714
再见

