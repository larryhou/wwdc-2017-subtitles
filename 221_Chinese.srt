1
00:00:30,597 --> 00:00:32,933
下午好各位
感谢你们来到这里

2
00:00:33,000 --> 00:00:35,402
欢迎来到“Health新特性”

3
00:00:35,469 --> 00:00:36,436
我叫亚历克萨

4
00:00:36,503 --> 00:00:38,906
我是名HealthKit团队的
软件工程师

5
00:00:39,306 --> 00:00:43,243
作为团队的一员
我最喜欢的一部分就是能够看到

6
00:00:43,310 --> 00:00:45,846
科技能够帮助人们改善生活

7
00:00:45,979 --> 00:00:47,414
就像许多我们的用户一样

8
00:00:47,981 --> 00:00:50,551
我非常喜欢使用所有那些健身功能

9
00:00:50,617 --> 00:00:52,119
在Apple Watch上

10
00:00:52,486 --> 00:00:55,889
每天让我的环闭合
并且与我的朋友们分享我的活动

11
00:00:55,956 --> 00:00:59,026
而且集成了你们所开发的
那些很棒的健身应用之后

12
00:00:59,092 --> 00:01:00,460
把健身变得更简单了

13
00:01:02,396 --> 00:01:04,197
许多人还使用科技

14
00:01:04,263 --> 00:01:07,034
来帮助他们追踪其他的健康组成部分
像是睡眠

15
00:01:07,234 --> 00:01:11,071
对于更好地了解睡眠可以帮助你
为白天做好准备

16
00:01:11,138 --> 00:01:12,606
而且可以晚上睡个好觉

17
00:01:14,041 --> 00:01:17,344
不过 我们的许多用户
还依赖于一些技术

18
00:01:17,411 --> 00:01:19,479
我们甚至都没有考虑过这些技术

19
00:01:20,314 --> 00:01:23,450
例如 控制长期的情况 像是糖尿病

20
00:01:24,751 --> 00:01:27,120
在iOS和watchOS上

21
00:01:27,321 --> 00:01:30,691
所有这些个人健康数据的家
就是HealthKit

22
00:01:32,693 --> 00:01:36,330
我们发现用户很喜欢
我们的健康生态系统

23
00:01:36,396 --> 00:01:37,931
通过HealthKit的创新

24
00:01:37,998 --> 00:01:41,368
你的应用可以立刻享受到这些保证
像是隐私

25
00:01:41,435 --> 00:01:44,771
透明度还有控制
这些都是我们致力于提供给用户的

26
00:01:45,806 --> 00:01:47,341
所以 在接下来的60分钟里

27
00:01:47,407 --> 00:01:50,077
我们会看看
今年我们的SDK有什么新特性

28
00:01:50,143 --> 00:01:52,279
在iOS 11和watchOS 4中

29
00:01:52,346 --> 00:01:53,814
用来继续帮助你们创造出

30
00:01:53,881 --> 00:01:56,183
在Apple平台上的创新健康技术

31
00:01:57,084 --> 00:01:57,918
让我们开始吧

32
00:01:59,286 --> 00:02:01,121
首先我们会快速说明下

33
00:02:01,188 --> 00:02:03,390
今年HealthKit中的
新数据类型

34
00:02:04,992 --> 00:02:07,895
在那之后 我们会说一下
对于锻炼API的一些常规更新

35
00:02:07,961 --> 00:02:10,297
借以得到出很棒的健身体验

36
00:02:11,798 --> 00:02:15,068
再接着我们会引入一个新功能
叫作同步标识符

37
00:02:15,135 --> 00:02:17,671
它会帮助你们跨设备消除数据

38
00:02:19,373 --> 00:02:21,008
最后 我们有一些要分享的更新

39
00:02:21,074 --> 00:02:23,477
是为用户控制糖尿病所提供的支持

40
00:02:25,279 --> 00:02:27,548
让我们从新的HealthKit类型
开始说起吧

41
00:02:27,614 --> 00:02:29,249
如果你之前使用过HealthKit

42
00:02:29,316 --> 00:02:31,418
你会知道
我们将所有的个人数据进行分类

43
00:02:31,485 --> 00:02:34,288
分为许多不同的类型后
再存入HealthKit

44
00:02:34,354 --> 00:02:36,590
我们今年要引入几个新的类型

45
00:02:37,491 --> 00:02:39,359
我会从样本类型开始讲起

46
00:02:39,560 --> 00:02:42,129
你所存入HealthKit的样本
就是小片的数据

47
00:02:42,196 --> 00:02:45,332
该数据有着特定的时间戳和类型

48
00:02:46,567 --> 00:02:50,404
我们今年的第一个新类型
叫作HKWorkoutRoute

49
00:02:50,637 --> 00:02:54,942
锻炼路线可以让你
保存锻炼中的主机托管地图

50
00:02:55,008 --> 00:02:57,778
我会在演讲的晚些时候
再谈关于它的更多细节

51
00:02:59,813 --> 00:03:02,049
我们还引入了腰围

52
00:03:02,115 --> 00:03:05,519
这是个类似于身高或者体重的体标

53
00:03:05,586 --> 00:03:08,956
用户可以随时间推移追踪并
更好地理解他们身体的变化

54
00:03:11,024 --> 00:03:14,228
我们今年引入的另一个身体测量指标
是最大VO2

55
00:03:14,294 --> 00:03:17,698
最大VO2测量的是氧气的最大吸入率

56
00:03:17,764 --> 00:03:18,966
在运动峰值的时候

57
00:03:19,299 --> 00:03:22,903
特别酷的是在watchOS 4上
Apple Watch

58
00:03:22,970 --> 00:03:27,674
甚至可以预估特定户外健走
和跑步的最大VO2值

59
00:03:27,875 --> 00:03:29,843
因此 有了浏览这项数据的权限后

60
00:03:29,910 --> 00:03:34,615
你的应用就可以看到由Apple Watch
所预估的最大VO2值

61
00:03:35,949 --> 00:03:38,619
最后 就是我们HealthKit中
需求呼声最大的类型之一

62
00:03:38,685 --> 00:03:40,988
我们今年引入了胰岛素注入

63
00:03:41,054 --> 00:03:42,956
我的同事迈克尔会讲解这部分

64
00:03:46,860 --> 00:03:50,230
我的同事迈克尔会在演讲的晚些时候
给你们讲解关于它的更多细节

65
00:03:50,664 --> 00:03:52,199
除了这些样本类型之外

66
00:03:52,266 --> 00:03:55,035
我们还引入了一些新的锻炼活动类型

67
00:03:55,102 --> 00:03:58,071
它们将你的用户
在做的不同锻炼进行了分类

68
00:03:58,205 --> 00:04:02,576
我们涵盖了其中的很多种
而且它们也会配置你的锻炼方式

69
00:04:03,844 --> 00:04:06,513
我们今年引入的第一个
新锻炼活动类型是太极

70
00:04:06,580 --> 00:04:10,317
还有混合有氧运动 最后是手骑自行车

71
00:04:10,617 --> 00:04:13,253
你就可以使用这些新类型来实现
更多的健身体验

72
00:04:13,320 --> 00:04:14,321
给你的用户

73
00:04:16,055 --> 00:04:20,060
除了我们这些新的锻炼活动类型
我们还有一些常规更新

74
00:04:20,127 --> 00:04:21,195
是给我们的锻炼API的

75
00:04:21,928 --> 00:04:25,065
其中有些是依赖于我们秋季发布的新品

76
00:04:25,132 --> 00:04:27,034
也就是我们发布的
Apple Watch Series 2

77
00:04:27,100 --> 00:04:30,103
其中有些是今年在iOS11
和watchOS 4中新推出的

78
00:04:30,437 --> 00:04:32,472
我们会谈到一些关于游泳的更新

79
00:04:32,539 --> 00:04:36,777
我们会讲到新的分段API
还会介绍一种新的方式

80
00:04:36,844 --> 00:04:38,912
你的应用可以用它来暂停和恢复锻炼

81
00:04:39,646 --> 00:04:43,150
去年秋天我们发布了
Apple Watch Series 2

82
00:04:43,217 --> 00:04:46,386
人们非常喜欢戴着他们的手表游泳

83
00:04:46,453 --> 00:04:50,057
你可以在游泳池戴着它
也可以在海里和湖里

84
00:04:50,257 --> 00:04:53,427
我要开始谈下一些追踪的类型

85
00:04:53,493 --> 00:04:55,863
即当你游泳锻炼时
Apple Watch所做的

86
00:04:55,929 --> 00:04:58,498
然后再谈下今年的一些新东西

87
00:05:00,000 --> 00:05:02,503
首先 正如我所说的
我们已经支持了游泳池

88
00:05:02,569 --> 00:05:03,904
和开放水域游泳

89
00:05:04,204 --> 00:05:06,640
对于泳池游泳 你可以配置泳道的长度

90
00:05:06,707 --> 00:05:09,209
以便得到更准确的锻炼数据

91
00:05:10,777 --> 00:05:13,647
我们还会自动追踪一些关键的游泳指标

92
00:05:14,014 --> 00:05:18,585
首先第一个是游程以及泳姿记录

93
00:05:19,119 --> 00:05:20,487
若你熟悉HealthKit

94
00:05:20,554 --> 00:05:23,657
你就会注意需要开启一个新的查询
来追踪相应的样本

95
00:05:23,724 --> 00:05:25,392
即在锻炼时你感兴趣的样本数据

96
00:05:25,459 --> 00:05:27,895
例如 用户燃烧的卡路里数

97
00:05:27,961 --> 00:05:30,430
或者他们的实时心率

98
00:05:30,931 --> 00:05:34,034
同样地
这两个指标你也要开启一个新的查询

99
00:05:34,101 --> 00:05:37,471
在锻炼中进行追踪
以便你可以给你的用户实时显示

100
00:05:39,206 --> 00:05:41,642
Apple Watch
还可以探测单独的圈数

101
00:05:41,708 --> 00:05:43,443
当用户正在游泳的时候

102
00:05:44,211 --> 00:05:47,314
另外
我们甚至可以追踪每圈所用的泳姿

103
00:05:47,381 --> 00:05:49,016
这很酷 而且可以给出

104
00:05:49,082 --> 00:05:52,352
锻炼时真正的实时数据

105
00:05:53,754 --> 00:05:56,723
泳姿探测是被存为元数据的

106
00:05:56,790 --> 00:06:00,827
包括泳姿计数样本 还有每圈的事件

107
00:06:00,994 --> 00:06:03,330
我们会看下这是什么样的

108
00:06:04,631 --> 00:06:09,002
今年在watchOS 4中
我们还新加入了自动组探测

109
00:06:09,069 --> 00:06:11,605
也就是HealthKit会探测用户

110
00:06:11,672 --> 00:06:14,441
持续游泳的时间 并醒目通知给用户

111
00:06:14,775 --> 00:06:17,377
而且你的应用也可以访问这些信息

112
00:06:18,645 --> 00:06:21,448
今年watchOS 4新特性还有

113
00:06:22,583 --> 00:06:24,551
你的应用现在可以开启水锁

114
00:06:24,685 --> 00:06:26,653
这真的是个很棒的功能

115
00:06:26,720 --> 00:06:30,123
可以让你的应用忽略一切
水中的屏幕操作

116
00:06:30,190 --> 00:06:33,026
这会带来很棒的一致性用户体验

117
00:06:33,360 --> 00:06:35,229
用户想退出水锁的时候

118
00:06:35,295 --> 00:06:38,232
只需要扭动他们表上的数字表冠

119
00:06:38,298 --> 00:06:42,102
它会发生特定的声音来说明
已经把扬声器里的水排出来了

120
00:06:43,904 --> 00:06:47,574
现在让我们看一些新的元数据键和值

121
00:06:47,641 --> 00:06:49,576
它们是在游泳中被引入的

122
00:06:50,310 --> 00:06:52,179
如我所说 我们有位置类型

123
00:06:52,246 --> 00:06:55,849
其中包括了泳池 开放水域 还有未知

124
00:06:57,117 --> 00:06:59,853
我们还有泳姿类型

125
00:06:59,920 --> 00:07:03,390
包括了常见的泳姿 像是自由泳和仰泳

126
00:07:03,457 --> 00:07:05,926
还有未知或者混合泳

127
00:07:08,962 --> 00:07:11,131
假如说你想开发一个游泳应用

128
00:07:11,198 --> 00:07:13,233
且你想知道如何利用
HealthKit开始进行开发

129
00:07:13,300 --> 00:07:15,969
首先第一步就是要配置一个游泳锻炼

130
00:07:16,036 --> 00:07:18,805
比方说 我们这里做的泳池游泳锻炼

131
00:07:19,106 --> 00:07:22,776
首先我们要创建
HKWorkoutConfiguration对象

132
00:07:23,477 --> 00:07:25,145
接下来 我们要设定它的一些属性

133
00:07:25,212 --> 00:07:27,347
首先 活动类型是游泳

134
00:07:28,649 --> 00:07:31,752
游泳位置类型
我们说了是要做泳池游泳

135
00:07:32,586 --> 00:07:33,687
然后就是泳道长度

136
00:07:33,754 --> 00:07:36,857
这里我将HKQuantity里
的数值设为25码

137
00:07:36,924 --> 00:07:38,792
这是个常见的泳池长度

138
00:07:39,393 --> 00:07:43,130
接着我们要通过创建一个会话对象
来开启我们的会话

139
00:07:43,197 --> 00:07:44,965
然后将这个对象
传给healthStore

140
00:07:45,966 --> 00:07:48,769
首先我们要创建新的锻炼会话

141
00:07:48,836 --> 00:07:50,304
然后将它传给配置

142
00:07:50,671 --> 00:07:55,108
你会注意到HKWorkout会话
的构造器是可以抛出的

143
00:07:55,309 --> 00:07:58,712
当你传了一个非法的锻炼配置时
它就会抛出异常

144
00:07:58,846 --> 00:08:02,249
例如 你想要在开放水域
游泳中设定泳道长度

145
00:08:02,683 --> 00:08:04,551
所以请确保你的代码处理了这种情况

146
00:08:05,886 --> 00:08:09,523
接着我们要把锻炼会话的代理
设为它自己

147
00:08:09,590 --> 00:08:13,160
以便我们可以在游泳事件发生时
收到来自HealthKit的回调函数

148
00:08:14,761 --> 00:08:16,830
最后我们要真的开始这个会话

149
00:08:16,897 --> 00:08:19,032
通过调用healthStore
的start方法

150
00:08:19,099 --> 00:08:21,335
并传入我们刚刚创建的会话

151
00:08:22,069 --> 00:08:24,638
很好 现在我们的游泳会话就开始了

152
00:08:24,705 --> 00:08:27,207
我们可能还想为本次锻炼开启水锁

153
00:08:28,675 --> 00:08:31,678
一个合适的地方就是在
我们的锻炼会话状态改变为

154
00:08:31,745 --> 00:08:32,746
开始运行的时候

155
00:08:32,846 --> 00:08:36,416
这是因为只有你有个激活的锻炼时
这个API才会工作

156
00:08:36,482 --> 00:08:40,654
或者说有个正在运行的位置会话
并且你是出于前台的话

157
00:08:41,054 --> 00:08:42,155
让我们看看这个方法

158
00:08:42,222 --> 00:08:45,292
workout session didchangeTo
fromState和date

159
00:08:46,827 --> 00:08:49,596
我们会从fromState
切换到toState

160
00:08:50,464 --> 00:08:53,700
在本例中我们感兴趣的是
从notStarted切换到running

161
00:08:53,767 --> 00:08:55,903
通过这样我们能知道会话开始了

162
00:08:56,803 --> 00:09:00,140
而这里我们想
抓取共享的WatchKit扩展

163
00:09:00,207 --> 00:09:02,376
然后在它上面调用开启水锁

164
00:09:04,611 --> 00:09:07,981
我们除了改动游泳数据类型

165
00:09:08,048 --> 00:09:10,684
还改变了我们的锻炼事件

166
00:09:10,751 --> 00:09:11,785
来更好地支持游泳功能

167
00:09:11,852 --> 00:09:14,721
还有更多大体上一致的锻炼体验

168
00:09:15,122 --> 00:09:17,824
让我们从
HKWorkoutEvent开始看起

169
00:09:19,393 --> 00:09:22,396
WorkoutEvents醒目标明了
你锻炼时的某个特定时间

170
00:09:23,664 --> 00:09:27,935
它可以用来暂停和恢复锻炼
还可以记录像是圈数以及标记这些数据

171
00:09:28,001 --> 00:09:31,305
标记可以是你应用中任何数据的组合

172
00:09:31,371 --> 00:09:33,640
且你可以把数据存储在事件的元数据中

173
00:09:33,707 --> 00:09:35,676
你可以选择存储你所需要的数据

174
00:09:37,578 --> 00:09:40,147
事件是通过HealthKit
和你的应用共同创建的

175
00:09:40,514 --> 00:09:42,883
这很关键
因为HealthKit会创建事件

176
00:09:42,950 --> 00:09:44,651
并把这些事件马上传给你

177
00:09:44,718 --> 00:09:48,121
这样你就可得到关于圈数和泳姿的信息

178
00:09:48,188 --> 00:09:51,692
还有锻炼应用
通常会有的暂停和恢复功能

179
00:09:53,460 --> 00:09:57,264
WorkoutEvent
被存在HKWorkout的一个列表中

180
00:09:57,497 --> 00:09:59,967
这样你在查询锻炼信息的时候
就能从列表将其取回了

181
00:10:00,033 --> 00:10:02,769
或是你从其他应用查看锻炼信息的时候

182
00:10:04,304 --> 00:10:07,107
另外 锻炼事件会影响锻炼的持续时间

183
00:10:07,474 --> 00:10:10,244
特别是暂停和恢复事件

184
00:10:10,310 --> 00:10:13,547
如果说我要跑步10分钟
并且暂停了1分钟

185
00:10:13,614 --> 00:10:15,382
HealthKit会发现一个暂停事件

186
00:10:15,449 --> 00:10:17,251
1分钟后紧接着一个恢复事件

187
00:10:17,317 --> 00:10:21,154
然后如我们所期望的那样
计算出总的跑步持续时间为9分钟

188
00:10:22,489 --> 00:10:25,092
让我们看看如何观察圈数事件

189
00:10:25,158 --> 00:10:26,593
回到我们的游泳例子中来

190
00:10:28,262 --> 00:10:31,565
我们有这个方法
workoutSession和didGenerate event

191
00:10:31,632 --> 00:10:33,267
HealthKit会在这个方法中传你的事件

192
00:10:33,333 --> 00:10:34,768
当你进行锻炼的时候

193
00:10:35,869 --> 00:10:38,906
我们要切换所给的事件类型

194
00:10:39,606 --> 00:10:41,909
这里我们感兴趣的是圈数

195
00:10:43,443 --> 00:10:46,547
有了圈数事件后
我们就可在应用中具体实现某些功能了

196
00:10:46,613 --> 00:10:49,583
像是计数加一
我们可以把它实时呈现给用户

197
00:10:51,051 --> 00:10:53,787
我们还可以从圈数事件中抓取泳姿类型

198
00:10:54,188 --> 00:10:56,223
泳姿类型是以元数据形式存储的

199
00:10:56,423 --> 00:10:59,826
我们想要得到关键泳姿的元数据

200
00:10:59,893 --> 00:11:02,396
然后再实现某些具体功能 像是

201
00:11:02,462 --> 00:11:04,331
给用户显示当前的泳姿

202
00:11:06,200 --> 00:11:09,169
如你所见
你能借此创造出极其详尽的体验

203
00:11:09,236 --> 00:11:12,105
来让你的用户一抬手腕就很快看到

204
00:11:14,041 --> 00:11:17,978
我们今年在iOS 11和watchOS 4上
还有一些新的锻炼事件

205
00:11:19,746 --> 00:11:22,449
这是我们现有的锻炼类型枚举

206
00:11:23,483 --> 00:11:26,320
而今年 我们新加入了分段
暂停和恢复

207
00:11:26,687 --> 00:11:29,323
这些新类型对于游泳功能
都有很重要的影响

208
00:11:29,389 --> 00:11:31,992
不过它们也能用到所有锻炼应用上

209
00:11:33,694 --> 00:11:35,562
让我们开始看看分段吧

210
00:11:35,629 --> 00:11:37,998
不是只呈现某个时刻

211
00:11:38,198 --> 00:11:40,801
分段可以呈现一个时刻
以及一段持续时间

212
00:11:41,668 --> 00:11:45,305
这就让我们更新了现有的锻炼事件类

213
00:11:45,372 --> 00:11:47,441
之前我们有一个日期属性

214
00:11:48,542 --> 00:11:51,378
我们用一个日期间隔属性将其替换了

215
00:11:51,879 --> 00:11:54,181
因此对于所有之前存在
HealthKit的事件来说

216
00:11:54,248 --> 00:11:57,384
日期就成为了状态间隔的起始时间

217
00:11:57,451 --> 00:11:59,152
并且其持续时间为0

218
00:11:59,953 --> 00:12:03,423
而对于分段来说
你会有起始时间和持续时间

219
00:12:03,490 --> 00:12:06,393
或者在该日期间隔上的
起始时间和结束时间

220
00:12:07,461 --> 00:12:09,663
我想给你们展示一下
有间隔的时间线是什么样的

221
00:12:09,730 --> 00:12:11,265
对于一个典型的游泳锻炼

222
00:12:11,331 --> 00:12:13,367
所有你在应用中获取到的事件

223
00:12:13,433 --> 00:12:15,869
发生在你的锻炼会话中

224
00:12:17,871 --> 00:12:19,640
首先让我们开始锻炼

225
00:12:20,741 --> 00:12:22,142
我们的用户开始游泳了

226
00:12:22,476 --> 00:12:26,180
这些灰点表示用户游泳的圈数事件

227
00:12:26,480 --> 00:12:28,148
如果我们查看某个特定的圈数事件

228
00:12:28,215 --> 00:12:30,184
你会发现事件的类型是圈数

229
00:12:30,717 --> 00:12:34,488
它有一个日期间隔
这里它的起始时间为2

230
00:12:35,022 --> 00:12:37,491
它还有泳姿的元数据

231
00:12:37,558 --> 00:12:39,560
我们的用户在做的是自由泳

232
00:12:41,361 --> 00:12:44,731
用户接着游 然后决定将泳姿换成蝶泳

233
00:12:44,798 --> 00:12:46,233
这会马上反映在

234
00:12:46,300 --> 00:12:48,869
你应用所接收到的下一个圈数事件中

235
00:12:50,304 --> 00:12:53,240
然后用户可能决定暂停锻炼

236
00:12:53,307 --> 00:12:55,175
那么你就会得到一个暂停事件

237
00:12:55,242 --> 00:12:57,644
在这个例子中
你不会得到暂停事件的元数据

238
00:12:57,978 --> 00:13:01,381
而且你的日期间隔
只有起始时间而没有持续时间

239
00:13:03,250 --> 00:13:07,654
现在watchOS 4中
HealthKit会生成自动组数探测

240
00:13:07,721 --> 00:13:09,289
对于这个特定的游泳锻炼

241
00:13:09,356 --> 00:13:11,925
还有用户持续游泳的时间

242
00:13:12,092 --> 00:13:16,964
因此这个分段事件的起始时间为0
结束时间为3:30

243
00:13:17,030 --> 00:13:18,131
也就是用户暂停的时间

244
00:13:18,398 --> 00:13:20,767
并且在本例中它没有任何元数据

245
00:13:22,769 --> 00:13:26,240
现在用户又恢复了锻炼
我们收到了相应的事件

246
00:13:26,440 --> 00:13:28,742
他们又换回了自由泳

247
00:13:29,176 --> 00:13:32,746
在6:30分这个点
我们的用户感觉累了

248
00:13:32,813 --> 00:13:35,582
他们决定在泳池边停下歇会儿

249
00:13:35,649 --> 00:13:37,851
但是他们忘了暂停锻炼

250
00:13:38,118 --> 00:13:41,054
不过HealthKit仍然会生成一个事件

251
00:13:41,121 --> 00:13:43,690
来记录用户持续游泳的时间

252
00:13:44,024 --> 00:13:46,426
所以分段就是从他们恢复锻炼开始

253
00:13:46,493 --> 00:13:48,462
到他们主动停止游泳结束

254
00:13:50,063 --> 00:13:53,133
我们的用户休息好之后又开始游了

255
00:13:53,200 --> 00:13:57,337
HealthKit从他们又开始游起
生成了最后一个分段

256
00:13:57,404 --> 00:13:58,839
一直到锻炼结束

257
00:13:59,239 --> 00:14:02,743
如你所见 你可以使用这些分段信息
来创造出非常丰富的游泳体验

258
00:14:02,809 --> 00:14:04,511
不过你的应用还可以生成其他分段

259
00:14:04,578 --> 00:14:07,681
而该分段是特别针对于
你所开发应用的其他锻炼类型的

260
00:14:09,883 --> 00:14:12,452
我们今年新添加的其他锻炼事件

261
00:14:12,519 --> 00:14:14,121
就是暂停和恢复请求

262
00:14:14,454 --> 00:14:17,457
若你用过Apple Watch的锻炼应用
你可能会熟悉

263
00:14:17,524 --> 00:14:20,827
同时按住数字表冠和侧边按钮这个操作

264
00:14:20,894 --> 00:14:23,630
这样无需点击屏幕就能暂停你的锻炼

265
00:14:23,697 --> 00:14:26,700
而今年 你的应用也可以这么做了

266
00:14:28,035 --> 00:14:31,338
就是快速按下数字表冠和侧边按钮

267
00:14:32,272 --> 00:14:33,707
它同样适用于水锁

268
00:14:33,807 --> 00:14:36,844
这对游泳应用来说很棒

269
00:14:36,910 --> 00:14:39,813
因为你的用户根本不用点击屏幕

270
00:14:39,880 --> 00:14:43,283
或者干扰他们锻炼
他们只需要按下按钮就可以暂停了

271
00:14:45,953 --> 00:14:49,523
像其他事件一样
你要在锻炼会话代理中对其进行处理

272
00:14:49,590 --> 00:14:52,860
不过需要注意的是
我们不会自动暂停和恢复

273
00:14:52,926 --> 00:14:55,128
当接收到这个事件的时候

274
00:14:55,195 --> 00:14:57,931
会实现什么行为实际上取决于你的应用

275
00:14:57,998 --> 00:14:59,266
调用的是暂停还是恢复

276
00:15:00,100 --> 00:15:03,637
让我们看下如果开启了这个行为
看上去是什么样的

277
00:15:05,138 --> 00:15:08,442
首先我们的用户
会按下数字表冠和侧边按钮

278
00:15:08,509 --> 00:15:10,143
来表明他们想要暂停

279
00:15:11,378 --> 00:15:14,147
接着HealthKit会生成
一个暂停和恢复请求

280
00:15:15,315 --> 00:15:18,552
你的应用在锻炼会话代理中
收到这个请求

281
00:15:18,619 --> 00:15:20,320
然后可以选择是不是回应它

282
00:15:20,387 --> 00:15:22,222
这里我们要回应它

283
00:15:23,190 --> 00:15:25,592
根据我们的状态
我们会暂停或者恢复

284
00:15:25,893 --> 00:15:27,961
如果我们正在跑 想暂停

285
00:15:28,028 --> 00:15:30,397
而如果我们正在暂停 想恢复

286
00:15:31,665 --> 00:15:33,033
当HealthKit接收到该改变时

287
00:15:33,100 --> 00:15:36,537
它就会这个暂停或者恢复
生成一个新的事件

288
00:15:36,837 --> 00:15:39,273
最后 这个暂停或是恢复事件

289
00:15:39,339 --> 00:15:41,675
也会被你的锻炼会话代理所接收

290
00:15:42,509 --> 00:15:45,779
我们觉得这是个不错的
用来提供持续性体验的功能

291
00:15:45,846 --> 00:15:47,681
对于使用不同锻炼应用的用户来说

292
00:15:47,748 --> 00:15:50,584
我们希望你可以采纳并持续使用它

293
00:15:54,555 --> 00:15:58,492
今年我们引入的另一个令人兴奋
的新锻炼API

294
00:15:58,559 --> 00:15:59,860
是锻炼路径

295
00:16:00,060 --> 00:16:02,863
用户可以用它来追踪锻炼时的位置

296
00:16:02,930 --> 00:16:06,099
人们很喜欢在用
Apple Watch Series 2的时候这么做

297
00:16:06,967 --> 00:16:09,503
人们在进行马拉松长跑时候会用它

298
00:16:09,570 --> 00:16:12,639
或者是在金门公园慢跑的时候

299
00:16:13,307 --> 00:16:17,077
让我们看下你的应用
应该如何从HealthKit中获得这个数据

300
00:16:18,812 --> 00:16:21,915
我们有一个新的数据类型叫作
HKWorkoutRouteType

301
00:16:22,916 --> 00:16:26,086
重要的是这个类型需要额外的授权

302
00:16:26,153 --> 00:16:27,688
它有两个前提

303
00:16:27,888 --> 00:16:31,925
首先 即使你已经有了
从HealthKit读写锻炼数据的权限

304
00:16:31,992 --> 00:16:35,028
你仍然需要额外读写
WorkoutRoutes的授权

305
00:16:35,128 --> 00:16:37,731
除外真正获得用户的位置

306
00:16:37,798 --> 00:16:40,868
你还要从Core Location
获得权限或授权

307
00:16:40,934 --> 00:16:42,769
来查看用户的位置

308
00:16:44,538 --> 00:16:47,641
HealthKit将WorkoutRoutes作为
CLLocation的一个数组来进行建模

309
00:16:47,708 --> 00:16:49,243
也就是Core Location Location

310
00:16:49,510 --> 00:16:52,713
每个位置信息包括了经纬度
和其他一些数据

311
00:16:52,779 --> 00:16:55,182
像是当时在该位置的速度

312
00:16:57,317 --> 00:17:00,153
值得注意的是
这些数据集可能会很大

313
00:17:00,220 --> 00:17:03,423
在马拉松的例子中
它可能是数千个数据点

314
00:17:03,590 --> 00:17:07,661
因此我们要引入一个新的查询

315
00:17:07,728 --> 00:17:10,696
专门为WorkoutRoutes而做
也就是HKWorkoutRouteQuery

316
00:17:12,499 --> 00:17:15,502
它会分批返回位置数据
而不是一次返回全部

317
00:17:15,569 --> 00:17:18,204
你就不用一次把所有数据都放内存中了

318
00:17:19,640 --> 00:17:21,608
让我们来看下代码是怎么样的

319
00:17:21,675 --> 00:17:23,410
用来从HealthKit中
读取WorkoutRoute

320
00:17:24,711 --> 00:17:26,480
我们假设已经有某个锻炼

321
00:17:26,547 --> 00:17:28,815
是我们感兴趣的
并且被保存成了一个锻炼对象

322
00:17:29,983 --> 00:17:35,055
首先我们要在HKSeriesType上
调用WorkoutRoute来创建想要的类型

323
00:17:35,589 --> 00:17:37,291
然后我们创建一个断言

324
00:17:37,357 --> 00:17:39,760
给与我们锻炼有关的对象

325
00:17:41,094 --> 00:17:43,797
接着我们要使用
HKSampleQuery

326
00:17:43,997 --> 00:17:47,401
这个现有的查询会返回
某个特定类型的样本数据

327
00:17:47,501 --> 00:17:49,636
我们要传入WorkoutRoute类型

328
00:17:49,703 --> 00:17:51,338
还有锻炼的断言

329
00:17:51,805 --> 00:17:55,776
我们对于本例中要接收回来的样本数据
没有任何限制

330
00:17:55,843 --> 00:17:57,678
我们没有任何的种类描述符

331
00:17:59,313 --> 00:18:01,315
所以就会返回查询本身

332
00:18:01,381 --> 00:18:04,618
还有我们感兴趣的样本以及潜在的错误

333
00:18:06,019 --> 00:18:07,521
我们首先第一步要注意的是

334
00:18:07,588 --> 00:18:10,724
我们返回的样本
实际上是HKWorkoutRoutes

335
00:18:12,226 --> 00:18:14,261
而第二步就是要从

336
00:18:14,328 --> 00:18:16,763
每个路径查询原始位置数据

337
00:18:18,065 --> 00:18:21,134
这里新的HKWorkoutRouteQuery
就会起作用了

338
00:18:21,268 --> 00:18:24,972
它会接收锻炼路径作为参数
然后返回该查询

339
00:18:25,372 --> 00:18:26,807
而原始位置

340
00:18:26,874 --> 00:18:29,743
是一个用来表明数据
是否已经分批传送给你的布尔值

341
00:18:29,810 --> 00:18:31,211
还会指示某个潜在的错误

342
00:18:33,113 --> 00:18:35,215
这里我们想让应用实现某个特定的功能

343
00:18:35,282 --> 00:18:37,084
像是将位置数据加到地图上

344
00:18:37,618 --> 00:18:40,420
要注意的是
这个代码段可能会被调用好多次

345
00:18:40,487 --> 00:18:42,389
因为数据是分批返回给你的

346
00:18:43,657 --> 00:18:47,027
最后 我们通过调用执行查询
来运行这个方法

347
00:18:47,561 --> 00:18:51,031
或是将这些查询传
入healthStore的执行方法

348
00:18:51,098 --> 00:18:52,466
并调用该方法

349
00:18:53,534 --> 00:18:56,036
现在让我们看看你的应用是如何

350
00:18:56,103 --> 00:18:58,405
创建并保存你自己的锻炼路径的

351
00:18:59,239 --> 00:19:00,674
我们要用到一个叫

352
00:19:00,741 --> 00:19:02,609
HKWorkoutRouteBuilder的
编码程序模型

353
00:19:02,676 --> 00:19:06,046
而这个模型的生命周期就是
每条路线你都要有一个编码程序对象

354
00:19:06,113 --> 00:19:07,447
对于你正在追踪的路线来说

355
00:19:09,550 --> 00:19:13,453
位置数据是异步加入的
HealthKit会将这些数据根据日期排序

356
00:19:13,520 --> 00:19:15,022
当这一系列命令完成的时候

357
00:19:15,088 --> 00:19:18,225
所以你就不需要担心
你加入数据的顺序了

358
00:19:19,760 --> 00:19:22,329
还有就是锻炼
需要在记录路线之前被保存

359
00:19:22,596 --> 00:19:24,831
让我们看下时间线是什么样的

360
00:19:24,898 --> 00:19:26,433
假如你有一个锻炼会话

361
00:19:26,500 --> 00:19:29,336
你想要追踪它的路线
并把它保存到HealthKit里

362
00:19:29,670 --> 00:19:32,339
首先我们要创建
锻炼路径编码程序

363
00:19:34,208 --> 00:19:37,811
接着如我们所见的
我们需要开始锻炼会话

364
00:19:39,780 --> 00:19:41,081
现在锻炼就开始了

365
00:19:42,249 --> 00:19:44,618
我们还要开始观测位置数据

366
00:19:44,685 --> 00:19:48,155
你会从Core Location中
观测到位置数据

367
00:19:48,222 --> 00:19:50,958
也就是iOS和watchOS上
的位置框架

368
00:19:52,426 --> 00:19:54,828
接着你需要将这些位置数据
加到你的编码程序中

369
00:19:55,596 --> 00:19:56,864
现在这个进程正在运行

370
00:19:56,930 --> 00:19:59,299
你需要在锻炼过程中执行它很多次

371
00:20:00,501 --> 00:20:03,704
最后你需要结束会话并保存本次锻炼

372
00:20:03,770 --> 00:20:06,740
然后最后一步就是要结束你的锻炼路径

373
00:20:06,807 --> 00:20:08,208
也就是将它保存到HealthKit中

374
00:20:08,909 --> 00:20:11,011
让我们看下它的代码是怎么样

375
00:20:12,746 --> 00:20:16,350
首先你要创建路径编码程序
然后加入位置数据

376
00:20:16,550 --> 00:20:20,721
我们创建了编码程序
传入了healthStore还有device

377
00:20:20,787 --> 00:20:23,357
在这里 本地设备默认为nil

378
00:20:24,858 --> 00:20:27,494
然后你要在锻炼进行时加入位置数据

379
00:20:27,561 --> 00:20:30,430
假设这个代码段被调用了很多次

380
00:20:30,797 --> 00:20:32,900
这里我调用了一个局部方法

381
00:20:32,966 --> 00:20:36,203
fetchRecentLocations
它会给我返回一个CLLocation的列表

382
00:20:36,270 --> 00:20:38,805
然后将这些位置数据插入到编码程序中

383
00:20:40,007 --> 00:20:43,243
作为负责任的程序员
我需要处理所有的错误

384
00:20:44,478 --> 00:20:47,247
第三步是在锻炼被保存之后

385
00:20:47,314 --> 00:20:48,682
我们要结束该路线

386
00:20:49,016 --> 00:20:51,919
它会传入我们已经保存的锻炼对象

387
00:20:51,985 --> 00:20:54,655
还有我们需要的
任何其他关于路线的元数据

388
00:20:58,125 --> 00:21:02,429
接下来我想做个加入锻炼路径的演示
给你们展示把锻炼路径加到某个应用中

389
00:21:02,596 --> 00:21:06,099
如果你参加或者上网观看了
我们去年的演讲

390
00:21:06,166 --> 00:21:09,903
你就会记得Speedy Sloth
这个很棒的锻炼应用

391
00:21:09,970 --> 00:21:10,938
对于爱偷懒的人来说

392
00:21:11,171 --> 00:21:13,507
现在我们会给它加入位置路径

393
00:21:19,913 --> 00:21:22,249
我要切换到Xcode
这里你就能看到

394
00:21:22,316 --> 00:21:23,917
我已运行了Speedy Sloth

395
00:21:24,318 --> 00:21:28,188
Speedy Sloth是个能让你配置锻炼的
WatchKit应用

396
00:21:28,255 --> 00:21:30,824
运行它就能给你显示一些实时指标

397
00:21:31,058 --> 00:21:33,160
并且它会把锻炼保存到
HealthKit里

398
00:21:33,894 --> 00:21:35,762
我先运行一下
Speedy Sloth

399
00:21:35,829 --> 00:21:38,065
这样你们就知道它现在是什么样子了

400
00:21:38,332 --> 00:21:41,168
你会发现我们在追踪锻炼的持续时间

401
00:21:41,268 --> 00:21:43,470
我可以暂停或者恢复

402
00:21:44,304 --> 00:21:48,375
并且我们随锻炼进行追踪
你当前的总指标数据

403
00:21:48,742 --> 00:21:51,745
我们这里有卡路里和里程数据

404
00:21:53,413 --> 00:21:54,648
现在我停止锻炼

405
00:21:55,716 --> 00:21:57,751
我们就能看到关于锻炼的总结信息

406
00:21:58,919 --> 00:22:00,354
现在切换到Xcode

407
00:22:00,420 --> 00:22:02,689
这里我有
一个叫healthStoreManager的类

408
00:22:02,923 --> 00:22:06,894
这个类会处理我们所有与
HKhealthStore的交互

409
00:22:06,960 --> 00:22:09,096
也就是从HealthKit
读取数据或是将数据存入

410
00:22:10,564 --> 00:22:11,865
我首先要做的是

411
00:22:16,069 --> 00:22:19,273
实现CLLocation管理代理协议

412
00:22:19,439 --> 00:22:22,843
它能让我从Core Location
接收位置数据

413
00:22:25,646 --> 00:22:29,349
我需要一些属性来追踪这些位置

414
00:22:30,517 --> 00:22:32,886
第一个属性是

415
00:22:32,953 --> 00:22:35,489
我们刚才说过的
HKWorkoutRouteBuilder

416
00:22:36,590 --> 00:22:39,226
接下来我还需要一个位置管理器

417
00:22:39,293 --> 00:22:42,896
它来自于Core Location
你会通过它来接收更新

418
00:22:45,732 --> 00:22:48,802
现在我想开始积累位置数据了

419
00:22:49,303 --> 00:22:52,005
我们有startAccumulatingData
这个方法

420
00:22:52,272 --> 00:22:55,309
它在我们锻炼会话的状态
发生改变的时候被调用

421
00:22:55,375 --> 00:22:56,910
从未开始到开始锻炼

422
00:22:57,411 --> 00:22:59,313
你们可以看到我已经用了这个地方

423
00:22:59,546 --> 00:23:01,782
来开始行走并运行查询

424
00:23:01,849 --> 00:23:05,619
也就是更新距离数据的地方

425
00:23:05,853 --> 00:23:09,056
还有主动燃烧能量查询

426
00:23:09,122 --> 00:23:11,391
也就是显示卡路里数的地方

427
00:23:11,458 --> 00:23:16,163
在这里开始积累位置数据也挺不错

428
00:23:18,265 --> 00:23:21,602
这里我有一个新方法 叫作
startAccumulatingLocationData

429
00:23:25,372 --> 00:23:27,508
我会把实现方法加到这里

430
00:23:29,409 --> 00:23:33,680
首先 我要使用guard语句
来开启定位服务

431
00:23:33,747 --> 00:23:34,681
否则就返回

432
00:23:36,383 --> 00:23:39,319
然后我要创建一个
CLLocationManager对象

433
00:23:40,220 --> 00:23:42,856
我要把对象的代理设为自己

434
00:23:42,923 --> 00:23:46,126
以便我可以接收到
即将到来的位置数据的回调函数

435
00:23:48,462 --> 00:23:52,699
我要把desiredAccuracy
设为最高精确度

436
00:23:52,933 --> 00:23:56,069
因为我们要把数据显示在地图上
所以这是个不错的主意

437
00:23:56,136 --> 00:23:59,573
我们想把尽可能准确的数据显示给用户

438
00:24:02,009 --> 00:24:05,179
接着我要把
allowsBackgroundUpdates设为真

439
00:24:05,579 --> 00:24:07,781
这样我们就可以继续接收位置信息

440
00:24:07,848 --> 00:24:09,149
即使当我们处于后台的时候

441
00:24:09,349 --> 00:24:10,884
为了使其正常工作

442
00:24:10,951 --> 00:24:13,654
我们还需在info.keylist中
设置一些键值

443
00:24:13,720 --> 00:24:15,489
我不会在这演示

444
00:24:15,556 --> 00:24:18,692
不过你们可以把Speedy Sloth
当成个例子来看看

445
00:24:18,759 --> 00:24:20,894
在演讲结束的时候
我会把它的网址给你们

446
00:24:22,963 --> 00:24:27,000
最后 在Core Location端
我想开始更新位置信息了

447
00:24:27,968 --> 00:24:29,937
在HealthKit端 我只需要

448
00:24:30,003 --> 00:24:32,940
实例化我的
HKWorkoutRouteBuilder

449
00:24:33,040 --> 00:24:36,443
传入healthStore变量
也就是HKhealthStore

450
00:24:36,844 --> 00:24:38,679
这里同样将设备设为nil

451
00:24:40,113 --> 00:24:40,948
不错

452
00:24:41,081 --> 00:24:44,117
现在所有我们需要用来
追踪位置信息的变量都有了

453
00:24:44,184 --> 00:24:45,552
我们把所有东西都设置好了

454
00:24:45,619 --> 00:24:48,755
现在我们需要在接收到这些位置信息时
对其进行处理

455
00:24:49,623 --> 00:24:50,557
为了实现这一点

456
00:24:53,026 --> 00:24:56,930
我们需要实现Core Location
Manager Delegate的这个方法

457
00:24:56,997 --> 00:24:59,700
locationManager还有
didUpdateLocations

458
00:25:00,267 --> 00:25:02,970
此方法就如同管理器对象
本身一样被传递

459
00:25:03,036 --> 00:25:05,906
还有CLLocation的列表

460
00:25:07,908 --> 00:25:10,711
首先我要过滤接收到的位置信息

461
00:25:11,311 --> 00:25:14,147
要不要这么做取决于
你的应用是做什么的

462
00:25:14,214 --> 00:25:16,583
这里我要实现一个简单的过滤器

463
00:25:16,984 --> 00:25:19,686
在某些情况下 你可能要实现别的功能
像是使路径更平滑

464
00:25:19,753 --> 00:25:21,922
不过在这里
我就实现一个简单的过滤器

465
00:25:22,322 --> 00:25:24,558
我所检查的是水平精确度

466
00:25:24,625 --> 00:25:27,227
小于等于附近的10米范围

467
00:25:28,262 --> 00:25:30,364
这么做很重要 因为即便我们在

468
00:25:30,430 --> 00:25:33,000
Core Location管理器上
设定了想要的精确度

469
00:25:33,066 --> 00:25:34,401
还是不能保证一定能实现

470
00:25:36,203 --> 00:25:39,206
接下来我要检查过滤器位置信息
是非空的

471
00:25:39,273 --> 00:25:40,207
否则就返回

472
00:25:43,177 --> 00:25:47,948
最后我要将这个数据插入到
WorkoutRouteBuilder

473
00:25:48,015 --> 00:25:49,683
传入过滤好的位置信息

474
00:25:49,750 --> 00:25:53,086
然后成功地回传 还有报错

475
00:25:53,520 --> 00:25:56,423
如果没有回传成功
我会把错误打印在这里

476
00:25:58,125 --> 00:26:01,261
不错 现在我们的锻炼会话
在正常运行着

477
00:26:01,328 --> 00:26:03,597
我们从Core Location
接收到了位置信息

478
00:26:03,664 --> 00:26:05,465
然后把它们插入到构造器中

479
00:26:05,532 --> 00:26:07,534
现在我们要确保完成收尾工作

480
00:26:07,601 --> 00:26:09,570
在用户结束了锻炼之后

481
00:26:11,638 --> 00:26:13,640
stopAccumulatingData
这个方法

482
00:26:13,707 --> 00:26:16,610
会在锻炼会话状态
改变的时候被调用

483
00:26:16,677 --> 00:26:21,215
在本例中 当装填从运行中或者暂停
变成结束时

484
00:26:22,182 --> 00:26:25,385
这里是我刚才提到过的
healthStore查询

485
00:26:25,452 --> 00:26:28,555
我们要将其移除
还有那些活动的查询

486
00:26:29,156 --> 00:26:33,260
我还要在这停止接收位置更新

487
00:26:33,427 --> 00:26:37,497
我只需在CLLocationManager上
调用stopUpdatingLocation这个方法

488
00:26:39,399 --> 00:26:43,637
最后一步就时将此数据
保存到HealthKit

489
00:26:44,505 --> 00:26:46,707
这里我有saveWorkout
这个方法

490
00:26:48,175 --> 00:26:51,245
你可以发现它传入了会话
开始和结束时间

491
00:26:51,745 --> 00:26:55,616
首先我要配置一些
用来保存锻炼的元数据

492
00:26:56,750 --> 00:27:00,120
在本例中 我会检查位置数据类型

493
00:27:00,187 --> 00:27:03,957
是室内
那么就把元数据室内的键值设成该值

494
00:27:06,226 --> 00:27:08,529
现在我要创建一个锻炼对象

495
00:27:08,595 --> 00:27:12,065
里面有来自于锻炼配置的活动类型

496
00:27:12,866 --> 00:27:14,067
开始和结束时间

497
00:27:14,668 --> 00:27:17,971
我保存在Speedy Sloth里
的锻炼事件列表

498
00:27:18,505 --> 00:27:21,375
燃烧的总能量 总里程

499
00:27:21,441 --> 00:27:23,443
还有我刚刚创建的元数据

500
00:27:25,479 --> 00:27:28,115
最后我要保存这个锻炼

501
00:27:28,282 --> 00:27:30,017
如果成功保存了此锻炼

502
00:27:30,083 --> 00:27:32,653
你就会发现我们
已经将样本添加到锻炼中了

503
00:27:32,719 --> 00:27:35,889
这会连接那些距离和卡路里样本

504
00:27:35,956 --> 00:27:36,990
到锻炼中去

505
00:27:37,224 --> 00:27:39,826
在这里结束锻炼路径也是个不错的选择

506
00:27:43,263 --> 00:27:45,465
我会把这段代码加到这里

507
00:27:46,500 --> 00:27:48,402
它会调用构造器上的
finishRoute方法

508
00:27:48,468 --> 00:27:52,606
传入锻炼 还有路径本身的无元数据

509
00:27:53,740 --> 00:27:56,510
最后 就是检查是否会出现错误

510
00:27:57,611 --> 00:27:59,379
让我们运行一下它

511
00:28:12,626 --> 00:28:14,595
你会发现在这个演示中没有出现

512
00:28:14,661 --> 00:28:17,598
要求接收HealthKit类型的授权

513
00:28:17,664 --> 00:28:20,267
因为我已经在应用的
iOS组件中实现了

514
00:28:20,334 --> 00:28:23,170
请你们也看下我们的示例代码
是如何实现的

515
00:28:24,004 --> 00:28:26,940
现在我们开始另一个户外健走锻炼

516
00:28:27,341 --> 00:28:29,409
同样可以看到我们的追踪记录

517
00:28:29,476 --> 00:28:32,980
也就是持续时间
还有接下来的卡路里和米数

518
00:28:33,180 --> 00:28:36,750
如果碰到了一个很酷的偷懒者
我们就可以做一个标记

519
00:28:37,985 --> 00:28:41,588
最后我们结束了锻炼
就可以看到锻炼总结

520
00:28:43,390 --> 00:28:47,027
然后打开HealthKit
你就能看到数据被保存了

521
00:28:47,294 --> 00:28:48,929
打开Health应用后

522
00:28:51,465 --> 00:28:53,634
我们就能看见一个锻炼列表

523
00:28:55,135 --> 00:28:58,972
而最新的一个
就是我们刚保存的锻炼路径

524
00:28:59,806 --> 00:29:02,576
点击进入就可以看到地图视图

525
00:29:03,644 --> 00:29:06,113
其他可以接入WorkoutRoute的应用

526
00:29:06,180 --> 00:29:08,615
也能接收并分析该数据

527
00:29:08,682 --> 00:29:10,617
或者随他们需要去实现其他功能

528
00:29:13,320 --> 00:29:14,555
你可以很简单

529
00:29:14,621 --> 00:29:17,524
就把WorkoutRoutes
加入到你现有的应用中

530
00:29:17,591 --> 00:29:19,426
让我切换回幻灯片

531
00:29:22,262 --> 00:29:24,464
我想总结下刚才都讲过了什么

532
00:29:24,798 --> 00:29:28,101
首先我实现了
CLLocationManager代理协议

533
00:29:28,168 --> 00:29:30,704
我介绍了一些用来追踪状态的变量

534
00:29:30,771 --> 00:29:33,207
有的来自于HealthKit
有的来自于Core Location

535
00:29:33,607 --> 00:29:35,542
我设置了Location Manager

536
00:29:35,709 --> 00:29:38,745
我保证了将得到的位置数据插入

537
00:29:38,812 --> 00:29:42,916
并且Location Manager将更新
WorkoutRouteBuilder里的位置信息

538
00:29:43,350 --> 00:29:46,053
在结束锻炼的时候要停止更新位置信息

539
00:29:46,386 --> 00:29:50,591
最后保存完锻炼 我结束了锻炼路径

540
00:29:52,426 --> 00:29:54,795
下面我会把时间
交给我的同事迈克尔

541
00:29:54,862 --> 00:29:57,364
他会给你们介绍一个叫
同步标识符的新功能

542
00:29:57,431 --> 00:29:58,365
谢谢

543
00:30:06,406 --> 00:30:07,341
谢谢 亚历克萨

544
00:30:07,574 --> 00:30:10,310
大家好 我叫迈克尔
我是名iOS软件工程师

545
00:30:10,377 --> 00:30:11,445
来自HealthKit团队

546
00:30:12,679 --> 00:30:14,982
如今我们的用户都会有超过一台设备

547
00:30:15,048 --> 00:30:16,583
像是手表和手机

548
00:30:17,751 --> 00:30:19,620
我知道有一点对你们很重要

549
00:30:19,686 --> 00:30:23,590
就是你的健康应用数据
在所有设备上都保持一致

550
00:30:23,657 --> 00:30:25,826
有时候这是很难实现的

551
00:30:27,895 --> 00:30:30,764
有时候我们想在一台设备上加个样本

552
00:30:30,831 --> 00:30:32,900
然后在另一台设备上也加个样本

553
00:30:32,966 --> 00:30:36,403
然后让这些样本同步
有时候这会非常复杂

554
00:30:36,837 --> 00:30:40,974
在iOS 11和watchOS 4中
我们引入了同步标识符

555
00:30:41,542 --> 00:30:45,479
同步标识符能让你辨识
HealthKit里的一个样本

556
00:30:45,546 --> 00:30:47,514
无论是在你的哪台设备上

557
00:30:49,583 --> 00:30:52,085
为了实现这点
我们加入了两个新的元数据键值

558
00:30:52,252 --> 00:30:56,723
它们是HKMetadataKeySyncIdentifier
以及HKMetadataKeySyncVersion

559
00:30:58,225 --> 00:31:00,294
同步标识符可以是任意字符串

560
00:31:00,360 --> 00:31:05,232
UUID字符串表示
或者是后端数据库的主键

561
00:31:06,633 --> 00:31:08,669
同步版本可以是任意数字

562
00:31:09,636 --> 00:31:13,574
HealthKit会使用同步版本
来替你解决版本冲突问题

563
00:31:14,174 --> 00:31:16,043
当你将某个样本存入HealthKit时

564
00:31:16,109 --> 00:31:19,346
首先它会查找符合同步标识符的
现有样本

565
00:31:19,613 --> 00:31:22,049
如果找到了 它就会比较版本号

566
00:31:22,449 --> 00:31:26,220
如果你的新样本有更高的版本号
HealthKit就会删除原来的样本

567
00:31:26,286 --> 00:31:29,022
然后将你的新样本存入替代旧样本

568
00:31:29,523 --> 00:31:31,225
如果你要保存的样本比原有样
本的版本号低

569
00:31:31,291 --> 00:31:32,926
HealthKit会忽略这个新样本

570
00:31:35,696 --> 00:31:38,632
你必须同时使用这两种键值
来实现这一功能

571
00:31:39,733 --> 00:31:44,271
这个元数据适用于任何HK对象
像是HKSample或者HKWorkout

572
00:31:46,006 --> 00:31:49,376
另外需要注意的是 它受限于你的来源

573
00:31:49,610 --> 00:31:53,013
因此 只有你的应用可以
覆盖你所插入的样本

574
00:31:58,118 --> 00:32:00,320
同步标识符可以非常灵活地

575
00:32:00,387 --> 00:32:01,955
让你管理数据

576
00:32:03,390 --> 00:32:05,492
仅靠这两个元数据键

577
00:32:05,559 --> 00:32:08,629
你就可以确保
在所有设备上你的样本都是唯一的

578
00:32:10,898 --> 00:32:14,568
另外 利用版本键

579
00:32:14,635 --> 00:32:16,737
你还可以进行本地版本控制

580
00:32:20,741 --> 00:32:23,577
HealthKit会为你管理
所有版本冲突

581
00:32:23,911 --> 00:32:25,579
在保存和同步的时候

582
00:32:27,114 --> 00:32:30,417
还有 所有使用同步标识符完成的操作

583
00:32:30,484 --> 00:32:31,652
都是安全的交易

584
00:32:32,052 --> 00:32:33,987
这就意味着如果有任何的错误

585
00:32:34,288 --> 00:32:37,357
你的数据都会是处于一致的状态

586
00:32:39,092 --> 00:32:42,329
最后 与父对象的关系被保留了

587
00:32:42,696 --> 00:32:45,732
如果你替换的是与
HKWorkout有关的样本

588
00:32:45,799 --> 00:32:47,167
或跟HKCorrelation有关

589
00:32:47,234 --> 00:32:49,236
那么替换后的样本仍然与

590
00:32:49,303 --> 00:32:51,572
HKWorkout
或者HKCorrelation有关

591
00:32:55,609 --> 00:32:58,412
现在让我们看下如何使用同步标识符

592
00:32:58,478 --> 00:33:01,048
让我们的应用变得完全独立

593
00:33:01,548 --> 00:33:05,352
假设我们的手机上有一个锻炼应用
还有一个WatchKit扩展

594
00:33:05,552 --> 00:33:07,321
我们需要用到一个远程服务器

595
00:33:07,387 --> 00:33:10,924
在锻炼结束后进行一些额外的处理

596
00:33:12,726 --> 00:33:15,395
用户会在锻炼时使用手表

597
00:33:15,462 --> 00:33:17,898
而我们的应用会将数据
存入到HealthKit中

598
00:33:18,165 --> 00:33:19,867
我们要使用一个随机同步标识符

599
00:33:19,933 --> 00:33:23,337
因为这是初始版本
我们就把它叫作版本1

600
00:33:24,938 --> 00:33:28,509
在保存之后
我们的手表会把收据直接上传到云端

601
00:33:30,911 --> 00:33:35,516
HealthKit会发现有新数据
并且将其同步到我们的设备上

602
00:33:37,484 --> 00:33:40,053
现在我们的两个设备就都有这个样本了

603
00:33:42,890 --> 00:33:45,392
接着不久后 我们的云端处理完数据

604
00:33:45,459 --> 00:33:47,694
这时候我们把它叫作版本2

605
00:33:50,964 --> 00:33:52,833
我们的手机发现了云端的新数据

606
00:33:52,900 --> 00:33:55,302
决定将它下载并
保存到HealthKit中

607
00:33:55,369 --> 00:33:58,138
我们还是用和之前一样的同步标识符

608
00:33:58,205 --> 00:34:00,407
不过这次我们要把它的版本设为2

609
00:34:02,576 --> 00:34:04,311
因为我们使用了同步标识符

610
00:34:04,378 --> 00:34:06,213
HealthKit
会首先查找现有的样本

611
00:34:06,280 --> 00:34:07,581
来匹配该标识符

612
00:34:07,681 --> 00:34:10,516
这里它找到了现有的样本是版本1

613
00:34:10,784 --> 00:34:12,518
而我们的新样本是版本2

614
00:34:12,619 --> 00:34:15,989
所以它就会删除现有的样本
并将其用新的样本进行替换

615
00:34:17,056 --> 00:34:19,826
HealthKit发现了这个新数据

616
00:34:19,893 --> 00:34:21,094
它就会进行一次同步

617
00:34:25,299 --> 00:34:27,234
因为我们使用了同步标识符

618
00:34:27,367 --> 00:34:30,070
在同步过程中
HealthKit还是会查找现有的样本

619
00:34:30,137 --> 00:34:31,505
来匹配该同步标识符

620
00:34:31,938 --> 00:34:34,007
在本例中 它找到了最初的样本

621
00:34:34,440 --> 00:34:36,376
发现我们的新样本是版本2后

622
00:34:36,443 --> 00:34:39,580
它就删除了初始的样本并将其
用我们的新样本进行替换

623
00:34:40,880 --> 00:34:43,817
如我们所预期的那样
在我们的所有设备上都只有一个样本

624
00:34:43,884 --> 00:34:46,719
HealthKit会为我们解决
所有的版本冲突问题

625
00:34:49,389 --> 00:34:51,324
由于你的应用是完全独立的

626
00:34:51,391 --> 00:34:52,993
手表就不需要知道

627
00:34:53,060 --> 00:34:55,228
手机是不是已经下载了数据

628
00:34:55,661 --> 00:34:58,599
我们的手表应用发现了云端的新数据

629
00:34:58,665 --> 00:35:00,501
然后将其下载
并保存到HealthKit中

630
00:35:00,634 --> 00:35:02,569
我们会使用同样的同步标识符

631
00:35:02,636 --> 00:35:04,738
我们会辨识出又是版本2

632
00:35:06,740 --> 00:35:09,610
在这里 HealthKit发现现有样本

633
00:35:09,676 --> 00:35:12,012
有着相同的标识符和版本号

634
00:35:12,346 --> 00:35:13,614
所以这个样本就被忽略掉了

635
00:35:16,216 --> 00:35:19,319
如我们所预期的那样
我们所有的设备上都只有一个样本

636
00:35:19,386 --> 00:35:22,055
HealthKit
会为我们解决所有的版本冲突问题

637
00:35:24,558 --> 00:35:27,661
现在我们的应用就能随时上传 下载
并同步内容了

638
00:35:27,728 --> 00:35:29,329
我们不需要担心任何问题

639
00:35:29,396 --> 00:35:31,865
HealthKit会为我们解决
所有的版本冲突问题

640
00:35:31,932 --> 00:35:34,601
还有所有需要解决的复杂问题

641
00:35:37,504 --> 00:35:40,407
亚历克萨刚刚在Speedy Sloth中
添加了锻炼路径

642
00:35:41,008 --> 00:35:43,677
现在我要演示下如何更新这条路线

643
00:35:45,579 --> 00:35:49,349
一个常见的例子就是
做某些额外的处理

644
00:35:49,416 --> 00:35:50,884
像是使路线更平滑

645
00:35:50,951 --> 00:35:52,953
然后我们更新下路线

646
00:35:53,420 --> 00:35:55,355
首先我进入Speedy Sloth

647
00:35:56,990 --> 00:36:00,994
早些时候我在Speedy Sloth中
加入了这个新功能 树懒化锻炼

648
00:36:02,729 --> 00:36:05,232
意思就是我们的原始路线

649
00:36:05,299 --> 00:36:07,467
会被改成我们要路过沿途的每棵树

650
00:36:07,534 --> 00:36:08,669
就像是树懒一样

651
00:36:11,939 --> 00:36:14,541
让我们看下如何实现此方法

652
00:36:14,608 --> 00:36:18,245
首先我们要看下配置界面控制器

653
00:36:20,347 --> 00:36:23,684
在这个类中 我们有个叫
updateWorkoutRoute的方法

654
00:36:24,785 --> 00:36:27,821
此方法需要传入一个锻炼
该锻炼的一条路线

655
00:36:27,888 --> 00:36:29,623
还有那条路线的所有位置信息

656
00:36:30,157 --> 00:36:32,826
在下面我已经实现了所有需要的查询

657
00:36:32,893 --> 00:36:34,061
来收集这些数据

658
00:36:34,728 --> 00:36:36,363
我们点击下树懒化锻炼按钮

659
00:36:36,430 --> 00:36:39,166
它就会收集所有这些数据
并将数据传到这个方法里

660
00:36:42,236 --> 00:36:44,671
有了这些从初始锻炼中
收集到的原始位置信息

661
00:36:44,738 --> 00:36:47,708
接下来我们把它传入
slothifyRouteLocations这个方法

662
00:36:47,841 --> 00:36:49,743
此方法会传入我们的位置信息

663
00:36:49,810 --> 00:36:52,446
找到所有的树
然后相应地调整我们的路线

664
00:36:53,514 --> 00:36:55,282
现在我们就有新的位置信息了

665
00:36:56,083 --> 00:36:57,985
接下来我们要创建一个新的锻炼路径

666
00:36:58,051 --> 00:36:59,686
并将它与我们的锻炼相关联

667
00:37:00,120 --> 00:37:04,291
要实现这个目的 首先我们要创建一个
HKWorkoutRouteBuilder

668
00:37:06,159 --> 00:37:08,061
我们同样需要传入healthStore

669
00:37:08,128 --> 00:37:10,163
还有一个表示我们本地资源的nil设备

670
00:37:11,965 --> 00:37:13,467
要插入这些位置信息

671
00:37:15,135 --> 00:37:17,738
我们需要在WorkoutRouteBuilder上
调用insertRouteData方法

672
00:37:17,804 --> 00:37:18,972
并传入我们的新位置信息

673
00:37:21,108 --> 00:37:23,410
我们要保证此方法成功了

674
00:37:23,477 --> 00:37:24,645
而一旦这些都实现了

675
00:37:24,711 --> 00:37:27,614
我们就可以结束初始锻炼中的路线

676
00:37:29,883 --> 00:37:31,385
让我们看个例子吧

677
00:37:36,723 --> 00:37:38,192
这里是亚历克萨的初始路线

678
00:37:44,932 --> 00:37:46,733
让我们树懒化这条路线

679
00:38:07,020 --> 00:38:07,855
好了

680
00:38:10,858 --> 00:38:13,994
正如你所见
初始路线被树懒化了

681
00:38:14,061 --> 00:38:15,629
然后被应用到锻炼中

682
00:38:16,430 --> 00:38:19,233
不过初始路线还在那里

683
00:38:19,800 --> 00:38:22,236
我们现在要做的就是删除初始路线

684
00:38:22,603 --> 00:38:25,539
然后添加我们的新路线
这有点复杂

685
00:38:25,606 --> 00:38:28,075
我们需要保证数据被正确同步了

686
00:38:28,141 --> 00:38:30,277
而且它还不是特别安全的交易

687
00:38:31,044 --> 00:38:34,581
为了能简单地实现这个功能
我要使用同步标识符

688
00:38:35,983 --> 00:38:39,386
首先我回到刚开始创建锻炼路线的地方

689
00:38:40,988 --> 00:38:42,322
在这个保存锻炼方法内

690
00:38:43,223 --> 00:38:45,392
在我们初始保存了锻炼后

691
00:38:45,459 --> 00:38:47,294
以及结束路线之前

692
00:38:47,794 --> 00:38:50,163
我要添加一些同步标识符元数据

693
00:39:02,342 --> 00:39:04,678
首先 我要创建一个元数据字典

694
00:39:06,280 --> 00:39:09,616
接着 我要把同步标识符的
元数据键设定为

695
00:39:09,683 --> 00:39:11,985
字符串表示的UUID值

696
00:39:13,253 --> 00:39:16,924
然后我把同步版本设为版本1

697
00:39:16,990 --> 00:39:18,592
因为这是我们的初始路线

698
00:39:19,560 --> 00:39:21,228
在创建了元数据之后

699
00:39:21,895 --> 00:39:23,931
我们将其传入
finishRoute方法

700
00:39:23,997 --> 00:39:27,801
这样当我们将其存入锻炼时
它就会和锻炼路线相关联了

701
00:39:29,069 --> 00:39:31,405
接着我们回来配置界面控制器

702
00:39:31,805 --> 00:39:33,540
也就是我们更新锻炼路径的地方

703
00:39:35,709 --> 00:39:38,579
为了使用同步标识符 我们还需要将

704
00:39:38,645 --> 00:39:42,349
相同的同步标识符元数据
添加到我们更新后的路线中

705
00:39:43,617 --> 00:39:45,385
首先我们需要抓取同步标识符

706
00:39:45,452 --> 00:39:47,855
也就是我们在初始路线上
所使用的同步标识符

707
00:39:48,555 --> 00:39:50,757
为防我们的路线没有任何元数据

708
00:39:50,824 --> 00:39:52,559
我们需要定义一个默认值

709
00:39:54,361 --> 00:39:56,630
接着我们要创建一个元数据字典

710
00:39:58,799 --> 00:40:00,567
这里我们创建了词典

711
00:40:00,634 --> 00:40:05,005
然后将这些新的同步标识符
赋给了那些初始的

712
00:40:05,739 --> 00:40:09,910
然后我们要用的同步版本为2
因为这是我们更新后的路线

713
00:40:11,311 --> 00:40:14,181
让我们把元数据传入
finishRoute这个方法

714
00:40:14,248 --> 00:40:17,484
这样在元数据被保存在锻炼中的时候
就可以与锻炼路径相关联了

715
00:40:18,151 --> 00:40:20,521
接着HealthKit
会替换我们的初始路线

716
00:40:21,154 --> 00:40:22,923
让我们看个实例吧

717
00:40:34,201 --> 00:40:36,537
首先让我们实现一个新锻炼

718
00:40:38,372 --> 00:40:41,575
当我们保存这个锻炼时
它会包含同步标识符元数据

719
00:40:42,643 --> 00:40:46,680
当我们走了几米
消耗了一定的卡路里之后

720
00:40:46,747 --> 00:40:49,783
我们就要停止锻炼
并将其存入HealthKit

721
00:40:55,956 --> 00:40:57,624
我们可以在这里看到初始路线

722
00:40:58,025 --> 00:41:00,627
让我们回到树懒化这条路线

723
00:41:15,375 --> 00:41:17,244
好了 如你所见

724
00:41:17,311 --> 00:41:19,613
初始路线就被我们的新路线替换掉了

725
00:41:19,847 --> 00:41:22,082
我们只需要加入几个元数据键

726
00:41:22,149 --> 00:41:24,952
HealthKit会为我们处理
所有的版本冲突问题

727
00:41:26,687 --> 00:41:29,723
现在你们都看到了
处理冲突是多么的简单

728
00:41:29,790 --> 00:41:32,492
只要利用好HealthKit中
新的高级功能就行了

729
00:41:34,328 --> 00:41:37,331
现在让我介绍一下样本源信息

730
00:41:38,198 --> 00:41:41,235
你们要注意
从HealthKit显示数据的时候

731
00:41:41,668 --> 00:41:43,837
该数据的来源

732
00:41:44,771 --> 00:41:49,009
当你查询数据的时候
样本会包含一个HKSourceRevision

733
00:41:49,243 --> 00:41:51,345
HKSourceRevision
包含了应用和设备

734
00:41:51,411 --> 00:41:55,449
也就是这些应用和设备
将样本存入了HealthKit

735
00:41:56,617 --> 00:42:01,255
在iOS 11和watchOS 4中
我们加入了一些新的属性和常量

736
00:42:01,321 --> 00:42:04,958
这样你就能对从HealthKit
获得的显示数据有更深入了解

737
00:42:07,561 --> 00:42:11,031
在iOS 10中 HKSourceRevision
包括了源

738
00:42:11,665 --> 00:42:15,802
作为HK源
以及NSString格式的应用版本

739
00:42:18,438 --> 00:42:19,973
首先 我们加入了产品类型

740
00:42:20,340 --> 00:42:22,142
产品类型是一种字符串形式表现的

741
00:42:22,209 --> 00:42:25,312
设备名 也就是这个设备
将样本存入到HealthKit

742
00:42:25,479 --> 00:42:28,081
如果你在Watch Series 2上
保存某个样本

743
00:42:28,148 --> 00:42:29,950
就会是这个样子 “watch2,4”

744
00:42:31,185 --> 00:42:33,520
然后我们加入了操作系统版本

745
00:42:34,021 --> 00:42:36,623
它就是设备上所运行的操作系统

746
00:42:36,690 --> 00:42:38,559
当把样本
存入HealthKit的时候

747
00:42:39,393 --> 00:42:43,263
如果我们使用
watchOS 4.0保存样本

748
00:42:43,330 --> 00:42:45,566
就会返回 “4,0,0”

749
00:42:47,868 --> 00:42:49,870
我们还添加了三个新的常量

750
00:42:49,937 --> 00:42:53,073
这些常量是
HKSourceRevisionAnyVersion

751
00:42:53,373 --> 00:42:55,375
HKSourceRevisionAnyProductType

752
00:42:55,609 --> 00:42:58,212
还有
HKSourceRevisionAnyOperatingSystem

753
00:42:58,812 --> 00:43:01,048
当你为查询数据而新建断言的时候

754
00:43:02,015 --> 00:43:06,220
这其中就包含了HKSourceRevision
你必须全部声明这三个常量

755
00:43:06,587 --> 00:43:08,155
你可以用这些常量来

756
00:43:08,222 --> 00:43:11,158
获得一个更细致的断言

757
00:43:11,225 --> 00:43:15,362
例如 对于某个特定产品类型
可以使用任何操作系统

758
00:43:16,530 --> 00:43:20,367
通过这些新信息
你可以获得更深入的理解

759
00:43:20,434 --> 00:43:22,569
对于你应用中所显示的数据

760
00:43:26,039 --> 00:43:26,940
（支持糖尿病管理）

761
00:43:27,007 --> 00:43:28,542
好了 最后是

762
00:43:29,243 --> 00:43:31,512
HealthKit中支持的糖尿病管理

763
00:43:33,947 --> 00:43:37,784
我们的用户喜欢使用Apple产品
来帮他们掌握身体情况

764
00:43:39,319 --> 00:43:42,723
现在在HealthKit中
我们支持了追踪血糖样本

765
00:43:42,789 --> 00:43:46,059
追踪碳水化合物和所有活动数据

766
00:43:46,260 --> 00:43:48,729
这些对于控制糖尿病很有帮助

767
00:43:49,429 --> 00:43:52,466
我们知道还缺失一些功能
现在我很高兴地宣布

768
00:43:52,533 --> 00:43:56,436
我们已经添加了新的功能来完善它

769
00:44:00,340 --> 00:44:04,178
首先 我们加入了追踪相对用餐时间

770
00:44:04,244 --> 00:44:05,512
和血糖样本的对应关系

771
00:44:06,813 --> 00:44:10,117
然后 我们加入了胰岛素注射追踪

772
00:44:12,819 --> 00:44:15,389
作为watchOS 4里
CoreBluetooth新特性

773
00:44:15,455 --> 00:44:17,691
你的蓝牙现在可以让糖尿病设备

774
00:44:17,758 --> 00:44:19,927
直接连到你的手表上

775
00:44:21,261 --> 00:44:24,364
请观看“CoreBluetooth新特性”
以获得更多信息

776
00:44:25,566 --> 00:44:28,268
为了支持相对血糖用餐时间

777
00:44:28,335 --> 00:44:29,736
我们添加了一个新的元数据键

778
00:44:30,237 --> 00:44:34,007
这个元数据键叫作
HKMetadataKeyBloodGlucoseMealTime

779
00:44:34,074 --> 00:44:37,377
你可以在保存血糖样本的时候
使用这个元数据键

780
00:44:38,378 --> 00:44:41,014
这个元数据键支持两种值

781
00:44:41,548 --> 00:44:45,152
你可以在HKBloodGlucoseMealTime
这个枚举中找到这两个值

782
00:44:45,519 --> 00:44:48,155
这两个值就是餐前和餐后

783
00:44:48,822 --> 00:44:51,391
餐前表示的是饭前的任意时间

784
00:44:51,458 --> 00:44:54,328
餐后表示的是饭后的任意时间

785
00:44:57,464 --> 00:44:59,833
通过这个新数据
你就可以更深入地了解

786
00:44:59,900 --> 00:45:03,403
用户上顿吃饭与血糖样本的对应关系

787
00:45:03,904 --> 00:45:07,107
现在让我们看一下
HealthKit中的胰岛素注射支持

788
00:45:07,908 --> 00:45:10,110
这里有张HealthKit的图表

789
00:45:11,578 --> 00:45:13,981
对应的是所有插入到
Health应用的数据

790
00:45:16,250 --> 00:45:17,351
为了支持这个新类型

791
00:45:17,417 --> 00:45:19,753
我们添加了一个新的计量类型标识符

792
00:45:19,853 --> 00:45:22,623
它叫作 HKQuantityTypeIdentifier
insulinDelivery

793
00:45:23,490 --> 00:45:28,662
你想向这个计量类型添加样本时
必须包括注射的原因

794
00:45:29,296 --> 00:45:31,131
为了实现这个功能 你应该使用

795
00:45:31,198 --> 00:45:34,668
HKMetadataKeyInsulin
DeliveryReasonMetadata

796
00:45:35,669 --> 00:45:37,905
这个元数据支持两个值

797
00:45:38,839 --> 00:45:41,875
你可以在HKInsulinDeliverReason
这个枚举中找到这两个值

798
00:45:43,243 --> 00:45:45,512
这两个值就是basal和bolus

799
00:45:46,313 --> 00:45:49,116
basal就是你每天所需的基础代谢量

800
00:45:49,183 --> 00:45:51,919
而bolus就是某一段时间内的需求量
像是一顿饭

801
00:45:51,985 --> 00:45:53,453
它还会纠正高血糖

802
00:45:55,455 --> 00:45:58,525
值得注意的是 你只能加入这三种样本

803
00:45:58,592 --> 00:46:00,394
在用户注射胰岛素之后

804
00:46:02,496 --> 00:46:06,133
当利用这个标识符创建HK样本时

805
00:46:06,200 --> 00:46:08,068
你应该使用国际单位

806
00:46:09,570 --> 00:46:11,171
为了支持国际单位

807
00:46:11,238 --> 00:46:15,776
或者说IU 我们已经扩展了HKUnit
现在它可以返回国际单位了

808
00:46:16,677 --> 00:46:17,744
国际单位

809
00:46:17,811 --> 00:46:20,647
就是物质的生物学有效性

810
00:46:22,149 --> 00:46:23,951
它所表示的不是一个特定的数量

811
00:46:24,017 --> 00:46:25,986
而是生物有效性

812
00:46:26,053 --> 00:46:27,688
对于所注射的计量而言

813
00:46:29,289 --> 00:46:33,293
值得注意的是
这个单位不能被转换为其他单位

814
00:46:33,360 --> 00:46:36,930
不过它支持常见的一些SI前缀
像是千和微

815
00:46:40,000 --> 00:46:43,604
让我们来看下
如何插入一个胰岛素注射样本

816
00:46:44,638 --> 00:46:49,676
比方说 我们通过胰岛素泵
注射了0.85个单位的基础胰岛素

817
00:46:49,743 --> 00:46:50,677
在过去的一小时内

818
00:46:51,912 --> 00:46:54,081
首先让我们用insulinDelivery
这个标识符

819
00:46:54,147 --> 00:46:56,316
来创建一个HKQuantityType

820
00:46:59,152 --> 00:47:01,221
接着我们创建了一个
HKQuantity

821
00:47:01,288 --> 00:47:05,526
使用了国际单位以及
双精度浮点值0.825

822
00:47:08,262 --> 00:47:10,931
然后 我们创建了一个
HKQuantitySample

823
00:47:11,265 --> 00:47:14,801
我们还要用到前面讲到过的
计量类型与计量

824
00:47:15,536 --> 00:47:19,640
我们要把开始和结束时间设定为
胰岛素泵注射胰岛素的起始时间

825
00:47:20,674 --> 00:47:23,243
然后我们要记得写入需要的元数据

826
00:47:23,310 --> 00:47:26,246
来记录注射原因
在本例中 这里是basal

827
00:47:28,315 --> 00:47:30,117
当样本被创建好以后

828
00:47:30,184 --> 00:47:34,254
我们可以通过将其传入healthStore中
的save方法来保存到HealthKit

829
00:47:35,455 --> 00:47:37,791
这样一个胰岛素注射样本
就被保存到HealthKit了

830
00:47:37,858 --> 00:47:40,460
你的应用还有
所有其他的应用都可以使用它

831
00:47:40,527 --> 00:47:42,262
来帮助用户控制糖尿病

832
00:47:45,732 --> 00:47:49,369
我们还可以从HealthKit中
取出已经保存的样本

833
00:47:49,436 --> 00:47:51,638
为了实现这个功能
我们需要对所有基础样本

834
00:47:51,705 --> 00:47:52,906
执行一次统计数据查询

835
00:47:53,307 --> 00:47:56,977
我对每个给用户注射的
基础样本都感兴趣

836
00:47:57,044 --> 00:47:58,545
每小时我都想看一下

837
00:47:59,646 --> 00:48:01,949
首先 我们需要新建一个断言

838
00:48:02,015 --> 00:48:03,750
我们会以元数据键作为基础

839
00:48:03,817 --> 00:48:06,753
此元数据键为insulinDeliveryReason
并且我们会传入基础

840
00:48:06,820 --> 00:48:09,056
因为这是我们感兴趣的类型

841
00:48:11,191 --> 00:48:13,126
接下来我们要定义计量类型

842
00:48:13,193 --> 00:48:14,661
就像我们之前做的那样

843
00:48:14,728 --> 00:48:17,798
我们要用到的是
insulinDelivery这个计量类型标识符

844
00:48:19,566 --> 00:48:22,769
然后我们要新建一个
HK统计数据集合查询

845
00:48:22,836 --> 00:48:26,507
我们要传入计量类型和
前面定义好的断言

846
00:48:27,508 --> 00:48:29,810
然后我们要传入一些选项

847
00:48:29,877 --> 00:48:32,112
就是cumulativeSum
还有separateBySource

848
00:48:32,613 --> 00:48:34,882
你一定要传入
separateBySource

849
00:48:34,948 --> 00:48:37,184
因为HealthKit一般

850
00:48:37,251 --> 00:48:40,554
只会返回一个特定时间段之内的样本

851
00:48:41,154 --> 00:48:42,389
因为用户可能会

852
00:48:42,456 --> 00:48:45,058
超过一个小时才注射胰岛素

853
00:48:45,125 --> 00:48:48,762
或是人工注射
而这些时间段是会重叠的

854
00:48:48,896 --> 00:48:51,665
因此我们需要使用separateBySource
来获取全部的信息

855
00:48:53,100 --> 00:48:55,702
接下来我感兴趣的是所有的基础样本

856
00:48:56,203 --> 00:48:58,739
对于这里的锚日期
我所使用的是Date.distantPast

857
00:49:00,307 --> 00:49:02,576
然后 为了表明是每个小时一检查

858
00:49:02,643 --> 00:49:06,213
我会把小时数为1的DateComponents
传给intervalComponents

859
00:49:08,916 --> 00:49:10,150
现在我的查询已经创建好了

860
00:49:10,217 --> 00:49:12,319
我就可以接着创建我的
initialResultsHandler

861
00:49:12,819 --> 00:49:14,821
而从这个处理器返回的结果

862
00:49:14,888 --> 00:49:17,658
就包括了所有我们需要总结的信息

863
00:49:17,724 --> 00:49:19,593
以便找出我们需要的信息

864
00:49:21,862 --> 00:49:23,363
最后 我要执行这条查询

865
00:49:23,430 --> 00:49:26,333
通过将其传入healthStore
中的执行方法

866
00:49:27,935 --> 00:49:30,571
现在你就知道如何插入并取回样本了

867
00:49:35,609 --> 00:49:38,445
今天我们讲了许多
HealthKit的新功能

868
00:49:40,147 --> 00:49:43,050
首先 你们了解了一些
新数据类型和活动类型

869
00:49:43,116 --> 00:49:46,053
这会让你的锻炼应用更上一层楼

870
00:49:49,790 --> 00:49:52,826
然后你学习了新的
WorkoutRouteBuilder API

871
00:49:53,327 --> 00:49:55,162
它可以让你记录锻炼路线

872
00:49:55,229 --> 00:49:56,897
并与锻炼相关联

873
00:49:58,565 --> 00:50:00,834
之后我们引入了同步标识符的概念

874
00:50:01,335 --> 00:50:05,072
现在你就可以利用
HealthKit来管理

875
00:50:05,138 --> 00:50:07,808
和防止所有跨设备的数据复制了

876
00:50:10,377 --> 00:50:15,315
最后 我们添加了
对于用户控制糖尿病的支持

877
00:50:20,120 --> 00:50:23,857
要了解更多内容以及
下载完整版Speedy Sloth

878
00:50:23,924 --> 00:50:25,058
请访问这个链接

879
00:50:34,334 --> 00:50:36,537
我们有些推荐的相关演讲

880
00:50:37,604 --> 00:50:39,339
谢谢 愿你们在WWDC
度过一段快乐时光

