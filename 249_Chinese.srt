1
00:00:21,067 --> 00:00:24,600
我们会讨论在iOS11
如何在应用程序里使用全新的API

2
00:00:24,667 --> 00:00:27,700
来过滤不需要的SMS和MMS信息

3
00:00:27,767 --> 00:00:30,333
并帮助用户避免不断增加的打扰

4
00:00:31,767 --> 00:00:33,467
在开始之前 来看一下

5
00:00:33,533 --> 00:00:38,167
iOS 10.3接收到不需要的
SMS信息时会发生什么

6
00:00:40,833 --> 00:00:44,533
这里收到一条非常明显的
不需要的 垃圾SMS

7
00:00:45,167 --> 00:00:48,933
像这样的信息对用户来说很烦人
因为它们会发出声音或震动

8
00:00:49,000 --> 00:00:52,133
就像普通的信息一样
并分心你正在做的任何事情

9
00:00:55,467 --> 00:00:58,100
如果打开信息应用 它就位于顶部

10
00:00:58,167 --> 00:01:01,000
和真正的信息混合在一起
让列表越变越乱

11
00:01:01,833 --> 00:01:04,766
不幸的是 一些iPhone用户
收到很多这种信息

12
00:01:04,833 --> 00:01:07,067
希望有一种方法可以过滤掉它们

13
00:01:07,667 --> 00:01:12,267
iOS 11推出了全新API
可以让你的应用程序分析

14
00:01:12,333 --> 00:01:16,433
来自未知发件人的
SMS或MMS的发件人和内容

15
00:01:16,500 --> 00:01:18,967
并且尝试过滤那些未经申请的信息

16
00:01:19,367 --> 00:01:20,667
让我来向大家展示其工作原理

17
00:01:22,833 --> 00:01:26,967
在运行iOS 11的iPhone上
启动全新的信息应用

18
00:01:27,700 --> 00:01:30,567
由于我已经安装了一个
信息过滤应用程序扩展

19
00:01:30,633 --> 00:01:35,200
并且在设置中启用
我看到第二个选项卡 名为SMS垃圾

20
00:01:35,767 --> 00:01:38,033
如果收到应用程序认为是垃圾的信息

21
00:01:38,100 --> 00:01:39,867
将会显示在该选项卡下

22
00:01:41,367 --> 00:01:43,867
啊 有一个新信息
来看一下是什么

23
00:01:46,033 --> 00:01:47,867
这和之前信息一样

24
00:01:47,933 --> 00:01:51,500
但现在它不再出现在
已知联系人的常规列表里

25
00:01:51,567 --> 00:01:54,133
并且不会发出声音或通知让我分心

26
00:01:55,933 --> 00:01:59,233
如果点开它阅读
可以看到底部的标签

27
00:01:59,300 --> 00:02:02,033
它被一个名为“Filter It”的
应用程序标为垃圾

28
00:02:05,100 --> 00:02:08,433
我们决定添加该功能有几个理由

29
00:02:09,600 --> 00:02:10,600
不需要的信息

30
00:02:10,667 --> 00:02:14,433
即用户收到的任何未经申请的
或垃圾类信息

31
00:02:14,500 --> 00:02:17,433
近年来已经越来越成为用户的困扰

32
00:02:18,267 --> 00:02:20,567
但除了困扰 更值得担心的是

33
00:02:20,633 --> 00:02:23,100
这些信息往往带有诈骗目的

34
00:02:23,167 --> 00:02:25,067
并含有可能会损害用户的链接

35
00:02:25,700 --> 00:02:28,333
因此 当然我们要阻止这些消息的发送

36
00:02:28,400 --> 00:02:29,567
只要有可能

37
00:02:30,700 --> 00:02:33,267
有一个重要区别 在iMessage

38
00:02:33,333 --> 00:02:35,300
SMS和MMS信息之间

39
00:02:36,033 --> 00:02:39,567
对于iMessage 我们在设备上
提供报告为垃圾邮件的功能

40
00:02:39,633 --> 00:02:42,000
因为这些信息是端对端加密的

41
00:02:42,067 --> 00:02:44,033
并通过iMessage网络发送

42
00:02:44,433 --> 00:02:47,867
但我们对SMS或MMS无法这样做

43
00:02:47,933 --> 00:02:51,600
因为它们直接通过
无线运营商发送到用户设备

44
00:02:51,967 --> 00:02:54,400
因此过滤这些信息必须在本地进行

45
00:02:54,467 --> 00:02:58,300
而不是在集中式的服务器上
因此这些API都在本地

46
00:02:59,433 --> 00:03:02,267
最后 我们听说你们中很多人都是

47
00:03:02,333 --> 00:03:05,567
分析并检测不需要信息的专家

48
00:03:05,633 --> 00:03:08,467
我们十分激动能够邀请一些应用程序
帮我们完成这个任务

49
00:03:10,900 --> 00:03:14,167
在本次演讲的剩余时间里
我将详细介绍几个方面

50
00:03:15,300 --> 00:03:18,900
首先 我会详细介绍
我们称之为信息过滤扩展

51
00:03:18,967 --> 00:03:20,100
以及它们的工作原理

52
00:03:21,700 --> 00:03:25,067
接下来 我会讲一些
关于隐私的重要考虑

53
00:03:25,133 --> 00:03:27,700
因为这些扩展都有一些特殊的规则

54
00:03:28,633 --> 00:03:32,167
然后 我会讲讲扩展
如何使用网络支持服务进行检查

55
00:03:32,233 --> 00:03:33,967
对某些应用来说应该有用

56
00:03:35,000 --> 00:03:37,333
我会做几个演示

57
00:03:37,400 --> 00:03:39,667
在Xcode里创建扩展的过程里

58
00:03:39,733 --> 00:03:40,833
现在开始

59
00:03:41,833 --> 00:03:43,400
（信息过滤器扩展）

60
00:03:43,467 --> 00:03:47,000
实现目标的方法
我们称之为信息过滤扩展

61
00:03:47,067 --> 00:03:48,767
让我们来深入了解一下

62
00:03:50,167 --> 00:03:52,933
顾名思义
这是个新的应用程序扩展类型

63
00:03:53,000 --> 00:03:54,233
可以包含在你的应用里

64
00:03:55,567 --> 00:04:00,033
它的API位于iOS 11全新的框架中
名为Identity Lookup

65
00:04:00,800 --> 00:04:04,033
如果用户安装了一个应用程序
带有其中一个扩展

66
00:04:04,100 --> 00:04:07,933
开始使用时
必须先在信息设置里启用

67
00:04:09,167 --> 00:04:11,600
一次只能启用一个扩展

68
00:04:11,667 --> 00:04:14,867
若用户想要禁用该功能
可以选择“无”

69
00:04:15,800 --> 00:04:18,267
如果被启用 该扩展被调用

70
00:04:18,333 --> 00:04:22,333
在每次从未知发件人
收到SMS或MMS信息时

71
00:04:23,000 --> 00:04:24,633
还可以使用其他一些标准

72
00:04:24,700 --> 00:04:26,967
来决定何时把信息发给扩展

73
00:04:27,033 --> 00:04:28,433
马上就要来讲解这一点

74
00:04:28,500 --> 00:04:31,133
首先来看一张显示整体流程的图

75
00:04:31,867 --> 00:04:35,433
当手机收到信息时
首先会在信息应用里

76
00:04:35,967 --> 00:04:38,233
如果是SMS或MMS信息

77
00:04:38,300 --> 00:04:41,533
并且发件人不在收件人的联系人名单里

78
00:04:41,600 --> 00:04:44,867
用户在设置里选择的扩展将会启动

79
00:04:44,933 --> 00:04:47,200
并且会被传递发件人和正文信息

80
00:04:47,267 --> 00:04:51,000
通过一个对象名为
ILMessageFilterQueryRequest

81
00:04:51,067 --> 00:04:53,300
它也是Identity Lookup框架的一部分

82
00:04:54,433 --> 00:04:57,533
当扩展收到后 将开始检查信息

83
00:04:57,600 --> 00:05:00,700
查看信息发件人或正文 或两者

84
00:05:00,767 --> 00:05:04,267
还可能检查不良电话号码列表

85
00:05:04,333 --> 00:05:07,467
也可能检查正文中
是否有可疑的网页链接

86
00:05:07,533 --> 00:05:08,967
任何适当的检查均可

87
00:05:09,167 --> 00:05:11,767
最后扩展必须产生一个回应

88
00:05:11,833 --> 00:05:15,633
使用一个对象名为
ILMessageFilterQueryResponse

89
00:05:15,700 --> 00:05:18,667
描述是否允许或过滤掉该信息

90
00:05:18,733 --> 00:05:20,700
并将回应发还给信息应用

91
00:05:21,667 --> 00:05:23,300
信息应用收到回应后

92
00:05:23,367 --> 00:05:25,567
要么正常提醒用户

93
00:05:25,633 --> 00:05:29,333
要么禁止通知
将该信息线程移动到垃圾选项卡

94
00:05:32,167 --> 00:05:33,000
（隐私考虑）

95
00:05:33,067 --> 00:05:35,100
这就是扩展工作原理概述

96
00:05:35,167 --> 00:05:38,233
在继续之前
我想讲一个非常重要的主题

97
00:05:38,300 --> 00:05:39,433
就是用户隐私

98
00:05:40,767 --> 00:05:43,633
关于如何维护Apple客户期待的
强大的隐私级别

99
00:05:43,700 --> 00:05:45,367
我们花了很多心思

100
00:05:45,433 --> 00:05:47,067
也允许客户启用该类扩展

101
00:05:47,133 --> 00:05:49,133
如果他们想要面对

102
00:05:49,200 --> 00:05:50,633
不需要的信息这一持续性问题

103
00:05:50,933 --> 00:05:53,833
扩展必须符合一些特殊规则

104
00:05:53,900 --> 00:05:55,400
在使用这些API时

105
00:05:56,867 --> 00:05:59,400
第一条规则是 信息收件人的电话

106
00:05:59,467 --> 00:06:01,333
绝不能发送至扩展

107
00:06:01,800 --> 00:06:04,633
只有发件人的电话号码或邮件地址可以

108
00:06:04,700 --> 00:06:06,067
因为需要这样做

109
00:06:06,133 --> 00:06:08,467
来决定是否过滤一条信息

110
00:06:09,400 --> 00:06:11,867
另一条关键规则是信息过滤扩展

111
00:06:11,933 --> 00:06:15,433
绝不能在容器外导出信息内容

112
00:06:15,500 --> 00:06:18,967
因此这些扩展还有额外的限制

113
00:06:19,567 --> 00:06:22,400
它们不能写入
和所包含应用共享的文件

114
00:06:22,600 --> 00:06:24,700
也不能执行网络操作

115
00:06:25,467 --> 00:06:26,500
这么规定的原因是

116
00:06:26,567 --> 00:06:28,933
尽管一些信息是不需要的垃圾

117
00:06:29,233 --> 00:06:30,367
另一些可能是合法的

118
00:06:30,433 --> 00:06:33,700
只是发件人还不在收件人的联系人里

119
00:06:33,900 --> 00:06:36,633
因此所有信息都要保密 这是必须的

120
00:06:36,700 --> 00:06:40,200
并且绝不能以任何方式
导出会暴露收件人的信息

121
00:06:40,267 --> 00:06:42,367
除了信息本身包含的以外

122
00:06:43,800 --> 00:06:46,167
尽管它们自己无法执行网络操作

123
00:06:46,233 --> 00:06:47,833
这些扩展可以

124
00:06:47,900 --> 00:06:50,500
间接向服务器推迟请求

125
00:06:50,700 --> 00:06:53,067
当扩展请求推迟时

126
00:06:53,133 --> 00:06:56,967
iOS会以扩展的名义
用一种安全的方法发出网络请求

127
00:06:57,367 --> 00:06:58,900
之后我们会来看一个例子

128
00:06:59,933 --> 00:07:01,200
需要记住的重点事项

129
00:07:01,267 --> 00:07:03,733
是扩展绝不能在容器外

130
00:07:03,800 --> 00:07:06,733
导出信息 这样才能维护用户隐私

131
00:07:09,667 --> 00:07:12,733
信息应用有一些具体的标准

132
00:07:12,800 --> 00:07:16,200
来决定是否给扩展发送信息

133
00:07:17,033 --> 00:07:20,667
首先该功能只针对SMS和MMS信息

134
00:07:20,733 --> 00:07:22,333
iMesssage除外

135
00:07:22,767 --> 00:07:26,933
如前所述 不需要的iMessage
使用不同的机制来处理

136
00:07:27,000 --> 00:07:29,567
所以扩展标准只适用于SMS和MMS

137
00:07:30,900 --> 00:07:33,500
我反复提到 只有未知发件人

138
00:07:33,567 --> 00:07:35,833
或不在收件人联系人名单里的

139
00:07:35,900 --> 00:07:38,433
才真正发送给扩展进行分析

140
00:07:39,033 --> 00:07:43,433
如果发件人在联系人名单里
我们认为收件人认识发件人

141
00:07:44,000 --> 00:07:46,000
并想要从发件人处收到信息

142
00:07:46,200 --> 00:07:49,600
也就是说如果一条信息
曾经错误地被归为垃圾

143
00:07:49,667 --> 00:07:52,300
那么用户可以把该发件人
加入到联系人名单

144
00:07:52,367 --> 00:07:54,267
以保证未来不会被过滤掉

145
00:07:55,333 --> 00:07:59,567
如果用户正在
和不是联系人的人交换信息

146
00:07:59,633 --> 00:08:02,267
并且多次回复了该线程

147
00:08:02,333 --> 00:08:05,200
我们会停止发送任何该线程的后续消息

148
00:08:05,267 --> 00:08:06,267
至扩展当中

149
00:08:06,900 --> 00:08:09,800
或者 如果用户多次回复

150
00:08:09,867 --> 00:08:11,600
已经被标为垃圾的线程

151
00:08:11,667 --> 00:08:14,200
该线程将会恢复至非垃圾选项卡

152
00:08:15,000 --> 00:08:18,333
多次回复将会被解读为
来自收件人的信号

153
00:08:18,400 --> 00:08:21,233
即他们确实想要和发件人进行交流

154
00:08:22,133 --> 00:08:25,467
因此 所有这些标准不直接影响API

155
00:08:25,533 --> 00:08:28,200
但是作为扩展开发者的你们

156
00:08:28,267 --> 00:08:31,167
在测试应用时应该注意这一点

157
00:08:34,732 --> 00:08:36,567
现在 我想在Xcode里做一个演示

158
00:08:36,633 --> 00:08:38,933
关于如何创建信息过滤扩展

159
00:08:40,633 --> 00:08:43,067
我编写了一个应用程序
名为Filter It

160
00:08:43,133 --> 00:08:45,267
我想添加一个信息过滤扩展

161
00:08:47,000 --> 00:08:49,667
首先需要做的是 添加一个新目标

162
00:08:52,500 --> 00:08:55,467
选择iOS信息过滤模板

163
00:08:56,267 --> 00:08:57,400
给它一个名字

164
00:09:02,900 --> 00:09:05,067
一个新文件已经加入到项目

165
00:09:05,133 --> 00:09:08,333
该文件名为Message
FilterExtension.swift

166
00:09:08,400 --> 00:09:09,633
来看一下该文件

167
00:09:20,000 --> 00:09:24,333
首先看到一个方法
名为handle_queryRequest context

168
00:09:24,400 --> 00:09:25,933
该方法呼叫扩展

169
00:09:26,000 --> 00:09:29,033
因此它可以检查传入的信息
以及返回的回应

170
00:09:29,100 --> 00:09:30,667
使用completion处理程序

171
00:09:33,167 --> 00:09:36,600
模板现有的结构是先尝试离线检查

172
00:09:36,667 --> 00:09:40,267
使用这个方法名为offlineAction
(for:queryRequest)

173
00:09:41,900 --> 00:09:46,033
它将返回一个操作 即允许 过滤或无

174
00:09:48,267 --> 00:09:49,867
在该演示里 我们需要做的是

175
00:09:49,933 --> 00:09:52,567
自定义该offlineAction
帮助方法

176
00:09:52,833 --> 00:09:54,600
来看一下它当前的功能

177
00:09:57,833 --> 00:09:59,833
现在它总是返回无

178
00:10:00,033 --> 00:10:02,000
我将会把它替换为一些简单的逻辑

179
00:10:02,067 --> 00:10:05,167
改为如果信息包含“垃圾”一词
则总是过滤

180
00:10:09,433 --> 00:10:12,333
在真正的扩展里
可以把这一步设得更复杂

181
00:10:12,400 --> 00:10:13,633
但目前这样已经可以了

182
00:10:14,467 --> 00:10:16,967
这就是如何创建一个简单的 离线的

183
00:10:17,033 --> 00:10:18,433
信息过滤扩展

184
00:10:20,067 --> 00:10:22,000
（网络推迟）

185
00:10:22,067 --> 00:10:24,067
尽管一些应用可以离线做大部分

186
00:10:24,133 --> 00:10:25,933
或者所有的检查

187
00:10:26,233 --> 00:10:28,833
另一些应用可能认为
利用网络服务器检查

188
00:10:28,900 --> 00:10:30,500
是否需要过滤信息更为有用

189
00:10:30,733 --> 00:10:33,133
接下来 我想讲讲网络推迟

190
00:10:34,867 --> 00:10:37,000
展示网络推迟工作原理的最好方法

191
00:10:37,067 --> 00:10:38,367
就是用另一张图

192
00:10:39,533 --> 00:10:43,267
如前所述 当消息被接收
会首先在信息应用里

193
00:10:43,333 --> 00:10:45,233
然后被发送至选中的扩展

194
00:10:45,933 --> 00:10:48,633
但这次扩展选择推迟该请求

195
00:10:48,700 --> 00:10:49,800
至网络服务器

196
00:10:49,867 --> 00:10:52,633
该服务器的URL信息
在info.plist中指定

197
00:10:53,300 --> 00:10:55,200
它告诉信息应用推迟

198
00:10:55,267 --> 00:10:59,100
然后信息应用对该服务器URL
发出JSON请求

199
00:11:00,067 --> 00:11:02,233
然后服务器检查

200
00:11:02,300 --> 00:11:06,200
JSON请求中的信息内容
并可以以任何格式进行回应

201
00:11:06,533 --> 00:11:09,267
该回应会马上传回给扩展

202
00:11:09,967 --> 00:11:12,933
这里 扩展从服务器读取响应

203
00:11:13,000 --> 00:11:17,600
并最终返回一个
ILMessageFilterQueryResponse

204
00:11:22,100 --> 00:11:23,967
请注意有一些限制

205
00:11:24,033 --> 00:11:25,667
在使用网络推迟时

206
00:11:26,233 --> 00:11:28,433
首先 推迟的网络请求

207
00:11:28,500 --> 00:11:31,100
不包含任何个人身份信息

208
00:11:31,167 --> 00:11:32,900
关于信息收件人

209
00:11:35,200 --> 00:11:40,167
网络URL被静态硬编码至
扩展的info.plist文件

210
00:11:40,233 --> 00:11:44,333
键名为ILMessageFilterExtension
NetworkURL

211
00:11:44,667 --> 00:11:48,500
因此不同的请求或不同的用户
该URL都不会改变

212
00:11:52,900 --> 00:11:57,400
所有URL都必须是安全的Https
服务器必须被配置为

213
00:11:57,467 --> 00:12:00,200
不需要任何应用程序传输安全技术

214
00:12:00,267 --> 00:12:03,767
即ATS覆盖 因为无法配置它们

215
00:12:05,567 --> 00:12:08,833
该功能还需要应用和服务器

216
00:12:08,900 --> 00:12:13,500
都使用关联的域
或Apple App Site Association功能

217
00:12:13,567 --> 00:12:15,133
也许你们对此已经很熟悉

218
00:12:15,200 --> 00:12:17,167
如果曾经采用过别的iOS功能

219
00:12:17,233 --> 00:12:19,633
比如 App Links
或者Shared Web Credentials

220
00:12:20,833 --> 00:12:22,733
更多信息请观看演讲

221
00:12:22,800 --> 00:12:26,800
2015年WWDC上的
“无缝连接你的应用程序”

222
00:12:28,167 --> 00:12:29,967
最后要注意的限制是

223
00:12:30,033 --> 00:12:32,500
任何网络服务器
想要设置的Cookie

224
00:12:32,567 --> 00:12:34,833
出于维护隐私 都会被忽略

225
00:12:38,100 --> 00:12:41,700
向网络服务发送的请求
都是格式化的JSON

226
00:12:41,767 --> 00:12:46,333
并包括ILMessageFilterQueryRequest
对象里的相同信息

227
00:12:46,400 --> 00:12:50,767
包括信息发件人
即一个电话号码或邮件地址

228
00:12:50,833 --> 00:12:52,033
以及信息正文

229
00:12:53,267 --> 00:12:55,800
请求还包括应用程序的版本

230
00:12:55,867 --> 00:12:59,300
即应用程序的info.plist文件中的
CFBundleVersion键值

231
00:13:00,233 --> 00:13:03,033
这一点可能有用
如果应用程序已经发布了

232
00:13:03,100 --> 00:13:05,833
几个具有不同功能的版本

233
00:13:05,900 --> 00:13:07,267
并且需要格式化回应

234
00:13:07,333 --> 00:13:10,467
以确保某个特定版本的
应用程序可以理解

235
00:13:11,567 --> 00:13:14,633
还包括了JSON请求格式本身的版本

236
00:13:14,700 --> 00:13:16,000
也就是当前版本

237
00:13:17,267 --> 00:13:18,800
和请求格式不同

238
00:13:19,167 --> 00:13:22,267
回应格式完全取决于你的应用程序

239
00:13:22,333 --> 00:13:24,567
并不一定非要JSON格式

240
00:13:25,033 --> 00:13:27,833
回应正文传回扩展进行解析

241
00:13:27,900 --> 00:13:30,100
因此对其格式没有要求

242
00:13:32,900 --> 00:13:35,433
快速看一下JSON请求格式

243
00:13:35,500 --> 00:13:38,033
可以看到 它包含所有之前提到的信息

244
00:13:43,867 --> 00:13:45,467
回到Filter It应用

245
00:13:45,533 --> 00:13:48,567
为扩展添加网络推迟功能

246
00:13:52,167 --> 00:13:53,167
再看一下

247
00:13:53,233 --> 00:13:55,833
之前的handle _query Request方法

248
00:13:56,200 --> 00:13:59,367
可以看到 在离线检查结束后

249
00:13:59,433 --> 00:14:01,600
如果返回的操作是“无”

250
00:14:01,667 --> 00:14:04,367
即处于Switch语句的这种情况

251
00:14:04,433 --> 00:14:06,033
我们假设该查询请求

252
00:14:06,100 --> 00:14:09,033
无法只用离线检查进行处理

253
00:14:09,100 --> 00:14:12,100
需要咨询网络服务器得到解答

254
00:14:18,633 --> 00:14:23,233
为此 代码调用
deferQueryRequestToNetwork方法

255
00:14:23,300 --> 00:14:24,500
在扩展上下文

256
00:14:25,400 --> 00:14:29,133
这将导致以扩展名义做出网络请求

257
00:14:29,200 --> 00:14:32,633
请求完成后 将异步调用该完成块

258
00:14:33,633 --> 00:14:36,933
在该完成块内部 如果网络有一个回应

259
00:14:37,000 --> 00:14:39,967
并且没有错误
可以使用另一个帮助方法

260
00:14:40,033 --> 00:14:44,167
名为action(for: networkResponse)
将其转换为一个操作

261
00:14:44,433 --> 00:14:46,700
来看看该方法及其功能

262
00:14:50,700 --> 00:14:53,167
和离线检查帮助方法一样

263
00:14:53,233 --> 00:14:55,433
该方法也默认返回“无”

264
00:14:55,500 --> 00:14:58,567
来对它进行自定义 解析服务器回应

265
00:14:59,667 --> 00:15:03,267
假设服务器返回JSON
尽管不是必须

266
00:15:03,333 --> 00:15:06,600
我将使用Swift 4中
新的Foundation Decoding API

267
00:15:06,667 --> 00:15:07,967
来解码回应

268
00:15:09,300 --> 00:15:11,967
我会把之前写好的代码粘贴过来

269
00:15:12,033 --> 00:15:13,733
简单讲一下

270
00:15:19,433 --> 00:15:21,033
首先定义了一个结构

271
00:15:21,100 --> 00:15:24,167
描述服务器返回的JSON格式

272
00:15:25,433 --> 00:15:27,967
然后创建了一个JSON解码器实例

273
00:15:29,267 --> 00:15:31,800
用于解码网络数据

274
00:15:31,867 --> 00:15:33,433
作为结构实例

275
00:15:34,867 --> 00:15:37,767
最后返回解码完成的操作

276
00:15:37,833 --> 00:15:39,033
并保存在结构里

277
00:15:42,633 --> 00:15:45,133
如果有任何错误 会在下面处理

278
00:15:47,867 --> 00:15:50,300
并返回默认回应“无”

279
00:15:53,967 --> 00:15:56,700
就这样 我们成功添加了网络推迟支持

280
00:15:56,767 --> 00:15:58,833
在信息过滤应用扩展里

281
00:15:59,100 --> 00:16:03,600
现在对于传入的信息
该扩展既支持离线也支持网络检查

282
00:16:07,133 --> 00:16:10,167
这就是应用程序
如何帮助过滤不需要的信息

283
00:16:10,233 --> 00:16:14,767
使用新的信息过滤扩展
以及iOS 11的Identity Lookup框架

284
00:16:15,700 --> 00:16:18,500
我们希望在用户隐私

285
00:16:18,567 --> 00:16:21,000
和解决用户该迫切需求之间
取得一个平衡

286
00:16:21,367 --> 00:16:24,633
结果是推出了应用程序
可以使用的强大API

287
00:16:24,700 --> 00:16:27,667
但其中有一些特殊规则需要注意

288
00:16:28,567 --> 00:16:30,900
请下载最新的STK

289
00:16:30,967 --> 00:16:33,033
看看最新的Identity Lookup框架

290
00:16:33,100 --> 00:16:35,533
今天就试着写一个信息过滤扩展吧

291
00:16:38,500 --> 00:16:41,100
更多信息请查看演讲页面的链接

292
00:16:41,167 --> 00:16:43,200
在WWDC官网上

293
00:16:45,767 --> 00:16:49,033
今年的大会 确实还有一些相关演讲

294
00:16:49,733 --> 00:16:52,767
关于平台上隐私实践的更多信息

295
00:16:52,833 --> 00:16:54,967
请观看“隐私和应用程序”演讲

296
00:16:55,033 --> 00:16:58,567
将于周二11:20在行政大厅举办

297
00:16:59,600 --> 00:17:03,867
关于演示中Foundation
和Coding API的更多信息

298
00:17:03,933 --> 00:17:07,200
请观看周三11点
在2号大厅举行

299
00:17:07,267 --> 00:17:09,400
的“Foundation新特性”演讲

300
00:17:10,333 --> 00:17:16,233
2015年WWDC有一个很棒的演讲
名为“无缝连接你的应用程序”

301
00:17:16,300 --> 00:17:18,367
详细讲解了相关联的域功能

302
00:17:18,433 --> 00:17:21,767
是使用网络推迟时
信息过滤扩展所需要的

303
00:17:22,067 --> 00:17:23,633
请在档案中查看该演讲

304
00:17:23,700 --> 00:17:27,200
关于如何在应用程序
和服务器上实现的详细信息

305
00:17:27,567 --> 00:17:28,767
非常感谢观看

