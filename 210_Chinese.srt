1
00:00:26,159 --> 00:00:29,563
大家好 欢迎来到演讲210
本场演讲主题是“Core Data新特性”

2
00:00:30,297 --> 00:00:31,298
我是梅利莎

3
00:00:31,365 --> 00:00:32,966
Core Data的工程师

4
00:00:33,033 --> 00:00:36,436
今天我的同事瑞希
将会和我一起登台演讲

5
00:00:37,070 --> 00:00:39,673
我们将会介绍

6
00:00:39,740 --> 00:00:41,441
过去一年里
我们所做的工作

7
00:00:41,508 --> 00:00:42,943
这项工作对我们来说充满乐趣

8
00:00:43,010 --> 00:00:44,578
希望你们也会觉得有趣

9
00:00:44,645 --> 00:00:47,681
而且对你们的应用开发有用处

10
00:00:48,215 --> 00:00:50,684
我们希望本场演讲中
所涉及的所有技术问题

11
00:00:50,751 --> 00:00:51,852
大家都曾经遇到过

12
00:00:52,252 --> 00:00:53,887
（路线图）

13
00:00:53,987 --> 00:00:55,322
那么 我们在做些什么呢？

14
00:00:55,956 --> 00:00:58,025
我们一直在做
Core Spotlight整合工作

15
00:00:58,959 --> 00:01:00,894
我们已经增加一系列的
新Indexing API

16
00:01:00,961 --> 00:01:03,697
我们还增加了另外一项重要功能
持续性历史跟踪

17
00:01:03,764 --> 00:01:05,532
瑞希将会介绍这项功能

18
00:01:05,799 --> 00:01:06,967
这是一项很酷的功能

19
00:01:07,034 --> 00:01:08,902
我很高兴能够在这里为大家展示

20
00:01:09,837 --> 00:01:13,006
首先让阿方斯给大家打一声招呼
它是我的吉祥物 一直陪伴着我

21
00:01:14,441 --> 00:01:15,442
那么Core Spotlight

22
00:01:16,276 --> 00:01:17,477
什么是Core Spotlight？

23
00:01:18,345 --> 00:01:19,446
讨论Core Spotlight之前

24
00:01:19,513 --> 00:01:21,281
首先让我谈谈Spotlight

25
00:01:21,815 --> 00:01:25,219
Spotlight是原创性的搜索API
它是Mac OS 10上的搜索技术

26
00:01:25,285 --> 00:01:28,322
它以文档为中心
这意味着…

27
00:01:28,589 --> 00:01:30,624
在Spotlight菜单中

28
00:01:30,691 --> 00:01:33,393
进行搜索操作

29
00:01:33,460 --> 00:01:36,263
所获得的搜索结果
将会标识出Spotlight

30
00:01:36,330 --> 00:01:38,365
检索到的文档

31
00:01:38,432 --> 00:01:41,201
但是不会告诉你
检索内容位于文档的哪个位置

32
00:01:42,102 --> 00:01:43,737
对于数据库来说
这并不是理想的方法

33
00:01:43,804 --> 00:01:46,006
我们知道
数据库中有大量的记录

34
00:01:47,541 --> 00:01:48,876
于是我们推出了
Core Spotlight

35
00:01:49,343 --> 00:01:50,811
Core Spotlight是iOS上的

36
00:01:50,878 --> 00:01:52,446
原创性搜索技术

37
00:01:52,513 --> 00:01:54,381
它十分适合数据库

38
00:01:54,781 --> 00:01:58,652
它不仅会返回
用户所选择的

39
00:01:58,986 --> 00:02:00,454
应用程序和文档

40
00:02:00,787 --> 00:02:02,723
而且会告诉你
搜索内容在文档中的位置

41
00:02:03,123 --> 00:02:05,058
你可以在你的应用程序中
集成这项功能

42
00:02:05,125 --> 00:02:09,530
这样就可以提供
你的用户真正想看到的结果

43
00:02:09,696 --> 00:02:12,065
现在Mac OS和iOS
已经支持这项功能

44
00:02:12,132 --> 00:02:15,068
我们认为现在应该将它集成到
Core Data之中

45
00:02:16,503 --> 00:02:18,071
那么Core Spotlight
是如何运作的？

46
00:02:18,138 --> 00:02:19,306
它与Spotlight十分相似

47
00:02:19,573 --> 00:02:20,807
当你安装一个应用之后

48
00:02:20,874 --> 00:02:21,975
里面会有很多的数据

49
00:02:23,043 --> 00:02:25,512
用户进入Spotlight菜单

50
00:02:25,579 --> 00:02:26,947
查找应用之中的数据内容

51
00:02:27,147 --> 00:02:29,750
比如 一张印度照片

52
00:02:30,384 --> 00:02:36,423
Spotlight会启动你的应用
为你提供一个用户活动

53
00:02:38,592 --> 00:02:40,260
你可以用它

54
00:02:40,327 --> 00:02:42,396
检索用户想要查找的信息

55
00:02:43,096 --> 00:02:46,033
弹出指定窗口
让用户能够看到搜索结果

56
00:02:47,768 --> 00:02:51,138
前面我说过 现在
Mac OS和iOS已支持此功能

57
00:02:51,438 --> 00:02:54,141
今天Core Spotlight团队
希望我告诉你们

58
00:02:54,575 --> 00:02:56,210
你们也可以使用
Core Spotlight API

59
00:02:56,276 --> 00:02:59,446
在你们的应用中
访问Spotlight搜索索引

60
00:02:59,513 --> 00:03:00,514
这真的很酷

61
00:03:00,948 --> 00:03:02,115
它可以完成这些功能

62
00:03:02,282 --> 00:03:04,718
而不会造成在系统中
留下大量的零长度文件

63
00:03:05,152 --> 00:03:06,253
我真的非常希望

64
00:03:06,320 --> 00:03:09,189
你们喜欢这个功能

65
00:03:11,525 --> 00:03:12,526
它是如何运作的呢？

66
00:03:12,593 --> 00:03:15,128
Core Spotlight集成
包含三个基本组件

67
00:03:15,195 --> 00:03:16,763
第一个是…

68
00:03:17,197 --> 00:03:20,868
我们已经在NSPropertyDescription上
重新定义Spotlight属性索引的用途

69
00:03:20,934 --> 00:03:23,904
用它指示属性
应该被推入Core Spotlight

70
00:03:25,138 --> 00:03:27,307
但我们需要一种方法来说明
在Spotlight 菜单中

71
00:03:27,374 --> 00:03:28,709
应该显示哪些内容

72
00:03:28,876 --> 00:03:29,877
我们的表达式为：

73
00:03:29,943 --> 00:03:32,646
NSEntityDescription.
coreSpotlightDisplayNameExpression

74
00:03:33,013 --> 00:03:34,615
当然还有Exporter

75
00:03:34,681 --> 00:03:36,617
无论何时在应用中进行存储

76
00:03:36,950 --> 00:03:40,454
无论将用户进行的任何更改
推入Core Spotlight Index

77
00:03:42,089 --> 00:03:44,091
CoreSpotlightDisplayNameExpression

78
00:03:44,157 --> 00:03:46,360
都能够理解这些操作

79
00:03:46,426 --> 00:03:48,161
它其实是NSExpression
的一个实例

80
00:03:48,228 --> 00:03:51,365
你将它设置为
NS Entity Description上的属性

81
00:03:51,965 --> 00:03:55,335
在Core Spotlight索引更新时
将会计算它的值

82
00:03:55,936 --> 00:03:56,970
在对象方面…

83
00:03:57,037 --> 00:04:00,474
经过更新的托管对象
作为求值对象参数

84
00:04:00,908 --> 00:04:04,044
这样就能够返回
被推入Core Spotlight的任何内容

85
00:04:04,111 --> 00:04:06,380
甚至不是
基本Core Data类型

86
00:04:06,446 --> 00:04:09,016
比如 一个
CS Localized String实例

87
00:04:09,750 --> 00:04:12,452
这些表达式
进行Keypaths求值

88
00:04:12,519 --> 00:04:14,354
但是 更有趣的是

89
00:04:14,421 --> 00:04:17,925
它们可以是内建函数
可以是小写 大写等

90
00:04:18,325 --> 00:04:21,428
当然 如果你也可以像我一样
使用完全随机的函数

91
00:04:21,495 --> 00:04:25,666
在你的运行时 寻找类实例

92
00:04:25,732 --> 00:04:28,635
调用随机方法以获取内容

93
00:04:29,636 --> 00:04:30,704
这是很酷的功能

94
00:04:32,439 --> 00:04:34,474
当然
还有NSCoreDataSpotlightDelegate

95
00:04:34,541 --> 00:04:36,777
它相当于一大块的代码

96
00:04:36,844 --> 00:04:37,911
完成所有工作

97
00:04:38,846 --> 00:04:41,381
它实现CSSearchableIndexDelegate

98
00:04:41,582 --> 00:04:44,017
提供所有方法的实现

99
00:04:44,084 --> 00:04:45,619
你可以直接使用它

100
00:04:46,553 --> 00:04:48,388
它在后台线程上使用单独的存储空间

101
00:04:48,455 --> 00:04:50,157
因此你不需要担心

102
00:04:50,224 --> 00:04:52,259
Spotlight Exporter
所做的任何事情

103
00:04:52,326 --> 00:04:55,629
阻止你的主视图上下文完成其工作

104
00:04:56,463 --> 00:04:57,297
你可以使用

105
00:04:57,364 --> 00:04:59,800
NSPersistentStoreDescription
和一个模型对它进行初始化

106
00:04:59,867 --> 00:05:01,935
因此它需要知道其处理的工作是什么

107
00:05:02,870 --> 00:05:05,172
你告诉Persistent Store

108
00:05:05,239 --> 00:05:09,076
它应该通过
将Exporter设置为一个选项

109
00:05:09,543 --> 00:05:12,145
将其内容导出到
Core Spotlight

110
00:05:12,212 --> 00:05:15,215
当你在PersistentStoreCoordinator上

111
00:05:15,482 --> 00:05:16,750
调用NSPersistentStore

112
00:05:17,451 --> 00:05:20,988
如果你不喜欢默认行为
也可以进行重写

113
00:05:21,054 --> 00:05:25,826
重写方法是 NSDataCoreSpotlight
delegate attribute set for object:

114
00:05:26,126 --> 00:05:28,495
重写方法可能是这样的

115
00:05:28,896 --> 00:05:30,864
我们有一个基本方法

116
00:05:30,931 --> 00:05:33,600
它获取超类返回的属性集

117
00:05:34,601 --> 00:05:37,371
它通过对象发现
这是一张照片的实例

118
00:05:37,437 --> 00:05:40,607
因为这是一个照片应用
而且这些照片具有标记

119
00:05:40,674 --> 00:05:42,743
当有人搜索内容时…

120
00:05:43,844 --> 00:05:46,847
当用户搜索内容时
将返回具有一个这种标记的结果

121
00:05:46,914 --> 00:05:49,183
我想要返回一张
具有这个标记的照片

122
00:05:49,550 --> 00:05:51,351
因此标记本身并不吸引人

123
00:05:51,885 --> 00:05:53,987
因此我会把所有标记信息

124
00:05:54,054 --> 00:05:57,491
堆集到照片对象上
当Spotlight中有匹配项时

125
00:05:57,691 --> 00:05:59,226
将会返回照片

126
00:06:00,027 --> 00:06:02,029
然后我返回属性集

127
00:06:02,663 --> 00:06:04,665
你们大多数人
都需要写这么多的代码

128
00:06:04,731 --> 00:06:05,966
来实现此功能

129
00:06:07,901 --> 00:06:09,002
现在我进行演示

130
00:06:09,369 --> 00:06:10,404
（演示）

131
00:06:16,410 --> 00:06:17,978
这里有一个小应用

132
00:06:20,247 --> 00:06:22,349
请忽略后面的X Code

133
00:06:23,917 --> 00:06:25,485
这个应用显示照片

134
00:06:26,220 --> 00:06:27,754
你可以滚动 查看内容

135
00:06:29,489 --> 00:06:32,659
点击可以查看

136
00:06:33,794 --> 00:06:34,995
是各种各样的人像照片

137
00:06:35,062 --> 00:06:36,730
含有少量的元数据信息

138
00:06:37,231 --> 00:06:38,232
但是有趣的是

139
00:06:38,832 --> 00:06:41,602
现在我可以调出Spotlight
输入搜索内容

140
00:06:44,171 --> 00:06:48,842
例如 在Spotlight中
输入我所知道的内容

141
00:06:48,909 --> 00:06:51,712
它会自动激活我的应用

142
00:06:51,778 --> 00:06:55,215
调用application
continue user activity方法

143
00:06:55,549 --> 00:06:56,917
使用NS user activity

144
00:06:57,317 --> 00:07:00,521
我已经跳入这个方法
看看其执行结果

145
00:07:00,687 --> 00:07:03,390
“有人打开了某物”

146
00:07:03,624 --> 00:07:07,261
我要挖掘用户活动用户信息

147
00:07:07,327 --> 00:07:09,096
因为那里有我们需要的内容

148
00:07:10,497 --> 00:07:11,798
然后查找标识符

149
00:07:12,432 --> 00:07:14,434
如果我打印出标识符
我们可以看到

150
00:07:14,635 --> 00:07:18,539
有很多的标识符和用户信息

151
00:07:18,605 --> 00:07:21,108
是托管对象ID
字符串表示

152
00:07:21,608 --> 00:07:24,411
我要将它转换成为URI

153
00:07:24,711 --> 00:07:28,282
要求persistent StoreCoordinator
将它转换成为托管对象ID

154
00:07:30,717 --> 00:07:31,985
然后我继续

155
00:07:33,854 --> 00:07:34,922
哇

156
00:07:36,623 --> 00:07:40,093
我打开了用户请求的照片

157
00:07:40,928 --> 00:07:43,964
多么可爱的视图

158
00:07:46,366 --> 00:07:47,201
这就是

159
00:07:47,768 --> 00:07:49,870
Core Spotlight Integration工作原理

160
00:07:49,937 --> 00:07:51,238
我们已经完成大部分工作

161
00:07:51,305 --> 00:07:56,176
你需要实现方法就可以了

162
00:07:56,877 --> 00:07:58,512
这就是Core Spotlight Integration

163
00:07:59,379 --> 00:08:00,948
（便利之处）

164
00:08:01,014 --> 00:08:03,984
我们为你提供一些
非常好用的便利功能

165
00:08:04,451 --> 00:08:06,820
如果你决定启用
Core Spotlight Integration

166
00:08:07,354 --> 00:08:09,990
传递exporter至…
作为选项之一

167
00:08:10,057 --> 00:08:12,259
当你添加store到persistent
store coordinator时

168
00:08:12,659 --> 00:08:14,361
当你的应用首次启动时

169
00:08:14,428 --> 00:08:16,797
我们将自动开始导出到
Core Spotlight

170
00:08:16,864 --> 00:08:19,766
将会继续导出
自动导出所有数据

171
00:08:19,833 --> 00:08:21,835
即使你的应用已经退出

172
00:08:21,902 --> 00:08:23,837
如果你的用户同时退出应用

173
00:08:24,304 --> 00:08:25,873
我们使用持续性历史跟踪功能

174
00:08:25,939 --> 00:08:27,574
确保所有数据被推入

175
00:08:28,075 --> 00:08:30,544
即使你的应用崩溃 退出

176
00:08:31,078 --> 00:08:33,145
运行不正常

177
00:08:35,249 --> 00:08:36,450
（不便之处）

178
00:08:36,517 --> 00:08:37,818
有少量的不便之处

179
00:08:37,885 --> 00:08:39,653
Core Spotlight
和Spotlight Integration

180
00:08:39,720 --> 00:08:41,722
如果你同时实现这两种功能
它们是互相排斥的

181
00:08:41,788 --> 00:08:43,890
如果你将实体设置到
Core Spotlight

182
00:08:44,458 --> 00:08:48,362
Display Name Expression
属性存储在外部记录中

183
00:08:49,496 --> 00:08:51,298
模型编译器将会报错

184
00:08:52,132 --> 00:08:54,735
目前我们不追踪
批处理操作的结果

185
00:08:56,770 --> 00:08:58,138
一些不便之处

186
00:08:58,205 --> 00:09:00,374
第一个是我在调试时发现的

187
00:09:00,440 --> 00:09:03,277
因为我在单独框架中
构建我的所有单元测试

188
00:09:03,343 --> 00:09:06,747
由XCTest运行
并没有这种授权

189
00:09:06,813 --> 00:09:09,550
这会造成困惑
让我无法与Spotlight对话

190
00:09:10,350 --> 00:09:12,719
无论任何应用
想要与Spotlight对话

191
00:09:12,786 --> 00:09:16,723
都需要com.apple.
application-identifier授权

192
00:09:17,157 --> 00:09:18,458
你们大多数都会默认获得授权

193
00:09:18,525 --> 00:09:21,562
但是如果你想要编写单元测试
并由XCTtest运行

194
00:09:22,229 --> 00:09:23,230
请认识到这一点

195
00:09:23,463 --> 00:09:25,532
当然你需要处理搜索结果

196
00:09:26,934 --> 00:09:29,002
你需在application delegate上

197
00:09:30,237 --> 00:09:32,773
实现Application
Continue User Activity

198
00:09:33,140 --> 00:09:34,908
设置你想要的内容

199
00:09:35,209 --> 00:09:36,710
我们可以在屏幕上看到

200
00:09:37,177 --> 00:09:39,446
也可以在演示中看到
我在这里显示给大家看

201
00:09:39,880 --> 00:09:41,281
这是你们要实现的方法

202
00:09:41,682 --> 00:09:44,685
非常简单 抓取用户活动用户信息

203
00:09:45,819 --> 00:09:48,622
托管对象ID标识符位于这里

204
00:09:48,689 --> 00:09:51,258
隶属于KCS Searchable Item
Activity Identifier

205
00:09:52,192 --> 00:09:54,027
我已经把它转换为托管对象ID

206
00:09:54,494 --> 00:09:56,129
然后你们就可以进行想要的操作

207
00:09:56,964 --> 00:10:00,767
比如查看新窗口
缩放到正确的视图大小等

208
00:10:02,836 --> 00:10:05,005
存在一些不便之处

209
00:10:05,172 --> 00:10:07,708
如果你使用旧的
Spotlight Integration

210
00:10:08,609 --> 00:10:13,046
你需要决定是否删除旧引用文件
如果磁盘上有这些文件

211
00:10:13,113 --> 00:10:15,182
因为我们不知道
这些文件是否有语义学意义

212
00:10:16,383 --> 00:10:19,286
Core Spotlight API是x86指令

213
00:10:19,353 --> 00:10:21,722
这意味着此功能
仅支持x86处理

214
00:10:21,788 --> 00:10:23,724
现在是时候升级你的应用了

215
00:10:26,026 --> 00:10:27,027
（新Indexing API）

216
00:10:27,094 --> 00:10:31,198
关于Core Spotlight就是这些
我们还增加了新Indexing API

217
00:10:32,833 --> 00:10:35,269
那么 indexing是什么呢？
Indexing让你能够

218
00:10:35,335 --> 00:10:37,404
配置你的数据库
更快地进行搜索

219
00:10:38,438 --> 00:10:40,474
你可以有多个索引

220
00:10:40,908 --> 00:10:42,009
每个索引可以有多个列

221
00:10:42,075 --> 00:10:44,344
一个列可以属于多个索引

222
00:10:44,411 --> 00:10:46,480
这让你能够设置大量索引

223
00:10:46,847 --> 00:10:49,850
数据库可以使用这些索引
来选择最高效的索引

224
00:10:50,184 --> 00:10:52,286
执行想要的查询

225
00:10:52,352 --> 00:10:54,121
其表达方式好像是：

226
00:10:54,388 --> 00:10:57,257
“我想要使用这些列
我将使用这个索引”

227
00:10:57,324 --> 00:10:58,892
（题外话：INDEXING）

228
00:10:58,959 --> 00:11:01,261
现在我想讨论一些
关于indexing的题话外

229
00:11:01,328 --> 00:11:03,263
主要是针对
不喜欢使用数据库的人

230
00:11:04,198 --> 00:11:07,067
基本的索引形式是二叉树索引

231
00:11:07,134 --> 00:11:08,302
支持任何位置和任何数据

232
00:11:09,469 --> 00:11:11,839
但是它们仅支持严格比较

233
00:11:11,905 --> 00:11:14,007
它们进行数据位比较

234
00:11:14,074 --> 00:11:16,610
如果不相同 索引就不匹配

235
00:11:18,145 --> 00:11:20,280
但是 更多类型的索引

236
00:11:20,347 --> 00:11:21,915
开始得到应用

237
00:11:21,982 --> 00:11:24,051
最近 一种非常有用的索引

238
00:11:24,685 --> 00:11:26,653
是RTree Index

239
00:11:27,054 --> 00:11:30,657
它是一种经过优化的索引
适用于各种基础搜索

240
00:11:31,291 --> 00:11:33,026
二进制索引看起来是这样的

241
00:11:33,093 --> 00:11:34,995
这是你的数据

242
00:11:35,062 --> 00:11:36,663
设备尺寸之类的数据

243
00:11:36,930 --> 00:11:40,033
如果构建一个BTree
你就会得到这样的东西

244
00:11:40,100 --> 00:11:41,401
（二叉树索引）

245
00:11:41,468 --> 00:11:43,770
所有节点…

246
00:11:43,837 --> 00:11:46,907
子节点中较小的数

247
00:11:46,974 --> 00:11:48,709
位于左边

248
00:11:48,775 --> 00:11:51,278
所有节点中较大的数
位于右边

249
00:11:51,345 --> 00:11:53,347
然后向下检索
非常简单

250
00:11:54,014 --> 00:11:56,283
但是 RTree Data
看上去通常是这样的

251
00:11:56,350 --> 00:11:59,286
形成很多奇怪的形状

252
00:11:59,353 --> 00:12:00,654
是多维图形

253
00:12:00,854 --> 00:12:03,657
它们通常互相重叠
看上去比较奇怪

254
00:12:04,024 --> 00:12:06,627
并没有一个很好的方法组织它们

255
00:12:06,693 --> 00:12:09,263
以形成方向线性二叉树

256
00:12:09,696 --> 00:12:12,332
RTree Data的存储方式
通常是这样的

257
00:12:12,399 --> 00:12:15,035
有一个范围零
是最小边界块

258
00:12:15,102 --> 00:12:18,539
围绕着它的所有子部分
或称集合元素

259
00:12:19,339 --> 00:12:24,278
比如 范围元素
包含范围R6和R10

260
00:12:24,344 --> 00:12:28,749
R6又包含子元素R7
R7又包含更多子元素

261
00:12:29,049 --> 00:12:30,918
这是一种轻度不平衡RTree

262
00:12:30,984 --> 00:12:32,085
我们将会适应它

263
00:12:34,755 --> 00:12:37,224
当前的indexing API
有两种类型

264
00:12:37,991 --> 00:12:40,527
你可以创建自己的资产索引

265
00:12:40,594 --> 00:12:44,364
通过调用
NSAttributeDescription.isIndexed

266
00:12:44,431 --> 00:12:46,600
设置那个资产
然后为它创建索引

267
00:12:47,100 --> 00:12:48,402
如果你想要使用多列索引

268
00:12:48,468 --> 00:12:51,205
需要调用NS Entity Description
compound Indexes

269
00:12:51,505 --> 00:12:52,973
这让你能够创建一个索引

270
00:12:53,040 --> 00:12:54,842
含有三、四、五个列

271
00:12:55,542 --> 00:12:58,579
这些API自动创建

272
00:12:58,645 --> 00:13:01,548
一个升序二叉树索引

273
00:13:03,183 --> 00:13:05,185
我们希望升级
Core Data API

274
00:13:05,252 --> 00:13:06,386
让它们变得更强大

275
00:13:06,787 --> 00:13:08,956
它们能够指向新的数据类型

276
00:13:09,556 --> 00:13:10,424
可配置性更强

277
00:13:10,991 --> 00:13:13,327
我们增加了大量的新模型类

278
00:13:14,328 --> 00:13:18,799
第一个是NSFetchIndexDescription
NSFetchIndexElementDescription

279
00:13:18,866 --> 00:13:21,935
我们为
NSEntityDescription.indexes

280
00:13:22,002 --> 00:13:24,905
增加新方法
它使用Fetch Index Description

281
00:13:25,339 --> 00:13:27,908
一个Fetch index descriptions数组
作为其参数

282
00:13:28,809 --> 00:13:30,410
我们还增加一些函数

283
00:13:30,477 --> 00:13:33,614
数据库是否应该使用特定的参数

284
00:13:33,680 --> 00:13:35,582
是否进行给定查询求值

285
00:13:36,183 --> 00:13:38,418
我们增加索引 让你能够声明

286
00:13:38,485 --> 00:13:39,953
“嘿 确实使用这个索引”

287
00:13:40,521 --> 00:13:43,423
始终都有索引存在

288
00:13:43,891 --> 00:13:46,326
能够比用户查询优化器更准确

289
00:13:46,393 --> 00:13:50,097
可以指定不要为where语句
使用这个特定的索引组件

290
00:13:52,499 --> 00:13:55,836
NSFetchIndexElementDescription
是一个基本组件

291
00:13:55,903 --> 00:14:00,107
它允许你指定索引元素
后者是一个属性

292
00:14:00,974 --> 00:14:03,911
你可以指定为属性创建
何种类型的索引

293
00:14:03,977 --> 00:14:06,613
可以是二叉树类型
或RTree类型

294
00:14:07,047 --> 00:14:09,650
如果是二叉树索引
将会使用指定的检索方向

295
00:14:09,716 --> 00:14:11,051
升序或降序

296
00:14:11,251 --> 00:14:13,854
如果进行特定类型的搜索
这一点很重要

297
00:14:13,921 --> 00:14:16,256
比如 如果搜索邮件
你可能想要

298
00:14:16,323 --> 00:14:19,493
首先显示最近的邮件
而不是以前的邮件

299
00:14:19,927 --> 00:14:24,698
因此 搜索方向会改变数据库的

300
00:14:24,765 --> 00:14:25,966
索引内容查找顺序

301
00:14:28,569 --> 00:14:32,840
FetchIndexDescription允许你
将一系列的Fetch Index Elements

302
00:14:32,906 --> 00:14:35,709
组合成一个索引
然后你可以命名

303
00:14:36,343 --> 00:14:38,545
而且你可以设置预测规则

304
00:14:38,712 --> 00:14:42,883
规定仅将匹配
此预测规则的行放入索引

305
00:14:43,617 --> 00:14:46,253
它还进行一些索引内容验证

306
00:14:46,320 --> 00:14:49,189
确保创建的索引是合理的

307
00:14:50,691 --> 00:14:54,761
这里有一些不足之处
现在你不能混合和匹配索引元素类型

308
00:14:55,095 --> 00:14:57,764
要么是RTree索引
要么是二叉树索引

309
00:14:58,465 --> 00:15:02,069
Range Index只能为小于或等于32位的

310
00:15:02,135 --> 00:15:03,237
数值资产创建范围索引

311
00:15:03,403 --> 00:15:06,039
这是基本SQLite数据库
所受到的限制

312
00:15:06,940 --> 00:15:09,142
如果你要创建自己的增量存储

313
00:15:10,010 --> 00:15:12,813
这是一个限制
如果你遇到问题 请告诉我们

314
00:15:12,880 --> 00:15:13,881
也许我们能够想出办法

315
00:15:15,482 --> 00:15:20,020
但被放入Ranged Index
的属性不能是可选的

316
00:15:20,587 --> 00:15:22,623
目前没有定义null范围

317
00:15:23,690 --> 00:15:27,027
如果你们使用代码构建模型
有一些人会这样做

318
00:15:27,094 --> 00:15:29,396
我曾经在WWDC大会上
为你们提供帮助

319
00:15:30,163 --> 00:15:33,967
如果在设置索引后 改变实体结构

320
00:15:34,434 --> 00:15:36,036
我们必须放弃索引

321
00:15:36,103 --> 00:15:38,305
这实际上应用于整个实体层级结构

322
00:15:38,372 --> 00:15:40,941
如果你在层级结构中

323
00:15:41,008 --> 00:15:43,610
增加或删除一个实体

324
00:15:43,677 --> 00:15:46,446
我们不能再确定索引是否有效
因此我们必须放弃索引

325
00:15:46,947 --> 00:15:47,814
始终放弃索引

326
00:15:50,751 --> 00:15:56,657
你们可能知道 在以前的版本中
对实体更改索引

327
00:15:56,723 --> 00:15:59,059
并不会更改实体版本Hash

328
00:15:59,126 --> 00:16:01,361
当用户使用新索引

329
00:16:01,428 --> 00:16:06,433
首次启动新版本应用时

330
00:16:06,500 --> 00:16:07,968
这意味着不会进行数据迁移

331
00:16:08,402 --> 00:16:09,670
因此不会造成性能损失

332
00:16:09,736 --> 00:16:11,872
另一方面
这也不需要迁移数据

333
00:16:11,939 --> 00:16:14,241
因此不需要更新索引

334
00:16:14,908 --> 00:16:16,910
如果想要迁移索引

335
00:16:16,977 --> 00:16:19,746
而且更新索引 你需要调用

336
00:16:19,813 --> 00:16:23,383
模型版本Hash Identifier
这将触发迁移

337
00:16:24,351 --> 00:16:27,487
SQL store将会忽略
它无法理解的任何索引

338
00:16:27,988 --> 00:16:30,490
这意味着如果你打开数据库

339
00:16:30,557 --> 00:16:33,026
你认为你已经添加索引
但是却看不到它们

340
00:16:33,594 --> 00:16:35,762
可以转到应用控制台
控制台会告诉你

341
00:16:35,829 --> 00:16:36,964
你为什么看不到索引

342
00:16:38,599 --> 00:16:39,967
我要再次进行演示

343
00:16:41,034 --> 00:16:42,202
这里有一个模型

344
00:16:42,836 --> 00:16:46,006
我不想使用

345
00:16:46,073 --> 00:16:49,843
因为这是演示
我可能会输入出错

346
00:16:50,978 --> 00:16:56,149
我在新的建模工具中
添加新索引看起来很简单

347
00:16:56,216 --> 00:17:00,754
选择想要添加索引的实体
然后来到这里

348
00:17:01,188 --> 00:17:05,959
添加实体 现在你可以看到
它有一个Add Fetch Index选项

349
00:17:06,292 --> 00:17:08,362
你可以添加一个
将它命名为by Location

350
00:17:10,864 --> 00:17:13,165
然后我可以添加多个属性

351
00:17:14,501 --> 00:17:17,171
latitude和longitude属性

352
00:17:18,105 --> 00:17:20,507
在这里 选择照片

353
00:17:21,474 --> 00:17:24,278
然后在这里 更改
Version Hash Modifier

354
00:17:27,748 --> 00:17:29,650
现在 当用户启动

355
00:17:29,716 --> 00:17:32,286
一个使用此模型版本
的应用时

356
00:17:33,854 --> 00:17:35,689
将会使用新的RTree索引

357
00:17:36,523 --> 00:17:39,359
我会运行我的演示应用

358
00:17:39,793 --> 00:17:41,495
它已经内建这种索引

359
00:17:44,598 --> 00:17:45,832
然后…

360
00:17:49,102 --> 00:17:50,337
来到这里

361
00:17:50,671 --> 00:17:54,241
获取我细心设置的
Predicate

362
00:17:56,577 --> 00:17:57,678
我忘了一件事情

363
00:18:00,414 --> 00:18:03,383
我要来到这里 编辑scheme
因为我们想要看到

364
00:18:03,450 --> 00:18:05,319
Core Data
向数据库发送什么

365
00:18:06,086 --> 00:18:09,223
我已经设置
Com Apple SQL Debug Argument

366
00:18:09,957 --> 00:18:12,993
如果你们熟悉SQL Debug
将会注意到

367
00:18:13,327 --> 00:18:14,995
与Core Data中的功能一样

368
00:18:15,395 --> 00:18:17,431
你可以非常熟悉

369
00:18:17,497 --> 00:18:19,299
1和2作为数字…

370
00:18:19,366 --> 00:18:20,534
你即将设置的级别

371
00:18:20,968 --> 00:18:24,771
我们增加一个新级别4
将打印SQLite使用的查询计划

372
00:18:24,838 --> 00:18:29,209
和Core Data发送至

373
00:18:29,276 --> 00:18:30,878
数据库的所有语句

374
00:18:31,278 --> 00:18:35,682
因此我将运行我的应用
将版本设置为4

375
00:18:38,485 --> 00:18:39,353
然后回过头来

376
00:18:41,855 --> 00:18:42,890
重置预测规则

377
00:18:44,358 --> 00:18:45,759
运行搜索

378
00:18:47,661 --> 00:18:50,898
现在我们来看上次搜索

379
00:18:53,567 --> 00:18:55,702
这更有意思 我来这里

380
00:18:55,769 --> 00:19:00,340
我把早期的版本
复制并粘贴到Text Edit之中

381
00:19:00,407 --> 00:19:02,075
在这里我要放大文本

382
00:19:04,211 --> 00:19:07,781
现在我要选择一小段文本

383
00:19:08,916 --> 00:19:10,450
Z Photo by Location

384
00:19:10,984 --> 00:19:13,253
如果查看查询计划

385
00:19:13,453 --> 00:19:15,489
你可以看到
这是一个虚拟表索引

386
00:19:15,789 --> 00:19:18,592
实际是在引导位置查询

387
00:19:18,892 --> 00:19:21,929
将经度查询导向
一个单独的RTree表

388
00:19:22,896 --> 00:19:27,901
在这里我们看到
查询16行用时0.056秒

389
00:19:27,968 --> 00:19:30,737
如果与未使用RTree的版本比较

390
00:19:32,372 --> 00:19:34,241
这是我们以前的查询

391
00:19:34,308 --> 00:19:36,310
这个与这个之间的Z经度

392
00:19:37,177 --> 00:19:41,949
我们可以看到
查询16行用时0.062

393
00:19:42,216 --> 00:19:44,685
性能提升约10%

394
00:19:45,118 --> 00:19:48,288
在配备SSD Fast Cash
的笔记本上

395
00:19:48,555 --> 00:19:51,225
在你的设备上
搜索速度提升了10%

396
00:19:51,291 --> 00:19:52,926
这是一个很小的数据集

397
00:19:53,160 --> 00:19:56,096
如果你设备上的数据大量上升

398
00:19:56,530 --> 00:19:59,800
RTree搜索速度相比
常规Binary Indexes会有大幅提升

399
00:20:01,068 --> 00:20:03,003
而且…

400
00:20:04,605 --> 00:20:05,739
我已经证明这一点

401
00:20:06,840 --> 00:20:08,008
这就是…

402
00:20:10,744 --> 00:20:11,945
这就是RTree搜索

403
00:20:12,946 --> 00:20:15,315
还有另外一张幻灯片
然后我将舞台交给瑞希

404
00:20:15,883 --> 00:20:17,851
我们还增加一些混杂的

405
00:20:19,720 --> 00:20:21,021
新的属性类型

406
00:20:21,455 --> 00:20:25,559
增加了NSUUIDA属性类型
和NSURL属性类型

407
00:20:25,759 --> 00:20:28,962
由UUID和URL值类提供支持

408
00:20:33,967 --> 00:20:36,537
很高兴你们欣赏
我们所做的工作

409
00:20:37,004 --> 00:20:38,472
现在我邀请瑞希上台

410
00:20:38,539 --> 00:20:40,707
（持续性历史跟踪）

411
00:20:41,675 --> 00:20:42,676
谢谢

412
00:20:47,514 --> 00:20:49,016
大家好 我是瑞希·维尔马

413
00:20:49,082 --> 00:20:51,018
我将为大家介绍持续性历史跟踪

414
00:20:52,586 --> 00:20:54,421
让我们先聊聊你们的应用

415
00:20:54,955 --> 00:20:57,691
你们开发了很多不错的应用
希望你们已经采用

416
00:20:57,758 --> 00:21:00,394
NS Persistent Container
那是我们去年推出的

417
00:21:00,460 --> 00:21:01,995
假设你已经设置
View Context

418
00:21:02,329 --> 00:21:03,564
和Background Context

419
00:21:04,164 --> 00:21:08,001
而且创建Shared Container
而且已设置Persistent Store

420
00:21:09,069 --> 00:21:12,639
现在你的View Context是一个连接
Background Context是另外一个连接

421
00:21:13,106 --> 00:21:17,010
也许你已设置Background
Context 从远程站点

422
00:21:17,077 --> 00:21:19,112
下载内容

423
00:21:20,614 --> 00:21:24,017
你们是非常勤勉的开发者
你们创建了

424
00:21:24,084 --> 00:21:28,388
文档扩展、共享扩展和照片编辑扩展

425
00:21:28,655 --> 00:21:32,025
现在所有这些
与persistent store之间的连接

426
00:21:32,092 --> 00:21:35,028
都可以在任何进程中运行
因为它们是扩展

427
00:21:35,095 --> 00:21:37,865
或者可能来自于程序中的任何上下文

428
00:21:37,931 --> 00:21:40,434
你们可能不知道
这些数据来自于何处

429
00:21:41,235 --> 00:21:43,704
我们把它们进行细分
看看会发生什么

430
00:21:45,973 --> 00:21:47,040
不好意思

431
00:21:47,674 --> 00:21:50,277
现在我们进入应用

432
00:21:52,479 --> 00:21:54,348
用户看到View Context

433
00:21:54,815 --> 00:21:56,450
同时还有Background Context

434
00:21:56,517 --> 00:21:59,052
正在从某个远程资源下载信息

435
00:21:59,620 --> 00:22:01,788
不幸的是我们经常看到的情况是

436
00:22:01,855 --> 00:22:04,391
Background Context
正在下载数据

437
00:22:04,725 --> 00:22:07,494
但是View Context可能
对这些对象并不知情

438
00:22:07,895 --> 00:22:09,897
或者它甚至并不关心这些对象

439
00:22:10,364 --> 00:22:13,867
但是Save Notifications进入后
必须处理它们

440
00:22:14,468 --> 00:22:18,605
因此如果忽略Background Context

441
00:22:18,672 --> 00:22:19,806
可能会忽略一些变更

442
00:22:20,073 --> 00:22:21,808
很可能会发生这样的情况

443
00:22:22,075 --> 00:22:24,878
你可能忽略Batch Updates
Batch Deletes

444
00:22:25,078 --> 00:22:26,813
它们并不生成保存通知

445
00:22:28,315 --> 00:22:32,553
现在用户进入Safari
决定共享一些东西

446
00:22:33,053 --> 00:22:34,821
这将写入数据库

447
00:22:35,155 --> 00:22:37,024
当开发人员返回应用时

448
00:22:37,925 --> 00:22:41,094
或用户返回应用时
并不知道已经发生哪些变化

449
00:22:41,595 --> 00:22:44,798
你知道已经发生变化
但是并不知详情

450
00:22:45,098 --> 00:22:47,467
因此你必须重新扫描
整个数据库并且查看

451
00:22:47,534 --> 00:22:49,469
自你上次离开之后
发生了哪些变化

452
00:22:50,704 --> 00:22:53,040
不幸的是有时候
我们的应用会崩溃

453
00:22:53,740 --> 00:22:56,743
可能是因为用户退出应用

454
00:22:57,110 --> 00:22:59,246
而此时Background Context
正在运行

455
00:22:59,313 --> 00:23:00,547
当你的应用恢复运行时

456
00:23:00,981 --> 00:23:04,117
Background Context并不知道
上次离开位置

457
00:23:04,318 --> 00:23:05,719
从而扫描本地数据库

458
00:23:06,186 --> 00:23:09,923
因此它必须检查远程内容
重新扫描整个本地数据库

459
00:23:10,123 --> 00:23:12,059
以了解需要从何处重新开始

460
00:23:13,794 --> 00:23:15,996
让我们来仔细看这个例子

461
00:23:16,630 --> 00:23:19,600
我们有一个应用决定载入一些数据

462
00:23:19,900 --> 00:23:24,338
因此Background Context载入数据
然后View Context开始更新

463
00:23:24,938 --> 00:23:28,575
现在 用户暂停应用
文档扩展开始运行

464
00:23:29,843 --> 00:23:32,045
我们将看到数据插入两个新对象

465
00:23:33,146 --> 00:23:37,584
然后共享扩展开始运行
更新一个对象并插入另一个对象

466
00:23:38,051 --> 00:23:39,920
照片扩展也是如此

467
00:23:40,988 --> 00:23:44,358
这些工作完成后 返回应用

468
00:23:45,092 --> 00:23:48,562
注意到一些数据已经过时

469
00:23:49,930 --> 00:23:55,202
我们的应用仅知道最初的六个对象

470
00:23:55,669 --> 00:23:57,804
数据库的其余部分已经修改过

471
00:23:57,871 --> 00:24:00,240
或者应用不知道这些对象

472
00:24:00,874 --> 00:24:02,943
因此必须查找和扫描所有内容

473
00:24:03,010 --> 00:24:05,179
弄清楚哪些内容
是View Context

474
00:24:05,546 --> 00:24:06,980
或Background Context
所需要的

475
00:24:09,650 --> 00:24:12,152
现在我们推出了
NS Persistent History

476
00:24:12,853 --> 00:24:13,754
它相当简单

477
00:24:14,755 --> 00:24:17,558
抓取你的Container
抓取你的Store Description

478
00:24:18,659 --> 00:24:20,894
瞧

479
00:24:22,696 --> 00:24:25,432
将NS Persistent History Tracking
选项设置为真

480
00:24:25,933 --> 00:24:29,136
现在 我们将跟踪数据库的所有变化

481
00:24:31,572 --> 00:24:34,174
让我们回到前面的…
谢谢

482
00:24:37,344 --> 00:24:39,046
我们回到前面的例子

483
00:24:39,313 --> 00:24:40,647
回到View Context之中

484
00:24:40,714 --> 00:24:42,549
此时Background Context加载数据

485
00:24:43,383 --> 00:24:46,453
我们将看到
事务处理内部所发生的事情

486
00:24:46,787 --> 00:24:48,889
此事务处理
对我的数据库执行写操作

487
00:24:49,223 --> 00:24:53,227
我可以看到它是
由Background Context在应用中完成的

488
00:24:54,161 --> 00:24:58,065
当我的跳出应用
用户启动文档扩展

489
00:25:02,035 --> 00:25:05,539
我们看到这也会生成一个事务处理

490
00:25:06,240 --> 00:25:08,208
在我的共享扩展上

491
00:25:11,712 --> 00:25:14,548
共享扩展也会注意到已经发生修改

492
00:25:14,615 --> 00:25:17,684
在这里不会进行插入

493
00:25:18,485 --> 00:25:21,054
在照片扩展上 我们也会看到

494
00:25:21,121 --> 00:25:22,422
发生第四个事务处理

495
00:25:23,824 --> 00:25:25,492
我们将看到它在照片中完成

496
00:25:26,527 --> 00:25:29,730
现在当我的应用回到前台时

497
00:25:30,330 --> 00:25:34,368
仍然有数据
但是我知道我在历史表中的位置

498
00:25:34,635 --> 00:25:37,271
只需要遍历事务处理1-4

499
00:25:37,804 --> 00:25:39,373
瞧 已经更新了

500
00:25:42,609 --> 00:25:44,344
我们引入新的

501
00:25:44,411 --> 00:25:46,947
Store Request
让你获取历史记录

502
00:25:47,447 --> 00:25:49,917
其名称为 NS Persistent History
Change Request

503
00:25:50,384 --> 00:25:52,052
你可以启动它

504
00:25:52,119 --> 00:25:55,522
通过日期、令牌或事务处理

505
00:25:57,457 --> 00:25:59,993
而且你可以很容易地
设置结果类型

506
00:26:00,427 --> 00:26:03,697
变化数量即手可得
就像状态变量一样

507
00:26:03,964 --> 00:26:05,566
也可以获得所有详情

508
00:26:05,666 --> 00:26:08,068
获取所有事务处理和所有变更

509
00:26:09,603 --> 00:26:13,307
另外 利用变更请求
你还可以清空历史记录

510
00:26:13,473 --> 00:26:17,311
你可以重头开始
删除特定日期、令牌

511
00:26:17,411 --> 00:26:20,380
或事务处理之前的历史记录

512
00:26:21,081 --> 00:26:25,953
持续性历史是线性的
始终保持较短的长度

513
00:26:27,754 --> 00:26:33,527
我们希望你记住 进行删除时
你应该保护历史记录

514
00:26:34,294 --> 00:26:37,397
这样它就会知道

515
00:26:37,464 --> 00:26:41,235
你曾经使用你所需要的历史记录
你的客户曾经用过它

516
00:26:41,301 --> 00:26:43,804
你就不会删除

517
00:26:43,871 --> 00:26:46,773
其他应用用户所需要的东西

518
00:26:47,140 --> 00:26:50,244
现在 我们有了
NS Persistent History Transaction

519
00:26:50,711 --> 00:26:56,383
这是一个大型数据集记录
哪些人对你的数据库进行过事务处理

520
00:26:56,550 --> 00:27:00,554
你可以看到 我们有Store ID
Bundle ID、Process ID

521
00:27:00,988 --> 00:27:02,389
我们还有令牌

522
00:27:02,456 --> 00:27:04,925
由于历史记录是线性的

523
00:27:05,492 --> 00:27:08,161
我们为你提供一个令牌
可以加密到磁盘

524
00:27:08,228 --> 00:27:09,897
这样 当应用退出时

525
00:27:09,963 --> 00:27:13,233
可以跟踪应用的历史位置

526
00:27:13,300 --> 00:27:15,802
只需重启应用 调出令牌

527
00:27:15,869 --> 00:27:18,839
取回历史记录
一切就会恢复正常

528
00:27:19,406 --> 00:27:22,309
现在 在事务处理中
我们允许开发人员

529
00:27:22,609 --> 00:27:26,513
希望你们进入
Manage Object Context

530
00:27:26,580 --> 00:27:30,083
告知谁是这个Context

531
00:27:30,150 --> 00:27:33,220
或这个Save Batch Update
或Batch Delete的编写者

532
00:27:33,954 --> 00:27:37,925
我们允许你进入
Manage Object Context

533
00:27:38,058 --> 00:27:39,993
设置事务编写者

534
00:27:40,661 --> 00:27:43,163
做这些工作
然后保存或执行请求

535
00:27:43,230 --> 00:27:47,234
我们将获取这个字符串
放入事务处理 这样你就可以知道

536
00:27:47,334 --> 00:27:50,003
后来哪些人对你的数据库
进行了哪些操作

537
00:27:51,839 --> 00:27:54,842
作为每个事务处理的一部分
都有一组变更

538
00:27:55,142 --> 00:27:58,579
变更表示对
对象进行的某项操作

539
00:27:58,645 --> 00:28:01,481
每个事务处理
包含许多变更

540
00:28:01,615 --> 00:28:05,419
比如插入、更新、删除

541
00:28:05,819 --> 00:28:09,890
在更新时 将会告知
哪些属性已经更新

542
00:28:10,157 --> 00:28:14,828
无论属性或关系
进行删除操作时

543
00:28:16,697 --> 00:28:21,001
将会告知tombstone是什么
你可以在模型编辑器中

544
00:28:21,068 --> 00:28:25,138
设置一组属性
允许你标识算后检查对象

545
00:28:25,205 --> 00:28:29,476
它已经不在数据库之中
因此对象ID已经无关紧要

546
00:28:29,543 --> 00:28:32,913
但是利用tombstone
你仍然可以标识对象

547
00:28:33,280 --> 00:28:35,382
以后进行处理

548
00:28:36,450 --> 00:28:38,619
现在我们进入模型编辑器

549
00:28:40,721 --> 00:28:41,922
（模型编辑器）

550
00:28:42,089 --> 00:28:44,691
这个实体有一个唯一标识符

551
00:28:44,758 --> 00:28:49,229
可以为它设置tombstone
我们进入并标记为

552
00:28:49,329 --> 00:28:50,964
“删除后保留”

553
00:28:51,331 --> 00:28:54,301
非常简单
将会显示在tombstone之中

554
00:28:55,736 --> 00:28:58,338
我将进行简短演示

555
00:28:58,572 --> 00:29:02,042
这里有一个简单的应用
它获取我的贴子内容

556
00:29:02,109 --> 00:29:04,311
然后将放入我的社交媒体内容源

557
00:29:04,511 --> 00:29:08,715
这里我设置几个按钮
一个下载按钮

558
00:29:08,782 --> 00:29:13,020
将会在Background Context
从云端读取信息

559
00:29:13,387 --> 00:29:17,124
一个后台任务将会运行
发布我的信息

560
00:29:17,191 --> 00:29:20,794
然后我设置一个标签页
在里面可以看到历史记录

561
00:29:21,361 --> 00:29:25,132
在我的代码中
Use Persistent History设置为假

562
00:29:25,299 --> 00:29:28,535
但是为我的store启用它
这样就可以看到发生了哪些变化

563
00:29:30,304 --> 00:29:32,840
在这里有一条用户贴子

564
00:29:33,140 --> 00:29:35,442
用户说：
“演示太棒！真不错”

565
00:29:35,509 --> 00:29:38,478
我可以在后台下载

566
00:29:38,946 --> 00:29:41,915
可以看到 我已经标记
贴子的来源

567
00:29:41,982 --> 00:29:44,985
第一个来自于用户
第二个来自于后台

568
00:29:45,953 --> 00:29:49,223
现在我们跳出转至共享扩展

569
00:29:49,890 --> 00:29:52,759
在这里分享Apple信息非常快速

570
00:29:52,960 --> 00:29:54,328
（活动历史演示）

571
00:29:56,663 --> 00:29:57,497
（取消 发布）

572
00:29:57,865 --> 00:30:00,968
我可以发布这条信息
然后在应用中看到

573
00:30:01,802 --> 00:30:05,772
我们回到应用
等等 我丢失了一些灵气

574
00:30:05,839 --> 00:30:06,974
真是奇怪

575
00:30:07,074 --> 00:30:10,677
肯定是出错了
但是如果我返回历史记录

576
00:30:10,744 --> 00:30:14,681
可以看到应用中有一条消息
而且我已经获得远程内容

577
00:30:14,982 --> 00:30:17,351
我甚至可以看到共享扩展

578
00:30:17,651 --> 00:30:19,720
但是 我在这里没有看到

579
00:30:20,587 --> 00:30:22,389
与用户一样 我开始添加数据

580
00:30:22,456 --> 00:30:24,725
尝试弄清楚
这个UI出了什么问题

581
00:30:25,726 --> 00:30:28,529
持续性历史正在显示所有内容

582
00:30:28,629 --> 00:30:29,997
真奇怪

583
00:30:30,230 --> 00:30:35,169
突然我的应用显出
我刚才加载的刷新内容

584
00:30:35,269 --> 00:30:37,404
在一些视图基础上

585
00:30:37,471 --> 00:30:40,340
我最终获取数据库内容
并且重新刷新所有内容

586
00:30:40,841 --> 00:30:43,810
只有通过这种方法
我才能解决这个问题

587
00:30:43,877 --> 00:30:45,979
这让用户感到困惑

588
00:30:46,713 --> 00:30:49,383
但是如果开启

589
00:30:49,449 --> 00:30:52,019
不再进行跟踪
将会发生什么呢？

590
00:30:52,119 --> 00:30:53,720
我开启它

591
00:30:53,887 --> 00:30:59,660
你可以看到
我很快就完成Background Context设置

592
00:30:59,826 --> 00:31:01,895
和View Context设置

593
00:31:01,962 --> 00:31:04,231
我让它们互相侦听

594
00:31:06,600 --> 00:31:10,871
我还设置事务编写者
非常简单

595
00:31:10,938 --> 00:31:12,639
这样我们就可以看到运行过程

596
00:31:13,507 --> 00:31:16,510
我可以非常快速地停止应用
然后重新启动

597
00:31:16,877 --> 00:31:18,579
（构建成功）

598
00:31:21,014 --> 00:31:21,949
（库）

599
00:31:24,451 --> 00:31:27,287
这次我们的应用使用历史

600
00:31:27,754 --> 00:31:30,791
让我们转到贴子分享功能
以前曾经问题重重

601
00:31:31,892 --> 00:31:36,296
High Sierra看上去很酷
让我们来快速分享它

602
00:31:37,798 --> 00:31:38,966
（High Sierra预览）

603
00:31:39,032 --> 00:31:40,801
我们来分享它

604
00:31:40,934 --> 00:31:43,837
非常快
让我们来分享其它内容

605
00:31:44,371 --> 00:31:45,906
很酷的新watchOS

606
00:31:51,044 --> 00:31:52,012
（发布）

607
00:31:55,549 --> 00:31:57,284
现在 当我们返回应用…

608
00:32:01,021 --> 00:32:02,322
瞧！它们出现了

609
00:32:02,523 --> 00:32:06,026
我做的只是当视图重新载入时
吸取历史记录

610
00:32:06,927 --> 00:32:09,129
而且可以快速地跳转到那段代码

611
00:32:11,498 --> 00:32:12,533
（取回更改）

612
00:32:15,302 --> 00:32:16,436
（跳转到定义）

613
00:32:18,172 --> 00:32:20,140
在以前
如果我使用Fetch Hit

614
00:32:20,207 --> 00:32:23,477
而不使用持续性历史
将会获取所有内容

615
00:32:23,544 --> 00:32:26,547
现在我做的是取回历史

616
00:32:26,613 --> 00:32:29,616
从历史吸取合并上下文

617
00:32:29,683 --> 00:32:31,652
这为我提供更小的子集

618
00:32:31,718 --> 00:32:35,155
我不再需要扫描整个数据库
来了解发生了哪些变化

619
00:32:40,127 --> 00:32:42,896
简单地说 事情变得更简单

620
00:32:43,130 --> 00:32:46,667
很容易启用持续性历史
它只是store中的一个选项

621
00:32:47,801 --> 00:32:50,003
它发现那些被忽略的变化

622
00:32:50,070 --> 00:32:52,873
你可能已经生成
Background Context

623
00:32:53,006 --> 00:32:55,542
你可能未注意到
你忽略了一个通知

624
00:32:55,609 --> 00:32:58,011
你已经使用
Batch Updates、Batch Deletes

625
00:32:58,078 --> 00:33:01,648
它们不会生成通知
你可以发现所有这些操作

626
00:33:01,949 --> 00:33:05,319
而不会对数据库的变化一无所知

627
00:33:05,385 --> 00:33:06,587
（回顾历史 充满乐趣！）

628
00:33:06,653 --> 00:33:07,621
（迁移变得更简单）

629
00:33:07,754 --> 00:33:10,958
关于使用持续性历史的两个要点：

630
00:33:11,024 --> 00:33:12,793
首先是迁移

631
00:33:12,860 --> 00:33:16,730
我们在迁移时尽可能多地
保存你的历史记录

632
00:33:17,998 --> 00:33:19,166
两种情况除外

633
00:33:19,399 --> 00:33:21,902
如果删除模型中的实体

634
00:33:21,969 --> 00:33:24,705
我们已经拥有这些实体的历史

635
00:33:25,005 --> 00:33:28,909
必须删除它们的历史记录
这将形成空白

636
00:33:29,343 --> 00:33:31,278
另一种情况是tombstones

637
00:33:32,145 --> 00:33:33,213
对于tombstones

638
00:33:33,280 --> 00:33:37,184
你并不想在以后
使用特定的数据来标识对象

639
00:33:37,251 --> 00:33:41,255
也许它会成为安全隐患
因此称之为tombstone

640
00:33:41,321 --> 00:33:45,225
我们将做同样的事情
从模型中删除它的值

641
00:33:45,559 --> 00:33:49,429
但是如果删除任何数据
将会在历史中留下空白

642
00:33:49,496 --> 00:33:53,567
这样只会保存在上次事务处理
完成之后的历史记录

643
00:33:53,634 --> 00:33:58,605
这样你可以跟踪历史而不会跌入陷阱

644
00:33:58,672 --> 00:34:01,875
让我因为空白而忽略变化

645
00:34:03,210 --> 00:34:04,511
在性能方面

646
00:34:06,046 --> 00:34:10,384
每次保存和批处理
会造成轻微的性能影响

647
00:34:10,884 --> 00:34:13,320
根据批处理的保存操作量

648
00:34:13,420 --> 00:34:17,391
将会计算哪些内容发生变化
并写入数据库

649
00:34:17,456 --> 00:34:22,094
在操作完成之后 占用的内存

650
00:34:22,161 --> 00:34:23,463
将会交还给你

651
00:34:23,530 --> 00:34:27,266
还会有少量的存储开销
但是历史记录将会被清空

652
00:34:27,333 --> 00:34:30,771
从而能够重新收回占用的空间

653
00:34:33,739 --> 00:34:35,309
这就是持续性历史跟踪

654
00:34:43,483 --> 00:34:47,387
让我们总结本场演讲的内容
梅利莎介绍了Core Spotlight

655
00:34:47,487 --> 00:34:51,425
这项技术容易使用
便于通过Spotlight分享数据

656
00:34:51,491 --> 00:34:52,960
提供深度链接

657
00:34:53,025 --> 00:34:56,763
用户可以在手机上的任何位置
找到你的应用中的数据

658
00:34:57,364 --> 00:35:00,934
新Indexing API
让搜索变得更加快速

659
00:35:01,001 --> 00:35:03,036
让你的应用变得更快

660
00:35:03,570 --> 00:35:06,740
最后持续性历史让你知道

661
00:35:06,807 --> 00:35:09,009
用户进行的变更
不会遗漏任何历史记录

662
00:35:09,076 --> 00:35:11,378
让你始终知道
谁对你的数据库进行了哪些操作

663
00:35:12,980 --> 00:35:15,782
另外还有一件事情 文件漏洞

664
00:35:16,149 --> 00:35:19,119
如果你遇到问题
如果你有任何需求

665
00:35:19,953 --> 00:35:22,556
请访问bugreport.apple.com
我们将会倾听你的意见

666
00:35:22,956 --> 00:35:24,291
请去访问

667
00:35:25,859 --> 00:35:28,795
有关更多信息
请访问WWDC网站

668
00:35:29,530 --> 00:35:33,200
另外还有一些相关演讲
我们之前举行了“Cocoa新特性”演讲

669
00:35:33,267 --> 00:35:34,835
你们可以观看视频

670
00:35:34,902 --> 00:35:37,337
接下来我们还有
“Foundation新特性”演讲

671
00:35:37,704 --> 00:35:41,208
在星期三
“Core Spotlight新特性”演讲

672
00:35:41,275 --> 00:35:42,776
将会和大家分享一些有趣的内容

673
00:35:42,843 --> 00:35:46,213
另外请留意星期五上午的
“Cocoa开发小技巧”演讲

674
00:35:46,547 --> 00:35:47,481
谢谢大家 非常感谢

