1
00:00:22,276 --> 00:00:23,606
我是 John Blackwell

2
00:00:23,606 --> 00:00:24,676
我是 Core Motion 框架

3
00:00:24,676 --> 00:00:25,426
的一名工程师

4
00:00:25,956 --> 00:00:27,336
今天 我们要讲一讲

5
00:00:27,416 --> 00:00:28,496
通过 Core Motion 框架

6
00:00:28,496 --> 00:00:29,776
来创建沉浸式

7
00:00:29,776 --> 00:00:31,306
应用软件 我们还会

8
00:00:31,306 --> 00:00:32,485
在过程中讨论一些

9
00:00:32,485 --> 00:00:33,886
最佳实践的例子

10
00:00:35,366 --> 00:00:37,376
那么今天 我们将要

11
00:00:37,376 --> 00:00:38,386
涉及到一系列话题

12
00:00:38,896 --> 00:00:40,746
第一就是一个简单的概况

13
00:00:40,746 --> 00:00:42,116
了解 Core Motion 可以提供什么

14
00:00:42,536 --> 00:00:43,816
接下来 我们会讲一下

15
00:00:43,816 --> 00:00:45,816
授权 这对于

16
00:00:45,816 --> 00:00:46,526
我们的很多开发人员来说

17
00:00:46,526 --> 00:00:47,096
是一个经常出现的痛点

18
00:00:47,676 --> 00:00:48,606
然后 我们要看一下

19
00:00:48,606 --> 00:00:50,116
有关 Historic Accelerometer

20
00:00:50,116 --> 00:00:52,336
的一些新版本 再之后我们

21
00:00:52,336 --> 00:00:53,926
要看一下 DeviceMotion

22
00:00:54,166 --> 00:00:55,526
也就我们在 Core Motion

23
00:00:55,526 --> 00:00:56,916
中提供的一个传感器混合体

24
00:00:57,346 --> 00:00:58,526
最后 我们要看一下

25
00:00:58,526 --> 00:01:00,556
Badger with Attitude 它是一款游戏

26
00:01:00,556 --> 00:01:01,536
其中我们采用了一些

27
00:01:01,536 --> 00:01:03,116
之前在 DeviceMotion 提到过的

28
00:01:03,116 --> 00:01:04,796
概念 并且将它们付诸

29
00:01:04,885 --> 00:01:05,556
实际应用中

30
00:01:06,686 --> 00:01:08,376
那么好了 我们先

31
00:01:08,376 --> 00:01:09,836
仔细了解一下 Core Motion

32
00:01:09,836 --> 00:01:10,356
框架

33
00:01:13,656 --> 00:01:15,266
Core Motion 框架

34
00:01:15,476 --> 00:01:16,686
提供访问

35
00:01:16,686 --> 00:01:18,186
accelerometer gyroscope

36
00:01:18,436 --> 00:01:19,556
magnetometer 以及

37
00:01:19,556 --> 00:01:20,896
altimeter 的途径 并且通过这一

38
00:01:20,896 --> 00:01:22,476
框架 你可以获取

39
00:01:22,476 --> 00:01:23,586
传感器数据的原始形式

40
00:01:23,586 --> 00:01:25,576
以及处理过的形式 并且

41
00:01:25,576 --> 00:01:26,886
在你的应用软件中使用它们

42
00:01:28,206 --> 00:01:29,546
现在 有一些

43
00:01:29,546 --> 00:01:30,996
接口可以通过 Core Motion

44
00:01:30,996 --> 00:01:31,626
获取

45
00:01:32,166 --> 00:01:35,446
第一个就是 CMMotionManager

46
00:01:35,726 --> 00:01:37,406
它帮助获取原始

47
00:01:37,486 --> 00:01:38,806
传感器数据 以及

48
00:01:38,806 --> 00:01:40,116
DeviceMotion 形式的传感器

49
00:01:40,116 --> 00:01:40,916
混合体

50
00:01:42,226 --> 00:01:44,156
CMAltimeter 帮助

51
00:01:44,156 --> 00:01:45,606
获取设备的相关高度

52
00:01:45,606 --> 00:01:45,976
更新

53
00:01:47,456 --> 00:01:49,216
CMPedometer 帮助获取

54
00:01:49,216 --> 00:01:50,836
步数 以作为步数相关

55
00:01:50,836 --> 00:01:52,156
信息 以及

56
00:01:52,156 --> 00:01:53,616
锻炼 暂停 和恢复

57
00:01:53,616 --> 00:01:53,996
活动

58
00:01:55,396 --> 00:01:56,996
MotionActivityManager 帮助

59
00:01:56,996 --> 00:01:58,696
获取设备的活动

60
00:01:58,696 --> 00:02:00,006
情境 例如

61
00:02:00,006 --> 00:02:02,106
走路 跑步 或坐车

62
00:02:02,296 --> 00:02:06,276
CMSensorRecorder

63
00:02:06,416 --> 00:02:07,976
帮助获取

64
00:02:07,976 --> 00:02:08,826
accelerometer 的历史数据

65
00:02:09,496 --> 00:02:13,576
所以这就是一个概况

66
00:02:13,576 --> 00:02:14,616
帮助我们了解 Core Motion 框架

67
00:02:14,616 --> 00:02:15,156
提供什么

68
00:02:15,696 --> 00:02:17,166
接下来 我们来仔细看一下

69
00:02:17,166 --> 00:02:18,196
授权

70
00:02:19,426 --> 00:02:21,456
所以在我刚刚

71
00:02:21,456 --> 00:02:23,906
提到的 API 中 以下四种

72
00:02:23,906 --> 00:02:25,636
都非常敏感 这是由于

73
00:02:25,636 --> 00:02:26,846
所显示的用户私人信息的本质所导致的

74
00:02:29,376 --> 00:02:31,936
为了处理此事 我们会有一个

75
00:02:31,936 --> 00:02:33,426
提示符 在你第一次

76
00:02:33,426 --> 00:02:34,806
唤醒某一个 灵敏的 API 时

77
00:02:34,806 --> 00:02:35,746
它就会出现

78
00:02:37,056 --> 00:02:39,056
记住是当你第一次

79
00:02:39,056 --> 00:02:40,966
唤醒灵敏的 API 时 那个

80
00:02:40,966 --> 00:02:42,336
提示符会出现在用户面前

81
00:02:42,626 --> 00:02:44,056
但是第一次之后 你的

82
00:02:44,056 --> 00:02:45,106
用户就需要到

83
00:02:45,106 --> 00:02:46,006
“设置”来改变

84
00:02:46,006 --> 00:02:47,216
你应用软件的授权

85
00:02:47,216 --> 00:02:47,986
状态

86
00:02:49,306 --> 00:02:50,916
现在 我们来看一看

87
00:02:50,916 --> 00:02:51,996
当你第一次

88
00:02:51,996 --> 00:02:53,036
调用这些 API 中的一个时是怎么样的

89
00:02:53,816 --> 00:02:55,406
这时候 你的用户将

90
00:02:55,406 --> 00:02:56,346
决定他们是否想要

91
00:02:56,346 --> 00:02:57,766
允许访问 Motion

92
00:02:57,766 --> 00:02:59,576
Fitness 数据 或者拒绝访问

93
00:03:00,016 --> 00:03:01,566
作为开发人员 你会

94
00:03:01,566 --> 00:03:02,676
想要处理用户拒绝访问

95
00:03:02,676 --> 00:03:05,166
这一问题

96
00:03:05,286 --> 00:03:07,376
在过去 我们要求你

97
00:03:07,376 --> 00:03:08,406
做这样的事

98
00:03:09,056 --> 00:03:10,596
你需要调用我们灵敏的

99
00:03:10,596 --> 00:03:12,046
API

100
00:03:12,696 --> 00:03:13,826
在这个例子中 我们正在调用

101
00:03:13,826 --> 00:03:15,756
queryPedometerData 然后你

102
00:03:15,756 --> 00:03:17,346
无视从

103
00:03:17,346 --> 00:03:19,336
API 获得的结果 只关注

104
00:03:19,336 --> 00:03:20,146
错误代码

105
00:03:21,026 --> 00:03:22,536
如果代码错误是因为

106
00:03:22,536 --> 00:03:24,376
没有授权 这时

107
00:03:24,376 --> 00:03:25,536
你就可以知道你的应用软件

108
00:03:25,536 --> 00:03:26,886
被拒绝访问动态和

109
00:03:26,886 --> 00:03:27,476
健康数据

110
00:03:28,646 --> 00:03:30,126
现在 我们意识到这种做法

111
00:03:30,126 --> 00:03:30,846
还不够理想

112
00:03:32,166 --> 00:03:33,196
你需要跳过一环一环

113
00:03:33,266 --> 00:03:34,816
来获得你的

114
00:03:34,816 --> 00:03:36,386
授权状态 一旦

115
00:03:36,426 --> 00:03:37,656
你得到了 你就无法知道

116
00:03:37,656 --> 00:03:39,316
为什么你的 App

117
00:03:39,316 --> 00:03:40,296
被拒绝访问

118
00:03:40,936 --> 00:03:43,326
这就是为什么今年我们

119
00:03:43,326 --> 00:03:44,636
提供了一个授权

120
00:03:44,636 --> 00:03:45,326
地位 API

121
00:03:46,226 --> 00:03:47,606
这个 API 在

122
00:03:47,686 --> 00:03:48,816
之前我提到的四类中

123
00:03:48,816 --> 00:03:50,086
都可用 而且它也在

124
00:03:50,086 --> 00:03:52,076
iOS 系统和 watchOS 系统上可用

125
00:03:52,886 --> 00:03:54,366
让我们进一步看一下

126
00:03:54,366 --> 00:03:56,226
CMAuthorizationStatus 值

127
00:03:56,226 --> 00:03:57,666
你将会从 API 得到它

128
00:03:59,386 --> 00:04:01,596
第一个状态是“notDetermined”

129
00:04:01,866 --> 00:04:03,566
它代表着

130
00:04:03,566 --> 00:04:04,866
用户还没有被问及

131
00:04:04,866 --> 00:04:05,856
你应用软件的有关

132
00:04:05,856 --> 00:04:06,466
授权

133
00:04:07,026 --> 00:04:08,806
“Restricted”表示

134
00:04:09,126 --> 00:04:11,386
用户无法

135
00:04:11,386 --> 00:04:12,756
为你的应该改变

136
00:04:12,916 --> 00:04:13,826
授权状态

137
00:04:13,826 --> 00:04:15,426
更确切地说

138
00:04:15,426 --> 00:04:17,086
当动态和健康

139
00:04:17,156 --> 00:04:18,546
在隐私中被禁用时会出现这样的状态

140
00:04:19,406 --> 00:04:20,495
下一个状态是“denied”

141
00:04:20,656 --> 00:04:21,596
就是指拒绝

142
00:04:21,776 --> 00:04:22,526
你的应用软件

143
00:04:22,526 --> 00:04:24,256
很明确地被用户

144
00:04:24,256 --> 00:04:24,746
拒绝访问

145
00:04:25,156 --> 00:04:26,906
而“authorized”代表你的 App

146
00:04:26,906 --> 00:04:28,026
已经被允许访问用户的

147
00:04:28,026 --> 00:04:29,006
动态和健康数据

148
00:04:30,586 --> 00:04:32,746
现在 我们回过来看一下

149
00:04:32,746 --> 00:04:33,836
我们之前正在看的

150
00:04:33,836 --> 00:04:34,606
授权确认

151
00:04:34,856 --> 00:04:37,176
第一批最佳实践中有一项

152
00:04:37,176 --> 00:04:38,796
我想要讲一讲

153
00:04:39,126 --> 00:04:40,266
那就是确保你检查了

154
00:04:40,266 --> 00:04:42,006
所给 API 的可用性

155
00:04:42,006 --> 00:04:44,006
在你请求

156
00:04:44,006 --> 00:04:44,946
授权地位之前

157
00:04:45,656 --> 00:04:47,036
在这个例子中 我们正在请求

158
00:04:47,036 --> 00:04:47,896
StepCountingAvailable

159
00:04:48,816 --> 00:04:50,136
接下来你

160
00:04:50,136 --> 00:04:51,476
想要做的就是请求

161
00:04:51,476 --> 00:04:52,496
授权地位

162
00:04:53,106 --> 00:04:54,446
这个时候 是由

163
00:04:54,446 --> 00:04:56,436
你 作为一个开发人员 来决定

164
00:04:56,506 --> 00:04:57,566
想要如何处理

165
00:04:57,566 --> 00:04:59,196
从框架中拿回的

166
00:04:59,396 --> 00:05:00,176
授权

167
00:05:00,596 --> 00:05:01,966
现在你有一个简单的机制

168
00:05:01,966 --> 00:05:04,256
可以来做这件事 无论是在 iOS 系统上还是在

169
00:05:04,366 --> 00:05:04,876
watchOS 系统上

170
00:05:06,336 --> 00:05:08,896
我鼓励你们考虑一下如何

171
00:05:08,896 --> 00:05:09,956
使用授权

172
00:05:09,956 --> 00:05:11,776
地位 App 也就是你应用软件中的

173
00:05:11,776 --> 00:05:13,266
授权地位 API

174
00:05:13,486 --> 00:05:14,586
而且你应该

175
00:05:14,586 --> 00:05:14,716
使用它

176
00:05:15,516 --> 00:05:16,836
接下来 我们要讲一讲

177
00:05:16,836 --> 00:05:18,066
Historical Accelerometer

178
00:05:19,056 --> 00:05:20,756
Historical Accelerometer

179
00:05:20,756 --> 00:05:22,196
也叫作 CMSensorRecorder

180
00:05:22,536 --> 00:05:24,336
可以提供 50 赫兹的 accelerometer

181
00:05:24,336 --> 00:05:25,926
数据 而且我们可以

182
00:05:25,926 --> 00:05:27,256
为你的应用软件记录这一数据 当你的

183
00:05:27,256 --> 00:05:28,356
App 在后台运行时

184
00:05:29,556 --> 00:05:31,426
你可以请求最多 36 小时

185
00:05:31,426 --> 00:05:33,406
的 accelerometer 数据 这些

186
00:05:33,406 --> 00:05:34,716
会被以你的名义

187
00:05:34,716 --> 00:05:36,386
最多储存 3 天

188
00:05:37,786 --> 00:05:39,696
现在 Historical Accelerometer

189
00:05:39,696 --> 00:05:41,176
在 Apple Watch

190
00:05:41,176 --> 00:05:43,476
可用 我很激动

191
00:05:43,476 --> 00:05:45,126
地宣布它现在

192
00:05:45,126 --> 00:05:46,826
也在 iPhone 7 和 7 Plus 上可用

193
00:05:47,886 --> 00:05:49,406
这为你的应用软件开拓了

194
00:05:49,406 --> 00:05:50,996
全新的用例

195
00:05:51,216 --> 00:05:52,206
并且让你思考

196
00:05:52,206 --> 00:05:53,626
要如何在 iPhone 上使用 Historical

197
00:05:53,626 --> 00:05:55,376
Accelerometer 让我们

198
00:05:55,376 --> 00:05:56,316
现在来看一个

199
00:05:56,316 --> 00:05:58,646
简单的应用软件

200
00:05:59,056 --> 00:06:00,496
让我们假设你是一个

201
00:06:00,496 --> 00:06:02,366
汽车狂粉

202
00:06:02,366 --> 00:06:03,726
你想要构建一款应用软件

203
00:06:03,726 --> 00:06:05,096
帮助你在很长的一段时间内

204
00:06:05,096 --> 00:06:06,736
追踪汽车的

205
00:06:06,736 --> 00:06:06,926
性能

206
00:06:07,736 --> 00:06:09,086
那么我们要怎么样来构建

207
00:06:09,086 --> 00:06:09,306
它呢

208
00:06:09,746 --> 00:06:10,986
好吧 首先我们

209
00:06:10,986 --> 00:06:12,256
想要弄清楚用户

210
00:06:12,256 --> 00:06:14,526
何时驾驶 为此

211
00:06:14,526 --> 00:06:15,726
我们可以使用 Motion Activity

212
00:06:16,266 --> 00:06:17,476
Motion Activity 提供一个

213
00:06:17,476 --> 00:06:19,436
汽车的状态 我们可以用

214
00:06:19,436 --> 00:06:20,566
它来判断何时

215
00:06:20,566 --> 00:06:21,576
用户在驾驶

216
00:06:22,996 --> 00:06:24,316
现在 我想要简单花

217
00:06:24,316 --> 00:06:25,636
几分钟讲一讲

218
00:06:25,636 --> 00:06:26,706
汽车检测

219
00:06:27,336 --> 00:06:29,566
在 iOS 11 系统中 汽车

220
00:06:29,566 --> 00:06:31,036
检测这一块得到了格外的

221
00:06:31,036 --> 00:06:32,156
关注 以此来确保

222
00:06:32,156 --> 00:06:33,626
最佳的效果

223
00:06:34,166 --> 00:06:35,956
在 Motion Activity 中的

224
00:06:35,956 --> 00:06:37,746
汽车状态也

225
00:06:37,746 --> 00:06:39,016
被用来控制 Do

226
00:06:39,016 --> 00:06:40,386
Not Disturb While Driving 这一项功能

227
00:06:40,386 --> 00:06:41,826
它也可以在你的应用软件中

228
00:06:41,826 --> 00:06:43,186
被使用

229
00:06:43,456 --> 00:06:44,496
比如你想要

230
00:06:44,496 --> 00:06:46,066
在你的用户驾驶时

231
00:06:46,066 --> 00:06:47,406
对应用软件的 UI 进行个性化设置

232
00:06:48,426 --> 00:06:49,766
现在 回到我们的

233
00:06:49,766 --> 00:06:51,156
汽车性能追踪

234
00:06:51,156 --> 00:06:52,666
应用软件 我们下一步

235
00:06:52,666 --> 00:06:54,526
想要做的事 收集

236
00:06:54,766 --> 00:06:55,776
accelerometer 数据

237
00:06:56,256 --> 00:06:57,876
对此 我们可以使用

238
00:06:57,876 --> 00:06:58,546
SensorRecorder

239
00:06:58,846 --> 00:07:00,566
我们可以收集

240
00:07:00,566 --> 00:07:02,056
用户在驾驶期间的

241
00:07:02,106 --> 00:07:03,336
accelerometer 数据 并且

242
00:07:03,336 --> 00:07:05,276
为用户将数据转换成公制

243
00:07:05,276 --> 00:07:07,066
的 例如

244
00:07:07,066 --> 00:07:07,946
汽车在转弯时的

245
00:07:07,946 --> 00:07:10,376
G 值 或者是最大横向或

246
00:07:10,376 --> 00:07:11,366
纵向加 G 值

247
00:07:12,006 --> 00:07:14,236
现在 你可以考虑通过很多不同的

248
00:07:14,236 --> 00:07:16,036
方式来构建

249
00:07:16,256 --> 00:07:17,956
这种应用软件 但是通过

250
00:07:18,066 --> 00:07:19,816
使用 Motion APIs 你可以

251
00:07:19,816 --> 00:07:20,786
为你的用户提供一个

252
00:07:20,786 --> 00:07:22,796
低功耗 全天候的体验

253
00:07:23,516 --> 00:07:26,206
现在请大家通过

254
00:07:26,206 --> 00:07:28,036
Historical Accelerometer 记住一些

255
00:07:28,036 --> 00:07:29,196
最佳实践

256
00:07:29,766 --> 00:07:31,216
首先 你会想要

257
00:07:31,216 --> 00:07:32,926
为你的应用软件选择

258
00:07:32,926 --> 00:07:34,096
合理的最低持续

259
00:07:34,096 --> 00:07:34,836
时间

260
00:07:35,536 --> 00:07:37,046
所以对于汽车性能

261
00:07:37,046 --> 00:07:38,786
追踪应用软件而言 我们也许不

262
00:07:38,786 --> 00:07:41,116
需要全程 36 小时的数据

263
00:07:41,986 --> 00:07:43,546
像 8 到 12

264
00:07:43,546 --> 00:07:44,706
小时更合理

265
00:07:45,896 --> 00:07:47,326
接下来的最佳实践就是

266
00:07:47,326 --> 00:07:48,516
要记得考虑

267
00:07:48,516 --> 00:07:50,506
大批销毁或是减少样本

268
00:07:50,506 --> 00:07:52,386
如果你不需要全部的 50

269
00:07:52,386 --> 00:07:53,626
赫兹 accelerometer 数据的话

270
00:07:54,326 --> 00:07:56,176
这两条建议 这两项

271
00:07:56,176 --> 00:07:58,206
最佳实践会减少

272
00:07:58,206 --> 00:07:59,316
你的应用软件需要进行的

273
00:07:59,316 --> 00:08:00,906
处理量 进而

274
00:08:00,906 --> 00:08:02,256
也可以节省用户电池的

275
00:08:02,256 --> 00:08:02,666
寿命

276
00:08:03,656 --> 00:08:05,836
现在我鼓励你想一想

277
00:08:06,086 --> 00:08:07,736
你要如何在 iPhone上使用

278
00:08:07,736 --> 00:08:09,546
Historical Accelerometer

279
00:08:10,046 --> 00:08:13,636
下面我们来讲一下

280
00:08:13,636 --> 00:08:14,566
DeviceMotion

281
00:08:15,126 --> 00:08:16,686
DeviceMotion 是指

282
00:08:16,766 --> 00:08:18,536
传感器混合体算法 我们

283
00:08:18,536 --> 00:08:19,826
将它提供在 Core Motion

284
00:08:19,826 --> 00:08:20,306
框架中

285
00:08:21,146 --> 00:08:23,106
现在我们还在

286
00:08:23,106 --> 00:08:23,846
DeviceMotion 中

287
00:08:23,846 --> 00:08:24,686
新加了一些内容

288
00:08:25,966 --> 00:08:27,396
我们在 DeviceMotion 中使用的第一个传感器

289
00:08:27,396 --> 00:08:28,176
是

290
00:08:28,176 --> 00:08:29,446
accelerometer

291
00:08:29,446 --> 00:08:30,806
通过 accelerometer 我们可以

292
00:08:30,806 --> 00:08:31,776
测量用户

293
00:08:31,776 --> 00:08:33,336
传递的加速度 以及

294
00:08:33,336 --> 00:08:34,535
重力

295
00:08:34,535 --> 00:08:35,025
加速度

296
00:08:36,176 --> 00:08:37,466
gyroscope 帮助我们

297
00:08:37,466 --> 00:08:38,885
准确测量

298
00:08:38,885 --> 00:08:39,716
设备的转动率

299
00:08:40,236 --> 00:08:41,946
而 magnetometer 则帮助我们

300
00:08:41,946 --> 00:08:43,566
测量设备周围的局部域

301
00:08:43,566 --> 00:08:44,876
以及

302
00:08:44,876 --> 00:08:45,906
地球磁场

303
00:08:47,226 --> 00:08:48,886
当我们要处理原始

304
00:08:48,886 --> 00:08:49,866
传感器时 需要记住

305
00:08:49,866 --> 00:08:51,096
一些我们面临的挑战

306
00:08:51,956 --> 00:08:53,176
使用 accelerometer

307
00:08:53,176 --> 00:08:54,916
我们很难区分

308
00:08:54,916 --> 00:08:55,996
用户的

309
00:08:55,996 --> 00:08:57,826
加速度

310
00:08:58,386 --> 00:09:00,166
和重力加速度

311
00:09:02,376 --> 00:09:03,566
使用 gyroscope 我们可能

312
00:09:03,566 --> 00:09:04,706
对时间的测量会产生

313
00:09:04,706 --> 00:09:06,986
偏差 使用 magnetometer

314
00:09:06,986 --> 00:09:07,756
我们很难

315
00:09:07,756 --> 00:09:09,256
区分局部域

316
00:09:09,256 --> 00:09:10,586
和地球磁场

317
00:09:11,326 --> 00:09:13,346
这就是为什么我们引入了

318
00:09:13,346 --> 00:09:13,876
DeviceMotion

319
00:09:14,566 --> 00:09:16,306
DeviceMotion 可以提供 3D

320
00:09:16,306 --> 00:09:17,716
追踪

321
00:09:17,716 --> 00:09:19,236
当设备正在经历自由空间

322
00:09:19,336 --> 00:09:19,846
动态

323
00:09:20,636 --> 00:09:22,156
它通过合并

324
00:09:22,156 --> 00:09:23,826
所有的传感器

325
00:09:23,826 --> 00:09:25,546
重新组织每一个的优点

326
00:09:25,676 --> 00:09:26,476
同时将缺点

327
00:09:26,476 --> 00:09:27,286
最小化

328
00:09:28,246 --> 00:09:30,026
对于开发人员来说

329
00:09:30,026 --> 00:09:31,856
这意味着你

330
00:09:32,126 --> 00:09:34,066
专注于自己想要如何使用

331
00:09:34,066 --> 00:09:35,466
动态数据 而不是

332
00:09:35,466 --> 00:09:36,766
纠结于如何最好地利用传感器这样的

333
00:09:36,766 --> 00:09:38,036
技术性问题

334
00:09:39,776 --> 00:09:41,016
目前 我们已经在

335
00:09:41,016 --> 00:09:42,496
之前的会议中讲过

336
00:09:42,496 --> 00:09:43,376
DeviceMotion

337
00:09:43,626 --> 00:09:44,796
我希望大家

338
00:09:44,796 --> 00:09:45,116
去看一下

339
00:09:45,436 --> 00:09:46,606
我们详细讲了

340
00:09:46,636 --> 00:09:48,116
传感器和 DeviceMotion

341
00:09:48,116 --> 00:09:48,756
算法

342
00:09:49,216 --> 00:09:51,036
但是今天 我们要考虑的是

343
00:09:51,036 --> 00:09:52,886
如何通过使用

344
00:09:52,886 --> 00:09:54,426
DeviceMotion 的某些部分来

345
00:09:54,426 --> 00:09:55,696
为你的用户创建

346
00:09:55,696 --> 00:09:56,386
沉浸式应用软件

347
00:09:56,386 --> 00:10:00,666
作为一名开发人员 当你

348
00:10:00,666 --> 00:10:01,616
第一次开始使用

349
00:10:01,616 --> 00:10:03,136
DeviceMotion 时 第一件

350
00:10:03,136 --> 00:10:04,256
需要考虑的事情是

351
00:10:04,256 --> 00:10:05,186
参照系

352
00:10:05,416 --> 00:10:07,076
参照系决定了

353
00:10:07,396 --> 00:10:08,906
会使用混合体中的哪一个

354
00:10:08,906 --> 00:10:11,006
传感器 以及如何

355
00:10:11,006 --> 00:10:11,886
计算你应用软件的

356
00:10:11,886 --> 00:10:12,656
空间方位

357
00:10:13,616 --> 00:10:14,786
第一个参照系是

358
00:10:14,956 --> 00:10:17,046
xArbitraryZVertical

359
00:10:17,046 --> 00:10:18,166
它将 accelerometer 和

360
00:10:18,166 --> 00:10:19,406
gyroscope 合并 但没有使用

361
00:10:19,406 --> 00:10:19,976
magnetometer

362
00:10:20,716 --> 00:10:21,886
其余三个参照系分别是

363
00:10:21,886 --> 00:10:23,536
xArbitraryCorrected

364
00:10:23,856 --> 00:10:25,076
xMagneticNorth 和

365
00:10:25,076 --> 00:10:26,936
xTrueNorthZVertical  同时使用

366
00:10:26,936 --> 00:10:27,626
三种传感器

367
00:10:28,776 --> 00:10:30,216
现在 我们来讲一讲有关第一个

368
00:10:30,216 --> 00:10:31,846
参照系的更多细节

369
00:10:33,166 --> 00:10:34,786
假设你现在有一款很棒的

370
00:10:34,786 --> 00:10:35,876
竞速游戏

371
00:10:35,876 --> 00:10:37,376
当前

372
00:10:37,596 --> 00:10:39,176
你的用户可以通过触控

373
00:10:39,176 --> 00:10:39,646
进行游戏

374
00:10:40,306 --> 00:10:41,556
这很棒 但是通过使用动态

375
00:10:41,556 --> 00:10:42,716
我们可以提供更加沉浸式的

376
00:10:42,716 --> 00:10:44,526
体验

377
00:10:45,926 --> 00:10:47,956
我们希望我们

378
00:10:47,956 --> 00:10:50,146
可以让用户

379
00:10:50,146 --> 00:10:51,526
通过设别进行驾驶 那么当他们将

380
00:10:51,526 --> 00:10:52,836
他们的车 他们的设备倾斜

381
00:10:52,836 --> 00:10:54,276
到左边时 汽车就会

382
00:10:55,836 --> 00:10:55,996
左转

383
00:10:56,206 --> 00:10:57,496
现在 只要设备是

384
00:10:57,496 --> 00:10:59,466
相对静止的 我们可以用

385
00:10:59,466 --> 00:11:01,226
accelerometer 来估算

386
00:11:01,306 --> 00:11:03,556
重力 一旦

387
00:11:03,556 --> 00:11:05,186
我们得到了重力 就可以

388
00:11:05,186 --> 00:11:06,466
决定倾斜角度 或者是

389
00:11:06,466 --> 00:11:07,966
重力抵消的角度

390
00:11:08,616 --> 00:11:11,656
但请记住一件事

391
00:11:11,656 --> 00:11:13,126
如果你

392
00:11:13,126 --> 00:11:14,776
让 accelerometer 自行运作的话

393
00:11:14,776 --> 00:11:17,126
有些手势会

394
00:11:17,126 --> 00:11:17,786
很模糊

395
00:11:18,846 --> 00:11:20,476
将装置向右倾斜

396
00:11:20,856 --> 00:11:21,896
对于 accelerometer 来说

397
00:11:21,896 --> 00:11:23,506
和将装置向左滑动

398
00:11:23,506 --> 00:11:24,536
是一样

399
00:11:25,306 --> 00:11:26,636
现在你可以考虑

400
00:11:26,636 --> 00:11:28,106
处理这个问题 通过

401
00:11:28,106 --> 00:11:29,846
将 accelerometer 信号

402
00:11:29,916 --> 00:11:30,236
平均化

403
00:11:31,276 --> 00:11:32,886
这样做的话 你可以减少

404
00:11:32,936 --> 00:11:34,446
来自用户的短期

405
00:11:34,446 --> 00:11:35,916
效应 只留下

406
00:11:35,916 --> 00:11:37,506
长期效应 例如

407
00:11:37,506 --> 00:11:38,226
重力

408
00:11:38,906 --> 00:11:40,786
然而 这样做的话 你

409
00:11:40,786 --> 00:11:41,836
也将注意到你的应用软件

410
00:11:41,836 --> 00:11:43,196
的响应速度会更慢

411
00:11:43,336 --> 00:11:45,396
这时候就需要 DeviceMotion

412
00:11:45,396 --> 00:11:45,916
发挥作用

413
00:11:46,736 --> 00:11:48,516
DeviceMotion 意味着你的

414
00:11:48,516 --> 00:11:49,816
应用软件不需要

415
00:11:49,816 --> 00:11:51,316
建立过滤逻辑就可以

416
00:11:51,316 --> 00:11:53,036
从传感器获取极大的性能

417
00:11:55,276 --> 00:11:57,846
xArbitraryZVertical

418
00:11:57,846 --> 00:11:59,706
参考系就是你

419
00:11:59,706 --> 00:12:00,786
应用软件的默认参考系

420
00:12:00,786 --> 00:12:02,276
如果

421
00:12:02,276 --> 00:12:03,886
你在开始

422
00:12:04,116 --> 00:12:05,616
DeviceMotion 更新时没有明确指明是哪个

423
00:12:05,616 --> 00:12:06,106
参考系的话

424
00:12:06,476 --> 00:12:08,136
这个参考系

425
00:12:08,136 --> 00:12:09,646
对于使用来说是很棒的 当你

426
00:12:09,646 --> 00:12:10,936
想要追踪设备各角度的

427
00:12:10,936 --> 00:12:13,706
倾斜的话

428
00:12:13,706 --> 00:12:15,516
在游戏的用例

429
00:12:15,516 --> 00:12:17,306
中 accelerometer 和

430
00:12:17,306 --> 00:12:18,596
gyroscope 合并使用

431
00:12:18,596 --> 00:12:19,976
可以让我们更加

432
00:12:19,976 --> 00:12:21,486
快速且准确地追踪

433
00:12:21,486 --> 00:12:21,936
重力

434
00:12:22,526 --> 00:12:24,256
一旦有了重力 我们就可以

435
00:12:24,256 --> 00:12:25,726
将它转换成倾斜角度设计到

436
00:12:25,726 --> 00:12:26,076
游戏中

437
00:12:27,326 --> 00:12:28,926
现在我们来看看如何

438
00:12:28,926 --> 00:12:30,596
操作 我的同事 Ahmad

439
00:12:30,596 --> 00:12:31,456
一会儿会来到讲台上

440
00:12:31,456 --> 00:12:33,386
向我们展示

441
00:12:33,936 --> 00:12:36,146
这个参考系对于

442
00:12:36,146 --> 00:12:37,816
使用还很棒的一点在于当你

443
00:12:37,816 --> 00:12:39,576
想要追踪用户的

444
00:12:39,576 --> 00:12:39,976
手势时

445
00:12:40,546 --> 00:12:41,926
我希望大家去看一下我们的

446
00:12:41,926 --> 00:12:43,646
样本应用软件 SwingWatch

447
00:12:44,356 --> 00:12:46,166
SwingWatch 是一款在

448
00:12:46,436 --> 00:12:47,906
手表上的 App

449
00:12:48,066 --> 00:12:49,696
它使用 DeviceMotion 进行追踪

450
00:12:49,696 --> 00:12:51,416
当你在网球比赛中进行正手击球

451
00:12:51,416 --> 00:12:53,116
或者反手击球时

452
00:12:54,236 --> 00:12:55,336
样本代码和

453
00:12:55,336 --> 00:12:56,336
会议都可以在网上找到

454
00:12:56,336 --> 00:12:58,146
我鼓励大家去查看一下

455
00:12:58,956 --> 00:13:00,936
那么 我们来假设你有另一款

456
00:13:00,936 --> 00:13:01,346
游戏

457
00:13:02,096 --> 00:13:03,386
假定是一款射击游戏

458
00:13:03,586 --> 00:13:05,666
你的用户可以

459
00:13:05,736 --> 00:13:07,066
通过虚拟的按钮开关进行瞄准

460
00:13:07,486 --> 00:13:09,496
这很棒 但是通过动态

461
00:13:09,496 --> 00:13:10,446
我们可以提供更加具有沉浸式的

462
00:13:10,446 --> 00:13:12,156
体验

463
00:13:15,936 --> 00:13:17,976
我们要做的是

464
00:13:17,976 --> 00:13:19,776
判断用户在哪里

465
00:13:19,776 --> 00:13:21,386
指向设备

466
00:13:21,386 --> 00:13:23,566
并且将这一信息转化

467
00:13:23,656 --> 00:13:25,306
成游戏中的瞄准 为此 我们

468
00:13:25,306 --> 00:13:26,346
想要使用空间方位

469
00:13:27,686 --> 00:13:29,496
空间方位可以提供

470
00:13:29,496 --> 00:13:31,306
旋转角度率

471
00:13:31,306 --> 00:13:32,186
从在你第一次

472
00:13:32,186 --> 00:13:34,086
DeviceMotion 更新时就固定的参考系到

473
00:13:34,086 --> 00:13:35,406
用户当前在 3D 空间中握着的

474
00:13:35,406 --> 00:13:38,346
设备

475
00:13:38,556 --> 00:13:39,946
现在 我们可以考虑用来

476
00:13:39,946 --> 00:13:41,966
获取空间方位的途径是

477
00:13:41,966 --> 00:13:43,826
取得整个原始参数

478
00:13:43,826 --> 00:13:44,226
信号

479
00:13:44,846 --> 00:13:47,256
你的摇摆会决定

480
00:13:47,256 --> 00:13:47,746
空间方位

481
00:13:48,236 --> 00:13:50,106
然而

482
00:13:50,106 --> 00:13:51,966
这一判断空间方位的方法

483
00:13:51,966 --> 00:13:53,926
会随时间产生偏离 这是由于

484
00:13:53,926 --> 00:13:56,936
参数的偏差 这时就需要

485
00:13:56,936 --> 00:13:58,616
xArbitraryCorrectedZVertical

486
00:13:58,616 --> 00:13:59,606
参考系的帮助了

487
00:14:00,196 --> 00:14:01,376
这一参考系通过使用

488
00:14:01,376 --> 00:14:03,076
magnetometer 来改进

489
00:14:03,076 --> 00:14:04,686
我们提供的水平

490
00:14:04,956 --> 00:14:07,236
空间方位预测 作为一名

491
00:14:07,236 --> 00:14:08,626
开发人员 这个参考

492
00:14:08,626 --> 00:14:09,886
系意味着

493
00:14:09,886 --> 00:14:11,546
通过一个固定的中心参考

494
00:14:11,546 --> 00:14:13,386
向你提供可靠的空间方位

495
00:14:13,386 --> 00:14:13,916
性能

496
00:14:14,286 --> 00:14:16,206
所以在游戏中 你的用户可以

497
00:14:16,206 --> 00:14:17,706
来回移动设备然后

498
00:14:17,746 --> 00:14:19,046
找到一个已知的中心

499
00:14:19,046 --> 00:14:19,666
位置

500
00:14:21,166 --> 00:14:22,546
现在 通过使用这个参考系

501
00:14:22,546 --> 00:14:23,756
你还有许多其他的方式

502
00:14:23,756 --> 00:14:24,426
可以考虑

503
00:14:25,046 --> 00:14:26,176
假设你想要构建一款

504
00:14:26,176 --> 00:14:28,356
360 度的相片和视频

505
00:14:28,356 --> 00:14:29,236
播放应用软件

506
00:14:29,236 --> 00:14:30,906
你的用户可以转动

507
00:14:30,906 --> 00:14:32,356
他们的设备然后

508
00:14:32,356 --> 00:14:33,966
回到追准一个中心的状态

509
00:14:34,126 --> 00:14:35,276
这里即对准湖上的

510
00:14:35,276 --> 00:14:35,646
码头

511
00:14:37,286 --> 00:14:38,296
另外一个你可以

512
00:14:38,296 --> 00:14:39,736
考虑使用参考

513
00:14:39,736 --> 00:14:41,366
系的是有关

514
00:14:41,366 --> 00:14:42,766
虚拟现实的房地产的

515
00:14:42,766 --> 00:14:44,646
应用软件 你会想

516
00:14:44,646 --> 00:14:46,636
让你的用户可以

517
00:14:46,636 --> 00:14:47,656
从不同角度环顾房间

518
00:14:47,886 --> 00:14:48,866
而仅需移动他们的设备

519
00:14:50,486 --> 00:14:51,596
假设现在你已经构建了这样的一款

520
00:14:51,596 --> 00:14:53,046
应用软件 你的用户

521
00:14:53,116 --> 00:14:55,066
很喜欢它 但是他们想要

522
00:14:55,066 --> 00:14:56,356
更清楚地了解

523
00:14:56,356 --> 00:14:58,646
窗户的朝向 或者

524
00:14:58,746 --> 00:14:59,736
哪个方向

525
00:14:59,736 --> 00:15:00,766
可以看到日出

526
00:15:01,096 --> 00:15:03,226
为此 我们想要一个“环境

527
00:15:03,226 --> 00:15:03,676
参考”

528
00:15:05,366 --> 00:15:07,076
现在你可以考虑使用

529
00:15:07,076 --> 00:15:08,136
magnetometer 来完成它

530
00:15:08,136 --> 00:15:09,466
它可以提供一个“环境

531
00:15:09,466 --> 00:15:10,556
参考”而且你的

532
00:15:10,556 --> 00:15:11,906
应用软件可以根据环境

533
00:15:11,906 --> 00:15:12,806
作出适应

534
00:15:13,646 --> 00:15:14,966
然而 使用原始

535
00:15:14,966 --> 00:15:16,846
magnetometer 你会发现

536
00:15:16,846 --> 00:15:17,946
输出容易被

537
00:15:17,946 --> 00:15:18,626
打乱

538
00:15:19,556 --> 00:15:21,406
有一些是

539
00:15:21,406 --> 00:15:23,306
设备固有的 而有一些是

540
00:15:23,306 --> 00:15:24,346
设备外的

541
00:15:25,706 --> 00:15:26,936
这个时候就需要用到最后两个

542
00:15:26,936 --> 00:15:28,026
参考系了

543
00:15:28,566 --> 00:15:30,706
这两个参考系使用

544
00:15:30,706 --> 00:15:32,586
magnetometer 根据环境

545
00:15:32,586 --> 00:15:34,616
适应设备

546
00:15:34,736 --> 00:15:36,956
这些参考

547
00:15:36,956 --> 00:15:38,606
系处理的是磁性

548
00:15:38,746 --> 00:15:40,966
设备级别的效应

549
00:15:40,966 --> 00:15:42,396
还可以挑战 magnetometer

550
00:15:42,396 --> 00:15:44,266
的状况 可以

551
00:15:44,266 --> 00:15:44,696
使输出变得稳定

552
00:15:46,176 --> 00:15:48,046
那么 在这两个

553
00:15:48,046 --> 00:15:49,656
参考系中作何选择则是

554
00:15:49,656 --> 00:15:50,576
根据你应用软件的

555
00:15:50,576 --> 00:15:51,206
需求

556
00:15:51,646 --> 00:15:52,886
如果你已经获得了

557
00:15:53,076 --> 00:15:54,276
有关真北的数据

558
00:15:54,486 --> 00:15:55,796
例如 地图数据

559
00:15:55,796 --> 00:15:57,166
那么使用

560
00:15:57,166 --> 00:15:58,786
xTrueNorthZVertical 参考

561
00:15:58,786 --> 00:15:59,106
系就更合理

562
00:16:00,326 --> 00:16:03,356
那么我们要如何考虑使用

563
00:16:03,356 --> 00:16:04,326
这些参考系呢

564
00:16:04,916 --> 00:16:07,106
其中一个例子是

565
00:16:07,106 --> 00:16:08,816
观星指南应用软件

566
00:16:08,816 --> 00:16:09,846
你希望你的用户可以通过

567
00:16:09,846 --> 00:16:11,506
将设备对准

568
00:16:11,506 --> 00:16:14,056
天空中的星星来进行识别

569
00:16:14,316 --> 00:16:14,896
另外你还可以

570
00:16:14,896 --> 00:16:15,636
考虑将这些

571
00:16:15,636 --> 00:16:17,106
参考系

572
00:16:17,106 --> 00:16:18,076
运用到增强现实

573
00:16:18,076 --> 00:16:19,756
的应用软件中去 在这类的应用软件中你需要

574
00:16:19,756 --> 00:16:21,736
结合相机数据和

575
00:16:21,736 --> 00:16:22,546
环境参考

576
00:16:22,906 --> 00:16:24,196
为此 我们会建议你

577
00:16:24,196 --> 00:16:25,106
查看 ARKit

578
00:16:25,496 --> 00:16:26,746
ARKit 会议将

579
00:16:26,746 --> 00:16:27,876
紧随本次会议举行

580
00:16:27,876 --> 00:16:32,196
现在 我们再回到

581
00:16:32,196 --> 00:16:33,516
虚拟现实的房地产

582
00:16:33,516 --> 00:16:34,116
应用软件上来

583
00:16:35,286 --> 00:16:35,886
假设你已经构建了一款

584
00:16:35,886 --> 00:16:37,276
应用软件 你的用户也很

585
00:16:37,276 --> 00:16:39,306
喜欢它 但是你想要提供

586
00:16:39,306 --> 00:16:40,696
更多的功能

587
00:16:41,186 --> 00:16:42,416
假设你想要

588
00:16:42,416 --> 00:16:44,166
根据现实的位置

589
00:16:44,166 --> 00:16:45,296
在水平面上添加

590
00:16:45,296 --> 00:16:45,576
地标

591
00:16:46,506 --> 00:16:48,166
我们要怎么

592
00:16:48,166 --> 00:16:48,346
做呢

593
00:16:49,096 --> 00:16:51,006
我们需要的是指向标

594
00:16:52,376 --> 00:16:54,266
指向标为我们提供

595
00:16:54,266 --> 00:16:55,376
设备所指的方向

596
00:16:55,376 --> 00:16:56,346
这是相对于正北而言的

597
00:16:56,786 --> 00:16:58,226
所以当设备指着

598
00:16:58,306 --> 00:17:00,086
正北时 指向标

599
00:17:00,086 --> 00:17:03,076
会回到 0 度

600
00:17:03,076 --> 00:17:04,486
当用户旋转他们的设备

601
00:17:04,546 --> 00:17:06,205
指向标的角度也会随之

602
00:17:06,205 --> 00:17:06,586
改变

603
00:17:08,106 --> 00:17:09,556
现在你要考虑的是

604
00:17:09,556 --> 00:17:11,086
通过使用 CoreLocation

605
00:17:11,086 --> 00:17:11,846
获得指向标

606
00:17:12,316 --> 00:17:14,306
CoreLocation 提供一个开始

607
00:17:14,306 --> 00:17:17,006
更新指向标 API 然后你

608
00:17:17,006 --> 00:17:18,796
使用那个指向标

609
00:17:18,796 --> 00:17:20,445
并进行合并 通过

610
00:17:20,445 --> 00:17:21,476
你已经从

611
00:17:21,476 --> 00:17:22,236
DeviceMotion 获取的数据

612
00:17:24,366 --> 00:17:25,256
但要记住

613
00:17:25,256 --> 00:17:26,965
CoreLocation

614
00:17:26,965 --> 00:17:28,926
的指向标可能会合并路线

615
00:17:29,846 --> 00:17:31,216
路线这里是指

616
00:17:31,216 --> 00:17:32,066
设备移动的反响

617
00:17:32,896 --> 00:17:34,646
这对于

618
00:17:34,646 --> 00:17:35,746
逐向

619
00:17:35,746 --> 00:17:37,886
导航应用软件也许是合理的 但是对于

620
00:17:37,886 --> 00:17:39,226
增强现实应用软件来说

621
00:17:39,436 --> 00:17:40,496
就不那么合理了

622
00:17:40,846 --> 00:17:42,296
我希望你可以

623
00:17:42,296 --> 00:17:43,666
听听周四的 CoreLocation 会议

624
00:17:43,666 --> 00:17:45,266
以获取更多细节

625
00:17:46,596 --> 00:17:48,126
此外你可能还考虑

626
00:17:48,126 --> 00:17:49,806
通过我们提供在 DeviceMotion

627
00:17:49,806 --> 00:17:51,376
中的空间方位估算

628
00:17:51,376 --> 00:17:53,276
来获得

629
00:17:53,276 --> 00:17:54,066
指向标

630
00:17:54,586 --> 00:17:56,266
然而 要想在

631
00:17:56,266 --> 00:17:57,476
所有情况下把这件事做正确

632
00:17:57,476 --> 00:17:59,946
绝非容易的事 这也是为什么

633
00:18:00,336 --> 00:18:01,876
今年我们在 DeviceMotion

634
00:18:01,876 --> 00:18:03,716
中添加了指向标 并将它作为

635
00:18:03,716 --> 00:18:04,546
一项顶级的性能

636
00:18:05,896 --> 00:18:07,716
指向标将

637
00:18:07,716 --> 00:18:09,276
accelerometer gyroscope 以及

638
00:18:09,276 --> 00:18:09,896
最重要的

639
00:18:09,896 --> 00:18:11,306
magnetometer 合并起来 利用正北方向

640
00:18:11,306 --> 00:18:12,736
为我们提供设备所指

641
00:18:12,736 --> 00:18:13,656
的方向

642
00:18:15,366 --> 00:18:16,746
记住 指向标

643
00:18:16,746 --> 00:18:19,026
仅在 iOS 系统上提供 同时

644
00:18:19,026 --> 00:18:20,206
磁场特性也是

645
00:18:20,206 --> 00:18:20,606
可用的

646
00:18:22,156 --> 00:18:23,576
现在我们来仔细看一下

647
00:18:23,576 --> 00:18:23,976
API

648
00:18:25,386 --> 00:18:27,066
指向标仅对

649
00:18:27,066 --> 00:18:28,986
xMagneticNorth 和 xTrueNorth

650
00:18:28,986 --> 00:18:29,766
参考系有效

651
00:18:30,126 --> 00:18:31,106
对以其他两个参考系

652
00:18:31,106 --> 00:18:32,146
你会

653
00:18:32,146 --> 00:18:33,326
从指向标收到一个负值

654
00:18:33,326 --> 00:18:36,426
指向标会

655
00:18:36,426 --> 00:18:39,586
从你在你应用软件中

656
00:18:39,586 --> 00:18:41,546
选择的 X 轴上 给你 0 到 359 度

657
00:18:41,546 --> 00:18:42,856
的数值范围 无论是

658
00:18:42,856 --> 00:18:44,356
MagneticNorth 还是 TrueNorth

659
00:18:44,986 --> 00:18:48,016
既然我们有了指向标 我们

660
00:18:48,016 --> 00:18:49,776
就可以用它来

661
00:18:49,776 --> 00:18:50,936
将金门大桥

662
00:18:50,936 --> 00:18:52,606
放置在它

663
00:18:52,606 --> 00:18:52,916
实际的方位上了

664
00:18:55,946 --> 00:18:57,496
现在 通过 DeviceMotion

665
00:18:57,496 --> 00:18:58,686
我们有一些最佳实践

666
00:18:58,686 --> 00:18:59,446
需要记住

667
00:19:00,266 --> 00:19:02,226
首先 你要

668
00:19:02,226 --> 00:19:03,456
确保在开始更新之前

669
00:19:03,456 --> 00:19:04,546
检查所给

670
00:19:04,546 --> 00:19:06,196
参考系的

671
00:19:06,196 --> 00:19:06,746
可用性

672
00:19:07,566 --> 00:19:09,646
为此 你可以使用

673
00:19:09,646 --> 00:19:10,966
availableAttitudeReference

674
00:19:10,966 --> 00:19:11,586
Frame 的 API

675
00:19:12,216 --> 00:19:13,176
它会返回给你一个

676
00:19:13,336 --> 00:19:15,356
CMAttitudeReferenceFrame 位掩码

677
00:19:15,586 --> 00:19:17,016
然后你可以通过

678
00:19:17,016 --> 00:19:17,856
相关的参考系

679
00:19:17,856 --> 00:19:19,136
来确定

680
00:19:19,136 --> 00:19:19,756
可用性

681
00:19:21,086 --> 00:19:22,736
下一件要

682
00:19:22,736 --> 00:19:23,866
记住的是 选择

683
00:19:23,866 --> 00:19:25,556
参考系对于你的应用软件来说

684
00:19:25,556 --> 00:19:26,326
很关键

685
00:19:26,506 --> 00:19:28,416
这会决定

686
00:19:28,416 --> 00:19:29,876
如何计算你应用软件的

687
00:19:29,876 --> 00:19:32,246
空间方位 以及决定哪些

688
00:19:32,246 --> 00:19:34,056
传感器会被

689
00:19:34,056 --> 00:19:34,686
合并

690
00:19:36,286 --> 00:19:37,806
现在 我们已经讲了一些

691
00:19:37,806 --> 00:19:39,686
有关 DeviceMotion 的事

692
00:19:39,686 --> 00:19:40,596
让我们来讲讲更加

693
00:19:40,596 --> 00:19:41,146
实际的东西

694
00:19:41,806 --> 00:19:45,126
我们来讲讲

695
00:19:45,266 --> 00:19:46,296
我们在 DeviceMotion 中讨论过的一些概念

696
00:19:46,296 --> 00:19:48,686
然后通过一个游戏

697
00:19:48,686 --> 00:19:50,516
看看它们的实际应用

698
00:19:51,466 --> 00:19:53,076
Badger with Attitude 是一款游戏

699
00:19:53,256 --> 00:19:54,246
其中我们需要使用

700
00:19:54,536 --> 00:19:56,776
DeviceMotion 为游戏

701
00:19:56,776 --> 00:19:58,616
转换控制

702
00:19:58,616 --> 00:19:59,806
为此 我会请我的

703
00:19:59,806 --> 00:20:01,516
同事 Ahmad 到台上来

704
00:20:01,516 --> 00:20:02,326
跟大家讲一讲这个

705
00:20:03,516 --> 00:20:07,500
[鼓掌]

706
00:20:14,396 --> 00:20:15,186
>> 谢谢你 John

707
00:20:16,676 --> 00:20:17,576
大家好 欢迎来到这里

708
00:20:18,346 --> 00:20:19,406
今天我会讲一讲

709
00:20:19,406 --> 00:20:21,246
有关那些概念的问题 也就是 John

710
00:20:21,246 --> 00:20:22,606
前面提到的

711
00:20:22,606 --> 00:20:23,656
通过一个实例帮大家加深

712
00:20:23,656 --> 00:20:24,126
了解

713
00:20:24,876 --> 00:20:26,106
我叫 Ahmad 我是

714
00:20:26,106 --> 00:20:27,256
Core Motion 团队的一名

715
00:20:27,256 --> 00:20:27,536
工程师

716
00:20:29,036 --> 00:20:30,296
我将会使用 Badger 这个 App

717
00:20:30,446 --> 00:20:31,666
它是由我们在 SceneKit

718
00:20:31,666 --> 00:20:32,946
的同事开发的

719
00:20:33,546 --> 00:20:34,626
你也许已经看到过它了

720
00:20:34,626 --> 00:20:35,456
就在去年的会议上

721
00:20:36,096 --> 00:20:37,476
在这款游戏里你需要操控一只很可爱的

722
00:20:37,476 --> 00:20:38,686
小獾 他叫 Bob

723
00:20:39,106 --> 00:20:41,156
他坐在一个采矿车里 在

724
00:20:41,156 --> 00:20:42,766
车轨上颠簸 一路上

725
00:20:42,766 --> 00:20:43,876
挑选宝石和获取能量

726
00:20:44,466 --> 00:20:46,566
所以我们要来讲一讲这款 App

727
00:20:46,566 --> 00:20:48,886
通过现存的滑动操作

728
00:20:49,046 --> 00:20:50,946
并使用 DeviceMotion 将其变成

729
00:20:51,376 --> 00:20:52,806
基于动态的姿势

730
00:20:53,236 --> 00:20:58,546
这是现在商店中可以为你

731
00:20:58,546 --> 00:21:00,396
提供的： 首先我们

732
00:21:00,396 --> 00:21:01,556
要讲讲现存的

733
00:21:01,556 --> 00:21:03,186
控制 以及我们正在努力

734
00:21:03,186 --> 00:21:03,926
完成的

735
00:21:04,816 --> 00:21:06,446
然后我们会向你展示

736
00:21:06,446 --> 00:21:08,126
关于使用 DeviceMotion 的一些基本的东西

737
00:21:08,906 --> 00:21:10,456
最后 我们用算法

738
00:21:10,456 --> 00:21:12,046
来捕捉那些姿势

739
00:21:12,586 --> 00:21:16,206
在 Badger 这款 App 中

740
00:21:16,206 --> 00:21:17,746
你可以在屏幕上滑动手指

741
00:21:17,746 --> 00:21:19,206
来使獾跳动

742
00:21:20,186 --> 00:21:21,166
如果你下滑手指

743
00:21:21,166 --> 00:21:22,956
獾会低头藏在

744
00:21:22,956 --> 00:21:24,226
手推车里 以避开

745
00:21:24,226 --> 00:21:24,746
障碍物

746
00:21:25,876 --> 00:21:27,366
向左右滑动可以

747
00:21:27,366 --> 00:21:29,306
让獾通过摆动

748
00:21:29,306 --> 00:21:30,196
够到宝石

749
00:21:31,406 --> 00:21:33,176
如果你在这么美丽的

750
00:21:33,176 --> 00:21:34,346
图案上进行操作

751
00:21:34,346 --> 00:21:35,356
仅仅将它们藏在

752
00:21:35,356 --> 00:21:36,516
手指后面玩游戏的话

753
00:21:36,516 --> 00:21:37,086
就太可惜了

754
00:21:38,516 --> 00:21:39,596
所以 这里我们就将手机作为

755
00:21:39,596 --> 00:21:42,456
控制器 让

756
00:21:42,456 --> 00:21:43,806
用户完全沉浸在

757
00:21:43,806 --> 00:21:45,156
我们为他们构建的体验中

758
00:21:47,456 --> 00:21:48,806
那么首先 我们要检测

759
00:21:48,806 --> 00:21:50,656
用户是否将设备

760
00:21:50,686 --> 00:21:52,226
转向自己来使獾

761
00:21:52,226 --> 00:21:52,636
跳跃

762
00:21:54,456 --> 00:21:55,856
轻微地向下晃动设备

763
00:21:55,856 --> 00:21:57,336
可以使獾

764
00:21:57,336 --> 00:21:58,906
蹲下藏到手推车里

765
00:21:59,796 --> 00:22:02,346
向左或向右倾斜设备

766
00:22:02,346 --> 00:22:04,226
会使獾相应地进行

767
00:22:04,226 --> 00:22:04,786
倾斜

768
00:22:05,336 --> 00:22:09,256
现在我想让你关注在

769
00:22:09,256 --> 00:22:11,646
这些点上

770
00:22:11,646 --> 00:22:12,966
当你之后在看着

771
00:22:12,966 --> 00:22:15,126
样本代码时想一想它们 或者

772
00:22:15,126 --> 00:22:16,556
想一想如何将动态并进

773
00:22:16,556 --> 00:22:17,366
你的应用软件

774
00:22:17,876 --> 00:22:20,646
正如 John 已经提到的

775
00:22:20,726 --> 00:22:22,236
通过 Core Motion 你可以

776
00:22:22,316 --> 00:22:23,386
直接和传感器进行

777
00:22:23,386 --> 00:22:23,896
互动

778
00:22:24,776 --> 00:22:25,966
拿 accelerometer

779
00:22:25,966 --> 00:22:26,636
来说

780
00:22:27,926 --> 00:22:29,616
只要用户是半静止的状态

781
00:22:29,616 --> 00:22:31,246
那样的输入看上去还行

782
00:22:31,506 --> 00:22:32,946
但是当你开始走动

783
00:22:32,946 --> 00:22:34,846
或者上一辆公交车 你就

784
00:22:34,846 --> 00:22:35,776
必须考虑

785
00:22:35,776 --> 00:22:37,236
这些额外的 加速度

786
00:22:38,286 --> 00:22:39,756
通过 DeviceMotion 我们已经

787
00:22:39,756 --> 00:22:41,216
用其他的传感器 比如

788
00:22:41,216 --> 00:22:43,046
gyro 和 magnetometer 来

789
00:22:43,046 --> 00:22:44,296
对 accelerometer 进行了

790
00:22:44,296 --> 00:22:46,346
很好的补充 我们

791
00:22:46,346 --> 00:22:48,576
为你合并这些输入 这样一来我们可以

792
00:22:48,576 --> 00:22:50,016
将环境因素的影响

793
00:22:50,016 --> 00:22:51,876
最小化 让你专注在

794
00:22:51,876 --> 00:22:53,746
捕捉动态控制上

795
00:22:54,206 --> 00:22:56,446
而不是如何处理

796
00:22:57,606 --> 00:22:58,286
传感器的输入问题

797
00:22:58,896 --> 00:23:01,276
通过 DeviceMotion API 你可以

798
00:23:01,276 --> 00:23:03,336
以两种不同的方式来质询

799
00:23:03,336 --> 00:23:06,126
样本 即“推”和

800
00:23:06,126 --> 00:23:06,996
“拉”这两种机制

801
00:23:07,376 --> 00:23:09,396
让我们来仔细看一下这

802
00:23:10,106 --> 00:23:10,176
两个机制

803
00:23:12,196 --> 00:23:13,886
“推”这一机制对于

804
00:23:13,886 --> 00:23:15,576
捕捉一定时间内

805
00:23:15,576 --> 00:23:17,336
的分离姿势是很

806
00:23:17,336 --> 00:23:17,656
有用的

807
00:23:19,046 --> 00:23:21,216
在去年的 SwingWatch App 中

808
00:23:21,216 --> 00:23:23,716
我们使用了“推”

809
00:23:23,716 --> 00:23:25,376
这个机制 因此框架

810
00:23:25,376 --> 00:23:27,226
会在固定的间隔内

811
00:23:27,226 --> 00:23:28,906
向我们推一些更新 只要

812
00:23:29,206 --> 00:23:29,666
有更新的话

813
00:23:31,026 --> 00:23:32,056
然后我们会捕捉这些

814
00:23:32,056 --> 00:23:34,256
更新并且检测用户是否

815
00:23:34,256 --> 00:23:35,746
摆动手臂来进行

816
00:23:35,746 --> 00:23:36,906
反手击球或正手击球

817
00:23:38,936 --> 00:23:40,696
这就是 API 的样子

818
00:23:41,286 --> 00:23:43,076
你使用 CMMotionManager 的

819
00:23:43,436 --> 00:23:44,746
开始 DeviceMotion 更新

820
00:23:44,746 --> 00:23:46,626
功能 你提供一个

821
00:23:46,626 --> 00:23:48,076
相关的参考系

822
00:23:49,466 --> 00:23:51,606
提供一个操作线索 来使

823
00:23:51,606 --> 00:23:53,206
你的 motionHandler 尽快

824
00:23:53,206 --> 00:23:54,556
处理那些已有的样本

825
00:23:57,156 --> 00:24:00,416
然而 如果你先要知道

826
00:24:00,416 --> 00:24:01,486
设备的当前状态

827
00:24:01,486 --> 00:24:04,126
那么你需要在这里使用

828
00:24:04,126 --> 00:24:05,226
“拉”这个机制

829
00:24:05,836 --> 00:24:07,266
正如我们之后会在

830
00:24:07,266 --> 00:24:09,086
Badger 这款 App 演示 对于倾斜

831
00:24:09,156 --> 00:24:11,366
姿势 我们想要让

832
00:24:11,366 --> 00:24:13,366
獾的倾斜角度

833
00:24:13,366 --> 00:24:14,406
和手机一样

834
00:24:15,316 --> 00:24:17,526
因此我们要确保

835
00:24:17,526 --> 00:24:19,386
为我们的图形应用软件提供

836
00:24:20,016 --> 00:24:21,426
反应灵敏而流畅的体验

837
00:24:23,056 --> 00:24:24,996
“拉”机制的 API

838
00:24:24,996 --> 00:24:25,826
更简单

839
00:24:26,416 --> 00:24:26,836
你调用

840
00:24:26,836 --> 00:24:28,756
startDeviceMotionUpdates 然后

841
00:24:28,756 --> 00:24:30,036
提供参考系

842
00:24:31,006 --> 00:24:32,156
只要你准备好了 你就

843
00:24:32,156 --> 00:24:33,376
可以从框架中拉取最新的

844
00:24:33,376 --> 00:24:34,916
DeviceMotion

845
00:24:34,916 --> 00:24:35,366
样本

846
00:24:35,856 --> 00:24:39,226
我们还将发布样本

847
00:24:39,226 --> 00:24:40,446
代码以供使用 你之后

848
00:24:40,446 --> 00:24:42,516
可以看一下 但是现在

849
00:24:42,516 --> 00:24:43,736
让我们先来关注 Core Motion

850
00:24:43,736 --> 00:24:44,336
的部分

851
00:24:44,956 --> 00:24:47,376
那么让我们从它们开始

852
00:24:47,376 --> 00:24:49,216
介绍 Core Motion 框架

853
00:24:49,216 --> 00:24:50,616
然后举一个

854
00:24:50,616 --> 00:24:51,696
CMMotionManager 的例子

855
00:24:52,936 --> 00:24:54,796
然后我们检查一下 DeviceMotion

856
00:24:54,796 --> 00:24:56,236
更新在这个平台是是否

857
00:24:56,236 --> 00:24:56,756
可用

858
00:24:57,266 --> 00:25:00,026
如果你回忆刚才 John

859
00:25:00,026 --> 00:25:02,126
讲的 我们

860
00:25:02,126 --> 00:25:03,806
关注的

861
00:25:03,806 --> 00:25:05,406
关于追踪重力的倾斜姿势也在

862
00:25:05,406 --> 00:25:05,656
设备框中

863
00:25:06,386 --> 00:25:08,116
我们会使用

864
00:25:08,116 --> 00:25:09,896
xArbitraryZVertical 参考

865
00:25:09,896 --> 00:25:11,626
系 我会还会检查它使用在

866
00:25:11,626 --> 00:25:12,646
平台上可用

867
00:25:13,606 --> 00:25:15,616
你也许注意到了在这里我没有

868
00:25:15,906 --> 00:25:17,526
检查授权

869
00:25:17,526 --> 00:25:18,686
这是因为我正在

870
00:25:18,686 --> 00:25:20,096
使用 MotionManager API

871
00:25:20,416 --> 00:25:22,506
它并不访问敏感

872
00:25:22,506 --> 00:25:22,796
数据

873
00:25:24,766 --> 00:25:27,896
接下来的部分 我们会

874
00:25:27,896 --> 00:25:29,866
假定设备属于

875
00:25:29,906 --> 00:25:31,116
最后一种定向 但是

876
00:25:31,116 --> 00:25:32,246
在样本代码中 我们会向你展示

877
00:25:32,246 --> 00:25:34,306
如何捕捉处理其他的

878
00:25:34,306 --> 00:25:35,406
设备定向

879
00:25:38,956 --> 00:25:41,126
对于第一种姿势 当

880
00:25:41,336 --> 00:25:42,976
向自己旋转设备

881
00:25:43,186 --> 00:25:45,296
来使獾起跳时 我们

882
00:25:45,296 --> 00:25:47,366
想要捕捉

883
00:25:47,366 --> 00:25:49,156
手机水平轴的

884
00:25:49,156 --> 00:25:50,986
旋转率数值

885
00:25:51,736 --> 00:25:53,206
在这个例子中 也就是 Y 轴

886
00:25:55,816 --> 00:25:57,286
那么我们还要看一下

887
00:25:57,286 --> 00:25:59,836
DeviceMotion 目标的

888
00:25:59,836 --> 00:26:00,906
旋转率特性

889
00:26:01,486 --> 00:26:02,946
我们特别选择它

890
00:26:02,946 --> 00:26:04,736
是因为我们与

891
00:26:04,736 --> 00:26:06,376
设备当前的角度不相关

892
00:26:06,376 --> 00:26:08,056
与我们相关的是

893
00:26:08,056 --> 00:26:09,006
那个角度的快速改变

894
00:26:10,286 --> 00:26:12,046
所以如果我们使用旋转率的话

895
00:26:12,096 --> 00:26:14,246
我们就可以检测到快速的

896
00:26:14,316 --> 00:26:16,036
跳动 并且让獾相应地

897
00:26:16,036 --> 00:26:16,646
进行跳跃

898
00:26:17,136 --> 00:26:19,676
这是我们

899
00:26:19,676 --> 00:26:21,786
在很短的一段时间要检测到的

900
00:26:21,786 --> 00:26:23,156
姿势 因此我们要对它

901
00:26:23,156 --> 00:26:26,346
使用“推”机制

902
00:26:26,616 --> 00:26:27,606
让我们来看看它

903
00:26:27,606 --> 00:26:27,976
在代码里是什么样的

904
00:26:28,606 --> 00:26:31,106
最开始 我们要将

905
00:26:31,106 --> 00:26:32,666
更新间隔设为 50 赫兹

906
00:26:33,176 --> 00:26:34,176
你需要在设置的时候

907
00:26:34,176 --> 00:26:34,736
很小心

908
00:26:35,466 --> 00:26:36,496
你希望样本

909
00:26:36,496 --> 00:26:38,006
过来的足够快 这样的话

910
00:26:38,006 --> 00:26:39,406
你就可以捕捉那个姿势

911
00:26:39,876 --> 00:26:41,126
但是也不要太快

912
00:26:41,126 --> 00:26:42,626
那样会提高对计算

913
00:26:42,976 --> 00:26:44,206
和记忆的要求

914
00:26:45,656 --> 00:26:47,716
然后我们开始

915
00:26:47,716 --> 00:26:49,696
使用“推”机制进行 DeviceMotion 更新

916
00:26:49,696 --> 00:26:51,416
提供我们的

917
00:26:51,416 --> 00:26:53,166
xArbitraryZVertical 参考

918
00:26:53,166 --> 00:26:56,216
系 一个“queue” 我正在这里

919
00:26:56,216 --> 00:26:58,586
使用标准操作线索

920
00:26:58,586 --> 00:26:59,796
最后就是我们的 motionHandler

921
00:27:02,636 --> 00:27:04,186
这就是我们的 motionHandler

922
00:27:04,186 --> 00:27:04,686
的样子

923
00:27:04,946 --> 00:27:06,426
只要样本准备好了

924
00:27:06,426 --> 00:27:07,206
就可以调动它

925
00:27:07,926 --> 00:27:08,966
我们要做的第一件事就是

926
00:27:08,966 --> 00:27:11,606
检查所有的错误

927
00:27:11,606 --> 00:27:13,076
从 DeviceMotion 目标获取旋转率

928
00:27:13,076 --> 00:27:15,426
然后看一下

929
00:27:15,696 --> 00:27:17,516
与我们相关的

930
00:27:17,516 --> 00:27:18,776
Y 轴分量

931
00:27:19,336 --> 00:27:21,016
然后我们将它储存在缓冲存储器中

932
00:27:21,416 --> 00:27:22,436
我这里使用的是循环

933
00:27:22,436 --> 00:27:24,296
缓冲 因此只要

934
00:27:24,296 --> 00:27:25,656
样本过来 我们就可以

935
00:27:25,656 --> 00:27:29,566
积累更多

936
00:27:29,966 --> 00:27:31,226
由于我们为这个应用软件

937
00:27:31,226 --> 00:27:33,266
使用的是 SceneKit 渲染器

938
00:27:33,266 --> 00:27:34,126
我选择渲染器的

939
00:27:34,126 --> 00:27:35,336
updateAtTime 功能

940
00:27:35,826 --> 00:27:37,256
在你渲染一个新的场景之前

941
00:27:37,296 --> 00:27:40,046
它会被调用 这

942
00:27:40,046 --> 00:27:41,286
对于我来说是一个理想的地方

943
00:27:41,286 --> 00:27:42,396
来检查缓存状态

944
00:27:42,396 --> 00:27:44,576
然后更新游戏

945
00:27:45,106 --> 00:27:47,986
我会让你们

946
00:27:47,986 --> 00:27:48,746
自己去发现

947
00:27:48,746 --> 00:27:50,136
应用软件里的哪一个地方最适合

948
00:27:50,136 --> 00:27:51,126
做那件事

949
00:27:52,766 --> 00:27:54,426
然后我只需要检查一下

950
00:27:54,426 --> 00:27:55,816
那种缓存的方式是否跨过了

951
00:27:55,816 --> 00:27:57,336
某一界点使得

952
00:27:57,336 --> 00:27:58,306
獾可以跳跃

953
00:27:59,676 --> 00:28:01,286
记住这个界点

954
00:28:01,336 --> 00:28:03,216
是可以根据你 App 的特殊需求

955
00:28:03,216 --> 00:28:04,256
来进行转变和调整的

956
00:28:08,316 --> 00:28:10,446
接下来我们要看一下

957
00:28:10,446 --> 00:28:12,166
第二个控制 在第二个控制中当我们

958
00:28:12,166 --> 00:28:13,746
向下晃动设备时

959
00:28:13,746 --> 00:28:14,976
獾会下蹲

960
00:28:16,386 --> 00:28:18,216
对于这个控制 我们要测量的是

961
00:28:18,216 --> 00:28:20,996
用户顺着重力矢量的

962
00:28:20,996 --> 00:28:22,136
加速度

963
00:28:25,076 --> 00:28:26,636
所以我们要看用户的

964
00:28:26,636 --> 00:28:29,116
重力性能 这里

965
00:28:29,116 --> 00:28:31,526
我们选择它是因为哪怕

966
00:28:31,526 --> 00:28:33,326
设备稍微倾斜或

967
00:28:33,326 --> 00:28:35,166
旋转一定角度 用户的

968
00:28:35,166 --> 00:28:36,536
加速度还是

969
00:28:36,536 --> 00:28:38,436
一样的 不管空间方位

970
00:28:38,436 --> 00:28:39,036
如何变化

971
00:28:43,316 --> 00:28:45,546
因此这又是一个

972
00:28:45,546 --> 00:28:47,126
我们要在短时间内检测的

973
00:28:47,126 --> 00:28:48,446
动作 我们也会

974
00:28:48,446 --> 00:28:49,706
使用“推”机制

975
00:28:51,386 --> 00:28:52,546
由于我们已经建立了

976
00:28:52,546 --> 00:28:54,576
“推”机制 我们将会

977
00:28:54,576 --> 00:28:56,246
返回我们的 motionHandler

978
00:28:56,246 --> 00:28:57,646
在那里我们之前存储了那些

979
00:28:57,646 --> 00:28:58,496
旋转率

980
00:28:59,006 --> 00:29:02,106
但是这次 我们要将

981
00:29:02,106 --> 00:29:03,806
重力性能排除在

982
00:29:03,806 --> 00:29:07,116
DeviceMotion 目标外 以及

983
00:29:07,116 --> 00:29:08,146
用户的加速度

984
00:29:08,686 --> 00:29:11,916
我们计算

985
00:29:11,916 --> 00:29:13,716
顺着重力矢量的用户加速度的值

986
00:29:13,716 --> 00:29:17,536
将它存储在

987
00:29:17,536 --> 00:29:17,896
一个缓冲器里

988
00:29:18,626 --> 00:29:21,306
一旦缓冲方式

989
00:29:21,306 --> 00:29:22,666
超过了某个界点

990
00:29:23,236 --> 00:29:24,696
我们就会让獾

991
00:29:24,696 --> 00:29:27,366
蹲在并且藏在手推车里

992
00:29:28,136 --> 00:29:29,826
所以我们来看一眼这两个

993
00:29:29,826 --> 00:29:31,886
控制 我们通过在这两个控制

994
00:29:31,886 --> 00:29:33,506
来监测一小段时间内的动态

995
00:29:33,506 --> 00:29:35,266
我们还为此使用了

996
00:29:35,266 --> 00:29:36,346
“推”机制

997
00:29:37,216 --> 00:29:38,716
让我们来看一下最后一个

998
00:29:38,766 --> 00:29:40,976
控制 对于这个控制我们的要求

999
00:29:40,976 --> 00:29:43,816
稍有不同

1000
00:29:44,826 --> 00:29:48,046
对于倾斜控制来说

1001
00:29:48,046 --> 00:29:49,686
举个简单的例子 当设备被

1002
00:29:49,686 --> 00:29:52,976
垂直拿着时

1003
00:29:52,976 --> 00:29:54,206
你可以将重力

1004
00:29:54,206 --> 00:29:56,236
矢量分割成 X 轴分量

1005
00:29:56,236 --> 00:29:59,236
和 Y 轴分量 通过运用

1006
00:29:59,236 --> 00:30:00,816
简单的三角学原理

1007
00:30:00,816 --> 00:30:01,646
你可以达到倾斜

1008
00:30:03,006 --> 00:30:05,086
但是由于我们希望这个姿势

1009
00:30:05,086 --> 00:30:06,476
更加灵活

1010
00:30:07,186 --> 00:30:08,636
我们要将重力分成

1011
00:30:08,636 --> 00:30:10,306
Y 轴分量

1012
00:30:10,306 --> 00:30:12,586
以及在设备 X－Z 轴上的

1013
00:30:12,586 --> 00:30:13,216
分量

1014
00:30:14,066 --> 00:30:15,386
这样一来

1015
00:30:15,386 --> 00:30:19,826
哪怕设备稍微旋转了一定角度 我们也可以

1016
00:30:19,826 --> 00:30:21,286
倾斜手机

1017
00:30:22,576 --> 00:30:23,856
这个控制的不同之处在于

1018
00:30:23,856 --> 00:30:25,326
我们想要知道

1019
00:30:25,766 --> 00:30:27,296
设备的当前状态

1020
00:30:27,366 --> 00:30:28,766
而不是发生的

1021
00:30:28,766 --> 00:30:29,156
分离动态

1022
00:30:30,536 --> 00:30:33,486
这使我们可以让

1023
00:30:33,486 --> 00:30:35,416
獾根据设备的倾斜角度

1024
00:30:35,416 --> 00:30:37,166
倾斜同样的角度

1025
00:30:37,166 --> 00:30:38,616
并且提供非常灵敏的

1026
00:30:38,616 --> 00:30:39,286
操作体验

1027
00:30:39,786 --> 00:30:42,416
基于那些原因 我们将

1028
00:30:42,416 --> 00:30:44,546
为此控制使用

1029
00:30:45,026 --> 00:30:47,076
“拉”机制

1030
00:30:47,146 --> 00:30:48,366
由于我们已经建立了

1031
00:30:48,366 --> 00:30:50,656
“拉”机制

1032
00:30:50,656 --> 00:30:51,996
当我们要拉回

1033
00:30:51,996 --> 00:30:54,396
任何时间点的样本时

1034
00:30:54,396 --> 00:30:54,716
框架都是准备好的

1035
00:30:56,716 --> 00:30:58,606
所以我们要回到我们的渲染器

1036
00:30:58,606 --> 00:30:59,226
功能

1037
00:30:59,456 --> 00:31:00,626
回想一下 它会在

1038
00:31:00,626 --> 00:31:02,356
你渲染一个新场景之前

1039
00:31:02,356 --> 00:31:02,886
被调用

1040
00:31:03,616 --> 00:31:05,406
这使得它成为了

1041
00:31:05,406 --> 00:31:06,926
我拉回最新样本的最佳

1042
00:31:06,926 --> 00:31:09,076
场所 也是计算和

1043
00:31:09,076 --> 00:31:12,516
更新图画的最佳场所

1044
00:31:12,516 --> 00:31:13,756
所以我们会向 MotionManager

1045
00:31:13,756 --> 00:31:14,986
请求最新的 DeviceMotion

1046
00:31:14,986 --> 00:31:18,016
样本 不考虑

1047
00:31:18,016 --> 00:31:22,096
重力性能 来计算出

1048
00:31:22,096 --> 00:31:23,546
矢量和 X-Z 轴的分量

1049
00:31:23,976 --> 00:31:28,446
以达到倾斜 也就是

1050
00:31:28,446 --> 00:31:30,246
X—Z 轴分量和

1051
00:31:30,246 --> 00:31:31,056
Y 轴分量的反正切函数

1052
00:31:31,546 --> 00:31:34,686
不要忘记

1053
00:31:34,686 --> 00:31:36,176
让框架知道你和

1054
00:31:36,176 --> 00:31:37,076
DeviceMotion 更新不再相关了

1055
00:31:37,076 --> 00:31:39,106
不再相关了

1056
00:31:39,106 --> 00:31:40,186
如果它之前是有效的话

1057
00:31:41,266 --> 00:31:42,556
这一点很棒

1058
00:31:42,556 --> 00:31:44,166
当你的游戏暂停或结束时

1059
00:31:45,126 --> 00:31:46,786
它可以确保你没有浪费

1060
00:31:46,786 --> 00:31:47,856
多余的电量

1061
00:31:48,846 --> 00:31:50,246
这里你可以看到一个结果

1062
00:31:50,866 --> 00:31:52,426
用户可以

1063
00:31:52,426 --> 00:31:54,766
通过将设备倾斜到一边

1064
00:31:54,766 --> 00:31:57,326
来使獾也以同样的方式倾斜

1065
00:31:57,326 --> 00:32:00,036
向他们的方向倾斜

1066
00:32:00,036 --> 00:32:01,436
设备可以让

1067
00:32:01,436 --> 00:32:05,936
獾跳起来 最后

1068
00:32:05,936 --> 00:32:07,086
向下轻推设备

1069
00:32:07,086 --> 00:32:08,446
可以使獾

1070
00:32:08,446 --> 00:32:10,026
下蹲并躲在手推车里

1071
00:32:10,496 --> 00:32:13,546
这很酷 我们已经

1072
00:32:13,606 --> 00:32:15,576
通过滑动控制和使用

1073
00:32:15,576 --> 00:32:17,926
DeviceMotion 来取代

1074
00:32:17,926 --> 00:32:18,856
原本基于动态的控制

1075
00:32:27,386 --> 00:32:29,126
我很激动地想要看到

1076
00:32:29,126 --> 00:32:30,636
你们能将 DeviceMotion API 应用成什么样

1077
00:32:35,516 --> 00:32:44,576
[鼓掌]

1078
00:32:45,076 --> 00:32:46,196
所以来总结一下

1079
00:32:46,196 --> 00:32:47,246
我们今天讨论的几个关键点

1080
00:32:47,306 --> 00:32:50,276
我们希望你看一下

1081
00:32:50,276 --> 00:32:52,356
授权 API

1082
00:32:52,356 --> 00:32:53,106
并且检查一下你 App 的

1083
00:32:53,106 --> 00:32:55,616
授权 来看一下你使用的 API

1084
00:32:55,616 --> 00:32:57,226
是否灵敏

1085
00:32:59,666 --> 00:33:00,986
你也许有

1086
00:33:00,986 --> 00:33:02,926
直接使用传感数据的用例

1087
00:33:02,926 --> 00:33:05,166
我们还是希望你

1088
00:33:05,166 --> 00:33:07,626
看一下 DeviceMotion API

1089
00:33:08,016 --> 00:33:09,176
因为我们的传感器混合

1090
00:33:09,176 --> 00:33:10,916
参数可以处理

1091
00:33:10,916 --> 00:33:11,526
绝大多数案例

1092
00:33:11,936 --> 00:33:13,026
它可以排除那些

1093
00:33:13,026 --> 00:33:14,966
环境因素

1094
00:33:14,966 --> 00:33:17,126
因此你可以专注在

1095
00:33:17,126 --> 00:33:18,496
用户的动态控制上

1096
00:33:20,546 --> 00:33:23,346
API 为你提供了一个流畅

1097
00:33:23,346 --> 00:33:24,936
且连贯的体验

1098
00:33:24,936 --> 00:33:26,826
在所有我们支持的设备上都是如此

1099
00:33:28,056 --> 00:33:29,806
我们本次发布还做了一些改进

1100
00:33:29,806 --> 00:33:31,566
来确保

1101
00:33:31,566 --> 00:33:33,136
当你询问更新时

1102
00:33:33,136 --> 00:33:33,896
可以通过一种

1103
00:33:33,896 --> 00:33:34,796
低能耗的方式

1104
00:33:34,796 --> 00:33:40,566
记住两种不同

1105
00:33:41,076 --> 00:33:43,466
询问更新的方式

1106
00:33:43,466 --> 00:33:45,226
当你想要捕捉

1107
00:33:45,226 --> 00:33:46,846
很短时间内的一个姿势时使用“推”

1108
00:33:46,916 --> 00:33:49,786
当灵敏性很重要且你

1109
00:33:51,816 --> 00:33:52,756
想要知道设备的

1110
00:33:52,756 --> 00:33:57,436
当前状态时用“拉”

1111
00:33:58,116 --> 00:33:59,196
还有一些会议

1112
00:33:59,196 --> 00:34:00,356
我们觉得你们可能会

1113
00:34:00,356 --> 00:34:01,196
感兴趣

1114
00:34:02,256 --> 00:34:04,436
请关注它们

1115
00:34:04,436 --> 00:34:05,366
如果你有兴趣

1116
00:34:05,366 --> 00:34:06,796
了解更多关于 Badger App 的内容

1117
00:34:06,796 --> 00:34:07,826
请查看去年的 SceneKit

1118
00:34:07,826 --> 00:34:08,246
会议

1119
00:34:09,676 --> 00:34:11,085
在这个链接中

1120
00:34:11,085 --> 00:34:13,446
你可以获得样本

1121
00:34:13,446 --> 00:34:14,496
代码 以及其他有关 Core Motion

1122
00:34:14,496 --> 00:34:15,286
的文件

1123
00:34:15,815 --> 00:34:19,476
感谢大家今天的出席

1124
00:34:19,476 --> 00:34:20,596
祝大家度过一个美好的夜晚

