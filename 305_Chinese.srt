1
00:00:19,286 --> 00:00:23,357
（STOREKIT收条验证
与订阅进阶知识）

2
00:00:23,423 --> 00:00:26,760
我是Pete Hare
是App Store团队成员

3
00:00:27,294 --> 00:00:30,364
你们可能来自于不同的群体

4
00:00:30,430 --> 00:00:34,101
想要更多地了解
如何将程序内购买

5
00:00:34,168 --> 00:00:35,836
集成到你的应用之中

6
00:00:35,903 --> 00:00:38,338
并且安全和可靠地做到这一点

7
00:00:38,605 --> 00:00:41,208
或许你们想了解订阅

8
00:00:41,275 --> 00:00:44,611
并且想知道
服务器环境中的

9
00:00:44,678 --> 00:00:47,347
跨平台订阅状态维护流程

10
00:00:47,414 --> 00:00:48,348
诸如此类

11
00:00:48,882 --> 00:00:52,319
无论你身处哪个群体
程序内购买都代表

12
00:00:52,386 --> 00:00:54,955
你和用户之间的信任

13
00:00:55,389 --> 00:00:59,359
当用户花钱购买数字内容或服务时

14
00:00:59,426 --> 00:01:03,931
他们相信你能够

15
00:01:03,997 --> 00:01:05,632
安全可靠地交付这些服务和内容

16
00:01:06,533 --> 00:01:09,536
今天我会讨论这方面的一些技术

17
00:01:09,603 --> 00:01:12,506
首先 我们会详细讨论收条验证

18
00:01:12,573 --> 00:01:15,242
今天上午的演讲已经简要讲到这个主题

19
00:01:15,309 --> 00:01:17,911
我们将会详细介绍

20
00:01:17,978 --> 00:01:19,079
如何在用户的设备在完成这些工作

21
00:01:19,680 --> 00:01:22,616
我们还会讨论如何维护订阅状态

22
00:01:22,683 --> 00:01:25,452
尤其是在服务器上
以及如何根据订阅状态

23
00:01:25,519 --> 00:01:28,422
更新不同的平台

24
00:01:29,556 --> 00:01:32,359
最后我们会简单讲述
沙盒环境下的开发

25
00:01:32,426 --> 00:01:35,028
在进行开发时
如何使用这些技术

26
00:01:35,095 --> 00:01:37,231
而不必自己花钱

27
00:01:38,465 --> 00:01:39,466
让我们来看这张图

28
00:01:39,533 --> 00:01:41,034
在今天上午的演讲上
我们见过这张图

29
00:01:41,101 --> 00:01:43,270
这是程序内购买流程

30
00:01:43,337 --> 00:01:45,038
你需要在程序中实现这个流程

31
00:01:45,105 --> 00:01:47,875
以销售程序内购买物品

32
00:01:48,342 --> 00:01:49,343
在这个演讲中

33
00:01:49,409 --> 00:01:52,012
我们将重点讨论最后三个环节

34
00:01:52,079 --> 00:01:54,381
我将它们称为处理交易

35
00:01:54,448 --> 00:01:56,683
StoreKit发送一个交易给你时

36
00:01:56,750 --> 00:01:59,820
用户付款之后
你需要处理交易

37
00:01:59,887 --> 00:02:03,490
然后交付用户所购买的内容

38
00:02:03,657 --> 00:02:05,893
现在我将扩展这些步骤

39
00:02:05,959 --> 00:02:09,663
我将引入一个附加层
也就是将你的服务器加入进来

40
00:02:10,531 --> 00:02:12,866
本演讲的内容就是这些

41
00:02:12,933 --> 00:02:15,936
流程是这样的
首先我们收到一个交易

42
00:02:16,303 --> 00:02:18,705
这个交易通过StoreKit
到达用户设备

43
00:02:19,339 --> 00:02:22,042
然后你选择是否

44
00:02:22,109 --> 00:02:24,745
想要在用户的设备或服务器上验证收条

45
00:02:26,713 --> 00:02:30,050
然后 你检查收条的内容

46
00:02:30,384 --> 00:02:32,619
解锁内容或者
在内容的基础上

47
00:02:32,686 --> 00:02:34,588
更新订阅状态

48
00:02:34,855 --> 00:02:36,290
此流程的最后一步是

49
00:02:36,356 --> 00:02:39,860
回到用户的设备上完结交易

50
00:02:40,861 --> 00:02:44,131
现在你注意到
这个流程的第一和最后部分

51
00:02:44,198 --> 00:02:45,933
在设备级别上完成

52
00:02:45,999 --> 00:02:48,602
我们不允许交易进入服务器级别

53
00:02:48,669 --> 00:02:49,570
这一点很重要

54
00:02:49,636 --> 00:02:52,673
即使你使用服务端流程
进行收条验证

55
00:02:52,739 --> 00:02:55,442
也必须确保
在用户的设备上

56
00:02:55,509 --> 00:02:56,777
接收和完结交易

57
00:02:58,745 --> 00:03:00,347
今天上午

58
00:03:00,414 --> 00:03:02,549
我们讨论了四种
不同类型的程序内购买

59
00:03:03,050 --> 00:03:05,919
如果你处理消费类产品或非消费类产品

60
00:03:05,986 --> 00:03:07,855
你将需要执行这样的流程

61
00:03:07,921 --> 00:03:09,590
这是在设备上执行的流程

62
00:03:09,656 --> 00:03:12,326
你在设备上检查收条和解锁内容

63
00:03:12,392 --> 00:03:15,996
而不会发送任何内容到服务器
或处理网络请求

64
00:03:16,563 --> 00:03:17,865
如果你处理订阅、

65
00:03:17,931 --> 00:03:19,800
尤其是自动续约订阅

66
00:03:19,867 --> 00:03:22,269
你将需要

67
00:03:22,336 --> 00:03:24,538
在服务器上保留状态

68
00:03:24,605 --> 00:03:28,041
你需要服务器能够更新多台设备

69
00:03:28,575 --> 00:03:31,245
当然你可以使用这些技术

70
00:03:31,912 --> 00:03:33,981
但无论哪些方法
流程都起始于同一个步骤

71
00:03:34,047 --> 00:03:36,683
也就是在设备上接收交易

72
00:03:36,750 --> 00:03:40,187
让我们来看每个步骤

73
00:03:43,123 --> 00:03:45,659
这是我的应用的生命周期起点

74
00:03:46,159 --> 00:03:48,328
我们创建应用方法

75
00:03:48,395 --> 00:03:49,830
此方法含有did finish launching参数

76
00:03:49,897 --> 00:03:51,798
并且注册一个
SKPaymentQueue

77
00:03:51,865 --> 00:03:53,500
交易观察器

78
00:03:53,567 --> 00:03:56,270
需要在程序生命周期的早期

79
00:03:56,336 --> 00:03:58,939
注册这个交易观察器
然后你通过StoreKit

80
00:03:59,006 --> 00:04:01,642
接收经过更新的交易

81
00:04:01,975 --> 00:04:03,777
这里我增加AppDelegate

82
00:04:03,844 --> 00:04:05,946
作为支付观察器

83
00:04:06,013 --> 00:04:08,849
你也可以添加一个单独的控制器对象

84
00:04:09,116 --> 00:04:10,984
重要的是
必须在程序生命周期的早期

85
00:04:11,051 --> 00:04:12,753
完成这些工作

86
00:04:12,819 --> 00:04:16,890
注册之后 就可以

87
00:04:16,957 --> 00:04:18,992
开始通过更新交易回调
接收交易

88
00:04:19,526 --> 00:04:23,197
就是交易观察器中的
更新交易回调

89
00:04:23,897 --> 00:04:26,800
你收到一个交易数组
可以迭代这个数组

90
00:04:26,900 --> 00:04:29,336
可以检查每个交易的
交易状态

91
00:04:29,403 --> 00:04:31,538
你需要查看处于购买状态的交易

92
00:04:31,605 --> 00:04:34,675
StoreKit认为

93
00:04:34,741 --> 00:04:37,811
你可以验证交易
然后解锁内容

94
00:04:37,878 --> 00:04:40,814
它告诉用户已经付款

95
00:04:42,749 --> 00:04:44,818
获得处于购买状态的交易之后

96
00:04:44,885 --> 00:04:47,654
你准备进行这个图表中的下一步处理

97
00:04:47,855 --> 00:04:51,358
让我们首先来看
如何在用户设备上

98
00:04:51,425 --> 00:04:52,893
进行收条验证

99
00:04:53,260 --> 00:04:54,828
那么收条是什么？

100
00:04:54,895 --> 00:04:56,196
今天上午我们已经讲过

101
00:04:56,263 --> 00:04:57,698
但你们一些人可能没参加那个演讲

102
00:04:57,764 --> 00:04:59,433
收条就像是文件

103
00:04:59,499 --> 00:05:01,468
就像百货商店开出的收据一样

104
00:05:01,535 --> 00:05:04,571
它是购买凭据

105
00:05:04,638 --> 00:05:07,107
表明用户确实已经购买
他们想要购买的内容

106
00:05:07,174 --> 00:05:10,577
这是一个程序收条
这是一个可信的

107
00:05:10,644 --> 00:05:14,248
程序内购买凭证

108
00:05:14,915 --> 00:05:17,251
这个收条存储在设备上

109
00:05:17,551 --> 00:05:20,254
由App Store签发

110
00:05:21,021 --> 00:05:24,858
它相当于一个可检验的文件
意味着你可以使用证书

111
00:05:24,925 --> 00:05:27,861
检查此文件是否确实由Apple签发

112
00:05:27,928 --> 00:05:30,764
并且放在用户设备上
以确保其真实性

113
00:05:32,065 --> 00:05:34,434
最后 它只能在设备上
用于你的程序

114
00:05:34,902 --> 00:05:36,370
这意味着不能
跨设备共享

115
00:05:36,436 --> 00:05:38,472
或者与其它程序共享

116
00:05:39,640 --> 00:05:42,910
在收条验证方面
需要使用流程

117
00:05:42,976 --> 00:05:44,678
确保此文件是可信文件

118
00:05:44,745 --> 00:05:47,080
而不是某个人的假文件

119
00:05:47,147 --> 00:05:48,081
这有两种方法

120
00:05:48,148 --> 00:05:50,851
可以在设备上验证

121
00:05:51,351 --> 00:05:53,954
也可以发送到服务器

122
00:05:54,021 --> 00:05:55,889
使用服务器对服务器验证方法

123
00:05:56,690 --> 00:05:58,992
需要指出的是
如果在用户设备上验证

124
00:05:59,059 --> 00:06:01,128
一定不能直接在用户设备上

125
00:06:01,195 --> 00:06:02,930
使用在线验证

126
00:06:02,996 --> 00:06:05,399
因为这不是安全的验证方法

127
00:06:05,465 --> 00:06:07,134
如果在设备上验证

128
00:06:07,201 --> 00:06:09,803
你需要使用
我们即将介绍的方法

129
00:06:10,871 --> 00:06:14,374
收条看上去是什么样的？
让我们来看实际文件

130
00:06:15,776 --> 00:06:16,910
收条文件

131
00:06:17,277 --> 00:06:19,580
我们获得程序的所有购买信息

132
00:06:19,646 --> 00:06:20,781
包括所有程序内购买

133
00:06:20,848 --> 00:06:24,017
另外还有证书和签名

134
00:06:24,084 --> 00:06:27,187
用于创建文件
以检查真实性

135
00:06:27,254 --> 00:06:29,957
此文件存储在程序捆绑包内

136
00:06:30,023 --> 00:06:33,660
我们提供一个API
用于获取此文件

137
00:06:34,328 --> 00:06:35,596
它是一个单文件

138
00:06:35,829 --> 00:06:38,465
含有程序的所有购买数据

139
00:06:38,532 --> 00:06:40,801
和已经发生的程序内购买

140
00:06:40,868 --> 00:06:44,805
包括一个签名
用于检查真实性

141
00:06:44,872 --> 00:06:46,607
确保它是Apple签发的

142
00:06:47,808 --> 00:06:50,310
此文件基于一系列的工业标准

143
00:06:50,377 --> 00:06:51,612
它使用公钥加密标准

144
00:06:51,678 --> 00:06:55,249
进行签名

145
00:06:56,116 --> 00:06:58,552
使用ASN.1数据编码方法进行编码

146
00:06:58,619 --> 00:07:01,321
不要对这些缩写术语感到困惑

147
00:07:01,388 --> 00:07:03,590
它们都是公开标准

148
00:07:03,657 --> 00:07:05,626
可以在网上

149
00:07:05,692 --> 00:07:07,828
找到许多的相关信息

150
00:07:08,195 --> 00:07:11,665
你可能熟悉的一种加密技术
是OpenSSL

151
00:07:11,732 --> 00:07:12,966
OpenSSL是一个框架

152
00:07:13,033 --> 00:07:16,803
不仅提供安全网页传输隧道功能

153
00:07:16,870 --> 00:07:18,305
且能从ASN.1数据负载中

154
00:07:18,372 --> 00:07:21,375
读取数据编码

155
00:07:21,441 --> 00:07:24,711
并且在这样的密文容器上检查签名

156
00:07:25,546 --> 00:07:28,081
当然 你可以使用
OpenSSL预构建解决方案

157
00:07:28,148 --> 00:07:31,552
也可以直接读取特定的数据

158
00:07:31,618 --> 00:07:34,454
你和你的公司应该
自行选择合适的解决方案

159
00:07:34,521 --> 00:07:38,559
你可以看到 在安全方面
尤其是这种验证

160
00:07:38,625 --> 00:07:41,061
并不是二项选择
不是安全与不安全

161
00:07:41,128 --> 00:07:42,429
安全是一种程度

162
00:07:42,496 --> 00:07:45,465
你必须自己决定
你所需要的安全程度

163
00:07:45,532 --> 00:07:47,734
来验证这些购买

164
00:07:48,936 --> 00:07:52,239
无论哪种方法 首先都需要
读取这个文件的加密数据

165
00:07:52,306 --> 00:07:54,541
你可以使用前面提到的API

166
00:07:54,608 --> 00:07:58,478
即Bundle.AppStoreReceiptURL API

167
00:07:59,112 --> 00:08:02,816
它提供一个URL
可以通过它传递数据对象

168
00:08:02,883 --> 00:08:06,220
你可以读取收条对象的加密二进制数据

169
00:08:06,286 --> 00:08:10,958
加密二进制数据现已读取到内存之中

170
00:08:13,527 --> 00:08:15,596
一点提示
如果你要使用OpenSSL

171
00:08:15,662 --> 00:08:17,064
在本演讲中

172
00:08:17,130 --> 00:08:18,866
不会介绍OpenSSL使用流程

173
00:08:19,566 --> 00:08:21,702
但你们该知道
iOS不含OpenSSL

174
00:08:22,169 --> 00:08:24,872
你必须自己创建并且加入到你的程序

175
00:08:25,205 --> 00:08:28,308
你应该将它作为程序的静态库

176
00:08:28,375 --> 00:08:30,511
而不是动态库

177
00:08:30,844 --> 00:08:33,246
如果使用动态库

178
00:08:33,313 --> 00:08:37,484
很容易被其它人调换为伪造的动态库

179
00:08:37,551 --> 00:08:40,386
而影响程序二进制代码中的
实际方法的执行

180
00:08:40,453 --> 00:08:43,423
静态库意味着

181
00:08:43,490 --> 00:08:45,325
二进制数据封装在你的程序之内

182
00:08:45,392 --> 00:08:48,228
其他人难以撰改
和调换你的OpenSSL实例

183
00:08:49,463 --> 00:08:51,064
在证书检查方面

184
00:08:51,131 --> 00:08:52,699
你可以从Apple网站
下载Apple Root证书

185
00:08:52,766 --> 00:08:55,369
这是官方证书

186
00:08:55,435 --> 00:08:57,504
可以使得这个证书执行检查

187
00:08:57,571 --> 00:09:01,508
使用OpenSSL查看
证书是否是真实的Apple证书

188
00:09:01,775 --> 00:09:04,845
如果绑定到程序中

189
00:09:04,912 --> 00:09:07,014
应该注意

190
00:09:07,080 --> 00:09:09,983
加入到捆绑程序中的
证书的有效日期

191
00:09:10,984 --> 00:09:12,753
这方面网上有很多的文档

192
00:09:12,819 --> 00:09:14,888
事实上 几年前我们有一个演讲

193
00:09:14,955 --> 00:09:18,058
实时演示如何使用OpenSSL

194
00:09:18,125 --> 00:09:19,660
并进行验证

195
00:09:19,726 --> 00:09:21,461
这个过程比较简单

196
00:09:21,528 --> 00:09:24,064
希望你们观看以前的

197
00:09:24,131 --> 00:09:26,400
收条验证演讲视频

198
00:09:28,035 --> 00:09:30,537
在现成解决方案方面
我相信你们已经

199
00:09:30,604 --> 00:09:34,074
尝试过集成程序内购买
而且曾经访问Get Hub

200
00:09:34,141 --> 00:09:37,811
以找到一个现成的解决方案
为你完成这些验证工作

201
00:09:38,612 --> 00:09:41,114
请记住 当你下载现成解决方案时

202
00:09:41,181 --> 00:09:42,783
虽然获得便利 但也会有所让步

203
00:09:43,851 --> 00:09:47,387
重复使用这样的代码
有可能产生错误和漏洞

204
00:09:47,454 --> 00:09:51,658
对于StoreKit等
交易处理API来说尤其如此

205
00:09:52,092 --> 00:09:54,061
你能想象全国的珠宝商

206
00:09:54,127 --> 00:09:55,996
都使用同一把钥匙打开其保险箱吗？

207
00:09:56,063 --> 00:09:59,032
只要这把锁有一个缺陷被发现

208
00:09:59,099 --> 00:10:00,667
全国的珠宝商的

209
00:10:00,734 --> 00:10:03,971
财产安全都会受到威胁

210
00:10:04,705 --> 00:10:06,306
对你们来说
很重要的一点是

211
00:10:06,373 --> 00:10:07,841
应该知道这样做的风险

212
00:10:07,908 --> 00:10:11,778
请记住 当你们使用StoreKit
进行这些集成时

213
00:10:11,845 --> 00:10:12,813
这关系到你的收入流

214
00:10:12,880 --> 00:10:15,816
开发现成解决方案的人

215
00:10:15,883 --> 00:10:18,986
并不像你自己一样
关心你的财产安全

216
00:10:22,656 --> 00:10:25,259
当你验证实际证书

217
00:10:25,325 --> 00:10:28,161
以签名收条时
有一些小技巧可供参考

218
00:10:28,529 --> 00:10:31,298
你不必实际检查
用于签名收条的

219
00:10:31,365 --> 00:10:32,966
证书的有效日期

220
00:10:34,535 --> 00:10:35,369
我的意思是

221
00:10:35,435 --> 00:10:38,372
如果收条是特定时间加密的

222
00:10:38,438 --> 00:10:39,506
比如说两年前

223
00:10:39,573 --> 00:10:42,643
然后有人使用当时有效的证书
签名这个收条

224
00:10:42,709 --> 00:10:45,078
那么证书应该在稍后不久过期

225
00:10:45,145 --> 00:10:47,414
证书已经过期

226
00:10:47,481 --> 00:10:50,217
并不会使收条失效

227
00:10:50,284 --> 00:10:51,351
在这里 重要的一点

228
00:10:51,418 --> 00:10:54,054
并不是证书是否仍然有效

229
00:10:54,121 --> 00:10:56,023
真正重要的是

230
00:10:56,089 --> 00:10:57,791
在生成收条时 证书是否有效

231
00:10:57,858 --> 00:11:01,361
应该将证书日期与

232
00:11:01,428 --> 00:11:03,063
收条内的购买日期比较

233
00:11:03,130 --> 00:11:05,199
确保在签名之时证书是有效的

234
00:11:07,134 --> 00:11:09,136
让我们来看收条的实际内容

235
00:11:09,203 --> 00:11:11,705
这是ASN.1编码内容

236
00:11:12,072 --> 00:11:14,341
它是一系列的类型和值

237
00:11:14,608 --> 00:11:15,442
很像词典

238
00:11:15,509 --> 00:11:18,545
可以把它视为词典
所含有的键值和值

239
00:11:18,745 --> 00:11:20,647
可以读取

240
00:11:20,714 --> 00:11:22,049
这些不同类型的值

241
00:11:22,583 --> 00:11:25,419
现在你已经检查
实际文件是否已经

242
00:11:25,485 --> 00:11:27,454
使用正确的Apple证书进行签名

243
00:11:27,988 --> 00:11:31,658
你需要确定进行签名的程序

244
00:11:31,725 --> 00:11:33,994
就是用户运行的程序
我们应该如何做呢？

245
00:11:34,962 --> 00:11:37,130
为了确定此收条用于此程序

246
00:11:37,197 --> 00:11:38,932
可以使用两种类型的属性

247
00:11:38,999 --> 00:11:40,200
即类型2和3

248
00:11:40,267 --> 00:11:43,070
它们含有此收条的适用程序的
捆绑包标识符

249
00:11:43,136 --> 00:11:45,739
和捆绑包版本

250
00:11:46,640 --> 00:11:49,710
你需要将这两个特定属性

251
00:11:49,776 --> 00:11:52,179
与程序内的硬编码值进行比较

252
00:11:52,479 --> 00:11:54,047
重要的一点是
这里应该使用硬编码值

253
00:11:54,114 --> 00:11:56,016
原因前面我们已经讲过

254
00:11:56,850 --> 00:11:59,753
这是一个info.plist文件
其它人很容易使用虚假值

255
00:11:59,820 --> 00:12:02,589
替换这个plist文件
以区配虚假收条

256
00:12:02,656 --> 00:12:06,760
相比之下 替换内容
以匹配硬编码值要困难得多

257
00:12:07,828 --> 00:12:10,030
将这两个类型
与硬编码值进行比较

258
00:12:10,097 --> 00:12:11,231
如果它们匹配 则一切正常

259
00:12:11,298 --> 00:12:14,301
现在你已经确认程序是正确的

260
00:12:14,902 --> 00:12:17,070
接下来的步骤是
检查用户使用的设备

261
00:12:17,137 --> 00:12:19,072
是否与文件匹配

262
00:12:19,373 --> 00:12:23,143
我们使用类型4和5
过程相似 但是这次

263
00:12:23,210 --> 00:12:25,379
需要检查是的第5个属性

264
00:12:26,046 --> 00:12:29,583
第5个属性实际上
是前三个值的SHA-1哈希值

265
00:12:29,650 --> 00:12:31,752
这是捆绑包ID和
设备ID的SHA-1值

266
00:12:31,818 --> 00:12:35,255
我们提供API读取设备ID

267
00:12:35,889 --> 00:12:37,257
第三个是非透明值

268
00:12:37,324 --> 00:12:40,194
它实际上是类型4中的属性

269
00:12:40,260 --> 00:12:41,762
我们这样做的原因是

270
00:12:41,828 --> 00:12:43,330
它使用加密技术

271
00:12:43,397 --> 00:12:46,800
允许SHA-1哈希值随时间变化

272
00:12:46,867 --> 00:12:49,436
即使捆绑包ID
和设备ID并不变化

273
00:12:49,570 --> 00:12:51,939
从而增加过程安全性

274
00:12:52,739 --> 00:12:56,577
因此 这个SHA-1值
对于程序和设备来说是唯一的

275
00:12:57,277 --> 00:12:59,880
你要做的是
使用你自己的硬编码值

276
00:12:59,947 --> 00:13:02,516
创建这个SHA-1值

277
00:13:02,583 --> 00:13:04,751
然后将它与类型5的值进行比较

278
00:13:04,818 --> 00:13:06,887
如果匹配 则一切正常

279
00:13:06,954 --> 00:13:09,156
这样你就确定
用户所使用的设备

280
00:13:09,223 --> 00:13:10,991
就是收条的目标设备

281
00:13:12,759 --> 00:13:14,661
现在你已经完成这三项检查

282
00:13:15,662 --> 00:13:17,898
这个过程就是
在设备上验证收条

283
00:13:17,965 --> 00:13:19,933
现在你知道这是一个可信文件

284
00:13:20,000 --> 00:13:22,202
可以从它读取更多信息

285
00:13:22,269 --> 00:13:23,971
让我们来看下面的步骤

286
00:13:24,371 --> 00:13:27,207
即更新和检查
收条内的程序内购买

287
00:13:27,274 --> 00:13:29,676
的状态和内容

288
00:13:31,044 --> 00:13:34,248
让我们回过来看
收条内的数据

289
00:13:34,982 --> 00:13:38,051
收条含有一个特定的类型
即类型17

290
00:13:38,118 --> 00:13:42,623
用户在设备上
进行的每次交易都有一个这样的类型

291
00:13:43,123 --> 00:13:48,929
在每个类型17中 实际数据是
另外一个ASN.1编码容器

292
00:13:50,030 --> 00:13:53,100
在这个容器内
一组类型和值

293
00:13:53,166 --> 00:13:56,069
与特定的交易相关联

294
00:13:56,136 --> 00:13:59,940
这样我们获得数量、
产品标识符和交易ID等数据

295
00:14:00,007 --> 00:14:01,642
你可以使用这些值

296
00:14:01,708 --> 00:14:05,179
来检查是否确实存在这样的交易

297
00:14:05,812 --> 00:14:08,148
我特别要指出的是类型1708

298
00:14:08,215 --> 00:14:11,618
如果你处理自动续约订阅
这个类型很重要

299
00:14:11,818 --> 00:14:14,788
它含有特定交易的

300
00:14:14,855 --> 00:14:16,190
结算截止日期

301
00:14:16,490 --> 00:14:18,759
稍后我们将会讨论订阅

302
00:14:19,560 --> 00:14:22,596
如果想要了解
所有不同的类型

303
00:14:22,663 --> 00:14:26,333
建议你们观看
“收条验证编程指南”演讲

304
00:14:26,400 --> 00:14:30,504
我们介绍了收条中
包含的所有不同类型

305
00:14:32,039 --> 00:14:34,208
现在你可以读出这些交易信息

306
00:14:34,908 --> 00:14:37,177
你可以使用这些信息
来核实它们是否与

307
00:14:37,544 --> 00:14:39,646
StoreKit告诉你的
用户购买内容一致

308
00:14:39,780 --> 00:14:41,715
你要做的是通过这个
updatedTransaction调用

309
00:14:41,782 --> 00:14:45,018
获取交易信息值

310
00:14:45,085 --> 00:14:48,422
将这些值与收条内的值进行比较

311
00:14:48,488 --> 00:14:50,224
你可以使用交易ID、

312
00:14:50,290 --> 00:14:53,994
购买日期 用户所购买产品
的产品标识

313
00:14:54,061 --> 00:14:56,830
如果你确认交易匹配

314
00:14:56,897 --> 00:14:59,900
将会获得一个文件
证明用户确实购买了所述产品

315
00:14:59,967 --> 00:15:01,468
而且已经进行支付

316
00:15:01,535 --> 00:15:04,505
你可以信任StoreKit
告知给你的交易

317
00:15:06,039 --> 00:15:08,909
当你处理订阅时
一些常见的问题是

318
00:15:08,976 --> 00:15:11,011
“我的用户是否具有有效的订阅？”

319
00:15:12,312 --> 00:15:15,115
这里需要注意的是
有效收条并不等同于

320
00:15:15,182 --> 00:15:17,518
获得订阅用户

321
00:15:17,651 --> 00:15:19,353
有时候这会让人感到困惑

322
00:15:19,419 --> 00:15:20,487
如果你可以验证收条

323
00:15:20,554 --> 00:15:22,789
这并不意味着用户已经进行支付

324
00:15:22,890 --> 00:15:24,291
每个应用都有收条

325
00:15:24,358 --> 00:15:27,427
它含有任何原始应用购买相关信息

326
00:15:27,494 --> 00:15:28,662
甚至免费应用也是如此

327
00:15:29,029 --> 00:15:31,098
收条内的数据
这些交易信息

328
00:15:31,164 --> 00:15:33,634
向你告诉用户的订阅状态

329
00:15:34,935 --> 00:15:36,904
我们如何找出订阅状态呢？

330
00:15:37,437 --> 00:15:39,139
你可以获取这些交易信息

331
00:15:39,206 --> 00:15:42,843
按照原始交易ID字段对它们分组

332
00:15:43,310 --> 00:15:45,879
交易ID字段含有

333
00:15:45,946 --> 00:15:48,615
用户的特定自动续约订阅的
首次交易ID

334
00:15:48,682 --> 00:15:51,685
可以将它视为订阅ID

335
00:15:51,752 --> 00:15:54,855
用于引用和分组这些交易

336
00:15:55,622 --> 00:15:57,391
你可以抓取这些交易信息

337
00:15:57,457 --> 00:16:00,360
并可以查看即将过期的交易

338
00:16:00,460 --> 00:16:03,830
这表示已经发生的最新交易

339
00:16:03,897 --> 00:16:05,933
如果找到截止日期

340
00:16:05,999 --> 00:16:08,435
表示用户的计费期还没有结束

341
00:16:08,502 --> 00:16:09,837
而且他们具有有效的订阅

342
00:16:10,137 --> 00:16:12,973
如果你找到过去的截止日期

343
00:16:13,040 --> 00:16:15,342
则表示从那时起没有发生任何交易

344
00:16:15,409 --> 00:16:17,644
用户的订阅已经过期

345
00:16:18,212 --> 00:16:21,114
如果你找到截止日期数据

346
00:16:21,181 --> 00:16:23,150
你可以发送接收刷新属性

347
00:16:24,084 --> 00:16:27,321
获取最新的收条副本
进行再次确认

348
00:16:27,387 --> 00:16:29,890
然后你可以

349
00:16:29,957 --> 00:16:32,926
重复收条验证步骤

350
00:16:32,993 --> 00:16:35,229
了解是否发生过任何新交易

351
00:16:36,330 --> 00:16:38,498
在设备上维护
订阅状态时

352
00:16:38,565 --> 00:16:40,334
需要注意一点

353
00:16:40,400 --> 00:16:44,071
前面我们讲过截止日期
和购买日期

354
00:16:44,137 --> 00:16:46,473
如果你在设备进行这些操作

355
00:16:46,540 --> 00:16:49,910
你仅需要将这些日期
与系统日期进行比较

356
00:16:49,977 --> 00:16:52,546
用户可能会回调系统时间

357
00:16:52,613 --> 00:16:55,315
让他们仍然处于有效订阅期

358
00:16:56,750 --> 00:16:58,151
并没有办法防止他们这样做

359
00:16:58,218 --> 00:17:00,921
如果你遇到这样的问题

360
00:17:00,988 --> 00:17:03,090
可能需要使用服务端解决方案

361
00:17:03,156 --> 00:17:05,925
可能需要在服务器上验证收条

362
00:17:05,992 --> 00:17:09,396
或者至少从服务器
获取时间和日期以进行检查

363
00:17:11,265 --> 00:17:12,833
如我前面所述

364
00:17:12,900 --> 00:17:14,001
当收条不存在或无效时

365
00:17:14,067 --> 00:17:16,435
或者你要搜索额外的交易

366
00:17:16,502 --> 00:17:18,839
可以发送刷新请求
获取最新的收条信息

367
00:17:19,039 --> 00:17:21,974
这需要发送网络请求
因为这会从App Store

368
00:17:22,041 --> 00:17:26,146
取回新收条
而且这需要用户签名

369
00:17:26,213 --> 00:17:27,347
因此你应该十分注意

370
00:17:27,414 --> 00:17:28,749
避免频繁地这样做

371
00:17:28,815 --> 00:17:31,552
应该避免持续性的验证和刷新

372
00:17:31,618 --> 00:17:33,554
如果你进行前面所述的操作

373
00:17:33,620 --> 00:17:36,690
即查找截止日期
应该确保如果未发现截止日期

374
00:17:36,757 --> 00:17:39,860
不会持续地提交收条刷新请求

375
00:17:39,927 --> 00:17:42,462
因为这会反复提示用户登录

376
00:17:42,529 --> 00:17:45,699
只应该发送一次请求

377
00:17:45,766 --> 00:17:47,501
代码看起来是这样的

378
00:17:47,801 --> 00:17:50,504
你创建一个
SKReceiptRefreshRequest对象

379
00:17:50,571 --> 00:17:52,339
为它设置委托

380
00:17:52,406 --> 00:17:53,707
然后使用start方法启动

381
00:17:55,442 --> 00:17:57,578
在mac iOS上
如果你开发Mac程序

382
00:17:57,811 --> 00:18:00,781
应该遵循同样的原则
你可以这样做

383
00:18:01,315 --> 00:18:03,750
这会发送网格请求

384
00:18:03,817 --> 00:18:05,786
并且要求用户登录

385
00:18:05,853 --> 00:18:07,487
但是在本例中
情况略有不同

386
00:18:07,554 --> 00:18:11,458
你要做的是
使用代码173退出程序

387
00:18:12,092 --> 00:18:14,661
看起来是这样的
这会退出你的程序

388
00:18:14,728 --> 00:18:16,129
在后台触发StoreKit

389
00:18:16,196 --> 00:18:17,931
并且下载新收条

390
00:18:17,998 --> 00:18:22,069
到Mac计算机上
提示用户登录并重新启动你的程序

391
00:18:23,670 --> 00:18:26,039
现在我们来看

392
00:18:26,106 --> 00:18:29,009
恢复交易与刷新收条的不同之处

393
00:18:29,076 --> 00:18:32,479
有时候这会让人感到困惑
这是两个不同的API

394
00:18:33,046 --> 00:18:36,250
关于恢复完整交易的API

395
00:18:36,316 --> 00:18:38,485
我们已在今天上午
“StoreKit新特性”演讲中讨论

396
00:18:38,552 --> 00:18:41,221
这一个SK支付队列API

397
00:18:41,889 --> 00:18:45,192
收条刷新请求是你创建的一个实例

398
00:18:45,259 --> 00:18:46,960
你使用start方法启动它

399
00:18:47,060 --> 00:18:48,829
它们的功能略有不同

400
00:18:48,896 --> 00:18:53,233
恢复完整交易
将会通过更新交易回调方法

401
00:18:53,300 --> 00:18:55,169
取回用户的所有已完成交易

402
00:18:55,235 --> 00:18:59,239
让你能够进行处理

403
00:18:59,840 --> 00:19:01,708
收条更新请求

404
00:19:01,775 --> 00:19:04,278
实际上是取回新收条文件

405
00:19:04,344 --> 00:19:08,515
此文件是加密二进制代码
让你能够检查其内容

406
00:19:09,483 --> 00:19:11,952
这两个操作返回的结果
也略有不同

407
00:19:12,019 --> 00:19:14,655
当你恢复完整交易时

408
00:19:14,721 --> 00:19:16,623
仅恢复非消费性产品

409
00:19:16,690 --> 00:19:18,659
和自动续约订阅产品

410
00:19:19,760 --> 00:19:23,230
收条刷新请求
不仅获取这两种产品

411
00:19:23,297 --> 00:19:26,900
而且包含收条中的
任何非续约订阅条目

412
00:19:27,267 --> 00:19:29,002
你会注意到

413
00:19:29,069 --> 00:19:31,371
这两种类型的请求
都不取回消费性产品交易

414
00:19:31,438 --> 00:19:34,174
如果你处理消费性产品购买

415
00:19:34,241 --> 00:19:36,910
它们只会出现
更新交易之中

416
00:19:36,977 --> 00:19:39,246
和购买时的收条之中

417
00:19:39,313 --> 00:19:42,783
因此 你可以检查消费性产品

418
00:19:42,850 --> 00:19:45,319
但是这两种调用不会取回它

419
00:19:46,153 --> 00:19:48,422
关于收条处理的另一个技巧是

420
00:19:48,488 --> 00:19:49,957
如果你想要切换到订阅产品

421
00:19:50,023 --> 00:19:51,225
你可能有一个付费应用

422
00:19:51,291 --> 00:19:53,760
想要把它切换到订阅模式

423
00:19:53,827 --> 00:19:57,865
可以在程序收条中
找到这个类型19值

424
00:19:58,599 --> 00:20:00,534
它包含原始程序版本

425
00:20:00,601 --> 00:20:04,171
可以使用
这个用户下载的程序版本

426
00:20:04,238 --> 00:20:06,773
以了解你是否应该需要

427
00:20:06,840 --> 00:20:09,877
在付费程序或订阅模式
的基础上提供内容

428
00:20:09,943 --> 00:20:12,279
我们知道
对于付费程序来说

429
00:20:12,346 --> 00:20:15,115
如果突然终止付费使用的功能
将会极大地影响用户体验

430
00:20:15,182 --> 00:20:16,216
对于订阅模式

431
00:20:16,283 --> 00:20:20,521
可以使用类型19
来提供相关信息

432
00:20:21,555 --> 00:20:23,891
这个步骤是在设备上检查交易

433
00:20:23,957 --> 00:20:26,827
和确认订阅状态

434
00:20:27,094 --> 00:20:28,996
在这个步骤之后
你就可以完结交易

435
00:20:29,062 --> 00:20:31,431
你向用户提供内容

436
00:20:31,498 --> 00:20:33,433
更新订阅

437
00:20:33,500 --> 00:20:35,569
当完结交易时

438
00:20:36,537 --> 00:20:38,338
你应该记住
需要完结这个流程中的

439
00:20:38,405 --> 00:20:39,706
所有交易

440
00:20:39,773 --> 00:20:42,576
但是仅应该
在向用户提供内容之后这样做

441
00:20:43,544 --> 00:20:46,380
也许你正在下载
与程序内购买相关的内容

442
00:20:46,446 --> 00:20:48,515
应该确保下载完成之后

443
00:20:48,582 --> 00:20:50,751
再完结交易

444
00:20:51,485 --> 00:20:54,555
对于所有自动续约订阅交易来说
也是如此

445
00:20:54,621 --> 00:20:55,889
对于在每个结算周期结束时

446
00:20:55,956 --> 00:20:57,658
发生的可续约交易

447
00:20:57,724 --> 00:21:00,727
你仍然需要完结所有这些交易
并处理它们

448
00:21:00,994 --> 00:21:03,997
如果你不这样做
支付操作实际上停留在支付队列中

449
00:21:04,064 --> 00:21:06,466
将会重复出现在更新交易回调之中

450
00:21:06,533 --> 00:21:09,336
直到你处理它并完结交易

451
00:21:10,370 --> 00:21:13,006
关于订阅结算重试
我们有一个特定的逻辑

452
00:21:13,073 --> 00:21:15,542
如果你不使用自动续约订阅

453
00:21:15,609 --> 00:21:17,845
很重要的一点是
你必须完结这些交易

454
00:21:17,911 --> 00:21:20,047
这样 如果出现任何类型的结算错误

455
00:21:20,113 --> 00:21:22,282
我们的订阅结算重试逻辑

456
00:21:22,349 --> 00:21:24,351
可以继续尝试
并且向用户的信用卡收费

457
00:21:24,551 --> 00:21:26,053
这一点很重要

458
00:21:26,119 --> 00:21:28,455
它让我们能够知道
所有交易的状态

459
00:21:29,056 --> 00:21:31,758
API是这样的
只有一行代码

460
00:21:31,825 --> 00:21:34,161
在流程开始时
在SKPaymentQueue默认队列上

461
00:21:34,228 --> 00:21:37,564
可以将我们收到的交易对象

462
00:21:37,631 --> 00:21:40,000
传递给交易完结处理方法

463
00:21:43,203 --> 00:21:45,973
关于用户设备上的收条验证

464
00:21:46,039 --> 00:21:48,275
和内容更新流程就是这些

465
00:21:48,342 --> 00:21:50,277
让我们来看
在服务端环境中

466
00:21:50,344 --> 00:21:51,778
这是如何工作的

467
00:21:52,145 --> 00:21:54,681
为此 让我们来看一个例子

468
00:21:56,250 --> 00:22:01,255
假设有一个用户在使用你的程序

469
00:22:01,321 --> 00:22:03,790
而且你有一台服务器
在后台提供支持

470
00:22:03,857 --> 00:22:06,393
流程开始时
在更新交易回调中

471
00:22:06,460 --> 00:22:09,396
接收交易

472
00:22:09,463 --> 00:22:11,999
然后 你使用前面所述的API

473
00:22:12,065 --> 00:22:13,700
读取二进制收条数据

474
00:22:13,800 --> 00:22:16,170
此时数据仍然经过编码
我们还没有使用证书或其它内容

475
00:22:16,236 --> 00:22:17,771
进行检查

476
00:22:17,838 --> 00:22:19,273
与设备上的操作不同的是

477
00:22:19,339 --> 00:22:23,644
我们要做的是获取二进制编码收条数据
将它发送到你的服务器

478
00:22:24,945 --> 00:22:28,282
然后 你可以
使用这个检查收条URL

479
00:22:28,348 --> 00:22:30,817
建立与服务器之间的连接

480
00:22:31,185 --> 00:22:33,287
将二进制数据传输到
App Store

481
00:22:33,353 --> 00:22:36,590
现在App Store完成后续工作
包括检查证书

482
00:22:36,657 --> 00:22:38,258
和验证所有相关信息

483
00:22:38,325 --> 00:22:40,827
并且返回收条有效性状态

484
00:22:40,894 --> 00:22:43,897
说明它是否是可信的文件

485
00:22:45,632 --> 00:22:47,701
这些处理工作使用文本格式

486
00:22:47,768 --> 00:22:49,136
回应信息位于JSON之中

487
00:22:49,503 --> 00:22:53,040
它返回一个状态
说明收条是否有效

488
00:22:53,106 --> 00:22:55,342
但是这里需要指出的是
前面我说过

489
00:22:55,542 --> 00:22:58,579
不应该直接在用户设备上
使用这项技术

490
00:22:58,645 --> 00:23:00,047
只有在你的服务器
与App Store之间的通道上

491
00:23:00,113 --> 00:23:01,748
进行这些处理才是安全的

492
00:23:04,685 --> 00:23:07,221
应该在你的服务器上验证收条

493
00:23:07,287 --> 00:23:09,823
这比用户设备上的操作简单一些

494
00:23:10,490 --> 00:23:12,559
让我们来看
在这种情况下

495
00:23:12,626 --> 00:23:15,662
你如何解锁内容
并检查交易

496
00:23:18,065 --> 00:23:19,032
让我们来再看这个例子

497
00:23:19,099 --> 00:23:22,202
假设你已经
发送二进制数据到你的服务器

498
00:23:22,469 --> 00:23:24,972
已经建立与App Store之间
的连接

499
00:23:25,038 --> 00:23:26,940
发送二进制数据到App Store

500
00:23:27,641 --> 00:23:29,776
不仅App Store

501
00:23:29,843 --> 00:23:31,945
返回收条的有效性状态

502
00:23:32,346 --> 00:23:35,282
而且这个回应信息
还包含

503
00:23:35,349 --> 00:23:38,252
最新程序收条的编码版本

504
00:23:38,418 --> 00:23:41,321
这是JSON中的解码版本
你可以查看

505
00:23:41,388 --> 00:23:42,756
所有交易信息

506
00:23:42,823 --> 00:23:45,492
与用户设备上的解密信息相同

507
00:23:45,559 --> 00:23:48,462
只是这次它们位于

508
00:23:48,529 --> 00:23:50,864
App Store发送的JSON数据负载之中
你可以检查所有交易

509
00:23:50,931 --> 00:23:53,800
决定是否解锁内容

510
00:23:53,867 --> 00:23:57,037
然后在用户设备上完结交易

511
00:23:57,337 --> 00:23:59,406
这特别有用
因为你们可以

512
00:23:59,473 --> 00:24:01,241
在服务器关联的其它平台上

513
00:24:01,308 --> 00:24:03,610
更新状态

514
00:24:04,678 --> 00:24:07,281
流程就是这样的
只是这次使用文本格式

515
00:24:07,347 --> 00:24:09,583
但是这里重要的一点是
如果使用此技术

516
00:24:09,650 --> 00:24:11,952
应该告诉设备

517
00:24:12,019 --> 00:24:13,487
仍然需要完结交易

518
00:24:18,325 --> 00:24:21,762
我们再次回答
解锁订阅功能的问题

519
00:24:21,828 --> 00:24:24,097
我的用户是否有
一个活跃的订阅？

520
00:24:24,831 --> 00:24:27,768
这实际上是相同的流程
因为我们说过

521
00:24:27,835 --> 00:24:29,002
此收条包含所有相同的信息

522
00:24:29,069 --> 00:24:32,072
你可以按照原始交易ID
分组收条中的交易

523
00:24:32,139 --> 00:24:35,843
就是这个订阅ID字段

524
00:24:36,009 --> 00:24:37,578
你需要找到

525
00:24:37,644 --> 00:24:39,379
具有最近截止日期的交易

526
00:24:39,446 --> 00:24:41,114
如果截止日期是未来日期

527
00:24:41,181 --> 00:24:44,618
表示用户仍然存于有效订阅状态

528
00:24:45,185 --> 00:24:46,520
如果截止日期不是未来日期

529
00:24:46,587 --> 00:24:47,754
而是位于过去

530
00:24:47,821 --> 00:24:50,791
则意味着订阅已经过期

531
00:24:51,091 --> 00:24:52,526
这是收条的最新副本

532
00:24:52,593 --> 00:24:55,395
因此你不能在服务器上

533
00:24:55,462 --> 00:24:58,131
进行收条刷新请求
你已经获得最新的副本

534
00:24:59,433 --> 00:25:03,136
现在 我们已经在这些信息基础上
解锁内容

535
00:25:03,203 --> 00:25:05,806
前面我说过
仍然应该记得

536
00:25:05,873 --> 00:25:07,241
在用户设备上完结交易

537
00:25:07,474 --> 00:25:09,676
在本演讲中
你将会经常听到我说完结交易

538
00:25:09,743 --> 00:25:12,412
这是一个很重要的知识点

539
00:25:13,981 --> 00:25:16,683
现在让我们来详细讨论订阅

540
00:25:16,750 --> 00:25:19,853
这些方案已经应用
在所有程序内购买类型之中

541
00:25:20,087 --> 00:25:22,689
接下来我们讨论维护订阅状态

542
00:25:22,756 --> 00:25:25,292
尤其是使用服务侧流程

543
00:25:27,094 --> 00:25:28,996
在本例中

544
00:25:29,630 --> 00:25:33,433
更新被发送到用户设备的交易调用

545
00:25:33,500 --> 00:25:35,736
用户可以读取二进制收条数据

546
00:25:35,802 --> 00:25:37,337
到用户设备的内存之中

547
00:25:37,404 --> 00:25:40,307
它们发送信息到你的服务器

548
00:25:41,175 --> 00:25:43,410
这次 我们准备使用稍微不同的技术

549
00:25:43,477 --> 00:25:45,846
这是一个现实世界例子

550
00:25:45,913 --> 00:25:49,116
我们将会在你的服务器上
复制二进制收条数据

551
00:25:49,183 --> 00:25:52,686
同时发送数据副本

552
00:25:52,753 --> 00:25:55,489
到App Store
以实现我们刚才看到的数据

553
00:25:55,556 --> 00:25:57,991
将会返回最近的收条副本

554
00:25:58,058 --> 00:26:00,994
我们可以使用同样的技术
在不同设备上

555
00:26:01,061 --> 00:26:02,829
完结交易和更新内容

556
00:26:03,163 --> 00:26:07,634
在本例中 我们处理
一个自动续约订阅

557
00:26:07,701 --> 00:26:10,103
假设用户离线一段时间

558
00:26:10,170 --> 00:26:14,107
停止使用你的应用几天

559
00:26:14,174 --> 00:26:15,475
可能会发生这样的情况

560
00:26:15,542 --> 00:26:18,011
如果发生这样的情况

561
00:26:18,078 --> 00:26:21,048
而且用户正好在此期间
在后台续约他们的订阅

562
00:26:21,114 --> 00:26:22,549
信用卡被扣费

563
00:26:22,816 --> 00:26:25,018
因此在某个地方发生新交易

564
00:26:25,752 --> 00:26:26,620
但是你并不知情

565
00:26:26,687 --> 00:26:28,989
然后用户重新连接到你的网站

566
00:26:30,257 --> 00:26:32,659
服务器并没有收到

567
00:26:32,726 --> 00:26:35,562
在后台发生的交易的任何信息

568
00:26:36,029 --> 00:26:37,497
为了从服务的角度

569
00:26:37,564 --> 00:26:39,199
获得这些信息

570
00:26:39,833 --> 00:26:42,402
我们在服务器上
保留二进制收条数据

571
00:26:42,469 --> 00:26:44,638
可以将数据视为令牌

572
00:26:44,705 --> 00:26:46,940
可以通过相同的请求

573
00:26:47,007 --> 00:26:48,075
将它发送回App Store

574
00:26:49,743 --> 00:26:51,979
前面我说过它不仅包含

575
00:26:52,045 --> 00:26:53,013
编码收条数据

576
00:26:53,080 --> 00:26:56,216
而且实际上是
应用收条的最近副本

577
00:26:56,283 --> 00:26:59,186
因此 这个最近副本将包含后台发生的

578
00:26:59,253 --> 00:27:00,988
任何新交易

579
00:27:01,054 --> 00:27:03,757
你可以发现已经发生的交易

580
00:27:03,824 --> 00:27:06,927
而且相应地
让用户再次访问你的网站

581
00:27:07,761 --> 00:27:10,631
然后 你可能想要
在多个设备上解锁内容

582
00:27:11,064 --> 00:27:13,166
但你必须记住
当用户重新使用他们的设备

583
00:27:13,233 --> 00:27:15,802
重新上线时

584
00:27:16,170 --> 00:27:19,840
将会通过更新交易调用
接受交易

585
00:27:20,140 --> 00:27:21,475
对此你仍然需要进行处理

586
00:27:21,542 --> 00:27:23,310
而且应该完结交易

587
00:27:23,377 --> 00:27:26,113
我们建议应该将这作为一个机会

588
00:27:26,180 --> 00:27:29,383
在你的服务器上
更新二进制收条数据

589
00:27:29,850 --> 00:27:32,219
你可能想要

590
00:27:32,286 --> 00:27:33,687
为你程序关联用户的账户

591
00:27:34,054 --> 00:27:35,722
应该记住

592
00:27:35,789 --> 00:27:36,790
重新在设备上完结交易

593
00:27:36,857 --> 00:27:39,126
因此 即使你的服务器
已经知道这个交易

594
00:27:39,193 --> 00:27:40,928
也应该完成这个流程

595
00:27:40,994 --> 00:27:43,630
并且按照前面所说的方法
完结交易

596
00:27:44,264 --> 00:27:46,200
对于这项技术
我们在这里所做的事情是

597
00:27:46,266 --> 00:27:48,769
将收条数据视为令牌

598
00:27:48,836 --> 00:27:50,871
把它存储在你的服务器上

599
00:27:50,938 --> 00:27:52,773
用它来执行多个请求

600
00:27:53,173 --> 00:27:56,210
这些二进制数据
可以反复使用

601
00:27:57,411 --> 00:27:59,580
可以用于在不同设备和平台上

602
00:27:59,646 --> 00:28:01,481
传播订阅状态

603
00:28:01,548 --> 00:28:04,351
但是仍然要记住
你必须处理

604
00:28:04,418 --> 00:28:06,019
所有更新交易调用

605
00:28:06,086 --> 00:28:07,821
这意味着

606
00:28:07,888 --> 00:28:10,257
对于每个结算期的所有续约交易

607
00:28:10,324 --> 00:28:12,526
必须完结这些交易

608
00:28:15,462 --> 00:28:17,464
现在你可以想象

609
00:28:17,531 --> 00:28:19,166
如果你要处理
一个自动续约订阅

610
00:28:19,233 --> 00:28:21,935
尤其是 如果它具有较短的结算期

611
00:28:22,002 --> 00:28:24,404
这个交易收条可能变得很大

612
00:28:24,471 --> 00:28:27,875
所有订阅交易都会出现在收条上

613
00:28:28,408 --> 00:28:30,811
随着时间的推移
这个文件可能变得很大

614
00:28:31,211 --> 00:28:33,180
我们听说 你们很多人

615
00:28:33,247 --> 00:28:35,315
只关心最近的交易

616
00:28:35,382 --> 00:28:37,718
前面我一直在说
检查最近的截止日期

617
00:28:37,784 --> 00:28:40,153
你们很多人仅关心最近的交易

618
00:28:40,220 --> 00:28:44,091
因此我们增强这个端点
加入一个新查询参数

619
00:28:44,157 --> 00:28:48,462
这个参数是
exclude-old-transactions

620
00:28:48,762 --> 00:28:50,197
如果将它设置为真

621
00:28:51,498 --> 00:28:53,834
验证收条端点将返回

622
00:28:53,901 --> 00:28:56,503
每个订阅的最近交易

623
00:28:56,570 --> 00:28:59,306
从而极大地减少

624
00:28:59,373 --> 00:29:01,975
从验证收条端点
返回的数据负载量

625
00:29:02,042 --> 00:29:04,912
不仅节省网络流量

626
00:29:04,978 --> 00:29:07,814
而且节省服务器处理时间

627
00:29:07,881 --> 00:29:09,883
因此不需要处理大量的交易数据

628
00:29:09,950 --> 00:29:12,586
看上去数据量并不多
但是 如果处理数以千计

629
00:29:12,653 --> 00:29:14,955
甚至百万计的用户请求

630
00:29:15,022 --> 00:29:16,590
将可以节省大量的时间

631
00:29:16,657 --> 00:29:18,559
对于处理这些应用的开发者来说

632
00:29:18,625 --> 00:29:20,427
这是极大的改进

633
00:29:22,296 --> 00:29:24,264
状态轮询技术…

634
00:29:26,900 --> 00:29:27,734
谢谢

635
00:29:29,536 --> 00:29:33,040
此技术十分适合于
用作服务器端工具

636
00:29:33,106 --> 00:29:35,876
我们来看这张图

637
00:29:36,376 --> 00:29:39,279
你会注意到
这个更新和完结交易流程

638
00:29:39,346 --> 00:29:41,415
因为仍然很重要的一点是

639
00:29:41,481 --> 00:29:45,352
你需要在用户设备上
处理发生的所有交易

640
00:29:48,021 --> 00:29:51,191
我们来看订阅

641
00:29:57,364 --> 00:30:01,401
我们打开自动续约订阅

642
00:30:01,468 --> 00:30:03,971
你们很多人都采用并且实现这个技术

643
00:30:04,037 --> 00:30:05,339
我们听到一些反馈意见

644
00:30:05,606 --> 00:30:09,343
我们尝试通过
iTunes Connect报告

645
00:30:09,409 --> 00:30:12,079
提供用户信息
和用户行为方面的信息

646
00:30:12,145 --> 00:30:14,381
你可以发现
获取了多少截止日期

647
00:30:14,448 --> 00:30:17,184
但是你们有很多问题

648
00:30:17,251 --> 00:30:19,553
直到现在才能够得到解答

649
00:30:20,020 --> 00:30:22,489
特别是关于用户的问题
那么有哪些问题呢？

650
00:30:22,556 --> 00:30:25,459
比如 为何发生特定用户的订阅过期？

651
00:30:25,526 --> 00:30:28,262
将会在计费期结束时

652
00:30:28,328 --> 00:30:29,997
续约用户的订阅吗？

653
00:30:31,098 --> 00:30:33,700
在计费期末会降级用户吗？

654
00:30:33,767 --> 00:30:35,068
用户是否选择

655
00:30:35,135 --> 00:30:37,538
他们已有的订阅？

656
00:30:38,405 --> 00:30:40,274
他们是否已经请求
通过AppleCare退款？

657
00:30:40,340 --> 00:30:41,441
其中的原因是什么？

658
00:30:41,508 --> 00:30:44,745
他们是否遇到问题
或者确实想要这样做？

659
00:30:45,279 --> 00:30:47,748
他们是否同意我的涨价？

660
00:30:48,148 --> 00:30:50,817
他们会在计费期结束时终止订阅吗？

661
00:30:50,884 --> 00:30:52,419
我如何提前知道这些信息？

662
00:30:52,486 --> 00:30:54,288
或者更简单地

663
00:30:54,354 --> 00:30:56,623
我需要向用户告知
哪些订阅相关信息？

664
00:30:56,690 --> 00:30:58,559
如何有效地

665
00:30:58,625 --> 00:31:01,495
向他们告知这些信息

666
00:31:01,562 --> 00:31:03,730
为什么所有这些问题都很重要呢？

667
00:31:04,965 --> 00:31:07,501
很明显 这是为了保证良好的用户体验

668
00:31:07,568 --> 00:31:10,604
这些问题之所以重要 是因为

669
00:31:12,639 --> 00:31:15,409
它们关系到

670
00:31:15,475 --> 00:31:18,645
用户是否会续约他们的订阅

671
00:31:18,712 --> 00:31:22,249
因此应该保证良好的用户体验

672
00:31:22,316 --> 00:31:26,186
必须尽量减少订阅障碍

673
00:31:26,486 --> 00:31:29,256
订阅障碍会导致订阅者减少

674
00:31:29,356 --> 00:31:31,491
当你失去订阅者时

675
00:31:31,558 --> 00:31:33,594
就会失去收入

676
00:31:33,694 --> 00:31:35,596
不仅会造成收入损失

677
00:31:35,662 --> 00:31:38,832
而且造成用户招揽成本损失

678
00:31:39,967 --> 00:31:43,303
我们可以从两个方面
来思考访问障碍

679
00:31:43,370 --> 00:31:45,739
首先是非自主性障碍

680
00:31:45,806 --> 00:31:48,809
也就是说 用户并没有自主地退订

681
00:31:48,876 --> 00:31:52,379
比如信用卡过期
这是一种非自主性行为

682
00:31:52,813 --> 00:31:53,814
现在…

683
00:31:54,281 --> 00:31:56,783
很多用户都属于这一种情况

684
00:31:57,651 --> 00:31:59,319
然后是自主性订阅障碍

685
00:31:59,386 --> 00:32:02,723
在这种情况下
用户选择在你的程序中退订

686
00:32:02,923 --> 00:32:04,925
也许他们请求
从AppleCare获得退款

687
00:32:04,992 --> 00:32:07,661
或者在设置中关闭续约

688
00:32:08,829 --> 00:32:11,265
我们想要为你们提供新工具

689
00:32:11,331 --> 00:32:12,332
以处理这两种障碍

690
00:32:12,399 --> 00:32:14,434
我们想到了一些很好的方法

691
00:32:14,501 --> 00:32:18,138
我们推出一些新工具
帮助减少订阅障碍

692
00:32:18,338 --> 00:32:19,173
让我们来看这些工具

693
00:32:19,239 --> 00:32:21,642
让我们来再看一个例子

694
00:32:22,509 --> 00:32:25,479
假设一个用户订阅你的服务

695
00:32:25,546 --> 00:32:27,748
这是一个视频订阅服务

696
00:32:28,515 --> 00:32:31,018
你使用状态轮询技术

697
00:32:31,084 --> 00:32:34,821
轮询App Store

698
00:32:34,888 --> 00:32:37,090
活跃用户

699
00:32:37,157 --> 00:32:38,192
的最新订阅状态

700
00:32:38,725 --> 00:32:40,961
然后用户离线几天

701
00:32:41,962 --> 00:32:44,898
在这段时间内
将续约他们的订阅

702
00:32:44,965 --> 00:32:46,300
这类似于前面的例子

703
00:32:46,366 --> 00:32:49,536
但是 这次我们假设
用户的信用卡过期

704
00:32:49,603 --> 00:32:51,738
App Store未能扣费

705
00:32:51,972 --> 00:32:55,309
因此发生结算错误
然后用户重新上线

706
00:32:55,375 --> 00:32:59,546
进入你的网站
想要继续观看视频

707
00:32:59,613 --> 00:33:01,815
这时 你的服务器

708
00:33:01,882 --> 00:33:02,950
使用前面讲过的状态轮询技术

709
00:33:03,517 --> 00:33:06,753
App Store将会告知
未发生交易

710
00:33:06,820 --> 00:33:08,755
因为发生了结算错误

711
00:33:08,822 --> 00:33:10,657
这时服务器

712
00:33:10,724 --> 00:33:14,061
将通知网站
订阅已经过期

713
00:33:14,127 --> 00:33:16,063
但这位可怜的用户
并没有做错什么事情

714
00:33:16,129 --> 00:33:17,698
他的信用卡过期了

715
00:33:17,764 --> 00:33:20,234
因此他更换信用卡

716
00:33:20,300 --> 00:33:21,969
在App Store上

717
00:33:22,035 --> 00:33:23,103
更新他的信用卡信息

718
00:33:23,203 --> 00:33:25,172
App Store
使用新的信用卡信息

719
00:33:25,239 --> 00:33:27,608
成功进行扣费

720
00:33:27,841 --> 00:33:30,043
然后用户重新回到你的网站

721
00:33:30,110 --> 00:33:32,679
想要观看视频

722
00:33:33,113 --> 00:33:34,014
但是情况不妙

723
00:33:34,948 --> 00:33:37,618
这时你的服务器并不知道

724
00:33:37,684 --> 00:33:39,953
已经发生交易

725
00:33:40,020 --> 00:33:42,256
不知道信用卡已经扣费

726
00:33:42,322 --> 00:33:44,958
如果你是用户

727
00:33:45,025 --> 00:33:47,561
你想尽办法更新
你的信用卡信息

728
00:33:47,628 --> 00:33:50,397
看到钱被划走

729
00:33:50,464 --> 00:33:52,165
但是你的订阅状态

730
00:33:52,232 --> 00:33:53,567
并没有更新

731
00:33:53,967 --> 00:33:57,271
你很可能会退订
并且直接请求退款

732
00:33:57,337 --> 00:33:59,339
这种情况经常发生

733
00:33:59,406 --> 00:34:01,508
为了解决这个问题
我们在App Store中

734
00:34:01,575 --> 00:34:04,645
引入新的服务器-服务器通知

735
00:34:10,150 --> 00:34:12,886
让我们来看解决方案

736
00:34:13,320 --> 00:34:15,489
用户收到信息

737
00:34:15,556 --> 00:34:16,723
提示发生结算错误

738
00:34:17,024 --> 00:34:19,458
于是他们更新信用卡信息

739
00:34:19,525 --> 00:34:21,495
这次 利用新通知

740
00:34:21,562 --> 00:34:24,364
在App Store
对信用卡扣费之后

741
00:34:24,431 --> 00:34:26,766
立即通知你的服务器

742
00:34:26,833 --> 00:34:28,768
告知发生了新交易

743
00:34:28,835 --> 00:34:30,603
你可以使用这个交易数据

744
00:34:30,670 --> 00:34:32,505
立即解锁用户

745
00:34:32,572 --> 00:34:36,443
让用户能够访问网站
从而确保良好的用户体验

746
00:34:36,510 --> 00:34:39,012
对于在服务器上
处理订阅的开发者来说

747
00:34:39,079 --> 00:34:40,947
这非常方便实用

748
00:34:41,181 --> 00:34:42,315
让我们来看

749
00:34:42,382 --> 00:34:45,686
你已获得
iTunes Connect中的状态URL

750
00:34:45,752 --> 00:34:47,788
你可以为服务器输入一个URL

751
00:34:48,554 --> 00:34:49,590
你的服务器不必

752
00:34:49,656 --> 00:34:52,125
遵守应用传输安全要求

753
00:34:52,860 --> 00:34:55,629
如果需要遵守安全要求

754
00:34:55,963 --> 00:34:58,966
可发送http端口到你的服务器
用于获取访问状态变更信息

755
00:34:59,032 --> 00:35:01,034
我们发送的这些URL和端口
用于哪些事件？

756
00:35:01,134 --> 00:35:04,238
它们用于任何初次订阅购买

757
00:35:05,772 --> 00:35:07,941
如果AppleCare取消订阅

758
00:35:08,008 --> 00:35:10,644
如果用户获得退款
你将会收到通知

759
00:35:11,245 --> 00:35:13,013
对于任何订阅降级
也会执行这样的流程

760
00:35:13,080 --> 00:35:15,282
因此任何时候
用户选择降级他们的订阅时

761
00:35:15,349 --> 00:35:18,252
相应地你可以在服务器上
发现这一情况

762
00:35:18,318 --> 00:35:19,686
并更新订阅状态

763
00:35:20,487 --> 00:35:23,690
我们继续使用刚才的例子
当成功续约

764
00:35:23,757 --> 00:35:25,726
或重新购买已到期的订阅时

765
00:35:25,792 --> 00:35:27,661
可以立即解锁用户

766
00:35:27,728 --> 00:35:29,630
让他们能够访问订阅内容

767
00:35:30,964 --> 00:35:33,834
通知负载数据

768
00:35:33,901 --> 00:35:36,603
包括实际交易的

769
00:35:36,670 --> 00:35:38,372
最近交易数据

770
00:35:39,206 --> 00:35:40,407
因此 当你这样做时

771
00:35:40,474 --> 00:35:44,077
不需要像以前那样
频繁地轮询验证收条

772
00:35:44,745 --> 00:35:47,381
你可能仍然需要
使用轮询调用验证收条

773
00:35:47,447 --> 00:35:50,050
但是做法需要更聪明一些

774
00:35:50,384 --> 00:35:53,453
也许App Store通知
未能到达你的服务器

775
00:35:53,687 --> 00:35:56,823
你可能仍然需要
利用此通知来获取

776
00:35:56,890 --> 00:35:58,458
订阅状态信息

777
00:35:58,525 --> 00:36:00,494
但是你可以做得更聪明一些

778
00:36:00,561 --> 00:36:04,231
也许你可以在用户
订阅到期前一天或当天查询

779
00:36:04,298 --> 00:36:06,767
而不是每五钟查询一次

780
00:36:07,534 --> 00:36:09,336
这些功能将会于今年晚些时候发布

781
00:36:09,403 --> 00:36:11,205
我们认为这将会极大地

782
00:36:11,271 --> 00:36:14,308
减少用户可能遇到的订阅障碍

783
00:36:17,778 --> 00:36:20,714
让我们再来看刚才提到的问题

784
00:36:21,515 --> 00:36:23,183
新通知功能

785
00:36:23,250 --> 00:36:24,952
将使用我们刚才介绍的技术

786
00:36:25,018 --> 00:36:26,353
极大地减少订阅障碍

787
00:36:26,420 --> 00:36:30,023
但是我们还有很多信息
提供给开发者

788
00:36:31,525 --> 00:36:34,228
尤其是有效期结束前的
用户相关信息

789
00:36:34,294 --> 00:36:37,564
为了让你们能够访问这些信息

790
00:36:37,631 --> 00:36:41,268
今天我们宣布
在验证收条端点中加入一些新字段

791
00:36:41,535 --> 00:36:42,669
这些字段

792
00:36:42,736 --> 00:36:44,371
将为你提供

793
00:36:44,438 --> 00:36:47,407
用户信息和关键性
订阅事件信息

794
00:36:47,474 --> 00:36:49,776
因此如果用户
在设置中关闭自动续订

795
00:36:49,843 --> 00:36:53,413
你将会提前知道
用户将在本付费期结束后

796
00:36:53,480 --> 00:36:54,414
停止订阅

797
00:36:54,481 --> 00:36:57,784
也可以知道
用户取消订阅或接收退款

798
00:36:58,118 --> 00:36:59,987
而不继续订阅

799
00:37:00,053 --> 00:37:02,089
因此你可以提前
采取应对措施

800
00:37:02,155 --> 00:37:05,058
并且根据这些信息
做出重要的业务决策

801
00:37:05,158 --> 00:37:07,094
让我们来看加入的新字段

802
00:37:08,262 --> 00:37:11,098
这是相同的请求
验证收条端点

803
00:37:11,398 --> 00:37:13,333
现在我们加入一个自动续约状态

804
00:37:13,767 --> 00:37:17,271
当用户选择关闭自动订阅续约时

805
00:37:17,337 --> 00:37:18,939
你可以在他们的订阅

806
00:37:19,006 --> 00:37:21,508
到期之前知道这一信息

807
00:37:22,242 --> 00:37:24,178
我们还加入一个自动续约设置

808
00:37:24,344 --> 00:37:27,347
如果用户选择降级
或更改他们的订阅设置

809
00:37:27,414 --> 00:37:29,316
你可以知道他们的操作

810
00:37:29,383 --> 00:37:32,419
并且了解特定付费期结束时的情况

811
00:37:32,819 --> 00:37:34,454
我们还加入价格同意状态

812
00:37:34,521 --> 00:37:37,324
如果你想对特定用户群
提高价格

813
00:37:37,391 --> 00:37:39,660
你可以这样做
让我们来看一个例子

814
00:37:39,726 --> 00:37:42,663
也许80%的用户不同意提价

815
00:37:42,729 --> 00:37:44,131
他们可能会

816
00:37:44,198 --> 00:37:45,399
在付费期结束时退订

817
00:37:45,465 --> 00:37:46,567
在以前 你并不知道

818
00:37:46,633 --> 00:37:48,035
多少用户将会退订

819
00:37:48,101 --> 00:37:50,637
现在你可以根据这些信息
进行重要的业务决策

820
00:37:50,737 --> 00:37:53,040
也许你会决定不提价

821
00:37:53,106 --> 00:37:55,475
因为你可能会流失过多的订阅者

822
00:37:57,211 --> 00:37:59,713
我们还增加一个订阅结算重试标记

823
00:38:00,013 --> 00:38:03,083
当用户由于结算错误
而需要重新结算时

824
00:38:03,150 --> 00:38:06,420
比如前面讲过的信用卡问题

825
00:38:06,486 --> 00:38:09,823
你可以看到用户将会具有此标记

826
00:38:09,890 --> 00:38:13,293
稍后我们将会演示
如何使用这些字段

827
00:38:14,461 --> 00:38:17,598
另外还有终止原因
为什么用户终止订阅

828
00:38:17,664 --> 00:38:19,867
是因为结算错误还是其它原因？

829
00:38:19,933 --> 00:38:22,669
现在你可以知道这些信息

830
00:38:23,403 --> 00:38:25,539
我们还加入取消原因

831
00:38:25,906 --> 00:38:29,309
在以前 如果用户
获得AppleCare退款

832
00:38:29,376 --> 00:38:31,144
你可能会猜想原因

833
00:38:31,211 --> 00:38:34,815
现在你可以知道用户是否
遇到程序或程序内购买问题

834
00:38:34,882 --> 00:38:38,785
还是因为某些个人原因
而导致用户获得退款

835
00:38:40,020 --> 00:38:41,121
让我们来看一些例子

836
00:38:41,188 --> 00:38:43,190
了解如何使用这些字段

837
00:38:43,257 --> 00:38:45,492
来消除或减少订阅障碍

838
00:38:45,559 --> 00:38:47,961
首先 让我们来看非自主性终止

839
00:38:48,362 --> 00:38:51,598
在这种情况下
用户并没有选择退订

840
00:38:51,899 --> 00:38:54,801
我们可以通过很多途径
来处理非自主性终止

841
00:38:54,868 --> 00:38:57,604
我们需要采取办法

842
00:38:57,671 --> 00:39:01,408
我们可以将重试付费时间延长为

843
00:39:01,475 --> 00:39:03,076
自现在起的60天

844
00:39:03,477 --> 00:39:06,947
在以前如果发生结算问题

845
00:39:07,014 --> 00:39:09,449
我们仅尝试
在几个小时之内重试信用卡扣款

846
00:39:09,516 --> 00:39:12,252
现在我们延长到最多60天

847
00:39:12,419 --> 00:39:15,656
我们认为这可以挽回很多的退订

848
00:39:16,223 --> 00:39:17,558
在你们这边

849
00:39:17,624 --> 00:39:19,493
可以做很多事情来应对这些情况

850
00:39:20,961 --> 00:39:23,463
你可以使用终止原因字段

851
00:39:23,530 --> 00:39:26,366
和订阅重试标记
来做一些重要的事情

852
00:39:26,767 --> 00:39:29,303
我希望你们

853
00:39:29,469 --> 00:39:32,306
记住本演讲中的三个要点

854
00:39:32,372 --> 00:39:34,608
并且实施我将要讲述的三个步骤

855
00:39:34,675 --> 00:39:37,678
这样你将会极大地
减少非自主性订阅障碍

856
00:39:37,878 --> 00:39:41,949
首先 你可以使用这两个字段
为用户提供消息

857
00:39:42,049 --> 00:39:43,817
如果你看到
他们发生结算错误

858
00:39:43,884 --> 00:39:46,787
你可以告诉他们
让他们在App Store中

859
00:39:46,854 --> 00:39:47,921
更新结算信息

860
00:39:48,655 --> 00:39:49,723
第二

861
00:39:50,357 --> 00:39:52,659
你可以为需要重试结算的用户

862
00:39:52,726 --> 00:39:54,494
继续提供经过降级的或暂时性的体验

863
00:39:54,561 --> 00:39:56,663
如果你看到他们需要重试结算

864
00:39:56,730 --> 00:39:59,533
也许你可以允许他们
访问你的视频目录

865
00:39:59,600 --> 00:40:00,901
但是不能观看视频

866
00:40:01,134 --> 00:40:04,238
这就是为他们提供临时性的体验

867
00:40:04,304 --> 00:40:07,975
第三
使用这些新服务器通知

868
00:40:08,041 --> 00:40:11,745
使用验证收条端点
或任何其它技术 在订购续约之后

869
00:40:11,812 --> 00:40:13,981
立即解锁用户

870
00:40:14,448 --> 00:40:17,484
这看上很容易理解

871
00:40:17,551 --> 00:40:20,621
如果你做好这三件事

872
00:40:20,687 --> 00:40:23,624
将可以挽回许多非自主性订阅终止

873
00:40:25,092 --> 00:40:27,227
对于自主性订阅终止
同样可以采取措施

874
00:40:27,294 --> 00:40:30,931
当用户自主地选择退订时

875
00:40:30,998 --> 00:40:33,467
也可以使用这些信息
帮助你留住用户

876
00:40:33,767 --> 00:40:36,170
现在我们加入一个终止原因字段

877
00:40:36,236 --> 00:40:39,606
你可以使用此字段
为特定用户提供消息

878
00:40:40,140 --> 00:40:41,942
假设一个用户取消订阅

879
00:40:42,409 --> 00:40:45,479
你可能会想
“让我们想办法把用户拉回来”

880
00:40:46,213 --> 00:40:47,948
你可能会降低价格

881
00:40:48,015 --> 00:40:50,651
用户仍然终止订阅
因为他们并不认可价格

882
00:40:50,717 --> 00:40:53,320
你可以推出更有吸引力的选项

883
00:40:53,387 --> 00:40:55,889
因为你知道是价格原因

884
00:40:55,956 --> 00:40:57,624
导致用户退订

885
00:40:57,691 --> 00:41:00,027
在这些例子中 你已经了解

886
00:41:00,093 --> 00:41:02,663
如何使用这些字段
进行重要的业务决策

887
00:41:02,729 --> 00:41:06,033
帮助调整用户互动方式
减少订阅障碍

888
00:41:07,634 --> 00:41:09,403
这些新字段和服务器通知

889
00:41:09,469 --> 00:41:11,405
将于今年末发布

890
00:41:11,471 --> 00:41:14,775
我们认为 这将会
为所有用户带来更好的体验

891
00:41:14,842 --> 00:41:17,678
帮助你提高订阅量

892
00:41:25,052 --> 00:41:28,956
你还可以使用另一组工具

893
00:41:29,022 --> 00:41:30,490
进行服务端订阅管理

894
00:41:30,557 --> 00:41:32,659
和状态轮询

895
00:41:32,926 --> 00:41:35,929
当然 你仍然需要在用户设备上

896
00:41:35,996 --> 00:41:38,565
使用这个交易更新和完结流程

897
00:41:39,867 --> 00:41:41,034
我们讨论了订阅

898
00:41:41,101 --> 00:41:43,237
我还要简单讨论免费试用

899
00:41:44,805 --> 00:41:47,107
免费试用是指用户可以开始订阅

900
00:41:47,174 --> 00:41:49,142
但是不需要付款

901
00:41:49,209 --> 00:41:52,579
只有在免费期结束后
才会进行收费

902
00:41:53,614 --> 00:41:57,618
我们看到过这样的复杂表格

903
00:41:57,684 --> 00:42:00,254
每个订阅周期

904
00:42:00,320 --> 00:42:01,855
都有一定的免费试用期

905
00:42:01,922 --> 00:42:04,391
你必须根据
你为用户提供的订阅周期

906
00:42:04,458 --> 00:42:06,460
选择免费试用期

907
00:42:06,527 --> 00:42:09,263
现在我们进行更改
让它变得更简单

908
00:42:09,329 --> 00:42:11,832
现在你可以为任何订阅周期

909
00:42:11,899 --> 00:42:13,233
设置任何免费试用期

910
00:42:13,300 --> 00:42:15,435
我们认为这是一项重要的改进

911
00:42:15,502 --> 00:42:18,372
这里也包括两个新免费试用期

912
00:42:18,438 --> 00:42:20,574
它们是三天试用期和两周试用期

913
00:42:20,641 --> 00:42:23,644
你可以为用户提供
这两个新试用期

914
00:42:25,846 --> 00:42:27,748
关于在服务器上维护订阅状态

915
00:42:27,814 --> 00:42:29,816
和管理自动续约订阅

916
00:42:29,883 --> 00:42:30,884
就是这些

917
00:42:30,951 --> 00:42:34,221
现在我想谈谈沙盒环境下的开发

918
00:42:34,288 --> 00:42:37,224
你们可以在开发时
使用这些技术

919
00:42:37,624 --> 00:42:38,992
什么是沙盒？

920
00:42:39,660 --> 00:42:42,329
这并不是在用户设备上

921
00:42:42,396 --> 00:42:45,465
对你的程序使用沙盒
来防止访问程序资源

922
00:42:45,532 --> 00:42:47,167
这个特定的沙盒

923
00:42:47,234 --> 00:42:51,271
是我们提供给你们的测试环境
用于测试程序内购买

924
00:42:51,505 --> 00:42:53,507
在用于签名程序的证书基础上

925
00:42:53,574 --> 00:42:55,576
选择沙盒

926
00:42:55,809 --> 00:42:58,612
这样StoreKit就知道
是否处于沙盒模式

927
00:42:58,679 --> 00:43:01,114
如果你在Xcode中
开发和运行你的应用

928
00:43:01,181 --> 00:43:02,983
将使用你的开发者证书进行签名

929
00:43:03,050 --> 00:43:06,320
StoreKit知道它需要
与沙盒环境通信

930
00:43:07,087 --> 00:43:09,389
当然 若你使用App Store
分发你的应用

931
00:43:09,456 --> 00:43:12,059
StoreKit就会知道
需要在你用于签名应用的证书基础上

932
00:43:12,125 --> 00:43:14,761
与生产环境通信

933
00:43:15,662 --> 00:43:17,030
你如何知道

934
00:43:17,097 --> 00:43:19,366
当你开发应用时
你处于哪个环境？

935
00:43:20,601 --> 00:43:23,103
当你在你的应用中
进行程序内购买时

936
00:43:23,170 --> 00:43:26,240
你获得这个新支付表格
在今天上午的演讲上我们已经见过

937
00:43:26,773 --> 00:43:29,109
这表示你处于沙盒模式

938
00:43:29,176 --> 00:43:30,878
这告诉你

939
00:43:30,944 --> 00:43:33,914
将会发生沙盒支付

940
00:43:33,981 --> 00:43:36,350
并不会进行真正的付款

941
00:43:37,951 --> 00:43:39,887
沙盒与生产环境的主要区别

942
00:43:39,953 --> 00:43:41,622
当然也是最大的区别是

943
00:43:41,688 --> 00:43:43,924
这里不会发生真正的付款

944
00:43:43,991 --> 00:43:45,959
不会产生实际扣费

945
00:43:46,026 --> 00:43:48,996
并不会从你的信用卡

946
00:43:49,062 --> 00:43:49,897
扣取费用

947
00:43:50,397 --> 00:43:51,798
进行服务器到服务器验证时

948
00:43:51,865 --> 00:43:53,700
有一个不同的端点

949
00:43:53,767 --> 00:43:56,703
我们为验证收条端点
提供一个不同的URL

950
00:43:57,104 --> 00:43:59,706
你还可以在沙盒环境中
请求过期和作废的证书

951
00:43:59,773 --> 00:44:03,110
以不同的方式进行处理

952
00:44:03,977 --> 00:44:04,978
另一个不同点是

953
00:44:05,045 --> 00:44:08,215
可自动续约订阅的时间约束

954
00:44:08,348 --> 00:44:10,951
因此 你不必等待一整年
来获得订阅续约

955
00:44:11,018 --> 00:44:14,388
以测试你的方案
我们可以跟踪这些时间间隔

956
00:44:14,454 --> 00:44:17,257
缩略规则是沙盒中的一小时

957
00:44:17,324 --> 00:44:19,660
相当于现实世界中的一年

958
00:44:19,726 --> 00:44:21,595
这就是沙盒中的

959
00:44:21,662 --> 00:44:24,031
各种不同订阅时间比例关系

960
00:44:25,165 --> 00:44:26,099
当你处于沙盒环境中

961
00:44:26,166 --> 00:44:27,835
我们做的另一件事情是

962
00:44:27,901 --> 00:44:30,838
如果你订阅一个自动续约订阅服务

963
00:44:30,904 --> 00:44:35,375
每八小时窗口的
续约订阅次数最多不超过八次

964
00:44:36,476 --> 00:44:37,811
然后就会过期

965
00:44:37,878 --> 00:44:41,114
因此你会遇到用户订阅过期的情况

966
00:44:41,181 --> 00:44:44,084
然后在你的应用中
进行相应的处理

967
00:44:45,552 --> 00:44:47,487
在设置这种测试环境时

968
00:44:47,554 --> 00:44:49,323
将通过iTunes Connect
完成设置

969
00:44:49,423 --> 00:44:51,358
你在iTunes Connect中
创建测试用户

970
00:44:51,425 --> 00:44:52,993
然后使用已经准备开始销售的

971
00:44:53,060 --> 00:44:54,628
程序内购买产品

972
00:44:54,695 --> 00:44:57,064
然后使用Xcode生成
并签名你的应用

973
00:44:57,130 --> 00:44:59,867
使用开发者证书
进行生成和签名

974
00:44:59,933 --> 00:45:02,302
然后在你的应用内
购买你的产品

975
00:45:02,369 --> 00:45:03,971
当提示你登录时

976
00:45:04,037 --> 00:45:06,473
你能使用在iTunes Connect中
创建的测试用户

977
00:45:06,540 --> 00:45:08,141
进行登录

978
00:45:08,909 --> 00:45:10,944
请注意
如果你开发Mac程序

979
00:45:11,378 --> 00:45:13,146
你需要在Finder中
启动你的程序一次

980
00:45:13,213 --> 00:45:16,116
以确保取回收条

981
00:45:16,550 --> 00:45:19,286
这是因为前面
我们讲到的exit代码

982
00:45:19,353 --> 00:45:23,090
在Mac计算机上
exit 173代码…

983
00:45:23,156 --> 00:45:25,292
如果你首次在Xcode中
生成和运行程序

984
00:45:25,359 --> 00:45:28,228
你需要确保在Finder中
启动二进制程序

985
00:45:28,295 --> 00:45:31,899
使StoreKit能够捕获
exit代码并进行合适的处理

986
00:45:33,433 --> 00:45:34,868
对于在服务器上使用沙盒

987
00:45:34,935 --> 00:45:36,937
前面我说过
我们为验证收条URL

988
00:45:37,004 --> 00:45:38,972
提供一个不同的端点

989
00:45:39,039 --> 00:45:40,707
在开发环境中
它看起来是这样的

990
00:45:40,774 --> 00:45:42,910
你们将具有
开发者签名应用

991
00:45:42,976 --> 00:45:44,945
可能与测试服务器通信

992
00:45:45,012 --> 00:45:47,381
测试服务器
可能通过不同的URL

993
00:45:47,447 --> 00:45:48,749
与App Store沙盒通信

994
00:45:49,583 --> 00:45:50,884
在生产中
你会遇到这样的情况

995
00:45:50,951 --> 00:45:53,687
你的生产应用
与你的生产服务器通信

996
00:45:53,754 --> 00:45:56,056
然后与生产App Store
服务器通信

997
00:45:56,123 --> 00:45:59,159
但是在特定情况下
可能存在不匹配

998
00:45:59,860 --> 00:46:01,962
这是当你的应用处于应用审查状态时

999
00:46:02,963 --> 00:46:03,931
为什么不匹配？

1000
00:46:03,997 --> 00:46:07,267
因为应用审查团队
实际上使用沙盒用户

1001
00:46:07,334 --> 00:46:09,570
测试你的程序内购买

1002
00:46:09,970 --> 00:46:10,871
因此看上去是这样的

1003
00:46:10,938 --> 00:46:14,608
你的生产签名应用
与你的生产服务器通信

1004
00:46:14,675 --> 00:46:16,910
但是你需要检查
沙盒用户的交易

1005
00:46:17,277 --> 00:46:19,847
以通过应用审查

1006
00:46:19,913 --> 00:46:22,349
那么 如何处理这种不匹配？

1007
00:46:22,583 --> 00:46:24,251
我们提供一个方法

1008
00:46:25,052 --> 00:46:27,321
首先 当你处于生产环境中时

1009
00:46:28,121 --> 00:46:30,891
请首先尝试生产
App Store URL

1010
00:46:31,325 --> 00:46:33,026
如果收条是用于沙盒环境的

1011
00:46:33,093 --> 00:46:36,230
你将收到一个错误代码21007

1012
00:46:36,630 --> 00:46:41,268
这表示你需要
尝试App Store沙盒

1013
00:46:41,335 --> 00:46:43,437
因此你可以将收条
保存在你的生产环境中

1014
00:46:43,504 --> 00:46:46,106
这意味着你的应用
能够通过应用审查

1015
00:46:46,173 --> 00:46:47,608
而不会发生问题

1016
00:46:49,576 --> 00:46:52,179
在新的服务器到服务器通知方面

1017
00:46:52,246 --> 00:46:53,447
处理方法略有不同

1018
00:46:53,514 --> 00:46:57,251
在iTunes Connect中
我们其实并没单独的URL用于沙盒

1019
00:46:57,317 --> 00:46:58,886
或用于你自己的测试服务器

1020
00:46:59,720 --> 00:47:03,657
我们使用通知的实际数据负载中的
参数处理这种沙盒机制

1021
00:47:03,724 --> 00:47:06,360
有一个环境键值

1022
00:47:06,426 --> 00:47:10,197
告诉你通知
是用于沙盒环境中的订阅

1023
00:47:10,264 --> 00:47:12,099
还是用于生产环境中的订阅

1024
00:47:14,001 --> 00:47:15,969
关于沙盒环境下的开发就是这些

1025
00:47:16,036 --> 00:47:19,439
今天我们讲了很多的内容

1026
00:47:19,573 --> 00:47:21,341
让我们进行回顾

1027
00:47:21,408 --> 00:47:23,377
我们详细讨论了收条验证

1028
00:47:23,443 --> 00:47:26,246
如何在用户设备上验证
如何检查收条文件

1029
00:47:26,313 --> 00:47:29,216
以确保真实性
以及如何读取收条中的交易信息

1030
00:47:29,550 --> 00:47:32,152
然后讨论了
在服务器环境中

1031
00:47:32,219 --> 00:47:33,320
维护订阅状态

1032
00:47:33,387 --> 00:47:37,257
如何更新设备
处理验证收条端点

1033
00:47:37,958 --> 00:47:40,928
我们引入新的通知功能

1034
00:47:40,994 --> 00:47:43,997
以解锁用户
并挽回大量的非自主性退订

1035
00:47:44,064 --> 00:47:46,500
为用户提供更好的体验

1036
00:47:47,134 --> 00:47:48,902
我们还引入新的收条字段

1037
00:47:48,969 --> 00:47:51,839
可以根据用户的交易信息

1038
00:47:51,905 --> 00:47:55,275
做出更好的业务决策
而且能够更直接地向用户发送信息

1039
00:47:55,542 --> 00:47:58,111
请记住三个简单的步骤
以保留订阅者

1040
00:47:58,278 --> 00:47:59,847
这三个步骤帮助你取得成功

1041
00:48:00,247 --> 00:48:03,350
如果你完成这三个步骤

1042
00:48:03,417 --> 00:48:05,085
将会为你挽回大量的非自主性退订

1043
00:48:05,152 --> 00:48:06,520
今年末这些新字段开始启用后

1044
00:48:06,587 --> 00:48:08,455
请执行这些步骤

1045
00:48:08,522 --> 00:48:10,490
最后我们讨论了沙盒开发

1046
00:48:10,557 --> 00:48:13,093
你能够在沙盒环境中
使用这些技术

1047
00:48:13,160 --> 00:48:14,962
有关本演讲的更多信息

1048
00:48:15,028 --> 00:48:18,398
请观看幻灯片
请访问这个链接 演讲305

1049
00:48:18,465 --> 00:48:20,734
可以在开发者网站上
观看这个视频

1050
00:48:21,335 --> 00:48:23,737
本周我们举行了一些相关的演讲

1051
00:48:23,804 --> 00:48:25,105
现在快到周末了

1052
00:48:25,205 --> 00:48:28,041
今天下午我们仍然会在这里

1053
00:48:28,108 --> 00:48:30,677
这里有整个企业的客户端和

1054
00:48:30,744 --> 00:48:33,814
服务器端的工程师

1055
00:48:33,881 --> 00:48:34,882
聚集在StoreKit实验室

1056
00:48:34,948 --> 00:48:36,783
今天下午和明天下午

1057
00:48:36,850 --> 00:48:39,753
欢迎大家前来提问

1058
00:48:39,820 --> 00:48:40,921
我们将解答你们的问题

1059
00:48:40,988 --> 00:48:43,624
并且讨论
你应该如何构建你的解决方案

1060
00:48:43,857 --> 00:48:45,659
感谢大家今天来参加演讲

1061
00:48:45,726 --> 00:48:47,261
谢谢大家 下午过得愉快

