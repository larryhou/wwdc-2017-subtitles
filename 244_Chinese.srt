1
00:00:24,591 --> 00:00:26,360
大家下午好
我是菲力浦豪斯勒

2
00:00:26,426 --> 00:00:28,662
今天 我和我的同事
唐娜汤姆一起

3
00:00:28,729 --> 00:00:31,865
和大家一起讨论
如何使用框架实现高效率交互

4
00:00:32,566 --> 00:00:35,769
如今 我们所有人
都非常关心性能问题

5
00:00:35,903 --> 00:00:37,538
我们希望笔记本电脑飞速运行

6
00:00:37,604 --> 00:00:40,807
希望我们的手机和平板电脑
支持一整天的使用时间

7
00:00:41,175 --> 00:00:43,777
期待我们的桌面电脑
具有强大的性能

8
00:00:43,977 --> 00:00:44,945
事实上

9
00:00:45,045 --> 00:00:47,648
所有这些设备
都应该具备良好的性能

10
00:00:48,081 --> 00:00:50,651
我们的任务是
努力实现这个目标

11
00:00:52,252 --> 00:00:54,188
我们需要从不同维度来评价性能

12
00:00:54,254 --> 00:00:57,457
例如 代码的运行速度
程序耗用的电量

13
00:00:57,658 --> 00:00:59,960
以及内存占用大小等

14
00:01:00,394 --> 00:01:01,795
由于具有多个不同的维度

15
00:01:01,862 --> 00:01:03,931
我们如何使用图形
来更好地进行描述呢？

16
00:01:04,697 --> 00:01:06,967
这里有一个框架

17
00:01:07,234 --> 00:01:09,670
进行形象化描述
你可以将它视为一个图表

18
00:01:09,903 --> 00:01:12,906
其中的一个轴
表示你所处理的数据量

19
00:01:13,140 --> 00:01:14,908
另一个轴表示处理频率

20
00:01:16,009 --> 00:01:19,746
如果你需要处理大量的数据
而且代码运行非常频繁

21
00:01:20,047 --> 00:01:22,516
那么其性能水平
将会位于第一象限

22
00:01:22,649 --> 00:01:27,654
这样的话很有可能会
对性能造成很大的影响

23
00:01:27,888 --> 00:01:31,758
你需要花费大量的时间
来进行优化

24
00:01:32,492 --> 00:01:34,161
但是 如果你处理的

25
00:01:34,228 --> 00:01:37,464
数据量比较小
而且代码运行次数较低

26
00:01:37,531 --> 00:01:39,600
那么性能水平
将会位于第三象限

27
00:01:39,766 --> 00:01:41,068
老实说

28
00:01:41,335 --> 00:01:43,170
你并不希望
花费很多的时间

29
00:01:43,237 --> 00:01:44,805
来优化性能

30
00:01:45,539 --> 00:01:49,476
第二象限和第四象限
的情况有点复杂

31
00:01:49,710 --> 00:01:51,078
它们的性能水平

32
00:01:51,144 --> 00:01:53,347
在很大程度上
取决于具体的情况

33
00:01:53,413 --> 00:01:54,348
在这些情况下

34
00:01:54,414 --> 00:02:00,053
你希望能够结合实际应用
来评估性能水平

35
00:02:00,254 --> 00:02:01,755
然后 根据性能指标

36
00:02:01,822 --> 00:02:04,124
来确定是否值得花时间

37
00:02:04,191 --> 00:02:05,626
进行修改

38
00:02:07,694 --> 00:02:09,596
在本版本中 我们深入地研究

39
00:02:09,663 --> 00:02:12,032
确保我们能够理解
该如何在整个操作系统中

40
00:02:12,099 --> 00:02:13,534
优化性能

41
00:02:13,700 --> 00:02:15,235
对于应用开发也是如此

42
00:02:15,903 --> 00:02:18,005
我们对Foundation
进行了一些

43
00:02:18,071 --> 00:02:19,540
非常重要的改变

44
00:02:20,274 --> 00:02:23,177
当然
Swift也是本版本的主要部分

45
00:02:23,343 --> 00:02:26,246
我们进行大量的工作
以保证一些Foundation类型

46
00:02:26,313 --> 00:02:27,848
之间的桥接

47
00:02:28,015 --> 00:02:32,219
以提升它们的运行速度
在你们的应用中更好地工作

48
00:02:33,687 --> 00:02:37,024
现在 许多应用
大量使用字符串

49
00:02:37,090 --> 00:02:40,027
它们被用作口令
作为易于识读的数据格式

50
00:02:40,093 --> 00:02:41,728
显示在屏幕上

51
00:02:42,062 --> 00:02:44,064
高效率的字符串处理

52
00:02:44,298 --> 00:02:46,600
对于提升应用性能具有很大意义

53
00:02:46,700 --> 00:02:49,503
作为关键性内容的
字符串占有很大的比例

54
00:02:49,570 --> 00:02:51,205
显示给用户

55
00:02:52,139 --> 00:02:54,208
当然
今天的演讲

56
00:02:54,341 --> 00:02:56,643
是为了帮助你们提升应用运行速度

57
00:02:56,743 --> 00:02:58,245
你们想要减少资源占用

58
00:02:58,445 --> 00:03:00,447
使用更少的资源
来完成更多的工作

59
00:03:00,514 --> 00:03:03,984
不要着急
后面我们将会详细论述

60
00:03:04,051 --> 00:03:06,019
今天 我们将会
进行讨论

61
00:03:06,353 --> 00:03:10,357
并为你们介绍一些
性能优化技巧

62
00:03:11,592 --> 00:03:14,761
前面我说过
我们在整个操作系统范围内

63
00:03:14,828 --> 00:03:16,363
进行大量的性能优化

64
00:03:16,563 --> 00:03:19,266
在Foundation中
我们进行一些不错的改变

65
00:03:19,399 --> 00:03:21,668
让我们来看一些代表性例子

66
00:03:22,369 --> 00:03:25,138
我们对NSCalendar日期枚举
进行重大更改

67
00:03:25,272 --> 00:03:29,343
不仅减少内存占用
而且加快速度

68
00:03:29,810 --> 00:03:31,044
在以前

69
00:03:31,111 --> 00:03:34,882
很难进行
正确的日历计算

70
00:03:35,182 --> 00:03:39,186
经过更新的
NSCalendar实现

71
00:03:39,253 --> 00:03:42,890
不仅更快速 而且
更正了一些

72
00:03:42,956 --> 00:03:44,791
长期以来没解决的
极端条件计算问题

73
00:03:46,093 --> 00:03:47,594
但是 在我们进行更改时

74
00:03:47,661 --> 00:03:51,031
必须考虑这些更改
的影响范围

75
00:03:51,465 --> 00:03:53,534
在Foundation和Core Foundation中

76
00:03:53,667 --> 00:03:57,004
我们在一些位置
将一些小项目进行整合

77
00:03:57,471 --> 00:03:58,906
我们深入分析

78
00:03:58,972 --> 00:04:01,508
Foundation 中的
线程安全运行机制

79
00:04:01,675 --> 00:04:05,012
决定转移到
使用Atomics和OS及Fairlock

80
00:04:05,212 --> 00:04:08,882
这让服务质量
得到很大提升

81
00:04:10,050 --> 00:04:12,519
在服务质量方面

82
00:04:12,719 --> 00:04:16,156
NSOperation和OperationQueue
经过重大修改

83
00:04:16,390 --> 00:04:18,257
以提升实现的正确水平

84
00:04:18,325 --> 00:04:20,560
从而提高
它们的服务质量

85
00:04:20,894 --> 00:04:23,697
你将会看到一些
非常灵巧的性能提升

86
00:04:24,031 --> 00:04:27,935
在重负载应用中
队列操作的性能提升

87
00:04:28,001 --> 00:04:31,338
最高可达25%
这只是其中一个代表性例子

88
00:04:32,906 --> 00:04:35,809
在研究Swift
一段时间之后

89
00:04:36,210 --> 00:04:40,080
我们发现
写时复制技术非常不错

90
00:04:40,547 --> 00:04:42,216
在Foundation中

91
00:04:42,282 --> 00:04:44,251
一些集合类型

92
00:04:44,318 --> 00:04:47,354
现在将使用写时复制
作为辅助存储

93
00:04:48,622 --> 00:04:51,058
那么 什么是写时复制？

94
00:04:51,658 --> 00:04:55,429
写时复制是一种机制
简称COW

95
00:04:55,762 --> 00:04:59,032
在这种机制中
两个项目可以指向共享后备存储

96
00:04:59,099 --> 00:05:01,134
直到发生变更

97
00:05:01,668 --> 00:05:03,437
当发生变更时

98
00:05:03,604 --> 00:05:06,507
突变方
复制后备存储

99
00:05:06,573 --> 00:05:08,609
从而允许
进行写入

100
00:05:08,942 --> 00:05:12,446
简而言之
复制操作不会占用过多资源

101
00:05:12,913 --> 00:05:15,215
这意味着
当你保护性地复制

102
00:05:15,282 --> 00:05:17,985
可变容器时 不会占用任何资源

103
00:05:19,052 --> 00:05:22,556
在以前
复制集合至少也会

104
00:05:22,689 --> 00:05:24,191
占用线性执行时间

105
00:05:24,558 --> 00:05:26,360
现在 无论何时复制它们

106
00:05:26,493 --> 00:05:29,530
资源耗用始终不变

107
00:05:30,063 --> 00:05:31,965
让我们来看一个例子

108
00:05:32,032 --> 00:05:34,668
以了解
其底层工作机制

109
00:05:36,170 --> 00:05:37,404
在这个例子中

110
00:05:37,471 --> 00:05:39,139
我们创建一个新可变数组

111
00:05:39,740 --> 00:05:42,142
创建之后

112
00:05:42,209 --> 00:05:46,246
我们得到一个COW后备存储
其存储项目数量为零

113
00:05:47,047 --> 00:05:51,952
我们需要做一些工作
在应用中 我们进行复制

114
00:05:52,653 --> 00:05:56,089
在这个例子中
我们分配B 作为A的副本

115
00:05:56,657 --> 00:05:59,026
发生复制时

116
00:05:59,126 --> 00:06:01,895
在应用中
只有付款价格

117
00:06:02,129 --> 00:06:04,932
是分配新集合

118
00:06:05,265 --> 00:06:07,568
实际上 你不必复制
任何项目

119
00:06:07,835 --> 00:06:11,138
因此在本例中 我们仍然指向
相同的后备存储

120
00:06:11,338 --> 00:06:13,473
存储项目数量为零

121
00:06:14,241 --> 00:06:17,411
以后
如果我们想要进行变更

122
00:06:17,711 --> 00:06:21,615
所发生的情况是
复制方

123
00:06:21,982 --> 00:06:25,953
获得一个指向共享
后备存储的引用

124
00:06:26,253 --> 00:06:27,821
为了进行变更

125
00:06:27,888 --> 00:06:30,090
必须从后备存储进行复制

126
00:06:30,324 --> 00:06:33,093
以确保
变更是安全的

127
00:06:34,361 --> 00:06:36,396
但是你必须考虑

128
00:06:36,463 --> 00:06:39,800
大多数应用
将会到此为止

129
00:06:39,867 --> 00:06:43,170
而不再进行
进一步的变更

130
00:06:43,637 --> 00:06:45,172
因此你可以看到

131
00:06:45,239 --> 00:06:48,075
利用此功能
性能将会得到

132
00:06:48,141 --> 00:06:51,445
大幅的提升

133
00:06:52,279 --> 00:06:54,681
现在 让我们来看
如何在你的应用中

134
00:06:54,748 --> 00:06:55,983
使用这项技术

135
00:06:56,917 --> 00:06:59,019
假设我是一名开发者

136
00:06:59,319 --> 00:07:01,822
我编写这样的代码 并附有注释

137
00:07:02,189 --> 00:07:05,759
希望我的同事
能够听从我的建议

138
00:07:05,826 --> 00:07:07,828
以提升性能

139
00:07:08,295 --> 00:07:10,397
但是这里有一个小陷阱

140
00:07:10,664 --> 00:07:13,634
如果需要用到
可变数组

141
00:07:13,901 --> 00:07:16,370
那么可能将会
共享可变状态

142
00:07:16,436 --> 00:07:18,639
这意味着
将会共享漏洞

143
00:07:18,972 --> 00:07:20,174
这不是我们想要的

144
00:07:20,774 --> 00:07:23,343
由于现在复制不会占用资源

145
00:07:23,577 --> 00:07:25,913
因此每次都可以进行同样的操作

146
00:07:25,979 --> 00:07:27,981
而不必担心
性能降低

147
00:07:28,715 --> 00:07:29,550
这非常不错

148
00:07:30,484 --> 00:07:32,920
这不仅仅是资产的
复制性质

149
00:07:33,220 --> 00:07:36,056
很多情况下 可变容器
用于构建工作

150
00:07:36,557 --> 00:07:40,294
在这个例子中
开发者知道NSMutableArray是

151
00:07:40,360 --> 00:07:41,995
NSArray的一个子类

152
00:07:42,462 --> 00:07:45,632
其返回值是
一个NSArray

153
00:07:45,732 --> 00:07:48,135
这应该很安全 是吧？

154
00:07:48,735 --> 00:07:51,471
但不幸的是
这里也可能

155
00:07:51,538 --> 00:07:53,073
存在一些后果

156
00:07:53,340 --> 00:07:56,243
如果我们查看
返回类型的实际类

157
00:07:56,543 --> 00:07:57,477
情况不妙

158
00:07:57,544 --> 00:08:00,380
它们可能具有
共享的变更状态

159
00:08:00,914 --> 00:08:04,751
因此
你可以保护性地复制返回值

160
00:08:04,985 --> 00:08:06,486
确保获得正确的结果

161
00:08:06,553 --> 00:08:09,189
而不必担心
性能开销

162
00:08:10,390 --> 00:08:14,628
还有另一个例子
看上去更隐蔽

163
00:08:14,862 --> 00:08:15,929
在Swift中

164
00:08:16,864 --> 00:08:20,133
无论何时
导出这两个API

165
00:08:20,400 --> 00:08:24,438
都必须进行复制
以保留值类型

166
00:08:24,905 --> 00:08:27,808
如果你将数据转换为

167
00:08:27,875 --> 00:08:30,611
任何NSArray类型
以使用这两个API中的任意一个

168
00:08:30,744 --> 00:08:32,312
以前的实现

169
00:08:32,379 --> 00:08:35,582
必须花费
线性执行时间

170
00:08:35,649 --> 00:08:37,017
才能够进行复制

171
00:08:37,417 --> 00:08:39,119
如果使用保护性的方法

172
00:08:39,520 --> 00:08:42,655
复制将不会
占用资源

173
00:08:42,722 --> 00:08:45,392
因此不会降低性能

174
00:08:47,661 --> 00:08:48,795
在Swift 3中

175
00:08:49,296 --> 00:08:52,766
我们为Foundation
引入多个结构化的类型

176
00:08:53,267 --> 00:08:55,602
这种做法

177
00:08:55,669 --> 00:08:58,639
将NSData引导向
结构型数据

178
00:08:59,439 --> 00:09:01,675
我们对数据进行大量研究

179
00:09:01,742 --> 00:09:04,378
理解常见的用例

180
00:09:04,444 --> 00:09:06,513
和情况并改进数据

181
00:09:06,580 --> 00:09:09,249
让它能够
在你们的应用中更好地工作

182
00:09:09,917 --> 00:09:14,721
在这个版本中
数据现在拥有自己的类型

183
00:09:14,788 --> 00:09:16,323
我们研究

184
00:09:16,390 --> 00:09:18,926
在执行常见任务时的
性能水平

185
00:09:19,026 --> 00:09:20,561
比如获取数据计数

186
00:09:20,661 --> 00:09:23,730
偏移位置的
特定字节索引等

187
00:09:24,631 --> 00:09:28,569
一些实现的情况
比较极端

188
00:09:28,802 --> 00:09:32,472
一般来说 几行机器指令
并不能起多大的作用

189
00:09:32,906 --> 00:09:35,776
但是 当表示
字节缓冲时

190
00:09:36,176 --> 00:09:38,679
少数几行指令

191
00:09:38,946 --> 00:09:40,547
就可能带来很大的变化

192
00:09:41,982 --> 00:09:44,284
这段代码看上去非常简单

193
00:09:45,719 --> 00:09:48,488
但是它具有
一些有趣的特性

194
00:09:48,555 --> 00:09:51,792
揭示我们可以
如何让数据变得更快

195
00:09:52,593 --> 00:09:55,762
首先 数据是一个集合
如同数据一样

196
00:09:55,929 --> 00:09:59,066
它可以具有标注
包括索引和范围

197
00:09:59,633 --> 00:10:02,769
因此 这意味着
数据的起始索引

198
00:10:03,003 --> 00:10:04,605
不一定是零

199
00:10:04,872 --> 00:10:08,609
索引类似于
其它语言中的迭代器

200
00:10:09,042 --> 00:10:11,545
这段代码
并没有什么问题

201
00:10:12,312 --> 00:10:14,147
我们使用它来帮助理解

202
00:10:14,214 --> 00:10:16,283
需要改进数据的哪些部分

203
00:10:16,783 --> 00:10:19,086
这里的两个问题是

204
00:10:19,453 --> 00:10:21,321
所要处理的数据量是多少

205
00:10:21,488 --> 00:10:23,524
另外 调用次数是多少？

206
00:10:23,957 --> 00:10:25,425
其性能水平位于哪个象限？

207
00:10:26,193 --> 00:10:30,330
正确的答案是
性能水平可能会位于任意象限

208
00:10:30,797 --> 00:10:34,334
最可能的情况是
我们需要分析性能水平

209
00:10:34,935 --> 00:10:36,970
我们的确这样做了

210
00:10:38,372 --> 00:10:40,207
上方的蓝色曲线

211
00:10:40,274 --> 00:10:42,543
表示初始的Swift 3 Data版本

212
00:10:43,043 --> 00:10:48,048
进行标注时
用时约为16纳秒

213
00:10:48,115 --> 00:10:51,118
这是在我进行分析时
所使用的计算机上的结果

214
00:10:51,919 --> 00:10:57,157
由于处理数据
实际上是处理字节集合

215
00:10:57,491 --> 00:11:00,294
因此速度应该非常快

216
00:11:00,961 --> 00:11:04,698
经过改进之后
用时降低为4纳秒

217
00:11:04,865 --> 00:11:05,899
提升非常明显

218
00:11:06,433 --> 00:11:08,902
如果你以前曾经使用Data

219
00:11:09,236 --> 00:11:11,538
就可以知道其优点

220
00:11:12,172 --> 00:11:14,808
它将能够与

221
00:11:14,942 --> 00:11:18,111
获取和使用Data的
所有其余API进行互操作

222
00:11:20,714 --> 00:11:21,548
谢谢

223
00:11:23,817 --> 00:11:26,687
需要提醒你们的是

224
00:11:26,753 --> 00:11:30,090
这些例子
都没有明显的错误或缺点

225
00:11:30,257 --> 00:11:32,759
但是 它们确实
在某些方面

226
00:11:32,993 --> 00:11:34,695
还需要改进

227
00:11:35,729 --> 00:11:38,398
通常 我们认为
字节集合

228
00:11:38,465 --> 00:11:39,766
可以用数组表示

229
00:11:39,833 --> 00:11:42,436
对于少量数据 确实可以

230
00:11:42,536 --> 00:11:43,704
工作也很正常

231
00:11:44,104 --> 00:11:46,473
但是 从某种角度来说

232
00:11:46,540 --> 00:11:50,344
这也存在隐藏的开销
比如当你写入文件时

233
00:11:51,111 --> 00:11:52,312
会增加复杂性

234
00:11:52,379 --> 00:11:54,047
有很多这样的边界例子

235
00:11:54,181 --> 00:11:55,782
我们已经考虑到这一点

236
00:11:56,049 --> 00:11:58,986
由于能够进行互操作
比如写文件

237
00:11:59,052 --> 00:12:02,789
转换成为基本C4
Data具有明显的优势

238
00:12:04,124 --> 00:12:06,693
有时候我们更喜欢老做法

239
00:12:06,760 --> 00:12:10,464
使用可靠的malloc方法

240
00:12:10,864 --> 00:12:12,733
不幸的是

241
00:12:12,833 --> 00:12:16,069
这可能会错失
其它一些优化机会

242
00:12:16,236 --> 00:12:19,006
比如
可以自动分配合适的内存

243
00:12:19,072 --> 00:12:21,708
而不需要
估算malloc 将多少内存

244
00:12:21,775 --> 00:12:24,311
交回给缓冲区

245
00:12:25,179 --> 00:12:27,281
Data为你完成所有这些工作

246
00:12:27,347 --> 00:12:29,950
你不必担心
重分配问题

247
00:12:30,017 --> 00:12:33,220
你不必担心
边界例子

248
00:12:33,287 --> 00:12:36,924
比如
malloc应该分配多少内存

249
00:12:39,159 --> 00:12:42,563
这两行代码
非常相似

250
00:12:42,796 --> 00:12:44,598
但是它们用处不大

251
00:12:44,798 --> 00:12:46,567
在某些情况

252
00:12:46,633 --> 00:12:49,536
你需要能够处理
大型数据区域

253
00:12:49,770 --> 00:12:51,071
另一些情况下

254
00:12:51,138 --> 00:12:54,441
你想要能够
保留一部分数据

255
00:12:55,108 --> 00:12:56,944
因此 Data有两个API

256
00:12:57,010 --> 00:12:59,012
其中一个是Subdata
有范围参数

257
00:12:59,146 --> 00:13:00,647
它创建一个副本

258
00:13:00,714 --> 00:13:03,283
如果你需要
处理大文件

259
00:13:03,450 --> 00:13:05,819
而只想保留其中一部分

260
00:13:06,119 --> 00:13:09,656
带有范围参数的Subdata
将进行强制复制 像这样

261
00:13:10,424 --> 00:13:13,894
我们已经更改Data
使它成为自己的子类型

262
00:13:14,061 --> 00:13:16,997
或类型的子集

263
00:13:17,331 --> 00:13:19,566
无论你是否使用范围语法

264
00:13:19,633 --> 00:13:22,002
举例来说 即使有这样的范围

265
00:13:22,803 --> 00:13:26,673
你也可以将它用作窗口
来了解你的数据量

266
00:13:26,940 --> 00:13:29,309
如果你需要
处理大文件

267
00:13:29,376 --> 00:13:31,378
只需要进行分析

268
00:13:31,578 --> 00:13:34,214
而且数据本身
将是临时性的

269
00:13:34,615 --> 00:13:38,318
然后 使用数据片段
是一种非常高效的方法

270
00:13:38,385 --> 00:13:41,288
让你轻松地访问数据
因为它无需进行复制

271
00:13:43,557 --> 00:13:46,560
我们多次
谈到桥接

272
00:13:46,793 --> 00:13:50,631
这里我们需要
了解两种类型的桥接

273
00:13:51,498 --> 00:13:55,135
在右侧
是无资源开销桥接

274
00:13:55,669 --> 00:13:57,437
在这些例子中

275
00:13:57,638 --> 00:13:59,806
它们将Foundation类型

276
00:13:59,907 --> 00:14:01,308
桥接到Core Foundation类型

277
00:14:01,842 --> 00:14:04,511
或者从Foundation类型
桥接到Core Foundation类型

278
00:14:05,212 --> 00:14:09,183
在转换过程中不会产生开销

279
00:14:09,383 --> 00:14:11,818
因此 在这个例子中
所做的工作是

280
00:14:11,885 --> 00:14:15,489
将NSArray桥接到CFArray

281
00:14:16,123 --> 00:14:18,525
这只是重新解释指针

282
00:14:19,359 --> 00:14:22,529
但是这里有少量的资源开销

283
00:14:22,663 --> 00:14:27,801
当你传递对象
到CFArrayGetCount时

284
00:14:28,502 --> 00:14:30,304
你会得到一些东西

285
00:14:30,537 --> 00:14:32,306
我们将会
稍作了解

286
00:14:33,340 --> 00:14:37,711
在Swift桥接中
有些情况下

287
00:14:37,778 --> 00:14:40,013
你需要
将引用类型

288
00:14:40,080 --> 00:14:41,415
桥接到结构类型

289
00:14:42,382 --> 00:14:44,551
或者也可以

290
00:14:44,685 --> 00:14:47,521
从结构类型
桥接到引用类型

291
00:14:48,956 --> 00:14:52,793
但是这些例子中的
资源开销已经预先提供

292
00:14:52,960 --> 00:14:55,229
因此 无论何时从Objective-C导入

293
00:14:55,395 --> 00:14:58,365
或者 在本例中
使用as？

294
00:14:58,599 --> 00:15:00,601
在二者之间进行转换

295
00:15:00,767 --> 00:15:03,003
这时会产生开销

296
00:15:04,538 --> 00:15:06,540
但是区别在于

297
00:15:06,607 --> 00:15:09,943
这些开销
是正常的资源开销

298
00:15:10,944 --> 00:15:12,513
让我们来深入了解

299
00:15:12,779 --> 00:15:14,214
我知道这看上去有点吓人/b>

300
00:15:14,648 --> 00:15:16,383
如果不使用写时复制
事实上

301
00:15:16,450 --> 00:15:17,518
这并不会…

302
00:15:17,584 --> 00:15:19,853
CFArray 并不实现写时复制

303
00:15:21,054 --> 00:15:24,791
但是当你传递
一个NSArray或子类

304
00:15:24,858 --> 00:15:26,793
到CFArrayGetCount时

305
00:15:27,127 --> 00:15:30,731
它将魔术般地
调出这个Objective-C 方法count

306
00:15:31,532 --> 00:15:33,233
让我们来进一步
并进行分析

307
00:15:33,300 --> 00:15:36,370
弄清楚这与
Swift桥接之间的区别

308
00:15:38,906 --> 00:15:40,841
这里进行了简化

309
00:15:41,141 --> 00:15:44,645
首先 我们使用数组
和Objective-C子类

310
00:15:44,912 --> 00:15:47,247
我们发现
将执行计数方法

311
00:15:47,648 --> 00:15:51,485
如果不是 我们会知道
对象的结构化部分

312
00:15:51,618 --> 00:15:54,788
我们获得
可变数量

313
00:15:56,523 --> 00:15:58,258
让我们更深入地分析

314
00:15:58,926 --> 00:16:00,994
它检查
对象的内部布局

315
00:16:01,061 --> 00:16:02,996
参照预期的类表

316
00:16:03,230 --> 00:16:04,097
因此 事实上

317
00:16:04,831 --> 00:16:07,467
它会进行
两次重导向

318
00:16:07,534 --> 00:16:09,336
和一次函数调用 以确定

319
00:16:09,403 --> 00:16:12,906
是否需调用
Objective-C子类方法

320
00:16:12,973 --> 00:16:14,908
Objective-C方法

321
00:16:16,343 --> 00:16:17,945
让我们进行总结

322
00:16:18,111 --> 00:16:22,616
转换为数组
或 CFArray子类

323
00:16:22,683 --> 00:16:25,185
仅仅是重新解释指针

324
00:16:25,819 --> 00:16:28,922
其使用过程
会占用资源

325
00:16:29,823 --> 00:16:32,726
但是这只会产生
较小的性能影响

326
00:16:32,993 --> 00:16:37,030
但是在极少数情况
也可能产生较大影响

327
00:16:37,397 --> 00:16:39,967
因此 性能水平可能

328
00:16:40,033 --> 00:16:42,970
位于第三象限
可能位于比较向上的位置

329
00:16:44,905 --> 00:16:48,242
现在 我们来看另一种做法
我们使用Swift桥接

330
00:16:48,609 --> 00:16:52,112
请记住
无论何时调用as？

331
00:16:52,312 --> 00:16:54,648
或者使用Objective-C API

332
00:16:55,082 --> 00:16:57,284
无论何时使用桥接引用类型

333
00:16:57,918 --> 00:17:01,655
编译器将会
使用可桥接函数族

334
00:17:01,855 --> 00:17:04,458
反过来
在这个例子中

335
00:17:04,525 --> 00:17:06,859
为Data调用
引用初始化函数

336
00:17:08,262 --> 00:17:11,265
当Data初始化时

337
00:17:11,464 --> 00:17:12,965
将会将存储数据

338
00:17:13,099 --> 00:17:16,136
复制到数据的
后备存储

339
00:17:16,270 --> 00:17:18,539
我们不仅需要保留

340
00:17:18,605 --> 00:17:21,441
数据的
值类型属性

341
00:17:21,642 --> 00:17:22,675
而且必须确保

342
00:17:22,742 --> 00:17:25,412
我们不会使用
共享可变引用

343
00:17:25,546 --> 00:17:27,214
因为这会产生漏洞

344
00:17:28,080 --> 00:17:31,785
你可以看到
如果这是可变数据

345
00:17:31,852 --> 00:17:34,354
或代理或其他子类

346
00:17:34,821 --> 00:17:38,125
这可能是一个
隐藏的资源开销点

347
00:17:39,660 --> 00:17:41,828
我们完成所有桥接

348
00:17:41,895 --> 00:17:43,330
再来看性能图

349
00:17:44,164 --> 00:17:46,733
这次

350
00:17:46,800 --> 00:17:49,603
桥接并没有占用过多资源

351
00:17:49,736 --> 00:17:52,840
通常情况下

352
00:17:53,207 --> 00:17:55,509
仅复制限定的部分

353
00:17:55,809 --> 00:17:58,645
因此 性能水平
可能仍然位于第三象限

354
00:17:59,279 --> 00:18:02,749
但是 对于子类之外的
其他情况

355
00:18:02,816 --> 00:18:04,484
比如可变数据

356
00:18:04,551 --> 00:18:08,288
复制可能导致
性能水平位于任意象限

357
00:18:08,589 --> 00:18:11,959
因此 如果你需要
处理子类

358
00:18:12,226 --> 00:18:16,230
或者在桥接之间
来回传递可变数据

359
00:18:16,763 --> 00:18:19,333
你应该结合这些有用的范例

360
00:18:19,399 --> 00:18:22,336
利用更好的测量参数
理解性能水平

361
00:18:23,337 --> 00:18:26,773
这种模式
不仅适用于Data

362
00:18:26,874 --> 00:18:29,743
也适用于Swift中的
所有结构类型

363
00:18:29,977 --> 00:18:32,946
比如数组
字典 字符串

364
00:18:33,380 --> 00:18:36,650
说到字符串
我听说它们非常受欢迎

365
00:18:37,317 --> 00:18:38,151
接下来

366
00:18:38,218 --> 00:18:42,956
唐娜将会和大家一起
讨论字符串、范围和文本

367
00:18:48,428 --> 00:18:49,263
谢谢 菲力浦

368
00:18:51,899 --> 00:18:52,900
字符串

369
00:18:52,966 --> 00:18:55,269
可能是使用频率最高的
数据类型之一

370
00:18:55,636 --> 00:18:56,737
如果你是应用开发者

371
00:18:56,837 --> 00:18:58,739
你的应用在使用时
可能会创建

372
00:18:58,805 --> 00:19:01,208
成百上千的
各种类型的字符串

373
00:19:01,742 --> 00:19:03,143
如果你是框架开发者

374
00:19:03,210 --> 00:19:05,279
每次用户
调用我们的API

375
00:19:05,445 --> 00:19:07,481
框架可能产生和更改字符串

376
00:19:07,881 --> 00:19:09,850
这些字符串
可能会在你的框架边界之外

377
00:19:10,017 --> 00:19:11,485
发生变化

378
00:19:11,952 --> 00:19:13,987
字符串并不会单独使用

379
00:19:14,188 --> 00:19:15,489
你需要与框架交互

380
00:19:15,556 --> 00:19:17,157
利用字符串完成一些工作

381
00:19:17,224 --> 00:19:20,527
无论分割
分组和组合

382
00:19:20,727 --> 00:19:22,362
或是简单地在屏幕上呈现

383
00:19:22,763 --> 00:19:26,266
你可能需要改进
你的应用或框架的性能

384
00:19:26,333 --> 00:19:30,871
理解字符串、范围、
文本与框架之间的交互方式

385
00:19:30,938 --> 00:19:33,874
在此理解基础上
选择合适的实现方法

386
00:19:34,708 --> 00:19:36,777
在我们讨论
技术细节之前

387
00:19:36,977 --> 00:19:37,978
我想回过头来

388
00:19:38,045 --> 00:19:40,180
重复菲力浦讲过的一些内容

389
00:19:40,314 --> 00:19:41,281
简要讨论

390
00:19:41,348 --> 00:19:44,184
如何评价
性能改进的影响

391
00:19:46,186 --> 00:19:48,822
很重要的一点是
当你思考如何改进性能时

392
00:19:48,889 --> 00:19:50,524
你必须
着眼于大局

393
00:19:51,325 --> 00:19:53,393
我们很容易
拘泥于细节

394
00:19:53,560 --> 00:19:57,197
专注于优化
特定的方案

395
00:19:57,364 --> 00:19:59,666
但是 如果方案不能反映

396
00:19:59,733 --> 00:20:01,969
用户如何
使用你的应用框架

397
00:20:02,336 --> 00:20:04,071
那么优化它们
将不会产生

398
00:20:04,137 --> 00:20:05,172
多么大的作用

399
00:20:06,039 --> 00:20:07,407
因此 如果你

400
00:20:07,641 --> 00:20:10,377
使用的方案反映
实际的框架使用情况

401
00:20:10,444 --> 00:20:13,247
你可以分析
特定代码段的性能

402
00:20:13,614 --> 00:20:16,750
在做这项工作时你应该回忆
前面我们讲过的一些概念

403
00:20:16,984 --> 00:20:18,785
我处理的数据量有多大？

404
00:20:18,852 --> 00:20:20,487
代码的运行频率如何？

405
00:20:21,955 --> 00:20:23,357
另外我们要使用性能象限图

406
00:20:23,824 --> 00:20:26,560
但我们需要
对轴标签进行一些更改

407
00:20:26,693 --> 00:20:28,095
以适用于字符串和文本

408
00:20:28,562 --> 00:20:30,197
总体思想是相同的

409
00:20:30,364 --> 00:20:31,465
但是对于字符串

410
00:20:31,532 --> 00:20:33,734
我们需要考虑
字符串的长短

411
00:20:33,867 --> 00:20:35,802
和代码的运行频率

412
00:20:37,471 --> 00:20:39,740
在我们回顾这些主题时
我们应该记住

413
00:20:39,806 --> 00:20:41,108
这些规模和频率概念

414
00:20:42,543 --> 00:20:44,278
首先 让我们来看
字符串桥接

415
00:20:45,012 --> 00:20:46,647
我们会讨论范围

416
00:20:46,713 --> 00:20:48,315
和字符串索引的精妙之处

417
00:20:48,949 --> 00:20:51,285
最后 我们将会分享一些技术
帮助你高效率地处理

418
00:20:51,351 --> 00:20:53,787
文本布局
和AVKit及UIKit中的显示

419
00:20:54,922 --> 00:20:56,390
我们先来看
字符串桥接

420
00:20:58,025 --> 00:21:00,427
我们的第一个例子
是UILabel

421
00:21:02,095 --> 00:21:03,630
假设我有一个这样的标签

422
00:21:03,697 --> 00:21:05,265
我想要访问它的文本

423
00:21:07,267 --> 00:21:09,169
在Swift中
我想启动这样的界面

424
00:21:10,103 --> 00:21:13,407
我们要求UIKit框架
提供标签的文本

425
00:21:14,241 --> 00:21:16,543
因此 界面看起来是这样的

426
00:21:18,178 --> 00:21:20,647
但是 请注意
这只是生成的界面

427
00:21:20,781 --> 00:21:23,116
UILabel在Objective-C中实现

428
00:21:24,685 --> 00:21:27,487
因此 虽然我们的可变文本
是一个Swift字符串

429
00:21:27,754 --> 00:21:29,823
后备存储实际上是一个NSString

430
00:21:29,890 --> 00:21:31,625
是从Objective-C桥接过来的

431
00:21:33,527 --> 00:21:35,095
让我们来看看
当我们在Swift中

432
00:21:35,162 --> 00:21:36,897
请求获取标签的文本时
将会发生什么

433
00:21:38,265 --> 00:21:40,300
框架中的NSString
是一个引用类型

434
00:21:40,767 --> 00:21:42,536
Swift的字符串是一个值类型

435
00:21:43,103 --> 00:21:45,772
因此 如果我们向框架
请求那个NSString

436
00:21:46,073 --> 00:21:48,542
当进行Swift桥接时
它被封装为值类型

437
00:21:49,943 --> 00:21:53,347
但是 我们并不知道在桥接之后
初始NSString将会发生什么

438
00:21:53,647 --> 00:21:55,849
为了保留Swift值语义

439
00:21:55,983 --> 00:21:57,951
框架必须复制它

440
00:21:58,919 --> 00:22:02,122
幸运的是 在本例中
初始NSString是不可变的

441
00:22:02,356 --> 00:22:04,224
因此 当框架进行复制时

442
00:22:04,291 --> 00:22:06,760
将经过优化
这并不需要很多开销

443
00:22:06,827 --> 00:22:08,829
因为这只是增大引用数量

444
00:22:11,965 --> 00:22:14,034
但是 如果我们
完整复制这个字符串

445
00:22:14,168 --> 00:22:16,436
我们回到图表
来评价性能影响

446
00:22:17,905 --> 00:22:20,974
在本例中 初始字符串
包含7个ASCII字符

447
00:22:21,074 --> 00:22:23,010
即使进行完整复制

448
00:22:23,844 --> 00:22:24,945
影响也是非常小的

449
00:22:26,013 --> 00:22:27,281
大多数情况下 UILabel

450
00:22:27,347 --> 00:22:28,949
仅包含短字符串

451
00:22:29,016 --> 00:22:30,717
这些字符串用于UI显示

452
00:22:31,251 --> 00:22:34,321
因此 你可能不会
频繁地获取它们的文本

453
00:22:34,721 --> 00:22:37,357
大多数情况下
性能水平位于这个象限

454
00:22:37,691 --> 00:22:40,227
因此 桥接复制
并不会造成很大的影响

455
00:22:43,096 --> 00:22:46,166
但是 让我们来看
对于大量数据 将会发生什么

456
00:22:46,233 --> 00:22:47,334
比如在NSTextStorage中

457
00:22:49,069 --> 00:22:49,903
NSTextStorage

458
00:22:49,970 --> 00:22:52,039
是TextKit背后的
基本存储机制

459
00:22:52,506 --> 00:22:54,608
它用于在Cocoa 和Cocoa Touch中
支持文本视图

460
00:22:54,675 --> 00:22:56,076
比如你在这里所看到的

461
00:22:57,144 --> 00:22:59,146
因此 如果你处理文本视图

462
00:22:59,413 --> 00:23:00,848
你需要能够
访问文本存储中的

463
00:23:00,914 --> 00:23:02,182
文本

464
00:23:03,217 --> 00:23:04,785
这是Swift中的内容

465
00:23:07,921 --> 00:23:09,356
这是生成的界面

466
00:23:10,257 --> 00:23:13,794
这是Objective-C界面

467
00:23:14,962 --> 00:23:16,997
但是请注意 NSTextStorage

468
00:23:17,064 --> 00:23:19,733
是NSMutableAttributedString的
子类

469
00:23:21,435 --> 00:23:24,471
由于这里NSTextStorage
用于文本编辑

470
00:23:24,671 --> 00:23:27,508
因此我们希望
文本存储的内容

471
00:23:27,574 --> 00:23:28,809
频繁发生变化

472
00:23:29,977 --> 00:23:32,946
文本存储的内容
也应该是很长的字符串

473
00:23:33,013 --> 00:23:35,482
可能是MB
甚至GB级别

474
00:23:36,216 --> 00:23:37,284
因此 为了确保效率

475
00:23:37,351 --> 00:23:39,620
框架仅保留
可变字符串

476
00:23:39,920 --> 00:23:42,656
当你请求文本存储中的
字符串资产时

477
00:23:43,190 --> 00:23:45,459
将会得到
NSString提供的结果

478
00:23:45,526 --> 00:23:47,227
它指向可变字符串

479
00:23:49,730 --> 00:23:50,664
现在 让我们再来看一看

480
00:23:50,731 --> 00:23:51,732
发生了什么

481
00:23:51,798 --> 00:23:53,634
当我们从Swift中
请求字符串资产时

482
00:23:55,769 --> 00:23:58,005
与前面一样
它封装为值类型

483
00:23:58,071 --> 00:24:00,941
当进行桥接时
因为它是一个NSString

484
00:24:01,441 --> 00:24:02,943
框架将会进行复制

485
00:24:04,011 --> 00:24:05,579
但与UILabel例子不一样

486
00:24:05,646 --> 00:24:08,515
在这里 底层NSString
实际上是不可变的

487
00:24:09,316 --> 00:24:10,784
因此 此复制将会占用大量资源

488
00:24:11,818 --> 00:24:12,819
如我们前面所述

489
00:24:12,886 --> 00:24:16,423
textStorage更适合
包含很长的字符串

490
00:24:16,823 --> 00:24:18,759
其大小可能是MB
甚至GB级别

491
00:24:18,825 --> 00:24:21,195
因此 这种复制
会占量非常多的资源

492
00:24:23,564 --> 00:24:24,865
现在 让我们看看

493
00:24:24,932 --> 00:24:26,600
当我们请求
可变字符串资产时 会发生什么

494
00:24:28,535 --> 00:24:31,104
NSMutableString是一个引用类型
没有进行桥接

495
00:24:32,139 --> 00:24:34,007
因为没有进行桥接
因此不会进行复制

496
00:24:34,575 --> 00:24:36,176
从而避免占用大量资源的复制操作

497
00:24:37,511 --> 00:24:39,413
这种情况源自于

498
00:24:39,479 --> 00:24:41,181
Swift的值语义与

499
00:24:41,315 --> 00:24:42,816
NSTextStorage设计之间的不匹配

500
00:24:42,950 --> 00:24:44,618
而需要使用引用语义

501
00:24:44,685 --> 00:24:46,753
针对文本
进行性能管理

502
00:24:47,754 --> 00:24:49,890
因此 现在Apple
致力于解决这个问题

503
00:24:49,957 --> 00:24:51,792
但是我们还没有很好的解决方法

504
00:24:51,925 --> 00:24:54,161
因此 你们应该认识到
这是可能会发生的情况

505
00:24:54,394 --> 00:24:56,396
如果你要处理
大量的文本

506
00:24:56,463 --> 00:24:59,066
并进行文本存储
使用MutableString访问文本

507
00:24:59,299 --> 00:25:00,901
即使你不打算改变文本内容

508
00:25:03,070 --> 00:25:04,137
但是 当你

509
00:25:04,204 --> 00:25:06,073
将所有字符串访问
更改为使用MutableString之前

510
00:25:06,139 --> 00:25:07,441
让我们再次考虑性能象限图

511
00:25:08,208 --> 00:25:10,043
由于TextStorage API /b>
的性质

512
00:25:10,210 --> 00:25:13,480
从频率的角度来看
性能水平可能会处于上方位置

513
00:25:13,714 --> 00:25:15,182
因此 真正的问题是

514
00:25:15,449 --> 00:25:18,652
你希望TextStorage
包含多少内容？

515
00:25:20,120 --> 00:25:23,123
1 KB？
这也许比较合适

516
00:25:23,323 --> 00:25:25,292
如果你使用字符串资产
这没有问题

517
00:25:26,960 --> 00:25:29,162
如果是1MB

518
00:25:29,229 --> 00:25:30,731
性能水平将位于第一象限

519
00:25:30,864 --> 00:25:32,766
你可能想要
使用MutableString

520
00:25:34,001 --> 00:25:37,004
如果是1GB 那我真的希望
你使用MutableString

521
00:25:39,106 --> 00:25:41,542
前面我说过 我们正在
努力解决这个问题

522
00:25:41,642 --> 00:25:43,544
请在未来的版本中
留意这一点

523
00:25:45,412 --> 00:25:46,914
现在 我们对于
字符串桥接

524
00:25:46,980 --> 00:25:49,283
具有更透彻的理解
现在来看范围

525
00:25:52,553 --> 00:25:54,821
我不知道你们是怎么想的
但是 当我必须在Swift中

526
00:25:54,888 --> 00:25:57,291
使用范围和字符串索引时
我就是这样的心情

527
00:25:58,225 --> 00:26:00,127
为了弄清楚原因 让我们来看

528
00:26:00,260 --> 00:26:02,162
一个字符串 它含有用手捂脸的表情

529
00:26:02,229 --> 00:26:04,398
这有一点
像我本人

530
00:26:06,600 --> 00:26:07,568
这是我们的字符串

531
00:26:07,801 --> 00:26:10,003
是一个长字符串
里面有很多人物表情

532
00:26:10,771 --> 00:26:13,440
这个角色
包含三个图形组成部分

533
00:26:13,674 --> 00:26:15,209
有一个黄色的捂脸表情

534
00:26:15,876 --> 00:26:18,645
一个肤色修改器
可以修改黄肤色

535
00:26:19,146 --> 00:26:20,314
还有一个性别修改器

536
00:26:21,415 --> 00:26:23,817
这些图形组成部分
还不是全部

537
00:26:24,017 --> 00:26:25,953
字符串中还有
两个控制角色

538
00:26:26,019 --> 00:26:28,655
一个零宽度连接器
和一个变体选择器

539
00:26:29,289 --> 00:26:31,425
让我们来看
构成字符串的

540
00:26:31,491 --> 00:26:32,392
Unicode Scalar值

541
00:26:32,492 --> 00:26:33,961
你可能不熟悉这个名词

542
00:26:34,094 --> 00:26:37,097
Unicode Scalar值是一个21位数字

543
00:26:37,164 --> 00:26:39,299
唯一地表示
Unicode字符

544
00:26:40,067 --> 00:26:42,669
这是构成字符串的
Unicode Scalar值

545
00:26:42,836 --> 00:26:45,606
以及与这些值
相关联的名称

546
00:26:46,106 --> 00:26:48,509
如果你从Unicode Scalar角度
分析这个字符串

547
00:26:48,775 --> 00:26:50,310
就会发现 它实际上
由五个不同的值构成

548
00:26:50,377 --> 00:26:51,645
其长度为5

549
00:26:53,247 --> 00:26:54,381
目前一切正常

550
00:26:54,448 --> 00:26:56,416
如果你使用
Swift的字符串API

551
00:26:56,884 --> 00:26:58,852
但是如果你使用NSAttributedString

552
00:26:59,186 --> 00:27:01,622
或任何使用NSRange

553
00:27:01,989 --> 00:27:04,024
它们实际上使用UTF-16

554
00:27:04,558 --> 00:27:06,760
因此 若你从UTF-16
的角度看待这个字符串

555
00:27:06,827 --> 00:27:09,696
它实际上包含7个值
其长度是7

556
00:27:10,464 --> 00:27:12,966
这很容易让人感到困惑
当我们使用NSRange

557
00:27:13,033 --> 00:27:15,035
和字符串索引范围时
会变得困难重重

558
00:27:16,904 --> 00:27:18,205
因此 让我们来消除这些困惑

559
00:27:18,272 --> 00:27:20,307
我们来讨论
如何使用NSAttributedString

560
00:27:20,374 --> 00:27:21,875
它大量使用NSRange

561
00:27:23,677 --> 00:27:24,978
这里有一个字符串

562
00:27:26,146 --> 00:27:28,282
我想使用它
创建一个属性化字符串

563
00:27:28,348 --> 00:27:31,118
并且将一个表情的
背景更改为绿色

564
00:27:34,154 --> 00:27:35,322
这个工作比较复杂

565
00:27:35,389 --> 00:27:38,025
我自己都好几次
忘记怎么做了 但请不要告诉别人

566
00:27:39,560 --> 00:27:41,128
我可能需要在网上查找

567
00:27:41,195 --> 00:27:42,229
然后

568
00:27:42,362 --> 00:27:44,264
我可能会编写
这样的代码

569
00:27:45,232 --> 00:27:47,201
看上去并不合适
因为我必须

570
00:27:47,267 --> 00:27:50,003
在这个字符串API
和这个NSString API之间转来转去

571
00:27:51,071 --> 00:27:54,007
我必须获取我的初始字符串
然后使用它创建一个NSString

572
00:27:54,074 --> 00:27:56,510
然后使用NSString
计算NSRange

573
00:27:56,743 --> 00:27:57,778
然后 我必须回过头来

574
00:27:58,078 --> 00:27:59,980
再次使用我的初始字符串

575
00:28:00,047 --> 00:28:01,448
创建我的NSMutableAttributedString

576
00:28:01,849 --> 00:28:03,784
哎 我可不喜欢这样做

577
00:28:04,318 --> 00:28:05,485
没有人喜欢这样做

578
00:28:06,920 --> 00:28:08,856
一个好消息是
你再也不用这样做了

579
00:28:09,089 --> 00:28:11,425
因为在Swift 4中
我们为NSRange 和Range

580
00:28:11,491 --> 00:28:12,926
引入新的初始化器

581
00:28:13,560 --> 00:28:17,030
因此 当我们使用
这些新初始化器时——谢谢

582
00:28:17,631 --> 00:28:20,901
同样的代码将会变得如此简短

583
00:28:20,968 --> 00:28:23,704
从而更容易识读
编写和记住

584
00:28:24,204 --> 00:28:26,773
这里使用的
新NSRange初始化器

585
00:28:26,840 --> 00:28:28,542
获取范围和Swift字符串

586
00:28:28,609 --> 00:28:30,310
并使用它创建NSRange

587
00:28:30,377 --> 00:28:33,247
你可以将它直接
传递给AttributedString API

588
00:28:35,649 --> 00:28:37,718
现在 让我们
从另一个方向来看待这种转换

589
00:28:37,784 --> 00:28:39,553
也就是从NSRange
到Range 和String Index

590
00:28:41,555 --> 00:28:42,523
请看这个简单的例子

591
00:28:42,589 --> 00:28:44,291
假设我们有这样的html代码

592
00:28:44,525 --> 00:28:46,260
我们想要
打印所有起始标记

593
00:28:46,960 --> 00:28:48,295
为此

594
00:28:48,829 --> 00:28:51,131
我们将使用NSRegularExpression
查找我们想要的标记

595
00:28:51,198 --> 00:28:52,432
然后将它们追加到字符串

596
00:28:52,699 --> 00:28:53,567
听上去很正确 是吧？

597
00:28:55,602 --> 00:28:57,304
但是NSRegularExpression API

598
00:28:57,404 --> 00:28:59,339
从我的匹配组中
为我返回NSRange

599
00:28:59,473 --> 00:29:01,074
我需要字符串索引的范围

600
00:29:01,141 --> 00:29:02,743
以便将内容追加到我的Swift字符串

601
00:29:04,178 --> 00:29:06,446
在这些新初始化器
推出之前

602
00:29:06,813 --> 00:29:08,048
我们可能会使用这样的代码

603
00:29:08,115 --> 00:29:10,384
从NSRange
转换到范围字符串索引

604
00:29:11,151 --> 00:29:12,319
请回忆几分钟前

605
00:29:12,386 --> 00:29:15,055
我们讲过的捂脸表情
为什么说从UTF-16的角度来看

606
00:29:15,122 --> 00:29:16,423
它的长度为7

607
00:29:16,490 --> 00:29:18,392
而从Unicode Scalar 的角度来看
它的长度是5？

608
00:29:18,659 --> 00:29:23,263
这段代码有一点复杂
因为它进行从UTF-16

609
00:29:23,597 --> 00:29:24,698
到Unicode Scalar的转换工作

610
00:29:26,433 --> 00:29:27,968
但是现在
利用这些新数组初始化器

611
00:29:28,035 --> 00:29:29,269
你不必自己完成这些工作

612
00:29:29,803 --> 00:29:32,072
我们可以获取NSRange
从匹配组中取回

613
00:29:32,372 --> 00:29:34,708
然后用它创建
字符串索引范围

614
00:29:34,775 --> 00:29:36,243
然后直接追加到字符串

615
00:29:36,844 --> 00:29:39,213
这更加方便
更容易使用

616
00:29:39,913 --> 00:29:41,281
这些新初始化器
真的很不错

617
00:29:41,348 --> 00:29:42,850
我希望你们使用它们

618
00:29:42,916 --> 00:29:44,918
进行所有的Range
和NSRange转换

619
00:29:47,321 --> 00:29:48,155
谢谢

620
00:29:49,923 --> 00:29:51,191
关于Range就是这些

621
00:29:51,258 --> 00:29:53,126
让我们来讨论文本布局
和呈现

622
00:29:54,962 --> 00:29:55,796
文本是硬内容

623
00:29:56,597 --> 00:29:57,965
在界面上 它看上去比较简单

624
00:29:58,432 --> 00:29:59,766
因为每个人都知道文本内容是什么

625
00:30:00,100 --> 00:30:01,902
所有人每天都会看到它

626
00:30:02,236 --> 00:30:04,238
文本常见而又普通

627
00:30:04,771 --> 00:30:08,141
因此 人们认为
它很简单

628
00:30:09,243 --> 00:30:10,410
其实并不简单

629
00:30:10,978 --> 00:30:12,880
文本会带来
一些性能挑战

630
00:30:12,946 --> 00:30:14,481
因为它的大小变化多样

631
00:30:16,717 --> 00:30:17,584
请思考这样的例子

632
00:30:17,651 --> 00:30:22,389
我们的iOS有40个本地化版本
macOS有35个版本

633
00:30:23,690 --> 00:30:27,327
watchOS有39个
tvOS有40个

634
00:30:28,562 --> 00:30:29,830
在所有这些平台上

635
00:30:29,897 --> 00:30:32,799
我们支持300种其它语言的
文本输入

636
00:30:34,468 --> 00:30:36,537
每种语言都有
不同的规则

637
00:30:36,603 --> 00:30:38,438
比如
断词和连字符等

638
00:30:38,839 --> 00:30:41,141
这些会影响到分行

639
00:30:41,275 --> 00:30:42,943
从而影响文本布局

640
00:30:43,143 --> 00:30:44,811
进而影响文本呈现

641
00:30:45,345 --> 00:30:46,847
我们的框架
需要正确地

642
00:30:46,914 --> 00:30:48,482
处理所有这些语言

643
00:30:50,217 --> 00:30:51,118
如果这还不能说明问题

644
00:30:51,185 --> 00:30:52,853
让我们来看

645
00:30:52,986 --> 00:30:54,388
在执行文本和呈现时

646
00:30:54,488 --> 00:30:56,123
框架需要考虑的其它一些因素

647
00:30:56,590 --> 00:30:57,991
我们必须考虑所有这些因素

648
00:30:58,058 --> 00:31:00,861
以正确、高性能地
呈现你的文本

649
00:31:01,094 --> 00:31:01,995
因此我建议你们

650
00:31:02,062 --> 00:31:04,631
尽可能地
使用标准标签控件

651
00:31:05,532 --> 00:31:08,702
由于要考虑许多不同的可变因素
我们的框架使用

652
00:31:08,769 --> 00:31:10,838
多种底层
优化策略

653
00:31:11,471 --> 00:31:14,408
必须根据具体的情况
选择合适的优化策略

654
00:31:14,474 --> 00:31:16,476
而且必须满足多个条件

655
00:31:16,610 --> 00:31:17,711
以正确地应用策略

656
00:31:18,812 --> 00:31:20,614
我想要提醒你们

657
00:31:20,681 --> 00:31:22,616
当你们在标准控件基础上
使用自己的优化策略时

658
00:31:22,683 --> 00:31:24,017
必须非常小心

659
00:31:24,551 --> 00:31:26,653
因为呈现条件或
输入数据的改变

660
00:31:26,820 --> 00:31:29,489
可能会让你的优化失效
而无法获得性能提升

661
00:31:31,124 --> 00:31:32,459
为了描述我的含义

662
00:31:32,526 --> 00:31:35,362
让我们来看一个例子
一个含有两个标签的表格

663
00:31:37,464 --> 00:31:38,565
曾经有一位开发者

664
00:31:39,032 --> 00:31:41,668
想要在她的应用中
显示许多的标签

665
00:31:42,603 --> 00:31:45,072
而且每个标签
都有一行粗体文本

666
00:31:45,305 --> 00:31:47,107
后面是一行普通文本

667
00:31:48,141 --> 00:31:51,211
她想要手动设置标准边框
来定位她的标签

668
00:31:51,278 --> 00:31:52,946
这是出于商业原因

669
00:31:54,882 --> 00:31:57,784
她使用属性字符串
设置标签 显示她的内容

670
00:31:59,486 --> 00:32:02,256
但是她注意到
应用的滚动显示性能

671
00:32:02,322 --> 00:32:04,091
低于她的预期

672
00:32:04,892 --> 00:32:06,393
因此她进行分析

673
00:32:06,793 --> 00:32:09,396
结果发现
标签的布局和呈现

674
00:32:09,463 --> 00:32:11,398
花费了大量的时间

675
00:32:13,066 --> 00:32:14,701
于是 她做了一些试验

676
00:32:15,002 --> 00:32:19,973
然后注意到
如果每个行显示在单独的标签中

677
00:32:20,207 --> 00:32:21,842
应用滚动显示性能将会得到提升

678
00:32:22,242 --> 00:32:23,610
“这太神奇了” 她心里想到

679
00:32:23,877 --> 00:32:24,711
于是她修改应用

680
00:32:24,778 --> 00:32:26,346
每个行都使用单独的标签

681
00:32:26,547 --> 00:32:27,948
然后她感到很高兴

682
00:32:28,015 --> 00:32:31,618
直到有一天 她的公司
进入中国市场

683
00:32:33,053 --> 00:32:35,489
于是她使用中文
测试她的应用

684
00:32:36,056 --> 00:32:37,591
她吃惊地发现

685
00:32:37,891 --> 00:32:41,028
滚动显示性能
比以前更低了

686
00:32:42,262 --> 00:32:43,430
这到底是怎么了？

687
00:32:44,998 --> 00:32:47,868
这位开发者
尝试找到正确的方法

688
00:32:48,268 --> 00:32:50,938
她看到许多短字符串
频繁地进行显示

689
00:32:51,305 --> 00:32:53,106
从而让性能水平落入第二象限

690
00:32:54,508 --> 00:32:56,143
因此 她采取一些措施

691
00:32:56,276 --> 00:32:57,744
找到改进突破口

692
00:32:57,811 --> 00:32:59,513
于是进行优化

693
00:33:00,447 --> 00:33:03,083
但是 当输入数据
变成中文时

694
00:33:03,217 --> 00:33:05,385
优化无法
获得性能改进

695
00:33:06,286 --> 00:33:08,088
为了弄清楚原因 我们进行事后分析

696
00:33:09,489 --> 00:33:10,457
在这个例子中

697
00:33:10,724 --> 00:33:12,926
初始条件
支持在框架内

698
00:33:13,060 --> 00:33:14,928
更快速地显示
属性化字符串

699
00:33:15,596 --> 00:33:18,265
优化方法
是将每个行放入单独的标签

700
00:33:18,398 --> 00:33:20,267
利用这样一个特性
即仅包含一种文本样式的

701
00:33:20,334 --> 00:33:23,770
属性化字符串
支持更快速的呈现

702
00:33:25,472 --> 00:33:28,308
但是 要实现更快速的呈现
只有这个条件还不够

703
00:33:28,909 --> 00:33:30,944
快速呈现方案会走捷径

704
00:33:31,011 --> 00:33:33,080
对输入数据和
呈现条件

705
00:33:33,146 --> 00:33:34,381
进行特定的预测

706
00:33:34,615 --> 00:33:37,317
在本例中 使用中文文本
将需要字体回调

707
00:33:37,384 --> 00:33:39,086
强制在框架内
使用慢速的

708
00:33:39,152 --> 00:33:40,988
呈现路径
以保持正确性

709
00:33:42,055 --> 00:33:42,923
在此基础上

710
00:33:42,990 --> 00:33:44,791
将双行字符串
放入不同的标签

711
00:33:44,858 --> 00:33:47,761
意味着将需要
对许多标签进行两次呈现

712
00:33:50,097 --> 00:33:52,966
此外应用使用陈旧的布局方法

713
00:33:53,033 --> 00:33:55,569
手动设置边框
而不是使用自动布局 也会降低性能

714
00:33:56,270 --> 00:33:58,172
因此一般来说
在使用新技术时

715
00:33:58,238 --> 00:34:00,807
比如自动布局
我们应该更加注意

716
00:34:00,874 --> 00:34:01,708
特定条件下的性能问题

717
00:34:01,775 --> 00:34:03,410
因为多数应用都会使用这些技术

718
00:34:03,477 --> 00:34:04,912
且在这些方面
性能优化会带来

719
00:34:04,978 --> 00:34:06,113
最大的影响

720
00:34:07,047 --> 00:34:08,282
以自动布局为例

721
00:34:08,348 --> 00:34:10,617
文本系统缓存
一些布局信息

722
00:34:10,851 --> 00:34:12,219
这可以切实地提升性能

723
00:34:12,286 --> 00:34:14,188
但是由于这个应用
未使用自动布局

724
00:34:14,721 --> 00:34:15,856
因此无法利用这一优势

725
00:34:17,190 --> 00:34:18,192
因此请记住

726
00:34:18,559 --> 00:34:20,694
有一些策略和技巧
可以帮助你

727
00:34:20,761 --> 00:34:23,797
改进应用中的文本布局
和呈现性能

728
00:34:25,666 --> 00:34:26,733
若你一直在认真听讲

729
00:34:26,800 --> 00:34:28,668
你可能已知道
我要说的第一个策略是

730
00:34:30,237 --> 00:34:32,139
使用标准标签
来呈现你的文本

731
00:34:32,306 --> 00:34:33,907
其它的幕后工作请交给我们

732
00:34:34,675 --> 00:34:37,177
在框架中
可以很好地运用优化策略

733
00:34:37,244 --> 00:34:39,413
因为它能够概览地
显示整个界面

734
00:34:39,478 --> 00:34:41,547
并且提供关于
呈现条件的更多信息

735
00:34:42,516 --> 00:34:44,384
当我们进行性能优化之后

736
00:34:44,451 --> 00:34:46,286
你们将自动获得这些好处

737
00:34:46,887 --> 00:34:48,054
来看一个例子

738
00:34:48,422 --> 00:34:51,058
在macOS 10.13中 NSTextField的

739
00:34:51,123 --> 00:34:54,360
文本呈现速度提高三倍
在实时大小调整时

740
00:34:54,527 --> 00:34:55,529
速度达到5.7毫秒/帧

741
00:34:55,762 --> 00:34:59,132
相比以前的
16.67毫秒/帧缩短10.12毫秒

742
00:34:59,800 --> 00:35:01,735
你们将会免费
得到这种性能提升

743
00:35:01,802 --> 00:35:03,437
如果你们使用
标准框架控件

744
00:35:03,871 --> 00:35:04,872
因此 使用标准控制

745
00:35:04,938 --> 00:35:07,007
确实是很好的做法
应该尽可能这样做

746
00:35:10,444 --> 00:35:12,546
第二个策略
也就是刚才的故事中所讲到的

747
00:35:13,080 --> 00:35:14,948
应该使用最新的布局方法
比如自动布局

748
00:35:15,516 --> 00:35:16,917
我们认真地研究了

749
00:35:16,984 --> 00:35:18,018
使用新技术

750
00:35:18,085 --> 00:35:20,287
所获得的文本布局和呈现性能提升

751
00:35:20,888 --> 00:35:22,623
通过采用这些新技术

752
00:35:22,689 --> 00:35:25,158
将很少会遇到
我们还没见到和改进的

753
00:35:25,225 --> 00:35:26,860
边界情况

754
00:35:30,797 --> 00:35:32,432
接下来介绍一个基本技巧

755
00:35:32,799 --> 00:35:34,668
如果你使用NSAttributedString

756
00:35:34,968 --> 00:35:35,903
有一些属性

757
00:35:35,969 --> 00:35:38,438
对于布局和呈现来说
十分必要

758
00:35:39,339 --> 00:35:41,275
如果你没有
自己提供这些属性

759
00:35:41,375 --> 00:35:44,178
文本系统将需要处理它们
才能进行呈现

760
00:35:44,545 --> 00:35:46,446
因此 如果你自己提供
这些属性

761
00:35:46,513 --> 00:35:48,115
在呈现属性化字符串时

762
00:35:48,348 --> 00:35:49,650
可以节约一些时间

763
00:35:52,186 --> 00:35:53,153
同样地

764
00:35:53,453 --> 00:35:54,655
显式指定写入方向和对齐

765
00:35:54,721 --> 00:35:57,491
而不是使用默认设置
也可以带来

766
00:35:57,558 --> 00:35:59,059
少量的性能提升

767
00:35:59,960 --> 00:36:01,061
这将帮助你节约一些时间

768
00:36:01,128 --> 00:36:02,996
因为文本系统
会跳过一些逻辑

769
00:36:03,063 --> 00:36:05,399
无需花费时间来确定
写入方向和对齐

770
00:36:06,500 --> 00:36:07,968
但是请记住
在这样做时

771
00:36:08,035 --> 00:36:10,204
你必须绝对确定
你的输入数据

772
00:36:10,270 --> 00:36:12,206
不会包含混合式写入方向

773
00:36:12,539 --> 00:36:14,675
现在 我们已经在
性能与正确性之间取得平衡

774
00:36:14,875 --> 00:36:17,311
一个优化方法是
如果你对输入不是很确定

775
00:36:17,444 --> 00:36:20,147
可以让平衡点
偏离正确性远一点

776
00:36:23,584 --> 00:36:26,086
这些代码描述如何
在性能与正确性之间进行取舍

777
00:36:26,420 --> 00:36:29,389
如果你知道你的所有标签
都只会包含一行内容

778
00:36:29,723 --> 00:36:31,658
你可以设置换行模式
以使用剪辑

779
00:36:32,392 --> 00:36:34,628
默认情况下
标签使用文字包裹

780
00:36:34,795 --> 00:36:36,930
当你这样做时
文本系统需要确定

781
00:36:36,997 --> 00:36:38,198
在哪些位置进行分行

782
00:36:38,599 --> 00:36:40,367
如果你使用
剪辑分行模式

783
00:36:40,467 --> 00:36:43,136
将会跳过这个分行
和连字逻辑

784
00:36:43,203 --> 00:36:45,172
文本呈现速度
将会加快

785
00:36:47,875 --> 00:36:50,410
最后进行总结
今天我们讨论了很多内容

786
00:36:50,511 --> 00:36:52,312
从Foundation 中的
性能改进

787
00:36:52,546 --> 00:36:54,548
到字符串桥接和文本处理

788
00:36:55,182 --> 00:36:56,984
如果你只能记住本演讲中的
一项内容

789
00:36:57,217 --> 00:36:58,085
那么应该是这个图表

790
00:36:58,685 --> 00:37:00,654
请使用规模和频率概念

791
00:37:00,787 --> 00:37:03,390
最低限度减少代码中的
运行资源开支

792
00:37:03,724 --> 00:37:05,259
不要专注于不常用的项目

793
00:37:05,592 --> 00:37:07,261
在不确定时 应该进行评估

794
00:37:10,063 --> 00:37:12,833
想了解更多内容
请访问我们的演讲URL

795
00:37:12,933 --> 00:37:14,234
本演讲是244

796
00:37:15,769 --> 00:37:19,406
另外请观看
这些相关的演讲视频

797
00:37:19,840 --> 00:37:22,309
它们非常不错 遗憾的是
大多数演讲已经结束

798
00:37:23,277 --> 00:37:24,945
谢谢
请关注本次大会的其它内容

