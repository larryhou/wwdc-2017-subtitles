1
00:00:24,424 --> 00:00:25,292
谢谢

2
00:00:26,193 --> 00:00:27,995
谢谢 早上好 欢迎大家

3
00:00:28,061 --> 00:00:30,631
我叫阿里·欧泽
这是我的同事 达芙妮

4
00:00:30,697 --> 00:00:33,200
我们将聊聊在这一年中
Cocoa的新特性

5
00:00:34,368 --> 00:00:37,804
我们今天菜单上的开胃菜
是API的改进

6
00:00:38,038 --> 00:00:40,674
然后是两个主菜
AppKit和Foundation

7
00:00:41,542 --> 00:00:42,576
我们开始吧

8
00:00:43,710 --> 00:00:45,245
在API改进方面

9
00:00:45,946 --> 00:00:49,049
在过去几年里 我们已经讲了
我们很努力来改进

10
00:00:49,149 --> 00:00:51,051
框架的API外接

11
00:00:51,485 --> 00:00:56,156
属性 为空性 泛型
Swift 3 命名指南 去年

12
00:00:56,490 --> 00:00:59,326
最近 又有字符串枚举和嵌套类型

13
00:00:59,760 --> 00:01:02,229
这次 我将聊一下后两者

14
00:01:02,729 --> 00:01:05,566
我会举一个涉及这两者的例子

15
00:01:06,033 --> 00:01:09,203
在这个我们关注的场景中
过去一年中有很多

16
00:01:09,269 --> 00:01:12,005
你会在我们很多的API中看到它

17
00:01:14,007 --> 00:01:18,212
这是NSSharingService
它来自Swift 3

18
00:01:18,745 --> 00:01:20,247
我们有很多全局符号

19
00:01:20,314 --> 00:01:22,683
如你这里所见
碰到S字符串

20
00:01:22,950 --> 00:01:25,686
然后我们有方法
比如在共享服务中的初始化方法

21
00:01:26,253 --> 00:01:28,255
它以一个字符串类型变量
作为传递参数

22
00:01:29,089 --> 00:01:32,359
现在Swift 4中
我们引入了一种新类型

23
00:01:32,726 --> 00:01:36,029
这个类型是嵌套
在NSSharingService里面的

24
00:01:36,663 --> 00:01:38,765
初始化方法现以
这个类型作为传递参数

25
00:01:38,832 --> 00:01:40,267
NSSharingService.Name

26
00:01:40,868 --> 00:01:43,871
当然 这个值
你前面看到的不同的值

27
00:01:43,937 --> 00:01:46,340
现在被用来声明
这个NSSharingService.Name

28
00:01:46,640 --> 00:01:49,910
它们的名字短了很多
因为它们不再在全局上下文中了

29
00:01:50,310 --> 00:01:52,779
有了它 代码变简单了很多

30
00:01:53,247 --> 00:01:56,817
不同于在Swift 3
你现可在Swift 4中这样输入

31
00:01:57,117 --> 00:02:00,287
当然 当你码代码的时候
你得到了一系列更加清晰的自动补全

32
00:02:00,821 --> 00:02:04,091
就是这样 当你输入点号
你就准确地得到了这些值

33
00:02:04,157 --> 00:02:05,859
对于这个初始化方法是合理的

34
00:02:05,926 --> 00:02:08,362
而不是在框架中的所有字符串

35
00:02:09,429 --> 00:02:13,033
对于这个改动导致的源代码兼容性
你可能会有疑惑

36
00:02:13,100 --> 00:02:14,434
（代码兼容性
OBJECTIVE-C）

37
00:02:14,501 --> 00:02:16,270
在Objective-C中
没有嵌套

38
00:02:16,603 --> 00:02:18,939
这只是Swift的东西
所以是没有影响的

39
00:02:19,106 --> 00:02:22,409
通过你这里看到的类型定义
来实现字符串枚举

40
00:02:22,643 --> 00:02:24,311
这是完全代码兼容的

41
00:02:24,378 --> 00:02:26,613
对于Objective-C

42
00:02:27,347 --> 00:02:31,818
在Swift中
Swift 3名字保持不变

43
00:02:32,119 --> 00:02:33,921
所以你的代码是兼容的

44
00:02:34,321 --> 00:02:35,956
Swift 4有一个全新的名字

45
00:02:36,023 --> 00:02:39,293
老名字不再存在
所以Swift 4是不兼容的

46
00:02:39,826 --> 00:02:41,695
但是 我们有一个迁移器

47
00:02:42,796 --> 00:02:45,866
转移到Swift 4
所以你可以选择何时转移

48
00:02:46,200 --> 00:02:47,668
转移你的代码

49
00:02:48,836 --> 00:02:49,703
就是这个

50
00:02:49,803 --> 00:02:51,505
这就是API改进

51
00:02:51,572 --> 00:02:54,608
你会看到我们很多API
都有了这些变化

52
00:02:55,843 --> 00:02:57,978
接下来
我会深入讲一下AppKit

53
00:02:58,078 --> 00:03:01,682
我会从去年秋季引入的
这一大功能讲起

54
00:03:01,748 --> 00:03:03,617
当然 这就是触控条

55
00:03:06,787 --> 00:03:08,188
触控条…

56
00:03:09,089 --> 00:03:09,923
所以…

57
00:03:12,259 --> 00:03:13,694
正如你们中很多人注意到的那样

58
00:03:13,760 --> 00:03:17,865
触控条是一个输入设备
用来代替键盘上的顶部一行键

59
00:03:18,131 --> 00:03:21,668
它为系统和默认提供了控制

60
00:03:21,735 --> 00:03:23,804
默认地 活动应用

61
00:03:24,371 --> 00:03:28,275
作为一个多点触控输入设备
和一个漂亮的视网膜显示

62
00:03:28,542 --> 00:03:32,045
触控条提供了丰富交互
和动态的内容

63
00:03:33,247 --> 00:03:36,483
这些是作为系统一部分

64
00:03:36,717 --> 00:03:38,585
以及系统应用一部分的触控条

65
00:03:38,652 --> 00:03:41,255
如你所见
各种各样丰富内容

66
00:03:41,321 --> 00:03:43,657
和这些控制中的交互模型

67
00:03:43,991 --> 00:03:46,894
关于触控条
很重要的一点是

68
00:03:47,427 --> 00:03:50,964
尽管它是漂亮的显示器
触控条也是输入设备

69
00:03:51,031 --> 00:03:52,699
这是它存在的重要目的

70
00:03:52,766 --> 00:03:54,868
它不适合用来显示

71
00:03:54,935 --> 00:03:57,538
比如股票 代码
通知消息等等

72
00:03:57,671 --> 00:04:01,375
所以在你的应用中
将它当作键盘的一个延伸

73
00:04:02,109 --> 00:04:04,978
我将强调一些特性
使得触控条

74
00:04:05,045 --> 00:04:07,781
成为支持你应用的好功能

75
00:04:09,816 --> 00:04:11,718
首先 触控条
是上下文敏感的

76
00:04:11,818 --> 00:04:14,788
意味着它容易适应
任何用户在做的事情

77
00:04:15,155 --> 00:04:16,957
举个简单的例子

78
00:04:17,156 --> 00:04:18,725
你在TextEdit中打字

79
00:04:19,026 --> 00:04:21,894
当你打字时
触控条默认显示

80
00:04:21,995 --> 00:04:24,965
用户输入任意内容的自动补全

81
00:04:25,299 --> 00:04:28,435
当你选取了文本
触控条的显示变成

82
00:04:28,502 --> 00:04:30,704
文字格式控制 如你这里所见

83
00:04:30,771 --> 00:04:32,773
颜色 加粗 斜体等等

84
00:04:33,607 --> 00:04:37,144
现在 你在输入邮件消息的收件人

85
00:04:37,578 --> 00:04:39,913
你可以看到
触控条自动补全

86
00:04:40,514 --> 00:04:42,216
给你电子邮箱地址

87
00:04:42,282 --> 00:04:43,951
事实上 邮件是在用预测

88
00:04:44,384 --> 00:04:47,521
地址来预测你可能想要输入的地址

89
00:04:48,322 --> 00:04:51,191
这里 当你输入邮件的主题行时

90
00:04:51,258 --> 00:04:52,492
你得到快速输入

91
00:04:52,626 --> 00:04:55,729
但是在触控条的最左边
你也得到了发送按钮

92
00:04:55,796 --> 00:04:57,064
因为你在邮件中

93
00:04:57,164 --> 00:05:00,033
因此触控条的
上下文敏感性有几种方式

94
00:05:00,100 --> 00:05:01,869
为此有很多例子

95
00:05:02,736 --> 00:05:05,272
第二 触控条是可定制的

96
00:05:05,339 --> 00:05:09,109
这使得用户可以安装
他们觉得合理的方式排列内容

97
00:05:09,176 --> 00:05:11,879
所以用户可以定制默认的控制条

98
00:05:12,613 --> 00:05:13,547
比你所见

99
00:05:13,614 --> 00:05:16,116
他们可以选择使用一个延伸的控制条

100
00:05:16,216 --> 00:05:19,052
这样他们可以定制各种不同的方式

101
00:05:19,453 --> 00:05:23,457
他们也可以选择默认功能键

102
00:05:23,991 --> 00:05:25,826
对于他们选择的特殊应用

103
00:05:26,927 --> 00:05:29,263
另外 用户可以定制应用程序栏

104
00:05:29,630 --> 00:05:31,431
对于提供定制的应用

105
00:05:31,698 --> 00:05:33,534
比如 我们在一个计算器中

106
00:05:33,600 --> 00:05:36,770
你可以在视图菜单中选择定制工具栏

107
00:05:38,071 --> 00:05:39,840
会让你进入定制模式

108
00:05:39,907 --> 00:05:42,342
你可以看到触控条中的条目

109
00:05:42,409 --> 00:05:44,811
抖动表示待定制

110
00:05:44,878 --> 00:05:46,213
让我放大一些

111
00:05:46,580 --> 00:05:50,117
你可以将全部条目拖到触控条

112
00:05:50,184 --> 00:05:52,719
现在 注意定制化是一个可选的功能

113
00:05:52,786 --> 00:05:54,388
它就像NSToolbar

114
00:05:56,056 --> 00:05:58,258
现在用户期待你的应用中有该功能

115
00:05:58,525 --> 00:06:01,695
所以如果这是合理的话
我们鼓励你实现它

116
00:06:01,762 --> 00:06:04,798
比如 如果你在触控条中
有多个命令要显示

117
00:06:04,865 --> 00:06:06,500
或者你只是想让用户有这个能力

118
00:06:06,567 --> 00:06:08,435
在触控条中排列默认条目

119
00:06:09,336 --> 00:06:11,872
我想强调的最后一个触控条功能

120
00:06:12,206 --> 00:06:16,210
是它能提供内容的无障碍访问

121
00:06:16,643 --> 00:06:20,147
你可以重复利用触控条的存在

122
00:06:20,214 --> 00:06:22,449
来隐藏屏幕中的控制
以减少杂乱

123
00:06:23,617 --> 00:06:25,085
比如 这是Keynote

124
00:06:25,152 --> 00:06:27,387
实际上 这是我们用来演讲的应用

125
00:06:27,754 --> 00:06:29,656
这是在演讲模式中的Keynote

126
00:06:29,790 --> 00:06:31,625
你可以看到在演讲模式中

127
00:06:31,692 --> 00:06:35,095
屏幕上是没有控制按钮的
但是触控条仍然给出了控制按钮

128
00:06:35,162 --> 00:06:37,097
使得我可以播放这些幻灯片

129
00:06:37,164 --> 00:06:39,132
到达任意我想要的一张幻灯片

130
00:06:39,399 --> 00:06:41,902
另一个例子是在全屏模式下的
QuickTime

131
00:06:41,969 --> 00:06:44,838
多媒体控制按钮从主屏幕中淡出了

132
00:06:44,905 --> 00:06:47,207
但是你仍然可以在触控条上展示它们

133
00:06:48,976 --> 00:06:51,378
我们做了一些重要的
macOS High Sierra中的

134
00:06:51,445 --> 00:06:54,781
触控条的功能性
和NSTouchBar API的更新

135
00:06:55,048 --> 00:06:57,084
我想强调其中的一部分

136
00:06:57,918 --> 00:06:59,786
我们从颜色选择器讲起

137
00:06:59,853 --> 00:07:00,921
（触控条颜色选择器）

138
00:07:00,988 --> 00:07:05,158
你可能注意到了macOS Sierra中
的触控条颜色选择器

139
00:07:05,225 --> 00:07:07,361
我们有两种颜色选择器模式

140
00:07:07,427 --> 00:07:09,630
简单模式和HSB模式

141
00:07:10,063 --> 00:07:11,598
我们现在增加一种模式选择器

142
00:07:13,267 --> 00:07:15,536
如你所见 有四种新增的模式

143
00:07:15,869 --> 00:07:20,908
灰度模式 RGB模式
CMYK模式和Swatch模式

144
00:07:21,341 --> 00:07:24,278
在Swatch模式中展示的颜色和

145
00:07:24,344 --> 00:07:27,948
在底部颜色选择器中的颜色是一样的

146
00:07:28,015 --> 00:07:30,918
它们是用户最喜欢的

147
00:07:30,984 --> 00:07:32,319
所以颜色在那里

148
00:07:32,686 --> 00:07:33,720
你也注意到

149
00:07:34,021 --> 00:07:37,391
我们在颜色选择器右端有个按钮
它们大部分

150
00:07:37,591 --> 00:07:40,127
能让你增加目前已选的颜色

151
00:07:40,460 --> 00:07:42,930
直接从触控条作为最爱样本

152
00:07:42,996 --> 00:07:45,465
有了这些新东西
触控条颜色选择器

153
00:07:45,566 --> 00:07:47,234
就变得相当先进

154
00:07:47,301 --> 00:07:50,838
在屏幕中的主颜色面板
可以替换主颜色选择器

155
00:07:50,904 --> 00:07:51,939
对于大多数使用情况

156
00:07:52,005 --> 00:07:54,341
回到我所说的

157
00:07:54,408 --> 00:07:56,343
启用内容的通畅访问

158
00:07:56,410 --> 00:07:59,513
没有开启颜色面板应用
用户实际上不能运行

159
00:07:59,580 --> 00:08:00,547
在大多数情况下

160
00:08:03,116 --> 00:08:06,386
好的 对于触控条条目的颜色选择器
我们有API更新

161
00:08:06,920 --> 00:08:10,123
这个新方法 这个新特性
允许颜色空间

162
00:08:10,457 --> 00:08:14,261
可以选择使用的颜色空间

163
00:08:14,328 --> 00:08:16,763
比如当前文档的颜色空间

164
00:08:16,830 --> 00:08:19,967
那么颜色选择器可以展示
它们表现的颜色

165
00:08:20,033 --> 00:08:21,401
当在文档中使用的时候

166
00:08:21,468 --> 00:08:23,036
举个例子

167
00:08:23,237 --> 00:08:24,838
这是简单的颜色选择器

168
00:08:25,839 --> 00:08:28,809
现在如果你把allowedColorSpaces
设为genericCMYK

169
00:08:28,876 --> 00:08:30,978
你发现颜色会更暗

170
00:08:31,044 --> 00:08:33,947
因为这是它们在CMYK文件中
的表现方式

171
00:08:34,014 --> 00:08:35,182
来个更加极端的例子

172
00:08:35,249 --> 00:08:37,251
如果你的文档是黑白的

173
00:08:37,317 --> 00:08:38,952
这是你将会得到的颜色

174
00:08:39,385 --> 00:08:42,756
我们对于NSGroupTouchBarItem
也有API更新

175
00:08:43,090 --> 00:08:45,559
首先是警告风格的构建器

176
00:08:46,126 --> 00:08:49,329
你可能主要到 当AppKit
展示一个NSAlert的时候

177
00:08:51,265 --> 00:08:54,968
按钮会自动出现在触控条 就像这样

178
00:08:55,035 --> 00:08:57,771
如果你自己用这些按钮
展示定制用户界面

179
00:08:57,838 --> 00:09:00,607
而且你想要做
和AppKit一样的东西

180
00:09:00,674 --> 00:09:04,511
对于按钮的位置和大小
我们有API给你

181
00:09:05,279 --> 00:09:08,949
这是初始化 AlertStyleGroupItem
有一个识别器方法 它允许你

182
00:09:09,016 --> 00:09:10,918
创建GroupTouchBarItem
添加你的按钮

183
00:09:10,984 --> 00:09:13,820
得到一样的大小位置表现

184
00:09:14,821 --> 00:09:17,090
GroupTouchBarItem
的另一个API

185
00:09:18,859 --> 00:09:21,361
提供了选择压缩选项的能力

186
00:09:21,929 --> 00:09:26,233
如果条上的空间比较紧张
这决定了内容如何被管理

187
00:09:26,900 --> 00:09:29,937
比如 这是条
在中间我们有四个按钮

188
00:09:30,137 --> 00:09:31,672
所有按钮有图标和标题

189
00:09:32,172 --> 00:09:34,408
在例如德语中
它有更大的标题

190
00:09:35,008 --> 00:09:36,944
默认地 其中一个按钮会丢失

191
00:09:37,010 --> 00:09:40,747
但是你宁可让这些按钮压缩在一起
也不愿丢失其中一个

192
00:09:40,981 --> 00:09:44,151
你可能想要在两者之间选择
要么你让图标消失

193
00:09:44,218 --> 00:09:45,352
要么是标题消失

194
00:09:45,419 --> 00:09:47,654
就像这样和这样

195
00:09:47,721 --> 00:09:49,857
同时注意到
当其中一个图标消失时

196
00:09:49,923 --> 00:09:52,826
你或许想要它们全部消失
为了保持一致性

197
00:09:52,893 --> 00:09:54,761
所以这个新的API能让你实现它

198
00:09:55,295 --> 00:09:58,165
你选择要使用的压缩选项优先级

199
00:09:58,665 --> 00:10:02,302
这些包含了隐藏图片
隐藏文本 或者空格

200
00:10:03,337 --> 00:10:06,773
最后一个API提供了
从右到左界面的支持

201
00:10:06,874 --> 00:10:09,276
在GroupTouchBarItem类中

202
00:10:10,110 --> 00:10:13,313
以前的API
在特定情况下提供了从右到左的支持

203
00:10:13,380 --> 00:10:14,681
例如分段控制

204
00:10:15,082 --> 00:10:18,552
现在我们有GroupTouchBarItem API
使得更加灵活

205
00:10:18,652 --> 00:10:21,121
这是FaceTime的触控条

206
00:10:22,322 --> 00:10:24,258
在从右到左语言中

207
00:10:24,324 --> 00:10:27,861
你想要它是这样显示
那些组被反转

208
00:10:27,928 --> 00:10:31,164
在各自内部 但是整个条
没有被反转 而且那些组

209
00:10:31,231 --> 00:10:36,069
在条的应用程序部分也没有被反转

210
00:10:36,537 --> 00:10:38,939
这个新的API让你

211
00:10:40,107 --> 00:10:44,211
对于每个GroupTouchBarItem
选定用户界面布局方向

212
00:10:45,379 --> 00:10:49,149
最后我想强调关于触控条的是
Playground支持

213
00:10:49,783 --> 00:10:52,586
Playground是非常有趣的
让我们来看一下

214
00:10:52,653 --> 00:10:54,588
输入你的触控条代码

215
00:10:54,655 --> 00:10:57,391
对不起 字体有点小
但是你不需要读这些

216
00:10:57,457 --> 00:10:58,292
不是考试

217
00:10:58,358 --> 00:11:02,663
当你看到这个
你可以看到你的触控条条目

218
00:11:02,729 --> 00:11:05,632
实际上 整个触控条
在Playground中出现了

219
00:11:08,802 --> 00:11:10,838
而且你可以做一些相当复杂的东西

220
00:11:11,205 --> 00:11:15,075
检查位置和大小
做一些诸如替换退出键的事情

221
00:11:15,175 --> 00:11:19,112
这是相当高级的操作
你可以直接在Playground中做到

222
00:11:20,681 --> 00:11:23,650
所以我们有两个关于触控条的演讲

223
00:11:23,750 --> 00:11:26,086
基本讲述就在本场演讲之后

224
00:11:26,186 --> 00:11:27,688
会给你一个很好的概述

225
00:11:27,754 --> 00:11:31,124
关于如何在你的应用中
使用NSTouchBar API

226
00:11:31,325 --> 00:11:33,460
和今天下午5:10一个高级别讨论

227
00:11:33,694 --> 00:11:36,997
它会通过一些强大的真实案例
告诉你更多

228
00:11:37,364 --> 00:11:39,399
这两场演讲都很有娱乐性和教育性

229
00:11:39,466 --> 00:11:41,134
所以我鼓励你们都去参加

230
00:11:41,201 --> 00:11:44,471
明早9点到11点
我们还有一个针对触控条的实验

231
00:11:46,740 --> 00:11:49,409
好了 接下来
我们讲一下文档分享

232
00:11:49,710 --> 00:11:52,379
在macOS Sierra中
我们引入了这个分享服务

233
00:11:52,579 --> 00:11:54,448
云分享

234
00:11:54,715 --> 00:11:59,386
它实现了永久基于云端的
与其他用户的共享

235
00:11:59,853 --> 00:12:02,856
在这个发布中 我们启用
基于iCloud存储的文件分享

236
00:12:02,956 --> 00:12:04,458
让我向你们展示这是什么意思

237
00:12:04,925 --> 00:12:06,126
我们在TextEdit中

238
00:12:06,493 --> 00:12:07,995
你可以进入分享菜单

239
00:12:08,328 --> 00:12:09,630
你可以选择添加人

240
00:12:10,063 --> 00:12:11,932
这会弹出添加人的对话框

241
00:12:11,999 --> 00:12:14,268
你可以选择你想要的方式
来发出你的邀请

242
00:12:14,334 --> 00:12:15,435
让我们选择信息

243
00:12:16,003 --> 00:12:17,437
让我们邀请我们的朋友

244
00:12:18,939 --> 00:12:21,108
约翰·爱普希德 当然

245
00:12:21,175 --> 00:12:22,009
然后发出去

246
00:12:22,075 --> 00:12:23,877
如你所见
这个文档现在已经被分享了

247
00:12:23,944 --> 00:12:25,579
你可以在标题栏中看到

248
00:12:25,646 --> 00:12:26,980
这表明它是分享的

249
00:12:27,047 --> 00:12:28,682
约翰·爱普希德可以继续

250
00:12:28,749 --> 00:12:31,385
对这个文件做出他的有价值的贡献

251
00:12:32,352 --> 00:12:33,520
或者没有那么有价值

252
00:12:33,754 --> 00:12:37,090
所以 给你们的问题是

253
00:12:37,424 --> 00:12:40,594
在TextEdit中
需要多少行代码来实现这个？

254
00:12:41,261 --> 00:12:45,732
当然 因为我在问你们
可能不是800行或者几千行

255
00:12:45,799 --> 00:12:48,402
但是答案可能会让你们惊讶
因为是0行

256
00:12:49,102 --> 00:12:51,839
TextEdit已经是一个
基于NSDocument的应用

257
00:12:51,905 --> 00:12:53,473
已经实现了自动保存

258
00:12:53,540 --> 00:12:57,311
因此TextEdit完全免费
得到这个我展示给你们的功能

259
00:12:57,377 --> 00:13:00,180
对于任何基于NSDocument的应用
这都是真实的

260
00:13:00,914 --> 00:13:01,748
实际上

261
00:13:02,382 --> 00:13:05,652
这里的整个分享菜单
在macOS High Sierra中都是新的

262
00:13:05,919 --> 00:13:08,455
它包括了各种其它经典的…

263
00:13:08,522 --> 00:13:11,158
我会称它们为经典的 你知道
它们来自几年前

264
00:13:11,225 --> 00:13:14,294
分享服务 比如Mail
AirDrop、Notes等等

265
00:13:14,361 --> 00:13:15,629
这整个菜单都是免费的

266
00:13:15,896 --> 00:13:18,866
在macOS High Sierra上的
基于NSDocument的应用中

267
00:13:19,499 --> 00:13:22,236
NSDocument
你可以对于每一个实例基础

268
00:13:22,302 --> 00:13:25,172
表明是否一个文件应该被分享

269
00:13:25,239 --> 00:13:27,107
所以你可以关闭默认的分享

270
00:13:27,174 --> 00:13:29,476
这个分享方法 初始化一个分享

271
00:13:29,877 --> 00:13:34,281
准备方法让你对选择器做任意的改动

272
00:13:34,448 --> 00:13:35,782
在菜单出现以前

273
00:13:36,283 --> 00:13:38,919
在NSDocument控制器
我们有一个属性让你

274
00:13:38,986 --> 00:13:40,721
取消这整个分享服务

275
00:13:40,787 --> 00:13:42,823
如果你想要这么做的话
那么你可以自己控制它

276
00:13:42,890 --> 00:13:45,726
然后StandardShare菜单项
会回到菜单

277
00:13:46,126 --> 00:13:47,561
你可以自己放置位置

278
00:13:47,628 --> 00:13:50,163
而不是让应用放在默认位置

279
00:13:53,200 --> 00:13:54,101
分页窗口

280
00:13:54,801 --> 00:13:57,204
在上次发布的macOS Sierra中

281
00:13:57,271 --> 00:13:59,206
我们添加了分页窗口
我们的操作方式使得

282
00:13:59,273 --> 00:14:02,242
对于所有的应用
几乎是自动工作的

283
00:14:02,910 --> 00:14:06,046
这里你可以看到实际情况
比如在Pages中

284
00:14:06,346 --> 00:14:09,750
我可以去窗口菜单
合并所有窗口 就完成了！

285
00:14:09,816 --> 00:14:13,220
现在我得到…所有的文件都是选项卡
你可以从中选择

286
00:14:13,287 --> 00:14:16,056
这非常棒
这功能减少了杂乱

287
00:14:16,523 --> 00:14:19,092
在macOS High Sierra中
我们添加了

288
00:14:19,159 --> 00:14:20,460
选项卡预览功能

289
00:14:20,527 --> 00:14:21,361
这是新的

290
00:14:22,496 --> 00:14:25,399
当你到视图菜单
选择显示所有选项卡

291
00:14:26,733 --> 00:14:28,702
然后 现在它向显示其他选项卡

292
00:14:28,869 --> 00:14:30,971
非常像Safari所做的

293
00:14:31,505 --> 00:14:34,041
然后你继续选择你想要的选项卡

294
00:14:34,208 --> 00:14:35,042
所以这全是自动的

295
00:14:35,209 --> 00:14:37,044
同样 你的应用可以免费获得

296
00:14:37,778 --> 00:14:41,081
我们也有一些API
让你对于选项卡有更多的控制

297
00:14:41,882 --> 00:14:44,418
一个是NSWindowTab类

298
00:14:44,818 --> 00:14:48,589
它代表了一个实例
代表关于单个选项卡的信息

299
00:14:49,389 --> 00:14:52,426
以Safari选项卡状态条为例

300
00:14:52,793 --> 00:14:55,095
title和attributedTitle这两个字段

301
00:14:55,262 --> 00:14:57,998
让你可以定制
要显示的默认标题

302
00:14:59,333 --> 00:15:02,169
默认的标题
显然是窗口的标题

303
00:15:02,936 --> 00:15:06,673
toolTip属性让你能定制
要显示的默认toolTip

304
00:15:07,207 --> 00:15:10,711
accessoryView属性让你
在选项卡条中插入一个accessoryView

305
00:15:10,777 --> 00:15:13,647
你可以看到 在Safari中
这个小的扬声器图标

306
00:15:13,714 --> 00:15:16,984
Safari拿它来表示
网页正在播放音频

307
00:15:17,217 --> 00:15:19,286
所以现在你也可对自己的选项卡
做这样的事情

308
00:15:20,754 --> 00:15:22,289
NSWindowTabGroup类

309
00:15:22,456 --> 00:15:25,526
表示那个窗口所有选项卡组的信息

310
00:15:25,592 --> 00:15:28,161
你可以要求它的属性
比如是否可见

311
00:15:28,228 --> 00:15:29,429
或者预览可见

312
00:15:29,496 --> 00:15:30,864
你可以整合窗口

313
00:15:30,931 --> 00:15:32,566
你可以改变哪个窗口在前端

314
00:15:32,633 --> 00:15:35,502
你也可以从选项卡组
添加和删除窗口

315
00:15:38,438 --> 00:15:42,309
现在 这个应用中有一个
打开URL的新委托方法

316
00:15:43,777 --> 00:15:47,247
你可能注意到了
NSApplicationDelegate提供了

317
00:15:47,314 --> 00:15:50,450
多个标注来打开文件
但是没有一个是来处理URL的

318
00:15:50,517 --> 00:15:53,387
所以这个打开URL的
新方法应用会被调用

319
00:15:53,687 --> 00:15:56,323
通过URL而非文件或路径

320
00:15:56,657 --> 00:15:57,558
但是它也会被调用

321
00:15:57,624 --> 00:16:00,961
对任何你的应用已经注册的
定制的URL方案

322
00:16:01,028 --> 00:16:03,830
以前这需要你已注册Apple事件

323
00:16:04,097 --> 00:16:05,065
句柄

324
00:16:05,132 --> 00:16:06,366
你不需要这么做了

325
00:16:06,433 --> 00:16:07,935
现在更加简单

326
00:16:08,302 --> 00:16:10,971
如果实现了
它会被所有公开请求调用

327
00:16:11,038 --> 00:16:13,440
除了那些被NSDocument自动处理

328
00:16:13,507 --> 00:16:15,008
会被移出这个列表

329
00:16:15,442 --> 00:16:16,710
所以相当简单明了

330
00:16:16,977 --> 00:16:17,811
谢谢

331
00:16:20,280 --> 00:16:22,115
NSCollectionView将…

332
00:16:22,416 --> 00:16:24,918
在macOS High Sierra中
做响应式滚动

333
00:16:25,285 --> 00:16:26,887
我来展示一下这是什么意思

334
00:16:27,187 --> 00:16:29,690
这里我们有一个CollectionView
它有六个可见条目

335
00:16:29,756 --> 00:16:32,926
但是在集合视图的上面或者下面
有更多条目

336
00:16:32,993 --> 00:16:33,827
可见区域

337
00:16:35,195 --> 00:16:38,465
CollectionView做预提取
意味着它会预提取

338
00:16:38,532 --> 00:16:40,167
一些还不可见的条目

339
00:16:40,667 --> 00:16:43,403
期待用户会在那个区域滚动

340
00:16:43,737 --> 00:16:46,607
这是10.13版本上的应用自带的

341
00:16:47,074 --> 00:16:48,375
你不需要做任何事情

342
00:16:49,042 --> 00:16:51,378
但是 如果你想要
影响它的工作方式

343
00:16:51,445 --> 00:16:54,948
有一个预提取数据源
其中有两个你可以实现的方法

344
00:16:55,015 --> 00:17:00,153
所以 这个prefetchDataSource
是和iOS一样的代理API

345
00:17:00,220 --> 00:17:02,856
一样的数据源方法

346
00:17:03,156 --> 00:17:04,758
它的两个方法

347
00:17:04,825 --> 00:17:07,560
一个让你监听预提取
被预提取的条目

348
00:17:07,627 --> 00:17:10,696
另一个让你监听
预提取被取消

349
00:17:10,763 --> 00:17:12,633
比如说用户停止了滚动

350
00:17:12,699 --> 00:17:15,969
所以 你可以使用这些
来定制预提取行为

351
00:17:16,036 --> 00:17:17,538
超越

352
00:17:18,137 --> 00:17:20,440
你已在实现的传统数据源行为

353
00:17:20,507 --> 00:17:21,742
但是 有一些选项

354
00:17:21,808 --> 00:17:24,678
你不必实现数据源
它们依旧运作

355
00:17:25,546 --> 00:17:27,347
接下来 我们有一些关于颜色的更新

356
00:17:29,783 --> 00:17:33,587
第一 新的NSColor属性
来实现系统颜色

357
00:17:33,654 --> 00:17:34,588
这是一些属性

358
00:17:34,655 --> 00:17:37,658
比如systemBlue
systemBrown systemGray等等

359
00:17:37,724 --> 00:17:38,892
这里有一个列表

360
00:17:38,959 --> 00:17:42,095
这是你想用时就会被用到的颜色

361
00:17:42,162 --> 00:17:44,431
符合系统颜色

362
00:17:44,498 --> 00:17:46,767
或者系统应用使用的颜色

363
00:17:47,501 --> 00:17:50,204
所以 在不同的发布中
以及在不同的表现下

364
00:17:50,704 --> 00:17:52,506
这些颜色可能会改变

365
00:17:52,573 --> 00:17:57,144
比如 同样的颜色
同样的系统颜色在触控条中

366
00:17:57,211 --> 00:17:59,613
会与它在窗口中的看上去不一样

367
00:17:59,913 --> 00:18:01,849
所以这让你的应用保持时髦

368
00:18:01,915 --> 00:18:03,283
无论何时 无论何地

369
00:18:03,650 --> 00:18:04,685
当然 这也意味着

370
00:18:04,751 --> 00:18:07,120
你不应该期望颜色会完全一致

371
00:18:07,187 --> 00:18:09,056
因为它们可能会改变

372
00:18:09,489 --> 00:18:12,659
macOS 10.10就已经有了
也就是Yosemite

373
00:18:12,726 --> 00:18:15,462
在颜色选择器的开发者列表中也有

374
00:18:15,529 --> 00:18:18,098
所以你可以直接选择它们
在你的应用中使用它们

375
00:18:18,165 --> 00:18:19,299
比如在Xcode中

376
00:18:20,400 --> 00:18:21,802
关于颜色的另外一个更新

377
00:18:22,269 --> 00:18:24,371
关于旧的标准颜色

378
00:18:25,305 --> 00:18:28,008
什么是旧的颜色标准？

379
00:18:28,075 --> 00:18:31,078
是这些家伙 NSColor.red
.green、.yellow

380
00:18:31,144 --> 00:18:32,913
等等 这些我们用了很多年

381
00:18:33,213 --> 00:18:36,917
这些已经被传统地定义为
饱和商业图像颜色

382
00:18:36,984 --> 00:18:40,287
比如 红色是100
绿色是010 等等

383
00:18:41,421 --> 00:18:45,092
过去它们在通用RGB
或者校准RGB颜色空间中使用

384
00:18:45,392 --> 00:18:47,261
现在这些值都保持一致

385
00:18:47,561 --> 00:18:51,298
但通过将它们强行变成sRGB
颜色空间 我们让它们现代化

386
00:18:51,665 --> 00:18:53,200
这意味着

387
00:18:53,267 --> 00:18:55,969
颜色值会多少有些不同

388
00:18:57,137 --> 00:18:58,438
因为这样

389
00:18:58,505 --> 00:19:02,409
这个改变只会发生在10.13或
更新版本的SDK的应用程序

390
00:19:02,709 --> 00:19:05,812
你可以看到
这是颜色在通用RGB的出现方式

391
00:19:05,879 --> 00:19:07,915
这是在sRGB中的方式

392
00:19:07,981 --> 00:19:09,750
存在一些视觉差别
我们不想要

393
00:19:09,816 --> 00:19:12,519
在你的应用中引入视觉不一致

394
00:19:14,087 --> 00:19:17,591
我要提的最后一个颜色功能
是在资产目录中的颜色

395
00:19:18,125 --> 00:19:21,862
Xcode现在有能力
让你给资产目录添加颜色

396
00:19:21,929 --> 00:19:23,497
举个简单例子

397
00:19:25,065 --> 00:19:25,999
现在你也可以…

398
00:19:26,200 --> 00:19:29,870
你不能添加或者提供
一个颜色给一个特定名字颜色

399
00:19:30,270 --> 00:19:33,574
你也可以提供多个颜色
不同的颜色给不同的色域

400
00:19:33,941 --> 00:19:36,076
比如 我们有放射性颜色

401
00:19:36,143 --> 00:19:38,679
在是sRGB色域中
一个显示P3色域颜色

402
00:19:39,413 --> 00:19:42,683
这不是你经常要做的事情
这是相当罕见的

403
00:19:42,916 --> 00:19:45,853
但是如果你有很多P3颜色
你可能需要做

404
00:19:46,486 --> 00:19:51,058
当降低到与sRGB一样
这些颜色是饱和的

405
00:19:51,258 --> 00:19:52,292
所以你想要区分它们

406
00:19:52,359 --> 00:19:54,828
在sRGB 你可能想要
提供RGB变量

407
00:19:54,895 --> 00:19:57,297
但是 这应该是相当罕见的需求

408
00:19:57,831 --> 00:20:00,100
所以 你如何得到这些颜色呢？

409
00:20:00,167 --> 00:20:03,737
同时在NSColor和UIColor中
我们提供了API

410
00:20:04,204 --> 00:20:07,241
通过提供一个名字
你基本上创建了一个NSColor

411
00:20:07,641 --> 00:20:09,943
你也可以提供一个束
如果资产目录

412
00:20:10,010 --> 00:20:11,578
不是你的主束

413
00:20:14,648 --> 00:20:15,616
对于访问性

414
00:20:15,682 --> 00:20:17,451
我们做了很多改进

415
00:20:17,518 --> 00:20:20,254
我会讲一下
NSAccessibilityCustomRotor

416
00:20:20,454 --> 00:20:22,856
你可能注意到 AccessibilityRotors

417
00:20:22,923 --> 00:20:24,525
使得内容搜索更简单

418
00:20:24,992 --> 00:20:26,560
通过辅助技术

419
00:20:27,427 --> 00:20:30,297
比如 一个配音用户
可以浏览网页中的链接

420
00:20:30,864 --> 00:20:32,633
这个新的API让你能

421
00:20:32,699 --> 00:20:35,569
自定义转子 比如页面文件的标题

422
00:20:35,636 --> 00:20:36,937
这是一个例子

423
00:20:37,571 --> 00:20:38,639
这个是类似的

424
00:20:39,106 --> 00:20:40,841
这是个好的API 它类似于

425
00:20:40,908 --> 00:20:42,976
iOS上面的
UIAccessibilityCustomRotor API

426
00:20:43,043 --> 00:20:44,745
我们在上个发布版本中引入的

427
00:20:45,512 --> 00:20:49,716
相当直接地 你可以实现
accessibilityCustomRotors方法

428
00:20:50,284 --> 00:20:52,686
基于访问性协议

429
00:20:52,753 --> 00:20:55,522
返回一个数组
包含你想要的自定义转子

430
00:20:56,723 --> 00:20:58,258
一个小的属性清理便条

431
00:20:59,359 --> 00:21:03,564
在AppKit中 有很多对象属性
仍然声明为一个标记

432
00:21:04,031 --> 00:21:06,366
现在Swift中就特别不幸

433
00:21:06,667 --> 00:21:10,103
作为未知的 然后在伤口上撒盐
也是不安全的

434
00:21:10,671 --> 00:21:13,006
所以我们改变了很多

435
00:21:13,407 --> 00:21:16,476
委托、iB出口
和自然弱关系

436
00:21:16,543 --> 00:21:19,746
比如父指针
或者第一应答器 如你所见

437
00:21:19,813 --> 00:21:20,981
这些变弱

438
00:21:21,281 --> 00:21:22,182
这里的contentView

439
00:21:22,249 --> 00:21:25,752
在NSBox
这是一个属性变强的例子

440
00:21:25,819 --> 00:21:29,089
你可以在10.13上
看到它们出现的方式

441
00:21:29,690 --> 00:21:31,925
现在 这些改变大部分兼容

442
00:21:31,992 --> 00:21:33,794
但是你需要意识到弱属性

443
00:21:33,861 --> 00:21:35,729
会自动凸显出来

444
00:21:35,796 --> 00:21:37,831
当被引用的对象消失时

445
00:21:38,031 --> 00:21:41,235
所以那可能代表一些兼容性问题

446
00:21:41,301 --> 00:21:43,704
一些行为上的改变
不兼容的风险

447
00:21:43,770 --> 00:21:45,706
所以这是要注意的东西

448
00:21:46,473 --> 00:21:48,542
顺便提一下 还有一件事情

449
00:21:48,976 --> 00:21:51,745
我们不能展示他的或者她的名字和脸

450
00:21:52,079 --> 00:21:55,516
但在此过程中 我们满足了
这个开发者的WWDC愿望

451
00:21:56,216 --> 00:21:59,152
所以 我不知道你是否在那里
但是祝你WWDC快乐

452
00:22:05,125 --> 00:22:06,159
所以 我们在听

453
00:22:07,594 --> 00:22:09,196
Text的一些更新

454
00:22:10,430 --> 00:22:14,334
第一个要讲的是 我们改进了
NSTextField的孤立处理

455
00:22:14,568 --> 00:22:17,037
意思是我们会减少发生次数

456
00:22:17,104 --> 00:22:19,840
当你有一个中文或者日语字符出现

457
00:22:19,907 --> 00:22:21,208
在独自一行

458
00:22:21,275 --> 00:22:22,643
特别是两行的情况

459
00:22:22,709 --> 00:22:25,546
这影响到 比如 查询警告等等

460
00:22:26,180 --> 00:22:30,184
在NSFont和NSBezierPath
我们有基于CGGlyph的API

461
00:22:30,517 --> 00:22:35,889
通过低级图形学API
提供了改进的阻抗

462
00:22:35,956 --> 00:22:37,958
当然 提供了更好的性能

463
00:22:38,625 --> 00:22:40,694
我们有一个新的类
叫NSFontAssetRequest

464
00:22:41,261 --> 00:22:42,796
下载系统字体

465
00:22:42,863 --> 00:22:44,965
这些字体是系统的一部分

466
00:22:45,032 --> 00:22:46,900
但是没有和系统一起发货

467
00:22:47,267 --> 00:22:49,036
所以现在有了这个API
而非获得

468
00:22:49,102 --> 00:22:50,437
默认的同步UI

469
00:22:50,604 --> 00:22:52,439
你可以组成异步UI

470
00:22:52,506 --> 00:22:54,174
直接在你的应用中

471
00:22:54,541 --> 00:22:57,845
最后对于Text
我们支持纳斯达力格字体脚本

472
00:22:58,111 --> 00:22:59,546
纳斯达力格字体是一种书写方式

473
00:22:59,613 --> 00:23:02,216
在阿拉伯手写体
用于诸如乌尔都语

474
00:23:02,449 --> 00:23:03,617
这是个引人注目的字体

475
00:23:03,784 --> 00:23:06,753
为了正确渲染
它需要一些输入设定

476
00:23:06,820 --> 00:23:10,791
在Cocoa Text系统中
我们终于支持它了

477
00:23:11,258 --> 00:23:12,860
我们可以给你举个例子

478
00:23:13,227 --> 00:23:16,063
这是Nastaliq单词
用传统字体渲染

479
00:23:16,396 --> 00:23:19,166
这是同样的单词
用纳斯达力格字体脚本渲染

480
00:23:19,233 --> 00:23:22,669
因为流动的对角线性质
你可以看到为什么这是挑战

481
00:23:24,104 --> 00:23:27,107
一些光彩的AppKit特性提到了

482
00:23:27,741 --> 00:23:31,078
NSSegmentedControl
有对齐和分布特征

483
00:23:31,144 --> 00:23:33,847
这给了你更多布局控制

484
00:23:34,181 --> 00:23:36,783
NSLevelIndicator
有精心优化的新外观

485
00:23:36,850 --> 00:23:38,485
一些API优化也有

486
00:23:39,520 --> 00:23:42,289
NSMenuItem使你能有
一个KeyEquivalentWhenHidden

487
00:23:42,356 --> 00:23:45,259
所以你可以有
额外的键等价物在你的菜单里

488
00:23:45,459 --> 00:23:51,465
NSTableView能让你使用
自动布局自动计算行高度

489
00:23:53,433 --> 00:23:55,669
我们有异步
可恢复状态编码

490
00:23:55,736 --> 00:23:59,006
意味着实现状态保持和恢复的对象

491
00:23:59,072 --> 00:24:02,242
可以异步进行
如果有性能

492
00:24:02,309 --> 00:24:05,412
在它们运行时 潜在性能会发挥出来

493
00:24:07,047 --> 00:24:09,816
在拖拽的过程中
我们改进了大量条目的处理

494
00:24:10,050 --> 00:24:11,785
当你在屏幕中拖拽一个大图片时

495
00:24:11,852 --> 00:24:13,387
现在它会自动地缩小

496
00:24:13,453 --> 00:24:15,756
这样你就可以看到拖到了哪里

497
00:24:16,223 --> 00:24:18,959
最后 NSDrawers被舍弃了

498
00:24:19,426 --> 00:24:24,064
若你想知道何谓NSDrawers
它们是什么？

499
00:24:24,131 --> 00:24:26,500
好吧 不要担心了
因为它们已经被舍弃了

500
00:24:28,368 --> 00:24:33,340
好的 在我把舞台交给达芙妮之前
还有两个事情

501
00:24:33,607 --> 00:24:34,608
首先 容器视图

502
00:24:34,975 --> 00:24:37,077
在Cocoa中有很多容器视图

503
00:24:37,144 --> 00:24:39,413
NSBrowser、TableView、OutlineView

504
00:24:39,479 --> 00:24:41,682
CollectionView
StackView和GridView

505
00:24:42,049 --> 00:24:44,985
如果你困惑如何在它们中间选择
我要告诉你一件事情

506
00:24:45,586 --> 00:24:48,956
今天下午3:10演讲
“选择正确的Cocoa容器视图”

507
00:24:49,656 --> 00:24:50,557
所以大家都要来

508
00:24:50,624 --> 00:24:52,960
它们中哪个是最好的容器视图呢？

509
00:24:53,460 --> 00:24:55,362
或者不仅有一个最好的

510
00:24:56,296 --> 00:24:57,798
接下来 我有一个问题问你们

511
00:24:59,066 --> 00:25:02,202
当你调试应用时 你尝试过调用打印

512
00:25:02,669 --> 00:25:04,505
而不是显示那个对象

513
00:25:04,571 --> 00:25:05,873
缝补你要打印的对象

514
00:25:05,939 --> 00:25:09,610
你得到像这样的一个面板？
你们中的有人可能有过这样的经历

515
00:25:09,676 --> 00:25:12,212
所以在NSView的子类中
打印是含糊的

516
00:25:12,446 --> 00:25:14,815
它会尝试让你打印你的应用

517
00:25:15,148 --> 00:25:16,617
花费很多张纸

518
00:25:17,484 --> 00:25:19,186
我不是说那很糟糕

519
00:25:19,486 --> 00:25:20,521
离开电脑

520
00:25:20,654 --> 00:25:23,690
一些纸有时是调试问题最好的方式

521
00:25:23,957 --> 00:25:25,626
但是通常不是你真正想要的

522
00:25:25,959 --> 00:25:27,427
所以我们有一个API改变

523
00:25:28,262 --> 00:25:30,864
NSWindow和NSView和NSWindows
打印方法

524
00:25:30,931 --> 00:25:33,267
被重命名为
printView和printWindow

525
00:25:33,734 --> 00:25:37,905
现在Swift 4中
给你一个小技巧 迁移和获利

526
00:25:38,605 --> 00:25:41,708
说到小技巧
请务必去参加这个演讲：

527
00:25:41,775 --> 00:25:44,645
周五早上9:00
Cocoa开发小技巧

528
00:25:45,045 --> 00:25:46,547
那里你可以听到更多的小技巧

529
00:25:47,080 --> 00:25:48,749
坦白地说 我真的不知道

530
00:25:48,815 --> 00:25:51,018
有多少 因为我们数不清
我们有多少小技巧了

531
00:25:51,185 --> 00:25:52,419
你们可以自己数一数

532
00:25:52,953 --> 00:25:56,356
我们也想给你这个机会
把你们自己的小技巧分享给所有人

533
00:25:57,391 --> 00:26:00,060
所以 如果你知道任何有用的
Cocoa开发小技巧

534
00:26:00,127 --> 00:26:01,495
要分享给开发者

535
00:26:01,562 --> 00:26:05,365
请在Twitter上发布
加上标签#WWDC17和#cocoatip

536
00:26:05,699 --> 00:26:09,069
你的小技巧可能会出现在
周五的演讲中

537
00:26:09,436 --> 00:26:12,940
好了 我要邀请我的同事
达芙妮上台 谢谢

538
00:26:17,845 --> 00:26:21,381
大家好 我叫达芙妮·拉罗斯
我是Foundation团队的工程师

539
00:26:22,449 --> 00:26:26,720
我们以Foundation中
两个大的新事物作为开始

540
00:26:26,954 --> 00:26:28,922
我们对键径有了更好的支持

541
00:26:29,423 --> 00:26:32,326
我们也支持Swift中编码和解码

542
00:26:32,893 --> 00:26:34,194
我们从键径开始谈起

543
00:26:34,728 --> 00:26:38,465
我们现在有一些字面语法
它是类型安全的和高性能的

544
00:26:38,899 --> 00:26:42,836
你们可能已经熟悉
它在Swift 3中是什么样子了

545
00:26:44,204 --> 00:26:46,673
现在Swift 4中 它变得更加简单

546
00:26:46,840 --> 00:26:50,344
它有一个反斜杠基础类型点
然后一个属性名字

547
00:26:50,844 --> 00:26:53,213
它的简单性使得我们提高了

548
00:26:53,280 --> 00:26:56,783
一些已经存在的API
比如KVO

549
00:26:58,318 --> 00:27:01,321
所以在这个例子中
我们尝试观察

550
00:27:01,455 --> 00:27:04,558
在DogOwner类中
一个特殊的属性dog

551
00:27:04,958 --> 00:27:08,061
所以在很多设置之前

552
00:27:08,128 --> 00:27:12,866
你需要写很多的代码
现你可以得到一个基于块

553
00:27:13,166 --> 00:27:18,839
基于闭包观察 它会简洁很多

554
00:27:19,006 --> 00:27:21,575
简单很多 在这个例子中
只有两行代码

555
00:27:21,742 --> 00:27:26,446
语法的简单性使得键径更加易用

556
00:27:26,647 --> 00:27:30,184
对于在Swift中的编码和解码
我们现在支持转化

557
00:27:30,250 --> 00:27:32,619
在你的类型安全Swift

558
00:27:32,886 --> 00:27:35,856
和失败者格式 比如
JSON P-lists等等

559
00:27:36,790 --> 00:27:38,125
深度定制化

560
00:27:38,192 --> 00:27:41,195
所以改变定制化结构体
非常简单

561
00:27:41,795 --> 00:27:43,230
而且使用也是相当简单

562
00:27:43,597 --> 00:27:46,500
太简单了 只需要

563
00:27:46,567 --> 00:27:48,836
声明你的结构体是可编码的

564
00:27:48,902 --> 00:27:51,471
这样一来
你不需要写任何样板代码

565
00:27:51,538 --> 00:27:55,275
你不需要做额外任何事情
你自动地获得了实现

566
00:27:55,342 --> 00:27:58,478
编码和解码
不费吹灰之力

567
00:28:00,247 --> 00:28:02,282
所以你们中可能有人已经注意到了

568
00:28:02,349 --> 00:28:05,452
大约两小时后 我们将有
“Foundation新特性”演讲

569
00:28:05,986 --> 00:28:09,256
那会对我们很有用
因为它让我们有时间

570
00:28:09,323 --> 00:28:12,059
谈论Foundation中
其它的新特性

571
00:28:12,593 --> 00:28:16,096
所以我会更深入地讲一讲
所以我们有了很多新的API

572
00:28:16,163 --> 00:28:20,501
在macOS和iOS上
有很多改进的API

573
00:28:21,001 --> 00:28:25,005
顺便说一下 我们以iOS上的
NSXPCConnection作为开始

574
00:28:25,272 --> 00:28:31,111
它允许编写者
以一种前所未有的方式发布进度

575
00:28:31,311 --> 00:28:35,516
我们有一个协议例子
被客户端和服务器共享

576
00:28:35,949 --> 00:28:37,584
之前它返回空

577
00:28:37,918 --> 00:28:40,220
现在它返回NSProgress

578
00:28:40,287 --> 00:28:42,890
这样的好处是它允许服务器

579
00:28:42,956 --> 00:28:48,362
返回一个进度给客户端
在它返回回复之前

580
00:28:49,296 --> 00:28:53,767
当它们发生的时候 客户端实际上
可以看到这些实时的更新

581
00:28:58,238 --> 00:29:03,076
URLSession现在有一个新的
布尔属性 它允许URLSession

582
00:29:03,143 --> 00:29:06,213
为你监测连接性

583
00:29:06,380 --> 00:29:09,683
所以它会等待开始你的
URLSessionTasks

584
00:29:10,017 --> 00:29:13,854
直到连接性达到满意程度
所以不再会有手动的重试

585
00:29:13,921 --> 00:29:17,424
如果网络条件不好
你一点都不需要担心了

586
00:29:17,491 --> 00:29:19,326
设置这个属性为你处理了

587
00:29:19,493 --> 00:29:22,563
现在 如果你选择不去设置它
也没有关系 那是你的选择

588
00:29:22,629 --> 00:29:24,631
但是它会回到旧行为

589
00:29:25,599 --> 00:29:28,368
现在iOS上已有多路TCP了

590
00:29:28,902 --> 00:29:33,674
URLSessionTask 比如NSXPCConnection
现在支持进度报告

591
00:29:35,309 --> 00:29:37,044
关于这个 我们会在

592
00:29:37,110 --> 00:29:40,747
今天晚些时候第二部分
“网络改进”演讲中谈论更多

593
00:29:40,814 --> 00:29:43,951
第一部分也会很精彩
所以你最好也去看一下

594
00:29:45,652 --> 00:29:50,958
NSFileProviderService
现在支持更加直接的通信

595
00:29:51,058 --> 00:29:53,460
在应用和文件提供者之间

596
00:29:53,794 --> 00:29:57,030
对于那些不知道的人
文件提供者是

597
00:29:57,164 --> 00:29:58,799
拥有和管理文档的应用扩展对

598
00:29:59,032 --> 00:30:02,135
它们也同步那些文档到私有的云服务

599
00:30:02,202 --> 00:30:04,938
它们可以使其他应用可访问那些文件

600
00:30:06,106 --> 00:30:08,709
在这个API中 应用可以

601
00:30:08,876 --> 00:30:11,411
对于任何URL 更加简单地
发现文件提供者

602
00:30:11,845 --> 00:30:15,382
而且它们可以使用
这些文件提供者提供的专业服务

603
00:30:15,716 --> 00:30:17,751
周五会有一个相关演讲

604
00:30:17,818 --> 00:30:19,820
所以如果你想要更多的信息
你应该去看看

605
00:30:21,655 --> 00:30:25,792
好消息是我们为
NSXPCConnection所做的改变

606
00:30:25,959 --> 00:30:28,328
我们为URLSession所做的改变
实际上是

607
00:30:28,395 --> 00:30:31,698
都与我们为NSFileProviderService
所做的改变有关

608
00:30:31,765 --> 00:30:33,300
所以把它们全部连起来

609
00:30:33,433 --> 00:30:35,869
我们回到前面提过的协议

610
00:30:36,637 --> 00:30:38,172
我们有一个应用 我们的客户端

611
00:30:38,238 --> 00:30:40,107
而且我也有一个文件提供者
我们的服务器

612
00:30:40,307 --> 00:30:44,511
这个应用调用文件提供者
得到一个NSProgress对象

613
00:30:46,713 --> 00:30:50,250
文件提供者开始下载
请求的文件

614
00:30:50,350 --> 00:30:52,386
使用URLSession
[听不清]

615
00:30:53,153 --> 00:30:56,156
然后更新进度
所以现在非常酷的是

616
00:30:56,323 --> 00:31:00,294
当更新发生时
应用实际上看到了这些更新

617
00:31:00,794 --> 00:31:03,864
下载终于结束了
最后的更新被发出去

618
00:31:04,198 --> 00:31:07,534
现在文件提供者可以
回复所请求的文件

619
00:31:08,635 --> 00:31:10,037
让我们稍微换一下装备

620
00:31:10,504 --> 00:31:14,775
我们现在有API
能够更准确地检查可用的存储空间

621
00:31:14,975 --> 00:31:17,344
还有一种专注的感觉

622
00:31:17,544 --> 00:31:23,684
我们认为它是重要的和机会主义的
它还是有些不清楚

623
00:31:23,784 --> 00:31:25,485
对于那到底是什么意思

624
00:31:25,552 --> 00:31:27,821
所以我们会更加深入地聊聊

625
00:31:27,988 --> 00:31:32,993
假设我们有一个空间
它有任意数量的空闲磁盘空间

626
00:31:34,194 --> 00:31:39,533
机会主义代表用户并不期望在那里的

627
00:31:39,600 --> 00:31:42,436
任意文件和免费空间

628
00:31:42,569 --> 00:31:46,440
例如一首播客的老曲子

629
00:31:46,640 --> 00:31:48,642
用户已经听过了

630
00:31:50,511 --> 00:31:55,048
重要代表免费和机会主义以及

631
00:31:55,115 --> 00:31:59,286
用户确实期望在那里 但是
最终是可替代可删除的任何文件

632
00:31:59,653 --> 00:32:01,655
音频文件就是一个例子

633
00:32:01,722 --> 00:32:05,058
用户要求下载的
他们期望它在那里

634
00:32:05,292 --> 00:32:08,328
然而 如果为了腾出空间而去移除它

635
00:32:08,462 --> 00:32:10,497
他们也可以要求再次下载

636
00:32:12,599 --> 00:32:15,169
好消息是作为开发者的你们

637
00:32:15,235 --> 00:32:16,970
现在可以做预检

638
00:32:17,037 --> 00:32:21,308
在这个例子中 我们实际上检查
有多少机会主义空间可用

639
00:32:21,475 --> 00:32:25,612
如果超过了50兆
我们继续下载另外的文件

640
00:32:25,679 --> 00:32:28,715
这些检查的好处是你可以预先做

641
00:32:28,782 --> 00:32:30,951
在你真的写入很多数据到磁盘之前

642
00:32:31,351 --> 00:32:34,388
这里暗指的是检查

643
00:32:34,555 --> 00:32:37,257
“嘿 我们有足够的空间给

644
00:32:37,391 --> 00:32:39,459
我们将要下载的文件吗？”

645
00:32:41,762 --> 00:32:45,365
所以NSLinguisticTagger
现在支持标志单元

646
00:32:45,699 --> 00:32:51,038
通过单词、句子、段落
也可以通过引理进行标志

647
00:32:52,272 --> 00:32:54,675
API完全被重做和修改

648
00:32:55,075 --> 00:32:58,879
现在它有一些简便的方法
包括dominantLanguage

649
00:32:58,946 --> 00:33:02,115
现在你可以检测给定字符串的
dominantLanguage

650
00:33:02,983 --> 00:33:05,452
JSONSerialization
支持排序的键

651
00:33:05,686 --> 00:33:09,957
我们可以说我们有一个词典
它有任意组键值对

652
00:33:10,724 --> 00:33:13,493
当你序列化这个词典 然后打印它

653
00:33:13,694 --> 00:33:15,562
值以随意的顺序被打印出来

654
00:33:16,163 --> 00:33:19,800
但你现可以添加这个sortedKeys选项
让它们按照顺序打印

655
00:33:19,867 --> 00:33:24,238
一个重要的使用例子是
可以区分JSON文件

656
00:33:24,304 --> 00:33:28,475
它可以提高可读性 也会好很多

657
00:33:28,742 --> 00:33:30,811
这曾经是一个被强烈要求的功能

658
00:33:30,878 --> 00:33:33,514
所以我们很高兴将其提供给你们

659
00:33:38,519 --> 00:33:41,722
NSItemProvider
现在可以使它的操作更加明确

660
00:33:42,122 --> 00:33:47,127
它也支持进度报告 比如
NSXPCConnection和URLSession

661
00:33:47,294 --> 00:33:48,929
你可能看到了趋势

662
00:33:49,263 --> 00:33:51,698
它也允许你增强自定义类

663
00:33:51,765 --> 00:33:54,868
与多个陈述一起 比如数据

664
00:33:55,969 --> 00:33:58,605
所以我们在这个版本API
和发布上花费大量心思

665
00:33:58,672 --> 00:34:02,576
实际上是被我们在iOS上的
添加的拖放功能所激励的

666
00:34:02,809 --> 00:34:06,613
所以若你想知道更多相关内容
你可以关注一下周四的演讲

667
00:34:08,215 --> 00:34:11,518
NSUserActivity已经有
一个webpageURL属性

668
00:34:11,985 --> 00:34:16,223
但是现在你可以指定链接
指向那个webpageURL

669
00:34:16,290 --> 00:34:17,524
这是非常方便的

670
00:34:18,926 --> 00:34:22,696
现在我们为好几个类
添加了新的可用API

671
00:34:22,763 --> 00:34:26,333
这允许更好的错误处理和方便的方法

672
00:34:26,500 --> 00:34:28,569
接收URL而不是字符串

673
00:34:28,902 --> 00:34:33,139
而且举个例子[听不清]
NSTasks 你看到它使用一个URL

674
00:34:33,340 --> 00:34:35,676
也返回一个NSError

675
00:34:35,943 --> 00:34:40,848
所以 处理中 它抛出
而不是提出一个异常

676
00:34:44,518 --> 00:34:50,791
对于NSDictionary和NSArray
已经有一些处理错误的方法

677
00:34:50,858 --> 00:34:55,429
但是现在我们有了更易用的方便方法

678
00:34:55,495 --> 00:34:59,066
更加简洁 帮助你做正确的事情
这是非常好的

679
00:35:01,001 --> 00:35:05,939
在NSError 我们有一个新键
使你能展示这个错误

680
00:35:06,006 --> 00:35:07,741
以一种与用户更加关联的方式

681
00:35:07,808 --> 00:35:09,977
所以你可以定制“什么失败了”

682
00:35:10,043 --> 00:35:14,014
同时仍然保持“为什么它失败了”
举个这样的例子

683
00:35:14,815 --> 00:35:17,417
这个错误消息 非常正经的消息

684
00:35:17,518 --> 00:35:20,254
然而 它有一些信息
可能不一定是

685
00:35:20,454 --> 00:35:24,458
与用户特别相关
比如ImgDatabaseV2

686
00:35:25,092 --> 00:35:29,396
对于它们 可能意味着任何东西
是吧？现在有了这个新的键

687
00:35:29,530 --> 00:35:33,200
你可以给它们一个错误
仍然传递同样的信息

688
00:35:33,267 --> 00:35:36,003
同样的错误
但是以一种更易接受的方式

689
00:35:36,103 --> 00:35:37,838
对于用户也更加容易理解

690
00:35:39,940 --> 00:35:42,776
现在我们可以在NSRanges

691
00:35:42,843 --> 00:35:47,748
和Swift之间更加简单地转换
所以在这个例子中 非常好

692
00:35:49,116 --> 00:35:51,985
在这个例子中 我们使用了
NSRegularExpression

693
00:35:52,152 --> 00:35:55,923
它只接收了NSRange
然后我们有一个初始化

694
00:35:55,989 --> 00:35:59,159
对于NSRange 它接收了
一个Swift范围和一个Swift字符串

695
00:35:59,693 --> 00:36:01,828
另一方面
我们有一个初始化器

696
00:36:01,895 --> 00:36:04,765
和接收一个NSRange和
同样Swift字符串的范围

697
00:36:05,032 --> 00:36:07,768
所以如你所见
更加简洁 更加简单

698
00:36:07,835 --> 00:36:10,938
对于那些受苦于写这个代码的人

699
00:36:11,171 --> 00:36:14,107
我希望这能让你开心
因为这是非常好的

700
00:36:15,108 --> 00:36:18,278
在这个Foundation的版本中
我们有很多性能提升

701
00:36:18,345 --> 00:36:19,479
这是非常令人兴奋的

702
00:36:19,880 --> 00:36:23,450
我们现支持了写时拷贝技术
和几个容器

703
00:36:23,617 --> 00:36:26,854
这意味着复制
已经从容器初始创建被移动

704
00:36:26,920 --> 00:36:31,158
到容器第一次发生了突变

705
00:36:31,525 --> 00:36:34,628
它为了更快创建

706
00:36:34,862 --> 00:36:37,731
你可以只创建它们
然后需要的时候扔掉它们

707
00:36:38,999 --> 00:36:42,035
数据现在你的应用中 使它更快

708
00:36:42,202 --> 00:36:46,473
它就更快了
而且它也是自己的子类型

709
00:36:47,875 --> 00:36:52,579
通过NSCalendar的
历法计算现在快了很多

710
00:36:52,646 --> 00:36:57,184
准确很多
也花费了更少的内存

711
00:36:58,819 --> 00:37:02,589
我们也支持更快从/到Swift
桥接到NSNumber

712
00:37:03,056 --> 00:37:06,860
我们在周五1:15有一场演讲
会对这些深入探讨

713
00:37:06,927 --> 00:37:08,562
我强烈推荐你们去参加

714
00:37:10,097 --> 00:37:14,134
我确定你们中很多人知道了
NSArchiver和NSUnarchiver

715
00:37:14,201 --> 00:37:18,105
在10.4中被替代了
现在它们正式被舍弃了

716
00:37:18,405 --> 00:37:20,440
但是 旧格式还是支持的

717
00:37:20,541 --> 00:37:23,210
所以你仍然可以
通过NSUnarchiver解压

718
00:37:23,510 --> 00:37:26,847
但是 代表Cocoa框架部门

719
00:37:27,147 --> 00:37:31,718
我们要求你们从现在开始使用
NSKeyedArchiver 谢谢

720
00:37:32,452 --> 00:37:34,855
Core Data现在有一些
新的索引功能

721
00:37:34,922 --> 00:37:37,124
也支持持续性历史

722
00:37:37,591 --> 00:37:39,693
现在macOS上也有
Core Spotlight了

723
00:37:39,760 --> 00:37:42,196
在iOS上有热通知

724
00:37:42,796 --> 00:37:47,467
所以他们会在演讲中谈到更多细节

725
00:37:47,534 --> 00:37:48,936
本周将有这些演讲

726
00:37:49,002 --> 00:37:51,605
事实上 Core Data的演讲
就在这个后面

727
00:37:52,005 --> 00:37:53,407
所以你要使用时间转换器

728
00:37:53,473 --> 00:37:55,976
这样你就可以
在触控条演讲或者那个演讲

729
00:37:56,877 --> 00:38:02,015
总结一下
阿里端上了API优化的开胃菜

730
00:38:02,115 --> 00:38:03,951
以及第一道AppKit的主菜

731
00:38:04,151 --> 00:38:06,286
我端上了第二道主菜Foundation

732
00:38:06,486 --> 00:38:09,122
作为甜点 我将告诉你们
发布版本记录

733
00:38:09,256 --> 00:38:12,693
建议你们自己去看看
获得很多事例代码

734
00:38:12,759 --> 00:38:16,129
以及对于大量的改动的详尽解释

735
00:38:16,196 --> 00:38:18,198
和改进 那些是我们这个版本发布的

736
00:38:18,398 --> 00:38:20,834
欲知更多信息
你可以查看这个链接

737
00:38:21,201 --> 00:38:23,604
另一个提醒是
在Twitter上发布你们的小技巧

738
00:38:23,770 --> 00:38:27,307
有可能你们的小窍门最终会展示到

739
00:38:27,374 --> 00:38:29,543
周五的演讲中
那是非常令人兴奋的

740
00:38:30,310 --> 00:38:33,747
这是一些相关的演讲
很多我们在本场演讲中都已经提到了

741
00:38:34,114 --> 00:38:35,349
谢谢大家

