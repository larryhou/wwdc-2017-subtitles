1
00:00:20,320 --> 00:00:22,155
下午好

2
00:00:23,490 --> 00:00:25,926
很高兴今天在这里看到这么多人

3
00:00:26,360 --> 00:00:29,930
来观看演讲505
“照片API新特性”

4
00:00:30,097 --> 00:00:33,400
我叫Eric Hanson
是照片平台的传道者

5
00:00:33,700 --> 00:00:35,269
今天下午我将在这里

6
00:00:35,335 --> 00:00:37,871
和我的两位同事一起
他们都来自照片工程师团队

7
00:00:38,438 --> 00:00:41,375
来讨论关于在照片应用里很多
很多全新的强大功能

8
00:00:41,441 --> 00:00:44,878
在iOS以及macOS High Sierra里

9
00:00:46,380 --> 00:00:50,150
所以 显然 我们齐聚一堂
是因为我们都关注摄影

10
00:00:51,518 --> 00:00:54,454
并且我们的用户
肯定你们大多数也知道

11
00:00:54,521 --> 00:00:56,557
都极为关注摄影

12
00:00:56,924 --> 00:00:59,893
每天在世界各地

13
00:00:59,960 --> 00:01:04,063
iOS设备会捕获数以百万计的照片

14
00:01:04,798 --> 00:01:08,068
因此库在不断增加

15
00:01:08,135 --> 00:01:13,707
充满大量回忆和有意义的瞬间

16
00:01:14,007 --> 00:01:17,144
用户们重温时将会非常愉快

17
00:01:17,878 --> 00:01:22,850
因此我们将谈谈如何在应用里
创建美好的体验

18
00:01:23,250 --> 00:01:25,319
并如何集成到Photo Library中

19
00:01:25,385 --> 00:01:29,690
我们有一些非常棒的全新API
能让这种操作变得非常简单

20
00:01:31,058 --> 00:01:33,093
我们还想讲讲

21
00:01:33,794 --> 00:01:36,530
如何在应用中高效达到这个目的

22
00:01:36,597 --> 00:01:40,334
并确保应用里的响应速度

23
00:01:40,400 --> 00:01:42,202
是尽可能快的

24
00:01:42,503 --> 00:01:44,404
我们也会讲这部分内容

25
00:01:45,739 --> 00:01:48,642
最后 我们想要以一种

26
00:01:49,009 --> 00:01:51,912
不违反用户对我们的信任的方式

27
00:01:52,212 --> 00:01:54,781
我们不会强迫用户放弃隐私

28
00:01:55,048 --> 00:01:59,753
只因为他们想把自己的照片
集成到你的应用中

29
00:02:00,320 --> 00:02:01,955
这方面内容我们也会讲到

30
00:02:02,456 --> 00:02:05,125
讲完这最后一点
我想欢迎上台的是

31
00:02:05,826 --> 00:02:07,794
我的第一位在照片工程团队的同事

32
00:02:07,861 --> 00:02:10,130
Hasan Adil
Hasan

33
00:02:14,134 --> 00:02:14,968
谢谢你 Eric

34
00:02:16,570 --> 00:02:18,372
大家好 很高兴见到你们

35
00:02:21,441 --> 00:02:24,878
UIImagePickerController
是一个简单好用的API

36
00:02:25,078 --> 00:02:28,248
可以在你的应用里选择照片和视频

37
00:02:29,183 --> 00:02:33,353
iOS 11有许多优秀的改进和新功能

38
00:02:33,420 --> 00:02:35,589
今天我很激动能和大家分享

39
00:02:35,822 --> 00:02:37,291
（照片-时刻-相机胶卷）

40
00:02:37,357 --> 00:02:38,859
（我的相簿）

41
00:02:38,926 --> 00:02:43,397
在Apple 我们十分关心
用户的隐私和安全

42
00:02:46,166 --> 00:02:49,837
因此 任何显示
UIImagePickerController时

43
00:02:50,137 --> 00:02:51,371
我们都要求

44
00:02:51,605 --> 00:02:55,375
获得用户的授权来使用整个图库

45
00:02:55,542 --> 00:02:57,945
为了选择一张照片或视频

46
00:02:58,011 --> 00:02:59,880
（“VACATION DIARY”
想要访问你的照片）

47
00:02:59,947 --> 00:03:02,482
我想你们对这个警告信息
都非常熟悉

48
00:03:03,851 --> 00:03:05,619
这在应用中产生了摩擦

49
00:03:06,420 --> 00:03:08,856
并让用户放弃了一级隐私

50
00:03:09,022 --> 00:03:10,657
这也许并不是他们想要做的

51
00:03:11,391 --> 00:03:15,629
并且程序无法执行
即便它有很多优秀的功能

52
00:03:15,896 --> 00:03:17,631
只因为用户不想让程序访问

53
00:03:18,465 --> 00:03:20,534
我们认为自己可以做得更好

54
00:03:21,668 --> 00:03:26,340
因此在iOS 11 我们重新设计了
隐私安全的基础

55
00:03:26,607 --> 00:03:28,108
关于UIImagePickerController

56
00:03:29,209 --> 00:03:30,644
我们一开始定了三个目标

57
00:03:31,879 --> 00:03:34,014
让用户决定内容

58
00:03:35,282 --> 00:03:38,318
在应用里创造良好的用户体验

59
00:03:39,987 --> 00:03:44,958
第三 给用户更高级别隐私

60
00:03:45,893 --> 00:03:51,465
因此 我很高兴地宣布 在iOS 11
这个警告不会出现

61
00:03:52,799 --> 00:03:53,867
就直接成功运行

62
00:03:58,038 --> 00:03:59,840
我们来看一个演示
可以清楚地了解

63
00:04:01,175 --> 00:04:03,644
这是有一个应用 我刚从App Store下载

64
00:04:03,744 --> 00:04:05,312
我很高兴可以运行它

65
00:04:05,512 --> 00:04:07,681
我很充实 今天在WWDC过得很高兴

66
00:04:07,814 --> 00:04:09,316
有点紧张 不过不要紧

67
00:04:09,983 --> 00:04:11,418
我想附上一张照片

68
00:04:12,052 --> 00:04:12,886
让我们来看一下

69
00:04:12,953 --> 00:04:16,089
在iOS 11中启动UIImagePicker时
会是什么样子

70
00:04:16,990 --> 00:04:18,024
直接成功了

71
00:04:18,791 --> 00:04:23,163
在 iOS 11 UIImagePickerController
成为一个自动处理API

72
00:04:23,830 --> 00:04:28,836
这指的是 我们显示API里的内容

73
00:04:29,036 --> 00:04:32,072
从一个自动处理的沙盒和安全环境中

74
00:04:32,539 --> 00:04:36,009
应用不再访问用户的Photo Library

75
00:04:37,211 --> 00:04:41,481
只有用户本人可以和
UIImagePickerController UI进行互动

76
00:04:43,217 --> 00:04:44,751
当用户做出了一个选择

77
00:04:45,319 --> 00:04:49,156
我们取出选中的照片或视频
发送到你的应用

78
00:04:50,657 --> 00:04:53,227
我们认为这将消除应用中的摩擦

79
00:04:53,427 --> 00:04:56,630
并且让用户有了非常高级别的隐私

80
00:04:57,397 --> 00:05:00,868
因为不存在授权 也不会有询问

81
00:05:01,768 --> 00:05:04,505
希望大家喜欢这点 使用起来非常容易

82
00:05:04,605 --> 00:05:07,341
你不用多做什么 直接操作即可

83
00:05:10,077 --> 00:05:12,012
照片包含丰富的元数据

84
00:05:12,446 --> 00:05:14,181
包括创建日期

85
00:05:14,481 --> 00:05:15,916
照片的格式

86
00:05:16,149 --> 00:05:17,851
以及其他不同的元数据

87
00:05:18,519 --> 00:05:21,455
在iOS 11 获取这些信息变得非常容易

88
00:05:22,789 --> 00:05:24,525
我们现在提供一个全新的键

89
00:05:24,591 --> 00:05:27,060
包含所有
UIImagePickerController的结果

90
00:05:27,227 --> 00:05:30,697
该键被称为
UIImagePickerControllerImageURL

91
00:05:32,833 --> 00:05:35,335
该URL是个文件URL

92
00:05:35,602 --> 00:05:38,272
指向一个应用中的临时文件

93
00:05:39,139 --> 00:05:41,308
如果想之后继续操作

94
00:05:41,675 --> 00:05:44,311
我们建议把文件移动到更永久的位置

95
00:05:44,711 --> 00:05:45,546
所以它会一直在那里

96
00:05:46,747 --> 00:05:48,348
你可以使用一个URL

97
00:05:48,615 --> 00:05:52,953
也可以把NSData读入应用
并按照需要进行处理

98
00:05:59,059 --> 00:06:03,063
在iOS 11 我们还为照片引进了
一种新格式叫HEIF

99
00:06:04,264 --> 00:06:08,769
我们意识到生态系统完全接受HEIF
需要一段时间

100
00:06:09,002 --> 00:06:12,105
我们利用UIImagePickerController
让它变得非常容易

101
00:06:13,607 --> 00:06:16,677
我们有了一个新属性
名为imageExportPresent

102
00:06:17,945 --> 00:06:19,413
它可以被设为两种类型

103
00:06:19,546 --> 00:06:22,382
可以设为兼容模式
也可以设为当前模式

104
00:06:22,683 --> 00:06:23,517
我们来看一下

105
00:06:25,552 --> 00:06:26,920
在兼容模式

106
00:06:27,654 --> 00:06:32,926
如果用户选中的源照片是HEIF格式

107
00:06:33,560 --> 00:06:36,897
我们将输送一个Jpeg
并给出它的Jpeg版本

108
00:06:38,131 --> 00:06:40,467
这也是该属性的默认值

109
00:06:40,968 --> 00:06:44,137
如果不需要有什么改变
就什么都不用做

110
00:06:45,606 --> 00:06:50,511
然而 如果需要照片格式
和拍摄时相同

111
00:06:50,811 --> 00:06:52,012
只需把属性值设为当前模式

112
00:06:52,212 --> 00:06:55,082
将会输出和Photo Library里
相同格式的照片

113
00:06:55,215 --> 00:06:57,784
将会得到HEIF格式 可以继续处理

114
00:06:59,219 --> 00:07:00,053
（获取视频）

115
00:07:00,120 --> 00:07:03,557
在选择视频方面 我们有很好的改进

116
00:07:05,425 --> 00:07:07,227
但暂时把这部分内容放在一边

117
00:07:08,328 --> 00:07:11,598
AVFoundation是Apple的框架
服务于丰富编辑

118
00:07:11,665 --> 00:07:13,433
以及照片播放

119
00:07:14,468 --> 00:07:19,239
AVFoundation拥有导出预设的丰富集合
也可以说是格式

120
00:07:20,674 --> 00:07:21,775
我很高兴宣布

121
00:07:22,176 --> 00:07:24,811
UIImagePickerController
支持所有格式

122
00:07:26,446 --> 00:07:28,949
我们有一个新属性叫作
videoExportPreset

123
00:07:30,651 --> 00:07:33,654
可以用这种方法告诉我们

124
00:07:33,820 --> 00:07:37,157
你想要选中的视频以哪种格式返回

125
00:07:38,625 --> 00:07:39,626
让我们来看一个例子

126
00:07:42,829 --> 00:07:47,434
导入AVFoundation后 将会创建一个
UIImagePickerController的实例

127
00:07:47,734 --> 00:07:49,837
并告诉我们想要哪种格式

128
00:07:51,038 --> 00:07:54,007
这里我要求最高品质的视频

129
00:07:55,409 --> 00:07:56,410
然后显示选取器

130
00:07:56,476 --> 00:07:59,847
当用户做出选择时
无论是什么格式

131
00:08:00,180 --> 00:08:04,151
我们会对其进行交叉编译
得到匹配格式 然后返回给用户

132
00:08:05,085 --> 00:08:07,821
这将非常有用
对于想让视频返回

133
00:08:07,888 --> 00:08:10,123
用最初形成的原始格式

134
00:08:12,025 --> 00:08:14,828
关于可用预设的完整清单

135
00:08:15,429 --> 00:08:18,765
请查看该接口 叫作
AVAssetExportSession

136
00:08:20,000 --> 00:08:22,069
或者到实验室来找我们
我们将竭诚帮助你

137
00:08:23,403 --> 00:08:25,339
（保存照片和视频）

138
00:08:25,405 --> 00:08:28,041
关于我之前讲到的增加隐私

139
00:08:28,108 --> 00:08:32,846
我们还深入研究了
如何在Photo Library里添加内容

140
00:08:34,081 --> 00:08:35,883
现在 既然我们已经实现了无缝选取

141
00:08:36,450 --> 00:08:38,751
我们应该也可以做到让添加更完美

142
00:08:40,020 --> 00:08:42,121
因此 在iOS 11

143
00:08:42,322 --> 00:08:44,791
如果采用这两种方法的任意一种

144
00:08:45,058 --> 00:08:49,296
保存一张照片或一段视频
到用户的图片库

145
00:08:49,763 --> 00:08:52,766
我们有一个全新的安全模型
以及权限级别

146
00:08:54,635 --> 00:08:57,704
这两种方法任意一种的权限级别

147
00:08:57,771 --> 00:08:59,006
在UIImagePickerController里

148
00:08:59,540 --> 00:09:03,010
一个叫作
UIImageWriteToSavePhotosAlbum

149
00:09:03,210 --> 00:09:07,814
另一个叫作UISaveVideoAtPath
ToSavedPhotosAlbum

150
00:09:09,049 --> 00:09:10,851
它们要求只添加授权

151
00:09:11,652 --> 00:09:14,354
对于用户来说是很小的要求

152
00:09:14,555 --> 00:09:18,892
因为这将允许你
添加内容到Photo Library 而不是读取

153
00:09:19,426 --> 00:09:22,162
我们认为用户很大可能会给出

154
00:09:22,229 --> 00:09:23,197
这个权限

155
00:09:24,531 --> 00:09:27,701
如前所述 如果有任何问题
请到实验室找我们

156
00:09:29,837 --> 00:09:32,472
对于PhotoKit的用户
我们提供了一些很好的功能

157
00:09:33,674 --> 00:09:37,110
现在对于每一个
UIImagePickerController的结果

158
00:09:37,477 --> 00:09:40,080
如果你是PhotoKit用户

159
00:09:41,815 --> 00:09:45,419
我们会返回的PHAsset对象
该对象和用户选择相匹配

160
00:09:46,820 --> 00:09:51,358
这可以让API间的PhotoKit无缝集成

161
00:09:52,159 --> 00:09:53,160
让我们看一个例子

162
00:09:53,794 --> 00:09:55,796
这里我实现了一个代理方法

163
00:09:55,929 --> 00:09:57,731
UImagePickerController的代理方法

164
00:09:58,866 --> 00:10:01,835
当获得结果词典时
有了一个全新的键

165
00:10:01,902 --> 00:10:05,305
该键名为
UIImagePickerControllerPHAsset

166
00:10:06,039 --> 00:10:09,676
取得该键的值 该键将会成为资产对象

167
00:10:09,877 --> 00:10:10,944
将可以对其进行自由使用

168
00:10:12,412 --> 00:10:15,649
现在 与此同时

169
00:10:16,183 --> 00:10:19,152
之前我们弃用了ALAssetsLibrary框架

170
00:10:20,254 --> 00:10:23,490
现在ALAssetsLibrary引用了URL

171
00:10:23,557 --> 00:10:28,262
即我们之前传给你的使用了一个键名为
UIImagePickerController

172
00:10:28,495 --> 00:10:30,864
引用URL现在也已被弃用

173
00:10:32,466 --> 00:10:34,635
是的 PhotoKit非常好
你们会热爱它

174
00:10:36,270 --> 00:10:39,840
我们认为通过这些改变
增强用户隐私

175
00:10:40,607 --> 00:10:45,345
让UImagePickerController成为
更强大而功能齐全的API

176
00:10:45,779 --> 00:10:49,149
将会满足市面上大部分应用的需求

177
00:10:50,584 --> 00:10:52,653
然而 有时会出现

178
00:10:52,853 --> 00:10:55,522
需要和照片框架进行更深入的集成

179
00:10:56,323 --> 00:10:58,225
这时我们推荐PhotoKit

180
00:10:59,026 --> 00:11:01,929
iOS 11中的PhotoKit有哪些新功能

181
00:11:02,229 --> 00:11:04,331
请欢迎我的同事来讲解
Andreas Karlsson

182
00:11:08,035 --> 00:11:08,869
谢谢你 Hasan

183
00:11:13,340 --> 00:11:16,109
所以 和照片有关的应用一直以来

184
00:11:16,176 --> 00:11:18,412
是App Store里最受欢迎的应用

185
00:11:19,046 --> 00:11:22,349
既要功能优秀 也要良好的用户体验

186
00:11:22,516 --> 00:11:24,017
才能赢得市场

187
00:11:24,518 --> 00:11:25,686
今天我十分激动在这里

188
00:11:25,752 --> 00:11:28,155
讲解我们在PhotoKit做出的改进

189
00:11:28,555 --> 00:11:31,758
希望可以让你们写出更优秀的新功能

190
00:11:32,059 --> 00:11:35,395
并让你们的应用更容易地增强用户体验

191
00:11:36,363 --> 00:11:37,197
让我们马上开始

192
00:11:37,331 --> 00:11:38,765
首先来看一下Live Photo效果

193
00:11:39,099 --> 00:11:41,101
周一Keynote演讲上刚刚宣布

194
00:11:42,302 --> 00:11:44,738
Live Photo效果包括这些循环

195
00:11:45,072 --> 00:11:47,508
是通过仔细分析视频所创建的

196
00:11:47,574 --> 00:11:52,045
并无缝和这些无止境循环缝合到一起

197
00:11:53,080 --> 00:11:56,350
还包含这些弹跳 其工作原理相似

198
00:11:56,416 --> 00:11:58,452
但是可以看到 在狗身上表现得更好

199
00:11:59,419 --> 00:12:01,922
最后 是长时间曝光

200
00:12:02,356 --> 00:12:05,158
它将分析Live Photo的视频帧

201
00:12:05,325 --> 00:12:07,461
创建这些令人惊艳的静物

202
00:12:09,129 --> 00:12:11,398
所以 我们相信用户将会
从中获得诸多乐趣

203
00:12:11,465 --> 00:12:14,168
我们也十分期待看到
你们的应用里会出现的创新

204
00:12:14,268 --> 00:12:16,370
在集成这些新的媒体类型时

205
00:12:17,304 --> 00:12:19,473
所以 来看看该如何实现
以及一些代码

206
00:12:21,975 --> 00:12:25,345
这些就是现存的PhotoKit媒体类型

207
00:12:26,113 --> 00:12:28,715
它们都非常好 描述什么是资产

208
00:12:28,949 --> 00:12:32,019
但是更重要的是 资产如何表现

209
00:12:32,386 --> 00:12:33,854
让我来解释一下这句话的意思

210
00:12:34,621 --> 00:12:36,323
如果用户拍摄了一段视频

211
00:12:36,456 --> 00:12:40,427
他们会想要在你的应用里
观看并将该资产以视频方式使用

212
00:12:41,028 --> 00:12:42,596
如果用户拍摄了一张Live Photo

213
00:12:42,663 --> 00:12:46,333
会对静止部分和视频部分同等关注

214
00:12:46,834 --> 00:12:49,436
因此用户会想要在应用中
看到该资产以Live Photo的方式呈现

215
00:12:50,370 --> 00:12:53,707
目前为了实现这一点
请看这里有三种媒体类型

216
00:12:53,807 --> 00:12:56,677
Image video和photoLive
来实现目标

217
00:12:57,811 --> 00:13:00,547
Live Photo效果有一点复杂

218
00:13:00,614 --> 00:13:04,117
为了更简化地达成目标
因为这如此重要

219
00:13:04,751 --> 00:13:05,986
今年在iOS 11

220
00:13:06,053 --> 00:13:10,190
我们引进了全新的PHAsset属性
名为playbackStyle

221
00:13:11,525 --> 00:13:14,695
现在PlaybackStyle是唯一属性
可以查看和决定

222
00:13:14,828 --> 00:13:17,064
要使用什么样的图片管理器API

223
00:13:17,431 --> 00:13:18,966
用什么样的视图来表现

224
00:13:19,233 --> 00:13:21,869
以及为该视图设置什么样UI限制

225
00:13:23,270 --> 00:13:25,205
因此 我们更新了PhotoKit示例应用

226
00:13:25,372 --> 00:13:27,140
包含所有这些新的播放风格

227
00:13:27,474 --> 00:13:29,476
但我想更深入地介绍其中三种

228
00:13:29,543 --> 00:13:32,813
它们和本次演讲的Live Photo效果相关

229
00:13:33,647 --> 00:13:35,015
首先从imageAnimated开始

230
00:13:36,884 --> 00:13:38,852
今年新出现的功能
在内置应用“照片”

231
00:13:38,919 --> 00:13:41,221
是支持动画GIF播放

232
00:13:46,426 --> 00:13:47,861
若要在你的应用中播放GIF

233
00:13:48,428 --> 00:13:50,697
需要从图像管理器请求图像数据

234
00:13:50,797 --> 00:13:53,700
然后使用图像IO和核心图形进行播放

235
00:13:53,934 --> 00:13:57,171
现在 示例应用包含了
一个如何实现的例子

236
00:13:57,271 --> 00:14:00,741
所以 若要播放GIF 请查看示例应用

237
00:14:01,842 --> 00:14:03,977
接下来是Live Photo

238
00:14:04,978 --> 00:14:07,247
Live Photos用户很关注Live Photos

239
00:14:07,314 --> 00:14:10,417
因此在应用中正确表现它们非常重要

240
00:14:10,484 --> 00:14:11,718
但也非常简单

241
00:14:12,452 --> 00:14:15,856
所以 在这个例子里
从图像管理器请求一张Live Photo

242
00:14:15,956 --> 00:14:19,326
然后设置PHLivePhotoView播放

243
00:14:20,327 --> 00:14:21,962
设成Live Photo 回到视图

244
00:14:22,029 --> 00:14:25,632
用户就可以轻触播放一张Live Photo

245
00:14:25,699 --> 00:14:27,601
正如用户在内置“照片”应用
的操作一样

246
00:14:27,935 --> 00:14:28,769
在你的应用里

247
00:14:29,403 --> 00:14:31,872
PHLivePhotoView也可以和
Live Photos一起使用

248
00:14:31,939 --> 00:14:33,440
在用户的Photo Library之外

249
00:14:33,740 --> 00:14:36,577
举个例子 如果通过Web服务器
或类似的工具传输

250
00:14:38,545 --> 00:14:40,747
最后 包含循环的视频

251
00:14:40,848 --> 00:14:43,851
既包括弹跳 也包括循环的
Live Photo效果

252
00:14:44,418 --> 00:14:45,619
今年所推出的

253
00:14:46,987 --> 00:14:50,057
现在 在你的应用里播放这些
和播放普通视频非常相似

254
00:14:50,123 --> 00:14:53,227
可以请求播放器项目
并使用AVFoundation播放

255
00:14:53,560 --> 00:14:56,797
还可以使用AVPlayerLooper
取得循环效果

256
00:14:59,066 --> 00:15:02,402
所以我希望你们看到
表现用户的媒体是多么简单

257
00:15:02,469 --> 00:15:04,238
以他们真正想表现的方式

258
00:15:04,404 --> 00:15:07,374
但我们更期待你们
在各自的应用中的创新表现

259
00:15:07,541 --> 00:15:09,176
和这些全新的媒体类型相关

260
00:15:10,477 --> 00:15:12,846
接下来 我想要讲讲
iCloud Photo Library

261
00:15:15,182 --> 00:15:17,684
iCloud Photo Library非常好

262
00:15:17,751 --> 00:15:20,587
因为现在用户可以把整个
Photo Library

263
00:15:20,721 --> 00:15:21,555
装入口袋

264
00:15:21,822 --> 00:15:25,492
对于一些图库非常大的用户来说
这个功能非常好

265
00:15:26,493 --> 00:15:30,430
有些用户的Photo Library
会有超过十万张照片

266
00:15:30,631 --> 00:15:32,165
实际上这很常见

267
00:15:33,333 --> 00:15:35,135
什么样的用户会有那么多照片？

268
00:15:35,235 --> 00:15:39,473
想要有十万张照片的话
则必须每天拍28张照片

269
00:15:39,840 --> 00:15:42,142
坚持每天拍 一直拍十年

270
00:15:42,543 --> 00:15:46,480
因此这些用户显然
非常喜欢相机和使用“相机”应用

271
00:15:47,114 --> 00:15:50,484
但他们也倾向于下载和使用
很多照片相关的应用

272
00:15:51,285 --> 00:15:54,421
这些用户对于这个房间里的我们
非常重要

273
00:15:56,190 --> 00:16:00,227
现在想象 这些用户中的其中一员
在拍完每天的28张照片以后

274
00:16:00,694 --> 00:16:02,863
他们会去App Store搜索有趣的应用

275
00:16:03,397 --> 00:16:04,765
他们找到了你的应用

276
00:16:05,465 --> 00:16:07,434
他们决定下载下来试试看

277
00:16:07,835 --> 00:16:10,971
当他们开始使用你的应用时
首先看到的是这个

278
00:16:14,708 --> 00:16:18,378
加载图标持续好几秒钟
可不是好的用户体验

279
00:16:18,612 --> 00:16:21,315
该用户可能会马上卸载你的应用

280
00:16:21,815 --> 00:16:23,584
或者更糟糕 给个差评

281
00:16:24,952 --> 00:16:27,955
所以 你会想 我的应用不会这样做

282
00:16:28,021 --> 00:16:32,559
如果出现这种情况 我在使用PhotoKit
该用户的图库非常之大

283
00:16:32,926 --> 00:16:34,328
也许这就是必然结果

284
00:16:36,430 --> 00:16:37,998
PhotoKit一开始设计

285
00:16:38,065 --> 00:16:41,802
就是为了非常快速和高效地
操作大型Photo Library

286
00:16:42,436 --> 00:16:44,505
但客户通常会犯一些错误

287
00:16:44,638 --> 00:16:47,074
会意味着操作时间的差距

288
00:16:47,407 --> 00:16:49,576
从10毫秒到10秒

289
00:16:50,944 --> 00:16:52,546
所以该如何修正？

290
00:16:52,613 --> 00:16:55,482
由于很容易结束一个耗时太久的东西

291
00:16:56,049 --> 00:17:00,254
第一步即为用一个巨大的
Photo Library测试你的应用

292
00:17:01,588 --> 00:17:03,290
我们讲过这样做有些难度

293
00:17:03,357 --> 00:17:05,192
用“照片”应用获取那么多照片

294
00:17:05,759 --> 00:17:08,228
因此今年我们想让它变得非常简单

295
00:17:08,595 --> 00:17:10,564
我们提供了一个示例应用下载

296
00:17:10,631 --> 00:17:12,232
名为Photo Library Filler

297
00:17:13,267 --> 00:17:15,368
下载该应用并安装到你的测试设备

298
00:17:15,669 --> 00:17:19,339
它会迅速生成一个巨大的库供测试使用

299
00:17:21,074 --> 00:17:21,909
很好

300
00:17:26,680 --> 00:17:29,583
很好 一个巨大的库产生了
测试你的应用

301
00:17:30,050 --> 00:17:31,885
有可能会看到 开始出现延迟

302
00:17:32,653 --> 00:17:34,021
因此我想讲将

303
00:17:34,121 --> 00:17:36,523
客户使用PhotoKit中的两个常见问题

304
00:17:36,590 --> 00:17:37,457
及其解决方法

305
00:17:38,825 --> 00:17:39,960
让我们看一段代码

306
00:17:41,595 --> 00:17:44,364
这是如何从用户的
Photo Library提取图片

307
00:17:44,431 --> 00:17:45,532
有两个部分

308
00:17:45,699 --> 00:17:48,836
这是提取数据库的部分
然后是处理结果

309
00:17:49,970 --> 00:17:52,139
首先来看数据库提取部分

310
00:17:53,140 --> 00:17:55,509
在这里 我们提取库里所有资产

311
00:17:55,576 --> 00:17:58,212
但我们用一个筛选器谓词筛选

312
00:17:58,345 --> 00:17:59,379
最喜欢资产

313
00:17:59,613 --> 00:18:01,315
并且按照创建日期排序

314
00:18:02,583 --> 00:18:04,551
如果你进行这一类的自定义提取

315
00:18:04,852 --> 00:18:06,253
应用一定支持

316
00:18:06,553 --> 00:18:09,323
但是如果在这些自定义提取里发现延迟

317
00:18:09,857 --> 00:18:12,926
则简化谓词十分必要

318
00:18:12,993 --> 00:18:14,428
或者简化描述符

319
00:18:14,828 --> 00:18:16,063
会意味着差异产生

320
00:18:16,129 --> 00:18:20,067
查询耗时10毫秒和10秒

321
00:18:20,801 --> 00:18:22,669
造成这种巨大差异的原因

322
00:18:23,270 --> 00:18:26,773
是你可能在数据库优化路径之外

323
00:18:27,174 --> 00:18:29,543
试图回到优化路径中

324
00:18:29,610 --> 00:18:30,511
一定有所回报

325
00:18:32,446 --> 00:18:34,781
比这种自定义提取更好的是

326
00:18:34,982 --> 00:18:36,850
尽可能避免这种操作

327
00:18:37,384 --> 00:18:40,854
因此在这个例子 我们实际上提取
用户最喜欢的智能相簿

328
00:18:41,054 --> 00:18:43,490
然后在智能相簿里提取资产

329
00:18:43,790 --> 00:18:46,727
这样既可使用已有的谓词和排序描述符

330
00:18:46,960 --> 00:18:50,797
还可以保证留在PhotoKit的优化路径中

331
00:18:53,333 --> 00:18:55,536
接下来看一下返回结果

332
00:18:55,602 --> 00:18:56,670
从这些提取之一

333
00:18:57,404 --> 00:19:00,107
这个对象是一个PHFetch结果

334
00:19:00,908 --> 00:19:03,477
该PHFetch结果非常像一个数列

335
00:19:03,644 --> 00:19:05,445
并且可以很像一个数组来使用它

336
00:19:05,712 --> 00:19:08,382
可以要求对象和索引

337
00:19:08,882 --> 00:19:11,351
可以要求计数 并对其进行枚举

338
00:19:11,952 --> 00:19:16,590
但从内部来看 提取结果
和数列的工作机制完全不同

339
00:19:16,924 --> 00:19:19,359
并且是PhotoKit
如此快速高效的原因之一

340
00:19:19,526 --> 00:19:20,561
在大型图库操作方面

341
00:19:20,861 --> 00:19:22,462
让我们看看其内部工作机制

342
00:19:24,264 --> 00:19:27,835
最开始它只包含一个标识符列表

343
00:19:28,268 --> 00:19:30,804
这意味可以迅速返回

344
00:19:31,004 --> 00:19:34,141
但开始使用后 更多工作必须执行

345
00:19:35,375 --> 00:19:37,077
让我们看一下枚举作为例子

346
00:19:37,544 --> 00:19:40,347
在这里 我们从索引0开始枚举

347
00:19:41,815 --> 00:19:43,317
目前只有一个标识符

348
00:19:43,383 --> 00:19:45,853
需要从数据库里提取元数据

349
00:19:45,986 --> 00:19:49,756
为了创建一个PHAsset对象
从块中返回给你

350
00:19:51,024 --> 00:19:52,926
现在 提取结果非常智能

351
00:19:52,993 --> 00:19:55,495
它实际上同时创建了一个批处理

352
00:19:55,829 --> 00:19:59,433
因此 当我们继续枚举时
索引1和2已经在内存中

353
00:20:00,167 --> 00:20:02,769
然后枚举继续 你们有所了解

354
00:20:03,170 --> 00:20:04,571
它将访问硬盘

355
00:20:04,671 --> 00:20:07,207
获取后续资产的元数据

356
00:20:09,109 --> 00:20:11,578
因此对于这种少量提取结果
并不受影响

357
00:20:11,812 --> 00:20:15,516
但可以想象该提取结果
包含10万个资产

358
00:20:17,050 --> 00:20:19,486
每一批都占据几千字节内存

359
00:20:20,087 --> 00:20:21,355
但如果有10万批

360
00:20:21,421 --> 00:20:24,024
将会产生几百兆的内存用量

361
00:20:24,858 --> 00:20:28,962
更糟糕的是
每一批都需要几毫秒的提取时间

362
00:20:29,196 --> 00:20:30,631
如果有10万批

363
00:20:30,764 --> 00:20:34,201
就需要耗费10秒钟
来枚举一个大型提取结果

364
00:20:35,169 --> 00:20:38,772
所以在任何情况下
都应该尽量避免枚举操作

365
00:20:40,040 --> 00:20:40,874
我们发现

366
00:20:40,941 --> 00:20:43,911
避免枚举操作总是可能的

367
00:20:44,211 --> 00:20:46,947
我想看一个避免枚举的例子

368
00:20:49,616 --> 00:20:52,819
所以在本例中我们想找到
一个资产的索引

369
00:20:52,886 --> 00:20:54,188
从一个提取结果中

370
00:20:54,888 --> 00:20:56,490
现在我们可以枚举该提取结果

371
00:20:56,557 --> 00:20:59,626
并且用“等于”比较返回的对象

372
00:20:59,927 --> 00:21:02,129
但是如屏幕所见 枚举非常慢

373
00:21:02,763 --> 00:21:05,699
所以更好的方法其实是使用高端API

374
00:21:05,766 --> 00:21:07,668
本例可以使用indexOfObject

375
00:21:08,235 --> 00:21:11,038
这可以使提取结果内部 变得非常智能

376
00:21:11,338 --> 00:21:15,209
并比较寻找的对象标识符

377
00:21:15,509 --> 00:21:17,311
用一个数组定义所需的索引

378
00:21:17,377 --> 00:21:21,181
完全没有附加的硬盘访问或数据库提取

379
00:21:22,015 --> 00:21:23,817
对containsObject也是如此

380
00:21:25,819 --> 00:21:27,721
所以希望你们了解这有多么简单

381
00:21:27,788 --> 00:21:30,290
用一个庞大的库测试你的应用

382
00:21:30,490 --> 00:21:31,425
以及有多么简单

383
00:21:31,491 --> 00:21:34,795
去真正改进应用的性能表现

384
00:21:35,362 --> 00:21:38,732
微小的修正可能意味着节省几秒钟

385
00:21:40,434 --> 00:21:42,669
如果有关于PhotoKit性能的问题

386
00:21:42,736 --> 00:21:44,571
明天早上请到实验室来找我们

387
00:21:44,738 --> 00:21:47,441
如果你遇到了无法解决的问题

388
00:21:47,674 --> 00:21:48,675
请 [听不清]

389
00:21:49,543 --> 00:21:51,945
如果本场演讲只需记住一点

390
00:21:52,346 --> 00:21:54,915
那就是请用大型
Photo Library测试你的应用

391
00:21:55,048 --> 00:21:57,918
并认真照顾那些重要客户的需求

392
00:21:59,686 --> 00:22:02,256
接下来 我想欢迎Eric Hanson回到讲台

393
00:22:02,556 --> 00:22:04,224
讲解照片项目扩展

394
00:22:04,925 --> 00:22:07,694
-Eric
-谢谢你 Andreas

395
00:22:09,429 --> 00:22:10,264
谢谢

396
00:22:10,330 --> 00:22:14,535
我非常 非常激动 终于可以来讲讲

397
00:22:14,601 --> 00:22:17,838
今年我们在High Sierra
一直努力工作的成果

398
00:22:17,971 --> 00:22:20,207
我现在非常需要喝口水 抱歉

399
00:22:22,743 --> 00:22:23,577
好了

400
00:22:25,078 --> 00:22:28,148
所以我们来讲讲照片项目扩展

401
00:22:28,415 --> 00:22:31,985
我觉得要开始讲这个主题
必须要先讲什么是项目

402
00:22:32,819 --> 00:22:35,289
你们知道Apple一直允许用户

403
00:22:35,355 --> 00:22:40,661
创建非常丰富的
有创意的围绕照片展开的项目

404
00:22:40,727 --> 00:22:43,397
很长时间以来在“照片”应用

405
00:22:43,463 --> 00:22:46,066
实际上 这可以追溯到很久以前的
iPhoto 1.0

406
00:22:46,133 --> 00:22:48,402
当我们第一次发布photobooks时

407
00:22:50,304 --> 00:22:52,339
但是今年 我们想要些不同的东西

408
00:22:52,739 --> 00:22:56,343
因为这么长时间以来 14年

409
00:22:56,944 --> 00:22:58,045
作为开发者的你们

410
00:22:58,111 --> 00:23:01,748
已经积累了非常宝贵的经验

411
00:23:01,915 --> 00:23:03,050
在自己开发的应用中

412
00:23:03,851 --> 00:23:06,520
我们认为 你们知道
让我们一起合作

413
00:23:06,720 --> 00:23:09,890
让我们给你们一个机会
真正创造一些东西

414
00:23:10,090 --> 00:23:13,760
直接在“照片”应用中的美好的体验

415
00:23:14,361 --> 00:23:16,663
这正是我们在扩展方面的成果

416
00:23:17,965 --> 00:23:22,035
我们从API着手
只有几个开发者参与其中

417
00:23:22,102 --> 00:23:23,437
看看他们会做出什么

418
00:23:23,504 --> 00:23:25,072
如Shutterfly这样的公司

419
00:23:25,439 --> 00:23:27,374
将会在秋天启动自己的照片集

420
00:23:27,441 --> 00:23:28,675
和照片应用

421
00:23:29,810 --> 00:23:30,944
一家名为WhiteWall的公司

422
00:23:31,011 --> 00:23:34,214
将会允许你制作这些
拥有画廊品质的表框印刷品

423
00:23:36,116 --> 00:23:39,286
Wix.com将会开发全新的功能

424
00:23:39,353 --> 00:23:42,422
让用户方便地创建网络相簿

425
00:23:44,124 --> 00:23:48,595
Animoto公司允许用户创建
这些非常漂亮的影片

426
00:23:48,662 --> 00:23:51,498
由服务器托管并和社交媒体集成

427
00:23:52,833 --> 00:23:57,938
还有一家名为ifolor的公司
做出了非常新颖的创新

428
00:23:58,438 --> 00:24:01,775
他们几乎是白手起家

429
00:24:02,242 --> 00:24:04,411
把这看作一个机会

430
00:24:04,811 --> 00:24:08,415
你知道 他们做出一样产品
能够真正融入到照片的生态系统

431
00:24:08,482 --> 00:24:10,717
并为用户真正创造某种魔法

432
00:24:11,084 --> 00:24:13,053
我觉得与其口头描述

433
00:24:13,253 --> 00:24:14,721
不如给你们放一段快速演示

434
00:24:14,988 --> 00:24:18,058
我们在这里
High Sierra的“照片”应用

435
00:24:18,659 --> 00:24:19,927
我在“回忆”里

436
00:24:19,993 --> 00:24:23,697
在这里有我最喜欢的回忆
我会在其中选择

437
00:24:24,398 --> 00:24:28,101
在侧栏 我可以将鼠标悬停在项目区域

438
00:24:28,168 --> 00:24:29,670
可以看到这个小按钮

439
00:24:30,137 --> 00:24:33,674
你会注意到 除了Apple现有提供的功能

440
00:24:34,508 --> 00:24:36,143
照片应用自动发现

441
00:24:36,210 --> 00:24:38,111
我还安装了另一款应用

442
00:24:39,847 --> 00:24:41,448
名为ifolor wall décor

443
00:24:41,682 --> 00:24:43,750
因此 这个扩展完全显示给我

444
00:24:44,918 --> 00:24:48,689
选中它 然后我面临着几个选项

445
00:24:48,889 --> 00:24:52,192
这些选项都是从扩展本身延伸出来

446
00:24:52,759 --> 00:24:54,561
因此 甚至在加载该扩展之前

447
00:24:54,628 --> 00:24:56,997
扩展通知我们说 你知道

448
00:24:57,064 --> 00:25:01,301
在你推送一个项目之前
我想要用户做出选择

449
00:25:01,368 --> 00:25:03,537
我想要分叉自己的代码

450
00:25:04,204 --> 00:25:07,007
因此 它给了我们标题 描述和图片

451
00:25:07,174 --> 00:25:09,576
照片应用在表格里将它摆放得非常漂亮

452
00:25:10,344 --> 00:25:12,346
现在我选择第一个选项

453
00:25:13,847 --> 00:25:14,848
点击“创建”按钮

454
00:25:16,149 --> 00:25:18,051
现在 它们的扩展

455
00:25:18,452 --> 00:25:21,288
它们的视图控制器将会直接
b>推送至照片应用

456
00:25:21,555 --> 00:25:26,426
全景视图 但这是它们的UI
这是它们在“照片”中的体验

457
00:25:27,261 --> 00:25:29,763
现在 本例中它们利用了内存

458
00:25:30,030 --> 00:25:33,367
并采纳了我们提供的提示来布局该网格

459
00:25:34,635 --> 00:25:37,538
但是他们还采纳了我们提供的提示

460
00:25:38,205 --> 00:25:40,474
让我能够提取所有的图片

461
00:25:40,541 --> 00:25:42,609
在内存被创建时就被考虑的

462
00:25:42,910 --> 00:25:45,112
因此 在这里会注意到 在右下角

463
00:25:45,179 --> 00:25:49,149
如果你可以看见它 你看不见
因为它在我后面 283张图片

464
00:25:50,484 --> 00:25:53,220
关于这点非常酷的一点是
我可以自定义

465
00:25:53,287 --> 00:25:55,656
现在我会将其切换到未使用图片

466
00:25:56,256 --> 00:25:59,526
因为我想选择一张更喜欢一点的照片

467
00:26:02,296 --> 00:26:05,499
我选择这张 我认为它将成为
非常伟大的杰作

468
00:26:05,866 --> 00:26:08,168
我将它拖上去
然后定义该布局

469
00:26:10,137 --> 00:26:11,705
然后他们更进了一步

470
00:26:11,772 --> 00:26:16,009
他们让我自定义网格本身
以一种非常新颖的方式

471
00:26:16,176 --> 00:26:18,779
我想要特别强调一下这一行

472
00:26:19,446 --> 00:26:20,714
这张也许可以往下移动一些

473
00:26:21,682 --> 00:26:23,450
把这张也往下移一些对齐

474
00:26:24,985 --> 00:26:26,920
再做一些调整

475
00:26:27,955 --> 00:26:29,156
我很喜欢

476
00:26:29,590 --> 00:26:32,526
所以我可以点击“购买”按钮
还在照片里面

477
00:26:33,827 --> 00:26:35,896
选择尺寸 将会在信箱里收到

478
00:26:35,963 --> 00:26:38,098
然后我就可以把这份回忆
挂在客厅的墙上了

479
00:26:38,498 --> 00:26:39,333
非常酷

480
00:26:39,399 --> 00:26:42,669
这是关于ifolor非常快速的演示

481
00:26:49,376 --> 00:26:52,412
所以 你们想知道的是
这些功能是如何实现的

482
00:26:55,482 --> 00:26:59,119
如果你熟悉在照片应用里的
编辑扩展功能

483
00:26:59,720 --> 00:27:03,357
那你已经对其工作原理有很好的感觉

484
00:27:04,625 --> 00:27:08,262
我们在照片中添加了一个新的扩展点

485
00:27:08,495 --> 00:27:10,964
com.apple.photo-project

486
00:27:12,466 --> 00:27:15,135
我们还在Xcode中添加了一个新模板

487
00:27:15,936 --> 00:27:19,373
这将让你在自己的应用里
轻松创建这些扩展

488
00:27:20,240 --> 00:27:22,176
如演示所示

489
00:27:22,643 --> 00:27:25,078
我们自动发现你的扩展

490
00:27:25,312 --> 00:27:28,248
提高应用在系统的可发现性

491
00:27:28,749 --> 00:27:31,351
但是我们让该可发现性更进一步

492
00:27:32,519 --> 00:27:35,856
通过为用户提供App Store的直接链接

493
00:27:36,523 --> 00:27:39,193
该链接会打开App Store窗口

494
00:27:39,593 --> 00:27:43,664
但并不要求用户搜索具有该扩展的应用

495
00:27:43,931 --> 00:27:47,734
将会自动只显示支持该扩展点的应用

496
00:27:48,302 --> 00:27:50,737
我们认为这将大大提高

497
00:27:51,205 --> 00:27:53,707
用户发现你的应用的能力

498
00:27:53,774 --> 00:27:55,976
并能快速下载并使用它们

499
00:27:56,743 --> 00:27:57,578
我们非常确信这点

500
00:27:57,644 --> 00:28:00,347
所以我们在“编辑”中
加入了类似的App Store链接

501
00:28:01,081 --> 00:28:04,751
所以 如果你已经在进行图片编辑扩展

502
00:28:05,152 --> 00:28:07,187
用户将会得到通往
App Store的直接链接

503
00:28:07,254 --> 00:28:10,224
去直接发现你的编辑扩展

504
00:28:11,191 --> 00:28:12,025
这非常酷

505
00:28:16,697 --> 00:28:21,702
所以你的扩展只存在于你的应用内
在你的应用内

506
00:28:22,936 --> 00:28:24,738
对你们来说是一个很棒的机会

507
00:28:24,805 --> 00:28:26,907
因为你也许已经在
App Store有了一个应用

508
00:28:27,174 --> 00:28:28,976
已经有了许多应用特定代码

509
00:28:29,042 --> 00:28:32,880
但也许你有一些资源
以及其他一些可共享代码

510
00:28:32,946 --> 00:28:34,248
你可以很容易地移动到

511
00:28:34,314 --> 00:28:36,884
该扩展空间内 并加以利用

512
00:28:37,985 --> 00:28:42,222
显然你也有一些扩展特定代码

513
00:28:42,289 --> 00:28:43,223
你可能需要写下的

514
00:28:43,323 --> 00:28:44,424
很少一部分

515
00:28:44,958 --> 00:28:47,761
最后 你只需要添加一个视图控制器

516
00:28:48,161 --> 00:28:50,264
实现该协议

517
00:28:50,330 --> 00:28:53,066
PHprojectextensioncontroller协议

518
00:28:53,901 --> 00:28:55,135
随着所有一切就位

519
00:28:56,136 --> 00:28:59,806
照片应用可以立即发现你的扩展

520
00:29:00,641 --> 00:29:04,311
让用户选择 你知道
用它创建一个项目

521
00:29:05,112 --> 00:29:08,549
我们简单称该协议为
方法开始项目

522
00:29:09,583 --> 00:29:15,022
我们这样做时 会发送一些字节数据

523
00:29:15,789 --> 00:29:16,890
除了照片以外

524
00:29:16,957 --> 00:29:19,626
我们还发送项目扩展上下文

525
00:29:19,927 --> 00:29:23,130
还发送一个名为PHProjectInfo的对象

526
00:29:24,031 --> 00:29:26,133
可以用任何想要的方式使用它

527
00:29:27,167 --> 00:29:31,638
然后只需迅速返回
我们发给你的完成结束

528
00:29:32,206 --> 00:29:35,342
并让照片知道
可以安装你的视图控制器

529
00:29:35,576 --> 00:29:37,778
照片应用里的全景视图

530
00:29:38,045 --> 00:29:41,682
从那点起 如你所见
它完全成了你的UI

531
00:29:41,748 --> 00:29:43,250
它是你的体验

532
00:29:43,650 --> 00:29:49,056
你拥有所有在macOS上可用的API

533
00:29:49,656 --> 00:29:53,594
可以利用并可以为用户
构建出很棒的体验

534
00:29:56,797 --> 00:29:59,032
所以 协议本身非常简单

535
00:29:59,600 --> 00:30:03,303
对支持的项目类型还有一个可选属性

536
00:30:03,537 --> 00:30:05,472
你已经在刚才我的演示中看到

537
00:30:05,906 --> 00:30:07,908
这将让你快速描述选项

538
00:30:07,975 --> 00:30:09,109
你想让用户选择的

539
00:30:09,676 --> 00:30:11,178
如果你想 也可以选择退出

540
00:30:11,245 --> 00:30:12,713
如果你只想直接进入扩展

541
00:30:12,779 --> 00:30:14,481
这也是完全可能的

542
00:30:15,449 --> 00:30:17,417
这就需要一些必需的函数

543
00:30:17,484 --> 00:30:19,419
需要在视图控制器里实现

544
00:30:20,220 --> 00:30:21,788
第一个是beginProject

545
00:30:22,689 --> 00:30:25,492
在这里我们传给你上下文
以及项目信息

546
00:30:26,560 --> 00:30:32,399
这杯我们称为第一次
一个用你的扩展创建的项目

547
00:30:33,200 --> 00:30:36,103
现在 如果用户回到你的扩展

548
00:30:36,170 --> 00:30:37,938
为了已经创建的项目

549
00:30:38,105 --> 00:30:40,307
我们则调用resumeProject函数

550
00:30:40,707 --> 00:30:43,277
并再一次发送
给你该扩展上下文

551
00:30:45,812 --> 00:30:49,616
最后 如果用户在你的扩展内

552
00:30:49,850 --> 00:30:52,986
他们决定切换离开
在照片里做别的事情

553
00:30:53,187 --> 00:30:54,821
我们只需调用finishProject函数

554
00:30:54,888 --> 00:30:58,158
允许你清理任何正在处理的数据

555
00:30:58,225 --> 00:31:01,562
也许关闭任何让处理器忙碌的任务

556
00:31:01,628 --> 00:31:03,630
或动画之类你正在处理的数据

557
00:31:08,402 --> 00:31:10,604
PHProjectExtensionContext

558
00:31:11,238 --> 00:31:14,074
是个包含两个非常重要的对象的容器

559
00:31:14,141 --> 00:31:18,946
一个是PHProject
另一个是PHPhotoLibrary

560
00:31:19,446 --> 00:31:23,483
也就是你将提取所有资产的库

561
00:31:27,154 --> 00:31:28,789
PHProject本身

562
00:31:30,557 --> 00:31:34,394
只是PHAsset的一个子集

563
00:31:34,728 --> 00:31:38,198
也许你已经对
PHAssetCollection很熟悉

564
00:31:40,701 --> 00:31:41,602
它是个容器

565
00:31:41,702 --> 00:31:43,937
它有一个资产数列

566
00:31:44,338 --> 00:31:45,272
还有一个名字

567
00:31:45,472 --> 00:31:47,307
还有一个关键资产 关键照片

568
00:31:47,841 --> 00:31:49,877
我们在子集中所做的

569
00:31:49,943 --> 00:31:52,813
创建PHProject
就是我们只添加了一个属性

570
00:31:53,647 --> 00:31:56,216
但是它是一个对你来说非常
非常重要的属性

571
00:31:56,450 --> 00:31:58,352
就是projectExtensionData

572
00:31:58,952 --> 00:32:01,054
所以 这就是你 扩展

573
00:32:01,121 --> 00:32:03,524
可以保存任何你需要的数据

574
00:32:03,690 --> 00:32:05,926
可以代表用户创建的项目

575
00:32:06,360 --> 00:32:09,496
所以 它是为了重要的项目数据

576
00:32:09,563 --> 00:32:13,667
它是你正在使用的资产标识符的列表

577
00:32:13,734 --> 00:32:16,670
也许是一些基本的布局信息

578
00:32:16,737 --> 00:32:18,138
配置信息

579
00:32:18,605 --> 00:32:22,509
并不是为了图片 以及
你知道 缓存

580
00:32:22,576 --> 00:32:24,311
缩略图 花名册 诸如此类

581
00:32:24,378 --> 00:32:27,548
因为你可以快速创建它们
或把它们缓存到其他位置

582
00:32:29,116 --> 00:32:33,187
所以我们需要它小而有用

583
00:32:33,554 --> 00:32:36,023
我们把这个限制定为1兆

584
00:32:36,590 --> 00:32:37,758
因为我们认为 你知道

585
00:32:38,325 --> 00:32:41,361
压缩资产标识符数组
非常非常简单

586
00:32:41,428 --> 00:32:42,829
它们都只不过是字符串

587
00:32:43,263 --> 00:32:45,265
我们认为 1兆大小已经足够

588
00:32:45,332 --> 00:32:48,702
而这么做 我们不会增大用户的库

589
00:32:48,769 --> 00:32:50,637
当用户们不断创建项目

590
00:32:50,737 --> 00:32:53,607
并探寻所有这些优秀的扩展
那些你将要创建的扩展

591
00:32:57,110 --> 00:32:59,246
所以 设置数据 非常简单

592
00:33:00,113 --> 00:33:02,616
有一个对象名为
PHProjectChangeRequest

593
00:33:03,116 --> 00:33:06,220
只需将其实例化 实例化以后

594
00:33:06,286 --> 00:33:11,391
可以在Photo Library调用
performChangesAndWait函数

595
00:33:11,758 --> 00:33:14,261
在里面将数据设置成任何你想要的形式

596
00:33:14,328 --> 00:33:19,066
本例我会用
NSKeyedArchiver.archivedData

597
00:33:19,233 --> 00:33:21,201
一个标识符数组

598
00:33:21,869 --> 00:33:23,337
就是这样 非常简单

599
00:33:26,340 --> 00:33:28,008
让我们来看有趣的东西

600
00:33:29,109 --> 00:33:31,411
我想讲讲魔法从哪里开始

601
00:33:33,380 --> 00:33:35,415
所以 你们在ifolor演示中看到

602
00:33:35,482 --> 00:33:38,919
他们完全利用了“回忆”功能

603
00:33:39,052 --> 00:33:42,389
“回忆”功能非常受欢迎

604
00:33:42,990 --> 00:33:44,725
用户很爱这些功能

605
00:33:45,192 --> 00:33:49,596
是的 当你睡觉时
“照片”整夜都还在工作

606
00:33:50,330 --> 00:33:56,136
遍历你的Photo Library
似乎正在学着了解你 对吧

607
00:33:56,336 --> 00:33:58,872
在你的设备上
一切都在本地发生

608
00:33:59,006 --> 00:34:03,710
并且它建立一个图形
那些对你来说意义重大的事件

609
00:34:03,777 --> 00:34:06,246
生命中和你相关的人

610
00:34:06,580 --> 00:34:11,385
通过这些 它可以产生这些美好的回忆

611
00:34:11,451 --> 00:34:14,288
每天用户都在消费

612
00:34:14,855 --> 00:34:17,024
我们想要确保你可以访问

613
00:34:17,090 --> 00:34:19,760
那一层数据 对吗

614
00:34:19,826 --> 00:34:23,664
如果只给你一组照片
这些扩展不会那么有趣

615
00:34:23,964 --> 00:34:27,067
我们得给你上下文
这样你才可以从中有所创新

616
00:34:27,668 --> 00:34:30,670
这就是我们对PHProjectInfo做的

617
00:34:32,371 --> 00:34:36,476
所以 最高层的ProductInfo分成几个区

618
00:34:36,743 --> 00:34:40,447
我们提供这个
PHProjectSection对象数组

619
00:34:42,382 --> 00:34:45,052
对于某个区 我们告诉你类型

620
00:34:45,219 --> 00:34:49,556
所以你想到一个回忆
我们在最上层得到一张关键照片

621
00:34:50,023 --> 00:34:51,891
我们把这个类型称为“封面”

622
00:34:52,159 --> 00:34:56,964
然后我们得到该编辑网格
我们称该类型为“内容”

623
00:34:58,298 --> 00:35:00,834
然后我们给你该内容数组

624
00:35:03,737 --> 00:35:05,038
看上去像这个样子

625
00:35:05,105 --> 00:35:06,206
在内容里

626
00:35:06,273 --> 00:35:08,075
我们会让你可以访问元素

627
00:35:08,141 --> 00:35:10,911
资产、标识符和一些布局信息

628
00:35:11,712 --> 00:35:13,981
当你看这个构造时 可能会问自己

629
00:35:14,047 --> 00:35:16,316
为什么数组里面还有数组

630
00:35:16,383 --> 00:35:18,418
为什么是这种嵌套结构

631
00:35:19,386 --> 00:35:24,057
但是如果想想“回忆”的功能
会发现是有道理的 对吧

632
00:35:24,124 --> 00:35:28,762
我们允许用户和回忆可以
在显示照片摘要

633
00:35:28,829 --> 00:35:30,297
和显示所有照片之间切换

634
00:35:30,430 --> 00:35:34,801
回忆本身建立于大量资产之上

635
00:35:36,637 --> 00:35:38,539
我们称之为管护层

636
00:35:39,039 --> 00:35:40,908
我们想要确保你可以访问

637
00:35:40,974 --> 00:35:43,410
这些不同层的信息 对吧

638
00:35:43,477 --> 00:35:46,980
我们已经努力做了这么多
我们完成各种智能操作

639
00:35:47,247 --> 00:35:50,184
让我和你们分享
希望你们在此之上继续开发

640
00:35:50,884 --> 00:35:54,955
那个sectionContent数组是已排序数组

641
00:35:55,322 --> 00:35:59,760
你会知道索引0的对象总是最好的

642
00:35:59,826 --> 00:36:01,161
是最优的

643
00:36:01,361 --> 00:36:05,966
是资产集合最精炼的摘要

644
00:36:06,600 --> 00:36:09,069
而在数组末端的对象

645
00:36:09,136 --> 00:36:10,003
是最多的

646
00:36:10,070 --> 00:36:11,705
是我们能想到的一切

647
00:36:11,839 --> 00:36:14,007
你可以选择想要使用什么

648
00:36:14,608 --> 00:36:17,477
最少的 最多的 中间所有的

649
00:36:17,845 --> 00:36:20,447
也许你想给用户一个选项

650
00:36:20,514 --> 00:36:22,482
你想让他们可以在其中切换

651
00:36:22,749 --> 00:36:24,985
你可以做到
用我们在这提供的上下文

652
00:36:29,389 --> 00:36:32,359
接下来 云资产标识符

653
00:36:32,993 --> 00:36:34,328
这是一个较新的概念

654
00:36:34,394 --> 00:36:37,264
如果你对iOS的PhotoKit比较熟悉

655
00:36:37,464 --> 00:36:40,501
你从未见过这个 因为是全新的

656
00:36:41,668 --> 00:36:44,671
但是 我们从未使用过构造

657
00:36:44,738 --> 00:36:48,308
当我们想把数据
存到用户的Photo Library时

658
00:36:48,375 --> 00:36:50,978
数据代表资产

659
00:36:51,044 --> 00:36:53,213
但数据可能会被同步到其他设备

660
00:36:53,280 --> 00:36:55,782
可能某个时刻出现在别的地方

661
00:36:56,183 --> 00:36:58,719
我们想要确保你在保存的数据

662
00:36:59,386 --> 00:37:01,488
在任何出现的地方都有意义

663
00:37:01,855 --> 00:37:05,158
所以 我们推出了一个新对象
名为PHCloudIdentifier

664
00:37:06,527 --> 00:37:09,997
你可以将它看做资产的全局标识符

665
00:37:10,931 --> 00:37:14,468
但并不像全局字符串那么简单

666
00:37:15,035 --> 00:37:17,437
你知道 处理云和同步状态等

667
00:37:17,504 --> 00:37:19,106
是非常非常复杂的

668
00:37:19,373 --> 00:37:21,241
我们都已经为你解决好了

669
00:37:22,876 --> 00:37:24,845
你必须要做的唯一操作

670
00:37:25,279 --> 00:37:28,415
是确保你的转换总是从全局标识符

671
00:37:28,482 --> 00:37:31,051
到本地标识符 在提取之前

672
00:37:31,251 --> 00:37:32,686
而且为此我们为你提供了

673
00:37:32,753 --> 00:37:36,156
一个简单的方法 在PHPhotoLibrary里

674
00:37:36,223 --> 00:37:37,958
可以双向转换

675
00:37:38,025 --> 00:37:42,663
从全局 从pod标识符
到本地 反之亦然

676
00:37:45,566 --> 00:37:47,634
接下来 我想讲讲布局

677
00:37:49,136 --> 00:37:53,807
我们不仅想提供资产
以及围绕管护的一些构造

678
00:37:53,874 --> 00:37:56,076
我们想给你一些提示

679
00:37:57,077 --> 00:38:00,380
关于如何表现那些资产给用户 好吧

680
00:38:00,447 --> 00:38:03,217
帮助你解决那些复杂的问题

681
00:38:03,283 --> 00:38:04,818
比如网格布局

682
00:38:05,118 --> 00:38:10,524
好 你在看一个回忆
我们已经做了很多辛苦的工作

683
00:38:10,991 --> 00:38:14,161
来布局这个被管护的网格
用一种非常有趣的方式

684
00:38:14,228 --> 00:38:15,662
对用户来说很愉快

685
00:38:16,663 --> 00:38:19,233
如果你可以访问那个布局
不是很好吗

686
00:38:19,867 --> 00:38:21,068
你确实可以访问

687
00:38:21,869 --> 00:38:23,637
但是为了访问

688
00:38:24,505 --> 00:38:27,374
我们首先确立了一些规则

689
00:38:27,441 --> 00:38:29,142
一个坐标系

690
00:38:30,644 --> 00:38:32,012
所以 如果你查看回忆

691
00:38:32,079 --> 00:38:34,948
会发现一切都排列到一个特定的网格

692
00:38:35,015 --> 00:38:37,851
这是由4乘3单元格构成的网格

693
00:38:39,119 --> 00:38:43,323
但它是一个奇怪的 非正方形尺寸

694
00:38:43,390 --> 00:38:44,958
来回分享

695
00:38:45,025 --> 00:38:46,827
对你来说是一个奇怪的尺寸

696
00:38:47,427 --> 00:38:49,429
我们只需再除一下

697
00:38:50,564 --> 00:38:51,965
本例中该布局

698
00:38:52,032 --> 00:38:56,069
是由20个统一列组成

699
00:38:57,004 --> 00:38:58,839
我们称之为网格空间

700
00:38:59,673 --> 00:39:02,009
一旦我们确立了这个坐标系

701
00:39:02,075 --> 00:39:03,644
可以根据需求任意缩放

702
00:39:03,710 --> 00:39:06,547
它只是一个乘法器
无论输出结果

703
00:39:06,880 --> 00:39:09,283
对吧 如果你正在调整一个窗口大小

704
00:39:09,349 --> 00:39:13,020
或在不同大小的网络浏览器的工作

705
00:39:13,086 --> 00:39:16,190
你可以用这个数据了解
该内容如何布局

706
00:39:17,324 --> 00:39:20,727
也会让我们可以和你交流位置信息

707
00:39:21,128 --> 00:39:22,996
在这个例子里 我有这张照片

708
00:39:23,063 --> 00:39:25,399
想在左上角动起来

709
00:39:25,632 --> 00:39:29,169
我可以很简单地告诉你 它在00位置

710
00:39:29,236 --> 00:39:32,506
它有8格空间宽 9格空间高

711
00:39:36,043 --> 00:39:38,011
接下来我想讲讲元素

712
00:39:40,447 --> 00:39:43,317
在sectionContent里
我们提供了一组元素

713
00:39:43,383 --> 00:39:48,488
所有的元素都是
PHProjectElement的子集

714
00:39:49,122 --> 00:39:50,757
这里有两个非常重要的属性

715
00:39:50,824 --> 00:39:53,293
一个是位置 我们刚讲过

716
00:39:54,027 --> 00:39:56,864
另一个被称为权重

717
00:39:58,665 --> 00:40:00,868
再次回到回忆的功能

718
00:40:03,237 --> 00:40:04,171
我们讲过

719
00:40:04,238 --> 00:40:06,406
所有我们正在研究的智能 对吧

720
00:40:06,607 --> 00:40:12,746
在大量资产中确定最相关的照片

721
00:40:14,114 --> 00:40:15,749
也就是我们的评分系统

722
00:40:16,450 --> 00:40:18,085
我们想和你分享这部分内容

723
00:40:18,585 --> 00:40:24,157
所以 我们通过给元素一个权重 好吧

724
00:40:24,224 --> 00:40:26,960
这是一个规范化的权重值从0到1.0

725
00:40:28,095 --> 00:40:33,267
默认值是0.5
也就是说并不是最重要的

726
00:40:33,333 --> 00:40:36,570
但也不是很不重要
希望听上去有道理

727
00:40:37,538 --> 00:40:41,308
但是你知道 它是一个规范化分数
遍布整个区域

728
00:40:41,375 --> 00:40:44,178
你可以利用它做出很多惊人的事 好吗

729
00:40:44,244 --> 00:40:45,679
而且非常容易 好吗

730
00:40:45,746 --> 00:40:47,447
用这种方式对资产进行排序

731
00:40:47,648 --> 00:40:52,019
决定在哪里切断
你知道 一个大量资产的数组

732
00:40:52,085 --> 00:40:54,087
只处理重要的资产

733
00:40:54,321 --> 00:40:56,490
好吗？把它们作为选项表现给用户

734
00:40:56,557 --> 00:41:02,429
你首先处理高权重的资产

735
00:41:02,729 --> 00:41:06,366
并预测该资产应该是
用户正在寻找的 想要的

736
00:41:10,337 --> 00:41:11,672
还有一点

737
00:41:12,573 --> 00:41:16,076
这一点是某个元素特有的

738
00:41:16,143 --> 00:41:18,312
也就是PHProjectAssetElement

739
00:41:18,879 --> 00:41:21,248
我们有这样一个概念 称为兴趣区

740
00:41:24,718 --> 00:41:26,653
你知道 如你所知

741
00:41:26,820 --> 00:41:30,324
在macOS API里 已经有很多方法

742
00:41:30,557 --> 00:41:34,428
来进行面部识别 寻找图片里的脸

743
00:41:36,430 --> 00:41:39,433
但从这些方法无法知道这些脸的相关性

744
00:41:39,633 --> 00:41:41,802
你不知道这些脸是否代表着

745
00:41:41,869 --> 00:41:44,238
某个人生命中特别有意义的人

746
00:41:45,005 --> 00:41:46,740
或只是人群中的陌生人

747
00:41:46,807 --> 00:41:50,143
那个在公园里走在你身后的人

748
00:41:50,410 --> 00:41:53,380
当你想给家人拍照时 对吗

749
00:41:53,447 --> 00:41:56,116
你真的无法辨别出来

750
00:41:57,317 --> 00:42:01,488
我们想给你什么让你知道

751
00:42:01,555 --> 00:42:04,391
并让你信任我们标出来的

752
00:42:04,458 --> 00:42:07,761
如果我们说这很有趣
那它就应该有趣 对吗

753
00:42:07,828 --> 00:42:12,032
如果可以对此加以利用
将可以为用户创造魔法

754
00:42:12,432 --> 00:42:14,568
并不是一定要知道为什么

755
00:42:15,602 --> 00:42:17,171
我们更进一步

756
00:42:17,237 --> 00:42:19,673
如果你注意到 这些上面有标识符

757
00:42:20,374 --> 00:42:23,977
我们实际上在不同的图片上
会改变这些标识符

758
00:42:24,511 --> 00:42:27,648
所以如果我们知道这个东西
在这张照片里很有趣

759
00:42:28,148 --> 00:42:31,185
并且代表了相同的东西

760
00:42:31,251 --> 00:42:35,088
或在另一张照片里相同的人
我们会给他们相同的标识符

761
00:42:35,422 --> 00:42:38,458
如果你正在处理动画 幻灯片等

762
00:42:38,525 --> 00:42:40,761
这将非常有用

763
00:42:41,128 --> 00:42:46,099
因为你现在可以真正把
大集合中的图片位置彼此联系起来

764
00:42:49,203 --> 00:42:51,505
所以 我本来可以继续看代码

765
00:42:53,006 --> 00:42:56,143
但我还是给你们放一段演示

766
00:42:57,010 --> 00:43:00,247
因为我觉得这非常重要

767
00:43:00,480 --> 00:43:03,217
让你们看看创建一个扩展有多么容易

768
00:43:03,951 --> 00:43:05,219
我在Xcode里

769
00:43:05,986 --> 00:43:08,355
我承诺如果需要会放大屏幕

770
00:43:08,422 --> 00:43:09,623
以便你们可以看清楚

771
00:43:10,757 --> 00:43:11,925
所以 我在Xcode里

772
00:43:12,492 --> 00:43:15,295
我启动了一个项目
但实际上里面什么都没有

773
00:43:15,362 --> 00:43:18,198
只有一些设计师给我的资产

774
00:43:18,932 --> 00:43:23,170
我们现在要做的 是一个幻灯片

775
00:43:23,937 --> 00:43:25,172
这个幻灯片将是

776
00:43:25,239 --> 00:43:28,542
包含照片应用提供的内容

777
00:43:28,809 --> 00:43:32,479
并将其同步成
非常引人入胜的3D动画

778
00:43:34,681 --> 00:43:35,516
让我们开始

779
00:43:36,817 --> 00:43:39,386
首先我可以做的是
我点击“项目”

780
00:43:39,887 --> 00:43:43,090
在底部有一个小的加号按钮
“添加目标”

781
00:43:44,057 --> 00:43:45,392
我在这里添加一个目标

782
00:43:45,459 --> 00:43:49,329
你会发现 出现了一个全新的模板

783
00:43:50,397 --> 00:43:52,232
是PhotoProject扩展

784
00:43:52,432 --> 00:43:54,768
所以选中该模板 给它命名

785
00:43:56,703 --> 00:43:57,538
Picture Show

786
00:43:59,673 --> 00:44:00,674
点击完成按钮

787
00:44:01,375 --> 00:44:03,777
是的 我想激活它成为一个方案

788
00:44:03,844 --> 00:44:05,579
之后运行它将会变得非常容易

789
00:44:06,647 --> 00:44:09,650
然后 我提过设计师给我了这些资产

790
00:44:09,716 --> 00:44:12,019
已经存在于项目中

791
00:44:12,085 --> 00:44:15,756
我只想让它们在扩展中也能被引用

792
00:44:16,557 --> 00:44:19,159
通过复制阶段添加这些

793
00:44:20,994 --> 00:44:24,064
这是整个资产集合

794
00:44:24,398 --> 00:44:27,367
点击“添加”按钮
这已经让我们写了一些代码

795
00:44:29,536 --> 00:44:32,472
现在 如果仔细看

796
00:44:32,539 --> 00:44:36,577
会发现Xcode已经为我添加了这个组

797
00:44:36,643 --> 00:44:38,245
为我的目标 为我的Picture Show

798
00:44:38,779 --> 00:44:42,950
在里面 已经准备好一个视图控制器

799
00:44:43,016 --> 00:44:45,385
它符合我们实行的协议

800
00:44:47,988 --> 00:44:49,456
继续进去

801
00:44:50,791 --> 00:44:53,760
首先添加一些属性

802
00:44:56,663 --> 00:44:58,932
在这里添加一小部分属性集合

803
00:44:58,999 --> 00:45:02,002
保持给我的上下文

804
00:45:02,436 --> 00:45:03,437
我有一些数组

805
00:45:03,504 --> 00:45:07,241
区分幻灯片的横向或纵向资产

806
00:45:07,608 --> 00:45:09,510
我有一个场景视图插座

807
00:45:10,210 --> 00:45:11,378
有一个动画生成器

808
00:45:12,546 --> 00:45:15,282
以及两个预期编译器

809
00:45:15,349 --> 00:45:16,917
还没有导入sceneKit

810
00:45:17,751 --> 00:45:19,386
很容易可以修正

811
00:45:22,189 --> 00:45:24,157
动画生成器是我自己的类

812
00:45:24,224 --> 00:45:25,459
只是还没有创建出来

813
00:45:25,526 --> 00:45:28,161
所以让我们现在就去创建

814
00:45:31,431 --> 00:45:34,568
点击“新建” 选择swift文件

815
00:45:36,870 --> 00:45:38,572
我们将其命名为Animator

816
00:45:42,910 --> 00:45:44,044
然后

817
00:45:48,415 --> 00:45:49,416
动画生成器创建好了

818
00:45:51,118 --> 00:45:52,452
我不会带着大家浏览全部代码

819
00:45:52,519 --> 00:45:53,987
但其实非常非常简单

820
00:45:54,188 --> 00:45:56,290
所以 我只想讲讲它实现的部分功能

821
00:45:56,957 --> 00:46:00,761
当初始化动画时 我只想进入场景中

822
00:46:01,094 --> 00:46:03,397
取出一些场景的特定元素

823
00:46:03,463 --> 00:46:06,967
我想在该3D场景里
找到这些标记的相框

824
00:46:07,367 --> 00:46:10,571
并且深入其中 在玻璃后面

825
00:46:10,637 --> 00:46:13,774
找出那些材料
变成我想要展现的照片

826
00:46:13,841 --> 00:46:16,210
在这些框架的玻璃后面

827
00:46:16,577 --> 00:46:18,879
这就是初始化真正所做的全部

828
00:46:19,279 --> 00:46:22,983
从这一点开始 场景

829
00:46:23,050 --> 00:46:24,618
我知道这有一点令人头晕

830
00:46:24,685 --> 00:46:27,087
有点像转桌子

831
00:46:28,055 --> 00:46:31,491
我有个小策略
好比你是一个好魔术师

832
00:46:31,558 --> 00:46:33,861
当你不再看切换照片时

833
00:46:34,161 --> 00:46:36,296
所以 我用几个计时器来实现

834
00:46:37,531 --> 00:46:38,899
基本上这就是动画

835
00:46:39,733 --> 00:46:44,671
回到控制器 开始填充有趣的位

836
00:46:45,939 --> 00:46:48,642
当用户创建其中一个项目时

837
00:46:50,043 --> 00:46:52,479
我想保存数据

838
00:46:52,546 --> 00:46:54,515
因为我想让用户可以返回到这张幻灯片

839
00:46:54,581 --> 00:46:55,649
在任何时间点

840
00:46:56,250 --> 00:46:57,851
我来添加一些数据方法

841
00:46:57,918 --> 00:47:01,555
这里是一个SaveProjectData函数

842
00:47:02,222 --> 00:47:05,092
实现的就是在幻灯片看到的功能 对吧

843
00:47:05,158 --> 00:47:07,928
这和我们刚刚讲的非常类似

844
00:47:08,996 --> 00:47:11,899
然后加载数据 只是读回去

845
00:47:13,000 --> 00:47:16,336
我正在获取云资产标识符
通过取消存档我的数据

846
00:47:16,904 --> 00:47:19,206
然后将它们转换为本地标识符

847
00:47:19,540 --> 00:47:20,874
从那开始

848
00:47:21,508 --> 00:47:26,146
我可以完成
PHAsset.fetchAssets请求

849
00:47:26,213 --> 00:47:27,581
用这些本地标识符

850
00:47:29,950 --> 00:47:33,520
好 回到顶部 开始填充剩下的

851
00:47:33,720 --> 00:47:34,788
所以 viewDidLoad

852
00:47:40,093 --> 00:47:42,629
我只需实例化动画生成器 之前提过

853
00:47:43,897 --> 00:47:45,098
supportedProjectTypes

854
00:47:45,165 --> 00:47:48,101
本例不需要询问用户任何事情

855
00:47:48,202 --> 00:47:51,238
所以不用填充 只是一张幻灯片

856
00:47:52,706 --> 00:47:55,709
但是beginProject显然需要做些什么

857
00:47:56,910 --> 00:47:58,312
我们填充进去

858
00:47:59,279 --> 00:48:05,118
本例中我所做的是
获取真正的分区数组

859
00:48:06,019 --> 00:48:09,389
我在搜索第一个分区类型内容

860
00:48:10,023 --> 00:48:11,959
都是根据一个回忆进行设计

861
00:48:12,025 --> 00:48:13,327
如之前所讲到的

862
00:48:13,961 --> 00:48:16,663
从那里 我想要得到最受管护的资产

863
00:48:16,730 --> 00:48:18,832
我想要最高级别的摘要

864
00:48:19,132 --> 00:48:21,668
所以 我请求数组的第一个对象

865
00:48:22,736 --> 00:48:27,307
从中获取云资产标识符
成功实现了

866
00:48:28,542 --> 00:48:32,513
现在后台 我想保存项目数据

867
00:48:32,579 --> 00:48:35,482
这样当用户回到幻灯片时
数据依然存在

868
00:48:37,117 --> 00:48:41,188
进入resumeProject 非常简单

869
00:48:43,891 --> 00:48:46,960
只需保持上下文

870
00:48:47,294 --> 00:48:49,930
加载项目数据 实例化动画生成器

871
00:48:51,632 --> 00:48:53,534
最后在finishProject里

872
00:48:58,205 --> 00:48:59,673
暂停动画

873
00:48:59,740 --> 00:49:01,108
不需要启动这些计时器

874
00:49:01,175 --> 00:49:03,911
当用户在做别的事时
我不想风扇一直转

875
00:49:04,144 --> 00:49:05,045
只需将它暂停

876
00:49:06,680 --> 00:49:07,514
相信不相信

877
00:49:07,581 --> 00:49:09,816
这就是该扩展的全部代码

878
00:49:09,883 --> 00:49:11,018
就是我的幻灯片

879
00:49:11,351 --> 00:49:13,520
我还没做的事 即连接UI

880
00:49:14,354 --> 00:49:15,322
可以很快实现

881
00:49:15,389 --> 00:49:18,559
模板为视图控制器提供了视图

882
00:49:18,825 --> 00:49:20,427
删除默认字符串

883
00:49:21,228 --> 00:49:23,297
在上面添加一个场景

884
00:49:28,468 --> 00:49:30,237
添加一个sceneKit视图

885
00:49:30,971 --> 00:49:34,408
我来调整一下大小

886
00:49:35,442 --> 00:49:39,880
进入这里 设为自动调整大小
设为全景视图

887
00:49:42,115 --> 00:49:45,018
还需要做的唯一一件事

888
00:49:45,085 --> 00:49:47,221
就是选择场景本身

889
00:49:47,287 --> 00:49:49,556
已经存在于加载进来的资产里

890
00:49:50,224 --> 00:49:52,459
只需将它和视图控制器连起来

891
00:49:53,126 --> 00:49:55,295
所以 按Control键拖到文件所有人

892
00:49:55,896 --> 00:49:58,799
可以看到在属性里添加的插座

893
00:50:00,033 --> 00:50:02,736
就这样 可以运行了

894
00:50:04,671 --> 00:50:05,672
点击“播放”

895
00:50:05,739 --> 00:50:09,109
将会询问选择应用
显然 本例选择“照片”

896
00:50:14,715 --> 00:50:17,184
生成 成功

897
00:50:17,684 --> 00:50:21,522
“照片”启动
选择一个回忆

898
00:50:21,688 --> 00:50:23,924
本例我想选择

899
00:50:24,258 --> 00:50:28,295
我想选择这个去非常酷的香港之旅

900
00:50:28,962 --> 00:50:30,464
点击加号按钮 看

901
00:50:30,531 --> 00:50:32,699
在照片里出现了这个扩展

902
00:50:34,468 --> 00:50:35,335
选中

903
00:50:35,802 --> 00:50:36,703
当我选中时

904
00:50:36,770 --> 00:50:39,039
是第一次运行这个扩展

905
00:50:39,373 --> 00:50:43,877
作为扩展没有访问整个
Photo Library权限

906
00:50:43,944 --> 00:50:45,746
还记得我们的API

907
00:50:45,812 --> 00:50:48,182
把整个Photo Library传给了扩展

908
00:50:48,582 --> 00:50:51,718
因此用户不必授予该访问权限

909
00:50:52,152 --> 00:50:53,120
只需点击“确定”

910
00:50:53,687 --> 00:50:54,855
幻灯片加载成功

911
00:51:04,064 --> 00:51:07,835
我还将演示另一个细节

912
00:51:07,935 --> 00:51:09,469
请看侧栏

913
00:51:09,736 --> 00:51:12,072
有一个刚创建的项目 “香港岛”

914
00:51:13,340 --> 00:51:16,910
它被保存在库里 紧挨着别的项目

915
00:51:17,444 --> 00:51:18,412
选择该项目

916
00:51:19,246 --> 00:51:23,717
可以看到它由一个叫作
“Picture Show”的扩展所创建

917
00:51:24,251 --> 00:51:25,352
打开

918
00:51:26,687 --> 00:51:28,689
将会马上回到同样的幻灯片

919
00:51:30,390 --> 00:51:33,927
这就是照片项目扩展

920
00:51:36,763 --> 00:51:37,598
谢谢

921
00:51:42,202 --> 00:51:46,440
在刚过去55分钟里我们讲了很多

922
00:51:48,609 --> 00:51:51,245
讲了iOS里的无摩擦照片选择器

923
00:51:51,378 --> 00:51:55,749
非常非常好的进步
允许你在原始的URL获得照片

924
00:51:55,816 --> 00:51:57,251
拥有高质量视频

925
00:51:57,484 --> 00:51:59,453
为你们准备了很好的东西

926
00:51:59,786 --> 00:52:03,123
Andreas为大家讲解了
全新的媒体表达类型

927
00:52:03,490 --> 00:52:06,426
我迫不及待地想看你们
如何吸收这些

928
00:52:06,493 --> 00:52:08,629
以及在自己的应用里如何处理

929
00:52:09,796 --> 00:52:11,932
允许用户看到内容播放

930
00:52:11,999 --> 00:52:13,233
以自己想要的方式

931
00:52:13,700 --> 00:52:16,970
他还讲到用大型图片库进行测试

932
00:52:17,337 --> 00:52:18,238
提醒一下

933
00:52:18,305 --> 00:52:21,775
有一个示例应用可以用来填充库

934
00:52:21,842 --> 00:52:26,213
里面有成千上万的资产
可以用这种方式测试

935
00:52:26,813 --> 00:52:29,183
然后 最后我们讲了项目扩展

936
00:52:29,249 --> 00:52:33,587
我非常非常期待你们有所创新

937
00:52:33,687 --> 00:52:38,292
在App Store里
当今年秋天macOS High Sierra推出时

938
00:52:39,459 --> 00:52:41,495
更多信息 请访问该链接

939
00:52:41,562 --> 00:52:44,231
developer.apple.com网站

940
00:52:45,098 --> 00:52:47,434
再讲一下相关演讲

941
00:52:47,668 --> 00:52:53,006
本场演讲结束后 就在这个会场
将会有一个非常非常精彩的演讲

942
00:52:53,073 --> 00:52:55,375
为大家介绍影像框架

943
00:52:55,542 --> 00:52:57,344
我知道你们都会等着听的

944
00:52:57,711 --> 00:53:01,281
今晚 在行政宴会厅

945
00:53:01,415 --> 00:53:06,653
将会有两场演讲的第一场
关于iPhone深度摄影技巧

946
00:53:06,920 --> 00:53:08,555
并有非常精彩的演示

947
00:53:08,622 --> 00:53:11,558
你们一定也非常非常想参与

948
00:53:11,792 --> 00:53:13,627
最后 今晚我们要做一件事

949
00:53:13,694 --> 00:53:15,963
从未在WWDC上做过

950
00:53:16,296 --> 00:53:18,298
我们将会举行一个“一起来摄影”活动

951
00:53:18,398 --> 00:53:19,566
地点是楼下

952
00:53:19,633 --> 00:53:22,636
科学实验室区 具体是实验室J

953
00:53:23,237 --> 00:53:24,872
我会在那儿

954
00:53:25,138 --> 00:53:27,374
本次演讲的另两位演讲者也会去

955
00:53:27,441 --> 00:53:30,677
所有今天关于Cameron Photos
的演讲者都会到场

956
00:53:30,744 --> 00:53:34,047
还会有很多工程师 管理人员

957
00:53:34,314 --> 00:53:36,283
希望你们大家也都到场

958
00:53:36,583 --> 00:53:38,619
享受接下来的演讲 非常感谢

