1
00:00:21,355 --> 00:00:22,589
大家下午好

2
00:00:26,093 --> 00:00:28,362
欢迎大家来到
“选择合适的Cocoa容器视图”

3
00:00:28,529 --> 00:00:29,730
我是雷利·雷德

4
00:00:30,163 --> 00:00:31,665
是AppKit团队的工程师

5
00:00:31,732 --> 00:00:34,201
稍后AppKit团队的另一名工程师
特洛伊·斯蒂芬斯

6
00:00:34,268 --> 00:00:35,869
也会上台和大家分享心得

7
00:00:36,703 --> 00:00:39,740
让我们进入主题
我们首先来玩一个游戏

8
00:00:41,742 --> 00:00:43,977
哪个视图看上去与众不同？

9
00:00:44,511 --> 00:00:47,281
这里有五个不同的视图
[听不清]

10
00:00:47,915 --> 00:00:50,784
其中哪一个视图
与其他视图不一样

11
00:00:50,851 --> 00:00:53,387
而没有使用
容器视图的基本样式？

12
00:00:53,720 --> 00:00:55,322
请仔细看

13
00:00:55,689 --> 00:00:57,057
这可能有一点困难

14
00:00:57,457 --> 00:01:00,260
我看到了一些线索
看到一些内容别具一格

15
00:01:00,627 --> 00:01:02,930
你们看出来
哪一个视图与众不同了吗？

16
00:01:03,197 --> 00:01:04,096
答案即将揭晓

17
00:01:05,232 --> 00:01:07,501
正确答案是邮件边栏

18
00:01:07,868 --> 00:01:09,603
邮件边栏是一个边框视图

19
00:01:09,903 --> 00:01:11,505
其它四个是表格视图

20
00:01:12,973 --> 00:01:14,241
让我们再来看一个例子

21
00:01:15,042 --> 00:01:16,543
在这三个视图中

22
00:01:16,610 --> 00:01:19,413
哪一个使用不同的
基本容器视图？

23
00:01:19,780 --> 00:01:23,617
上一个例子已经告诉我们
这并不容易分辨出来

24
00:01:24,751 --> 00:01:26,954
我已经看出来了

25
00:01:27,354 --> 00:01:28,755
知道哪个视图与众不同吗？

26
00:01:29,423 --> 00:01:31,692
正确的答案是这个

27
00:01:31,758 --> 00:01:32,893
这是一个网格视图

28
00:01:33,594 --> 00:01:35,629
其它两个是集合视图

29
00:01:38,131 --> 00:01:40,133
我的同事特洛伊将会为大家简要介绍

30
00:01:40,200 --> 00:01:43,971
AppKit的一些更强大
而且有趣的容器视图类

31
00:01:44,238 --> 00:01:47,641
它们是经过精心设计的
多功能和可重用的组件

32
00:01:47,708 --> 00:01:51,078
你可以在系统和
第三方应用中部署它们

33
00:01:51,445 --> 00:01:52,946
你现在就可以使用它们

34
00:01:53,013 --> 00:01:55,983
来轻松地构建
你自己的用户界面

35
00:01:56,416 --> 00:01:59,453
这些界面包含一些
常用的组件

36
00:01:59,520 --> 00:02:01,455
用户已经熟悉它们的用法

37
00:02:01,522 --> 00:02:03,757
让他们能够方便而且

38
00:02:03,824 --> 00:02:05,826
高效率地使用你的应用

39
00:02:06,527 --> 00:02:10,396
特洛伊将会概括介绍他们的
设计目标、功能和高效率套件

40
00:02:10,797 --> 00:02:14,468
然后 我将会回到舞台
介绍一些有趣的真实UI范例

41
00:02:14,535 --> 00:02:16,470
而且提供一些有用的指导

42
00:02:16,537 --> 00:02:20,107
帮助你们
从AppKit扩展库中选择

43
00:02:20,174 --> 00:02:21,775
最合适的容器视图

44
00:02:22,409 --> 00:02:24,545
关于这个主题
我将会邀请特洛伊为大家讲解

45
00:02:26,880 --> 00:02:27,714
谢谢 雷利

46
00:02:28,682 --> 00:02:29,516
大家好

47
00:02:30,450 --> 00:02:33,353
在我们进入主题之前

48
00:02:34,555 --> 00:02:37,224
我想花一点时间来回顾

49
00:02:37,291 --> 00:02:40,594
AppKit视图体系的
一些基本内容

50
00:02:43,330 --> 00:02:48,135
从最基本的简化几何角度来讲
视图是什么？

51
00:02:48,202 --> 00:02:52,372
它是屏幕上的一个矩形
用于向用户展示你的内容

52
00:02:52,439 --> 00:02:54,374
让用户能够进行交互

53
00:02:54,875 --> 00:02:57,044
当你准备展示内容时

54
00:02:57,110 --> 00:02:59,246
你需要做的一项基本工作是

55
00:02:59,313 --> 00:03:01,882
确定和应用合适的布局

56
00:03:01,949 --> 00:03:05,419
你需要确定各个项目的
大小和位置

57
00:03:05,485 --> 00:03:08,889
以便于展示给用户
它们可能是项目 也可能是视图

58
00:03:09,289 --> 00:03:12,192
AppKit提供一个
非常强大和通用的

59
00:03:12,259 --> 00:03:15,495
开放式自动布局系统
提供你所需要的功能

60
00:03:15,562 --> 00:03:20,234
用于构建非常复杂和富于变化的
布局 能够自动适应大小变化

61
00:03:20,834 --> 00:03:24,404
你可以设置各个组件和约束条件

62
00:03:24,705 --> 00:03:28,342
但今天演讲的要点之一是提醒你们

63
00:03:28,408 --> 00:03:30,344
有一些现成的解决方案

64
00:03:30,410 --> 00:03:33,213
提供给许多常用的用户界面设计模式

65
00:03:33,280 --> 00:03:35,315
你可以在应用中使用它们

66
00:03:35,382 --> 00:03:39,286
在AppKit庞大的
预设视图类库中

67
00:03:39,353 --> 00:03:41,388
有许多即手可用的组件

68
00:03:41,855 --> 00:03:44,591
因此 在可能的情况下
你需要让工作简单化

69
00:03:44,658 --> 00:03:48,095
你需要重复使用
我们已经为你设计好的解决方案

70
00:03:50,464 --> 00:03:52,466
我们今天要介绍的所有视图

71
00:03:52,533 --> 00:03:54,301
能够展现你的任何内容

72
00:03:54,368 --> 00:03:57,204
即使你使用标准商用组件

73
00:03:57,271 --> 00:03:59,673
你的视图看上去不是预设的

74
00:04:00,007 --> 00:04:04,344
你也具有完全的自由度
来设计你想要的视图

75
00:04:04,411 --> 00:04:07,114
你可以在每个视图中
放入你想要的内容

76
00:04:08,649 --> 00:04:10,851
让我们先来看一下简单的例子

77
00:04:11,151 --> 00:04:14,755
这是一些最基本的工作
这里有一系列的视图

78
00:04:14,821 --> 00:04:17,357
它们的类型并不重要
对于布局系统来说

79
00:04:17,423 --> 00:04:18,425
它们只是一些黑方框

80
00:04:18,692 --> 00:04:20,726
我们希望以线性方式
来布局它们

81
00:04:20,994 --> 00:04:22,663
比如像这样的行

82
00:04:23,197 --> 00:04:25,065
或者垂直的列

83
00:04:25,699 --> 00:04:29,303
AppKit提供真正简单
易用的解决方案

84
00:04:29,536 --> 00:04:32,973
一个隐形容器视图
我们称之为NSStackView

85
00:04:33,941 --> 00:04:38,011
StackView提供非常简单的方法
使用行或列的方式布局视图

86
00:04:38,078 --> 00:04:41,715
而不需要自己管理
布局约束条件

87
00:04:41,782 --> 00:04:45,786
StackView的特点是
它提供非常易于使用的API

88
00:04:45,886 --> 00:04:50,023
你可以设置属性指定对齐和大小

89
00:04:50,090 --> 00:04:52,726
StackView将会自动管理

90
00:04:52,793 --> 00:04:54,962
所有必要的布局约束

91
00:04:55,028 --> 00:04:56,763
这可能特别有用

92
00:04:56,830 --> 00:04:59,533
如果你想要
StackView动态变化内容

93
00:04:59,600 --> 00:05:01,168
你想要添加和移除项目

94
00:05:01,235 --> 00:05:04,471
而不想要自己
更新布局约束

95
00:05:05,172 --> 00:05:08,509
在StackView中可以设置的
属性包括边框嵌入

96
00:05:08,575 --> 00:05:12,880
这有一点像设置
布局视图区域周围的边界

97
00:05:14,281 --> 00:05:16,416
可以配置视图对齐

98
00:05:16,483 --> 00:05:19,019
在本例中
你可能想要在设置界面中

99
00:05:19,086 --> 00:05:22,322
水平对齐项目、右对齐或左对齐项目

100
00:05:22,389 --> 00:05:24,825
或者将所有项目设置为相同的宽度

101
00:05:24,892 --> 00:05:26,226
或者设置间隙

102
00:05:26,293 --> 00:05:28,695
所有这些都可以
轻松地使用属性来完成

103
00:05:28,762 --> 00:05:31,632
而不需要自己管理
自动布局约束

104
00:05:32,332 --> 00:05:35,669
你唯一需要考虑的事情是

105
00:05:36,136 --> 00:05:39,239
确保放入StackView
的所有项目

106
00:05:39,306 --> 00:05:40,807
都具有明确定义的高度

107
00:05:40,874 --> 00:05:45,078
或者 如果它是StackView
你需要明确定义宽度

108
00:05:45,312 --> 00:05:47,414
现在 你可以通过

109
00:05:47,481 --> 00:05:50,250
内容的固有大小来确定这些属性

110
00:05:50,317 --> 00:05:53,353
这里有一些标签
而且由于所选字体的原因

111
00:05:53,420 --> 00:05:54,254
它们有特定的高度

112
00:05:54,321 --> 00:05:56,723
我们想在上方和下方
留出一定的空白

113
00:05:56,790 --> 00:05:58,759
因此 每个项目的总高度

114
00:05:58,825 --> 00:06:01,195
由标签高度确定

115
00:06:02,196 --> 00:06:05,699
我们进行设置之后
其余工作交给StackView就可以了

116
00:06:05,966 --> 00:06:09,136
项目之间的空隙是可以配置的
而且不必完全相同

117
00:06:09,203 --> 00:06:11,338
在这方面 有许多的选项

118
00:06:11,405 --> 00:06:13,407
这是一个多功能的视图

119
00:06:14,741 --> 00:06:16,343
StackView还能够

120
00:06:16,410 --> 00:06:19,012
处理空隙约束

121
00:06:19,246 --> 00:06:21,915
若需要 可在StackView中
放入数百个项目

122
00:06:21,982 --> 00:06:24,952
可以放入滚动视图
其显示的项目数量

123
00:06:25,018 --> 00:06:26,286
多于窗口显示的数量

124
00:06:26,353 --> 00:06:27,921
但是 通常情况下

125
00:06:27,988 --> 00:06:31,091
你可能会在空间受限区域中
使用StackView

126
00:06:32,759 --> 00:06:36,129
StackView提供一个API
处理所有空间限制

127
00:06:36,196 --> 00:06:41,268
让你能够轻松地指定
视图集合如何适应大小调整

128
00:06:41,535 --> 00:06:42,870
你所要做的是

129
00:06:42,936 --> 00:06:47,374
将视图的相对优先级
告知StackView

130
00:06:47,441 --> 00:06:48,475
因此我们可以这样说

131
00:06:48,542 --> 00:06:51,578
假设这里的视图2
具有相对较低的优先级

132
00:06:52,112 --> 00:06:55,349
因此 当空间受限时
如果窗口变小

133
00:06:55,415 --> 00:06:59,419
StackView将自动放弃
这些低优先级视图

134
00:06:59,786 --> 00:07:02,389
确保最重要的视图
仍然显示出来

135
00:07:02,456 --> 00:07:06,326
这类似于工具栏和
触控条中的响应模式

136
00:07:08,962 --> 00:07:11,598
StackView还支持
引力区概念

137
00:07:11,665 --> 00:07:13,000
这有一点像分区

138
00:07:13,100 --> 00:07:16,470
在垂直StackView中
有顶部、中间和底部分区

139
00:07:16,904 --> 00:07:20,874
在StackView中
有前置、中间和后置分区

140
00:07:20,941 --> 00:07:23,577
另外请注意
我们使用的术语是前置和后置

141
00:07:23,644 --> 00:07:27,548
而不是左侧和右侧

142
00:07:27,614 --> 00:07:30,217
通过这种方式

143
00:07:30,284 --> 00:07:34,555
我们能够更轻松地
处理从右至左的布局

144
00:07:34,655 --> 00:07:38,192
在从左至右的布局
前置分区位于左侧

145
00:07:38,258 --> 00:07:40,494
后置分区位于右侧

146
00:07:40,561 --> 00:07:45,732
如果应用中的文本
从右向左显示

147
00:07:45,799 --> 00:07:48,368
那么前置和后置分区
将会自动交换

148
00:07:48,435 --> 00:07:51,872
事实上
StackView中的所有子视图

149
00:07:51,939 --> 00:07:53,674
将会以相反的方向布局

150
00:07:53,907 --> 00:07:57,177
因此 利用正确的思维模式

151
00:07:57,244 --> 00:07:58,879
StackView让我们的布局

152
00:07:58,946 --> 00:08:03,483
能够自动适应从右至左布局

153
00:08:04,551 --> 00:08:06,520
StackView还支持组合

154
00:08:06,854 --> 00:08:10,023
假设这里有一组视图
我们想要垂直堆叠它们

155
00:08:10,090 --> 00:08:13,126
它们可能是一些复选框
可以放入StackView

156
00:08:13,260 --> 00:08:15,662
也许需要在它们旁边
放置一个边栏

157
00:08:16,096 --> 00:08:18,398
我们可以使用另一个StackView
一个水平StackView

158
00:08:18,465 --> 00:08:19,766
将视图放入其中

159
00:08:20,701 --> 00:08:23,504
我们可以底部在放置
一些按钮 将它们放入StackView

160
00:08:23,570 --> 00:08:26,707
然后使用第四个StackView
将它们分成两个组

161
00:08:26,907 --> 00:08:29,009
在我们编程时

162
00:08:29,076 --> 00:08:30,911
我们喜欢这样做 是吧？

163
00:08:30,978 --> 00:08:35,282
用模块化的方法
利用这些容易理解的组件进行组合

164
00:08:35,349 --> 00:08:38,352
让你能够创建复杂的布局

165
00:08:38,418 --> 00:08:39,852
而且容易维护

166
00:08:39,919 --> 00:08:42,890
仅使用StackView
就可以做很多的事情

167
00:08:45,158 --> 00:08:48,195
几年前有一个很不错的演讲
名为“自动布局会话的谜”

168
00:08:48,262 --> 00:08:49,696
详细介绍了StackView

169
00:08:49,763 --> 00:08:52,332
包括如何进行配置
以获得各种效果 讲解很详细

170
00:08:52,399 --> 00:08:54,001
我强烈建议你们看一看

171
00:08:54,067 --> 00:08:57,905
如你们所知
过去几年的视频演讲

172
00:08:57,971 --> 00:08:59,540
可以在开发者网站上看到

173
00:08:59,606 --> 00:09:01,175
在“自动布局”演讲中

174
00:09:01,241 --> 00:09:03,577
有一节名为
“自动布局技巧”

175
00:09:03,644 --> 00:09:06,013
详细介绍各种方法

176
00:09:06,079 --> 00:09:07,981
指导你使用和设置StackView

177
00:09:09,116 --> 00:09:11,752
让我们运用刚才学过的知识
进行实战演练

178
00:09:11,818 --> 00:09:13,687
我们实现一种新型布局

179
00:09:13,754 --> 00:09:18,492
这里是一个UI的外观首选项

180
00:09:18,959 --> 00:09:22,029
我们看到这里有一些列表

181
00:09:22,362 --> 00:09:24,364
左侧是一个标签列表

182
00:09:24,431 --> 00:09:27,267
在右侧 有一个相应的控件列表

183
00:09:27,801 --> 00:09:31,138
都是向下排列
在这种情况下 我们自然想到

184
00:09:31,572 --> 00:09:34,408
可能需要使用多个
并列StackView

185
00:09:34,474 --> 00:09:35,509
来解决这个问题

186
00:09:36,643 --> 00:09:39,580
我们很快发现

187
00:09:39,646 --> 00:09:42,115
这些StackView
能够很好地独立工作

188
00:09:42,182 --> 00:09:44,518
但是它们相互之间
没有任何交互和联系

189
00:09:44,585 --> 00:09:47,187
它们能够很好地显示自己的内容

190
00:09:47,588 --> 00:09:50,724
但是问题在于左侧的标签

191
00:09:50,791 --> 00:09:54,361
与右侧的控件之间
不再存在必要的显示对应关系

192
00:09:54,695 --> 00:09:57,397
这将会造成应用可用性问题

193
00:09:57,998 --> 00:10:01,902
我们可能使用凑合方法为外观标签

194
00:10:01,969 --> 00:10:05,405
设置人为增大的高度
或使用类似的方法

195
00:10:05,472 --> 00:10:07,374
但是 这是Cocoa技术
我们并不会拼凑了事

196
00:10:07,441 --> 00:10:10,143
我们想要一个
优雅、便于维护的解决方案

197
00:10:11,211 --> 00:10:14,715
我们希望使用简单、
可维护的方法完成这些布局

198
00:10:14,781 --> 00:10:17,284
以便于开发网格视图

199
00:10:17,718 --> 00:10:18,886
利用网格视图

200
00:10:20,420 --> 00:10:23,757
你将能够轻松地
在带坐标的行和列中进行布局

201
00:10:23,824 --> 00:10:26,627
将在给定的行和列中对齐视图

202
00:10:26,693 --> 00:10:27,995
非常好用

203
00:10:28,262 --> 00:10:29,930
NSStackView使用高级API

204
00:10:29,997 --> 00:10:32,432
完成所有这些工作

205
00:10:32,499 --> 00:10:36,470
不需要你自己维护自动布局约束

206
00:10:36,537 --> 00:10:38,238
你可以配置高级属性

207
00:10:38,305 --> 00:10:41,975
设置行和列的大小
对齐和间隙

208
00:10:42,109 --> 00:10:44,077
网格视图会完成其它工作

209
00:10:47,047 --> 00:10:49,483
与StackView一样
GridView自动适应

210
00:10:49,550 --> 00:10:50,584
从右至左的布局

211
00:10:50,651 --> 00:10:53,654
因此 在这个特定的布局中
我们希望使用从右至左的样式

212
00:10:53,720 --> 00:10:55,956
标签和控件将会交换位置

213
00:10:56,023 --> 00:10:58,625
如果我们在RTL中运行
就会得到这样的结果

214
00:11:01,094 --> 00:11:04,331
去年的“自动布局新特性”演讲
真的非常不错

215
00:11:04,398 --> 00:11:07,601
它详细地讲解GridView
及其功能

216
00:11:07,668 --> 00:11:09,536
我强烈建议你们观看

217
00:11:10,504 --> 00:11:12,139
目前 仅使用GridView
和StackView

218
00:11:12,206 --> 00:11:13,841
我们就可以做很多的事情

219
00:11:13,907 --> 00:11:16,944
特别是我们需要组合
和模块化结构时

220
00:11:17,077 --> 00:11:21,682
它们帮助你轻松地
布局和展示视图组

221
00:11:22,382 --> 00:11:25,219
但是 如果我们还需要
其他的布局 应该怎么做呢？

222
00:11:26,420 --> 00:11:30,824
如果我们需要其它类型的布局
比如非线性的布局应该怎么做？

223
00:11:32,025 --> 00:11:35,562
更重要的是 如果我们需要
支持用户交互 应该怎么做？

224
00:11:35,629 --> 00:11:39,066
比如 用户选择项目进行拖放等

225
00:11:40,367 --> 00:11:44,471
另外我们可能不知道
运行时需要处理多少个项目

226
00:11:44,538 --> 00:11:46,240
也许用户的数据很庞大

227
00:11:46,306 --> 00:11:50,043
可能需要显示成千上万个项目

228
00:11:50,110 --> 00:11:54,081
这就超出GridView
和StackView的目标用途

229
00:11:54,147 --> 00:11:57,117
你可以在这些视图中
放入许多项目 也可以放入滚动视图

230
00:11:57,184 --> 00:12:00,888
但是它们不会进行高效率资源利用

231
00:12:01,488 --> 00:12:04,291
而只是分页显示需要显示的内容

232
00:12:04,358 --> 00:12:06,660
并且努力确保平滑滚动显示

233
00:12:06,727 --> 00:12:08,428
我们希望更进一步

234
00:12:08,495 --> 00:12:11,398
我们想要解决这些问题

235
00:12:12,299 --> 00:12:16,170
我们首先来看一个例子
这个例子强调可交互性和可扩展性

236
00:12:17,271 --> 00:12:20,440
如果我们想要创建交互功能
更强的网格 应该怎么做？

237
00:12:20,507 --> 00:12:23,810
这个有一个例子
类似于我们的一个系统应用

238
00:12:24,144 --> 00:12:25,112
活动监测器

239
00:12:25,913 --> 00:12:28,549
从外观上看
它像是一个网格 是吧？

240
00:12:28,615 --> 00:12:29,950
这里有行和列

241
00:12:30,184 --> 00:12:33,020
但是这里
它更像一个列表

242
00:12:33,220 --> 00:12:37,391
我们看到显示项目向下排列
每行显示一个进程

243
00:12:37,691 --> 00:12:39,993
信息分列呈现

244
00:12:40,060 --> 00:12:42,496
以显示每个进程的不同属性

245
00:12:43,263 --> 00:12:46,767
用户可能想要选择
单个项目或多个项目

246
00:12:48,101 --> 00:12:50,404
由于我们按列显示数据

247
00:12:50,470 --> 00:12:53,473
因此可以方便地告诉用户
每列的内容是什么

248
00:12:53,540 --> 00:12:56,677
我们在顶部设置一个标题视图
显示每个列的标题

249
00:12:57,444 --> 00:13:01,215
用户可以点击列标题

250
00:13:01,715 --> 00:13:04,051
让应用自动根据列的属性

251
00:13:04,117 --> 00:13:06,153
对列表内容进行排序

252
00:13:06,520 --> 00:13:09,923
用户可以拖放
经过重新排序的列

253
00:13:09,990 --> 00:13:12,192
以更简单易懂的方式

254
00:13:12,259 --> 00:13:14,561
显示各列内容的关系

255
00:13:14,795 --> 00:13:18,232
所有这些功能都封装在
AppKit的NSTableView之中

256
00:13:19,967 --> 00:13:22,870
TableView是一个交互式
垂直列表视图

257
00:13:23,237 --> 00:13:25,038
我们将它们视为多列视图

258
00:13:25,105 --> 00:13:27,341
你可以见到
许多的多列TableView

259
00:13:27,774 --> 00:13:28,842
它们也十分适合

260
00:13:28,909 --> 00:13:30,878
单列列表

261
00:13:30,944 --> 00:13:33,814
在系统中 你可以
看到许多这样的例子

262
00:13:33,881 --> 00:13:35,849
虽然可能难以识别
这点雷利前面已讲过

263
00:13:35,916 --> 00:13:38,485
因为其外观是可以自定义的

264
00:13:39,219 --> 00:13:40,687
这里有一些例子

265
00:13:40,888 --> 00:13:44,157
右侧是一个简单的例子
这里有一个文本标签列表

266
00:13:44,224 --> 00:13:47,694
因此你可以使用TableView
在左侧 这也是一个TableView

267
00:13:47,761 --> 00:13:51,098
每个项目显示为
一幅图片和相应的标签

268
00:13:51,698 --> 00:13:54,001
在基于TableView的最新视图中

269
00:13:54,067 --> 00:13:56,904
你可以使用任何方式
呈现你的项目内容

270
00:13:56,970 --> 00:14:00,641
你可以使用AppKit标准控件
构建任何视图子树

271
00:14:00,707 --> 00:14:02,042
创建自己的定制视图

272
00:14:02,442 --> 00:14:05,812
可以使用它
在你的TableView中显示项目

273
00:14:05,879 --> 00:14:08,081
你可以使用很多的创意设计方案

274
00:14:08,148 --> 00:14:09,816
来显示项目内容

275
00:14:11,385 --> 00:14:13,353
TableView支持类型选择

276
00:14:13,420 --> 00:14:15,522
键盘导航为你处理所有这些事情

277
00:14:16,723 --> 00:14:18,759
TableView还提供分组行

278
00:14:18,825 --> 00:14:21,328
有时候按照特定的类别
对项目内容进行分组

279
00:14:21,395 --> 00:14:22,930
可以便于用户理解内容

280
00:14:23,096 --> 00:14:24,398
这里有一个例子

281
00:14:25,065 --> 00:14:28,735
顶部的黄色方框是标题视图的边框
但是在它们下方

282
00:14:28,802 --> 00:14:31,371
其他的黄色方框是分组行的边框

283
00:14:31,438 --> 00:14:32,873
看上去像是标题

284
00:14:32,940 --> 00:14:35,309
它们可以是你想要的任何设计视图

285
00:14:35,375 --> 00:14:37,077
你可以使用它们

286
00:14:37,144 --> 00:14:38,812
对项目内容进行分类

287
00:14:40,647 --> 00:14:43,283
这是另一个使用分组行的例子

288
00:14:43,684 --> 00:14:46,854
你会注意到 本例中的分组行
具有不同的高度

289
00:14:46,920 --> 00:14:49,723
因为我们想要在旁边
显示更大的图标

290
00:14:49,790 --> 00:14:52,159
它们下方的项目行更短

291
00:14:52,226 --> 00:14:55,128
还可以在TableView 中
设置可变行高度

292
00:14:55,896 --> 00:14:57,698
它们支持灵活的布局

293
00:14:57,764 --> 00:15:01,068
TableView还支持行操作
这在iOS操作系统上很常见

294
00:15:01,134 --> 00:15:04,104
你可以交换行位置
显示操作按钮

295
00:15:04,171 --> 00:15:06,106
或者立即执行操作

296
00:15:06,507 --> 00:15:08,575
TableView还支持变换动画

297
00:15:08,642 --> 00:15:12,012
因此 如果你有一个动态更新的模型
而不需要用户进行任何操作

298
00:15:12,079 --> 00:15:15,382
你可以提供视觉提示
表明项目已经被插入或删除

299
00:15:15,449 --> 00:15:17,518
用户可以看到模型如何变化

300
00:15:17,584 --> 00:15:19,553
并且立即反映出来

301
00:15:21,388 --> 00:15:24,725
更重要的是 TableView
可以扩展以容纳大量的项目

302
00:15:24,791 --> 00:15:27,961
对于要显示的内容

303
00:15:28,028 --> 00:15:30,264
TableView在实例化视图时
非常谨慎

304
00:15:30,330 --> 00:15:33,734
它有一小块预取区域
当用户执行滚动操作时

305
00:15:33,800 --> 00:15:34,902
可以平滑地滚动显示

306
00:15:35,669 --> 00:15:38,639
TableView将会回收
超过滚动显示范围之外的内容

307
00:15:38,705 --> 00:15:40,707
而不是实例化全新项目

308
00:15:40,874 --> 00:15:45,479
这些特性让其具备很好的扩展性
让你能够平滑地滚动显示内容

309
00:15:45,546 --> 00:15:49,349
和动态地交互操作大量项目

310
00:15:50,551 --> 00:15:53,754
TableView具有非常
灵活的内容封装功能

311
00:15:53,820 --> 00:15:56,557
你可以使用绑定功能
从而减少代码编写工作量

312
00:15:56,623 --> 00:15:59,560
也可以使用
基于索引的行数据源API

313
00:15:59,626 --> 00:16:00,894
非常灵活

314
00:16:00,994 --> 00:16:03,130
总而言之 其用途十分广泛

315
00:16:03,197 --> 00:16:08,001
便于在macOS上显示
表格数据和简单列表

316
00:16:10,237 --> 00:16:13,407
有一个面向Mac计算机的
编程指南 详细介绍

317
00:16:13,473 --> 00:16:14,775
如何使用TableView

318
00:16:14,842 --> 00:16:19,246
去年 有一场现代Cocoa应用
会话开发的演讲 通过一个例子

319
00:16:19,313 --> 00:16:23,851
循序渐进地介绍
开发和配置基于视图的TableView应用

320
00:16:23,917 --> 00:16:25,085
我强烈建议你们观看

321
00:16:27,087 --> 00:16:29,523
我们已经讨论网格和列表

322
00:16:29,590 --> 00:16:32,526
当我们想要处理树状结构的数据

323
00:16:32,593 --> 00:16:36,196
或者处理文件、文件夹、
或者其他任何层级树结构数据模型时

324
00:16:36,263 --> 00:16:39,533
应该怎么办呢？

325
00:16:40,133 --> 00:16:42,469
这就需要用到NSOutlineView

326
00:16:42,703 --> 00:16:45,873
OutlineView具有
TableView的所有功能

327
00:16:45,939 --> 00:16:49,042
因为它是一个TableView

328
00:16:49,309 --> 00:16:52,179
NSOutlineView是
NSTableView的子集

329
00:16:52,246 --> 00:16:54,915
因此 TableView的所有功能

330
00:16:54,982 --> 00:16:56,850
也适用于OutlineView

331
00:16:57,050 --> 00:17:00,921
在上方 OutlineView是
一个层级数据模型

332
00:17:02,222 --> 00:17:05,125
它跟踪你所指定的模型对象

333
00:17:05,192 --> 00:17:07,728
及其子对象以及子节点等等

334
00:17:08,328 --> 00:17:11,298
在用户界面中
OutlineView的一个优点是

335
00:17:11,365 --> 00:17:15,969
它并不强制用户一次性浏览
所显示的整个树结构

336
00:17:16,136 --> 00:17:19,772
你可以使用程序
来设置显示哪些特定的内部节点

337
00:17:19,839 --> 00:17:21,340
或者收起哪些节点

338
00:17:21,708 --> 00:17:25,012
用户可以进行选择
只需点击展开三角形按钮

339
00:17:25,078 --> 00:17:26,646
也可以通过程序

340
00:17:26,713 --> 00:17:30,617
选择性地显示
用户想要查看的特定子树

341
00:17:32,786 --> 00:17:35,489
OutlineView的另一个优点是

342
00:17:35,556 --> 00:17:37,024
允许查看多个分支

343
00:17:37,090 --> 00:17:40,060
可以同时显示层级结构的
多个子树结构

344
00:17:40,127 --> 00:17:43,330
这十分有用
比如说在查找程序的列表视图中

345
00:17:43,397 --> 00:17:44,932
如果你有一个文件夹子树

346
00:17:44,998 --> 00:17:47,234
你想要删除
这个文件夹中的文件

347
00:17:47,601 --> 00:17:49,670
可以很轻松地完成操作

348
00:17:51,171 --> 00:17:54,341
如我所述 TableView的一切
都适用于OutlineView

349
00:17:54,408 --> 00:17:57,044
因此TableView编程指南
是一个很不错的参考材料

350
00:17:57,110 --> 00:17:59,780
另外还有一个
OutlineView编程指南

351
00:17:59,847 --> 00:18:03,851
总结OutlineView
和TableView的区别

352
00:18:06,053 --> 00:18:07,888
我们还提供另一个选择

353
00:18:07,955 --> 00:18:10,757
如果你拥有基于树形结构的数据
希望用户能够浏览

354
00:18:10,824 --> 00:18:13,193
我们可以使用NSBrowser

355
00:18:13,527 --> 00:18:16,263
这是一个NSBrowser例子
它含有两个列

356
00:18:17,364 --> 00:18:20,968
左边的列显示项目的根列表

357
00:18:21,034 --> 00:18:22,069
右边的列

358
00:18:22,135 --> 00:18:25,405
显示左边列表项的子项目

359
00:18:26,540 --> 00:18:29,576
这个例子类似于
查找程序的ColumnView

360
00:18:30,177 --> 00:18:31,445
这里有三个列

361
00:18:32,079 --> 00:18:33,780
左侧的列中选定一个文件夹

362
00:18:33,847 --> 00:18:35,415
我们想要显示该文件夹的内容

363
00:18:35,482 --> 00:18:36,717
并在右侧预览

364
00:18:37,885 --> 00:18:41,755
NSBrowser是一个
基于列的展开式UI

365
00:18:41,822 --> 00:18:44,525
当用户点击选择列中的项目时

366
00:18:44,591 --> 00:18:46,593
右侧将会显示更多的列

367
00:18:46,660 --> 00:18:48,495
或者在左侧显示
如果我们运行RTL

368
00:18:48,562 --> 00:18:50,631
用户可以展开

369
00:18:50,697 --> 00:18:52,933
浏览特定的树分支

370
00:18:54,334 --> 00:18:55,702
用户可以调整列的大小

371
00:18:55,769 --> 00:18:59,006
因此 用户可以进行配置
有效地使用水平空间

372
00:19:00,274 --> 00:19:02,776
它还有一些新功能
例如可选的自定义标题视图

373
00:19:02,843 --> 00:19:05,245
可以在列顶部放置任何视图

374
00:19:06,079 --> 00:19:10,784
如果想要构建
基于浏览器的主详情界面

375
00:19:10,851 --> 00:19:14,421
可以为浏览器
自定义预览视图控制器

376
00:19:14,488 --> 00:19:17,758
进行配置之后
当用户展开到叶节点时

377
00:19:17,991 --> 00:19:20,427
可以在一个视图上
显示一个列

378
00:19:20,494 --> 00:19:23,664
从而显示对象属性的详细描述

379
00:19:23,730 --> 00:19:27,034
这类似于查找程序中的列视图

380
00:19:30,304 --> 00:19:33,807
Outline View与NSBrowser
之间的用户界面区别

381
00:19:33,874 --> 00:19:37,044
用户一次只能查看一个树分支

382
00:19:37,110 --> 00:19:39,179
在很多情况下 这已经够用了

383
00:19:39,246 --> 00:19:40,581
而且这能够

384
00:19:40,647 --> 00:19:42,749
更高效地利用垂直空间

385
00:19:44,151 --> 00:19:46,286
我们有一个浏览器编程指南

386
00:19:46,353 --> 00:19:48,555
而且附带一些示例代码

387
00:19:48,622 --> 00:19:50,057
指导你学习如何使用浏览器

388
00:19:50,123 --> 00:19:51,558
（自定义布局如何呢？）

389
00:19:51,625 --> 00:19:53,360
最后让我们来讨论自定义布局

390
00:19:53,427 --> 00:19:56,396
前面我说过 我们的布局
不仅局限于网格和列表

391
00:19:56,964 --> 00:19:58,899
有时还需要使用NSCollectionView

392
00:19:58,966 --> 00:20:02,202
NSCollectionView是一种
非常灵活、多用途、可自定义

393
00:20:02,269 --> 00:20:03,637
而且可扩展的项目视图

394
00:20:04,671 --> 00:20:07,407
它支持任意开发者定制布局

395
00:20:07,474 --> 00:20:11,311
如果想要使用程序设定的
一系列矩形

396
00:20:11,378 --> 00:20:13,514
可以插入CollectionView布局

397
00:20:13,580 --> 00:20:15,782
它会相应地调整
项目的大小和位置

398
00:20:17,150 --> 00:20:19,520
另外 它提供一个简单的
封装布局 称为流

399
00:20:19,586 --> 00:20:22,389
依次显示尽可能多的项目
与页面上显示的文本一样

400
00:20:22,456 --> 00:20:24,491
也可以用列显示项目

401
00:20:26,026 --> 00:20:30,831
CollectionView也能够
将项目划分为多个区域

402
00:20:30,898 --> 00:20:32,633
若你想用这种方式对它们进行分组

403
00:20:32,699 --> 00:20:35,836
每个区域都可以
有一个标题视图和一个页脚视图

404
00:20:35,903 --> 00:20:37,971
你完全可以自定义设计

405
00:20:38,906 --> 00:20:42,376
另外 它支持用户交互功能
比如选择项目

406
00:20:42,442 --> 00:20:45,846
拖放项目
在CollectionView内重新排序

407
00:20:45,913 --> 00:20:47,181
拖出拖入等

408
00:20:48,515 --> 00:20:51,919
与视图方式一样 TableView
和OutlineView支持任意项目显示

409
00:20:51,985 --> 00:20:55,389
你可以使用自己的自定义视图
构建任何视图子树结构

410
00:20:55,455 --> 00:20:57,624
在本例中 使用的是
标准AppKit视图

411
00:20:59,226 --> 00:21:01,628
与基于视图的TableView
和OutlineView一样

412
00:21:01,695 --> 00:21:05,132
它非常智能
仅实例化必要项目

413
00:21:05,199 --> 00:21:08,268
并且回收项目使用的资源
因此我们可以保持高性能

414
00:21:08,335 --> 00:21:10,504
即使在处理大量项目时

415
00:21:11,271 --> 00:21:13,574
它还可以显示动画
插入 删除 和移动

416
00:21:13,640 --> 00:21:17,511
类似于TableView 和OutlineView
另外 还可以在布局之间过渡

417
00:21:19,546 --> 00:21:23,550
两年前 我们有一场演讲
专门讨论CollectionView

418
00:21:23,984 --> 00:21:26,587
其内容与UICollectionView
十分相似

419
00:21:27,120 --> 00:21:30,624
另外还有CocoaSlideCollection
示例代码

420
00:21:30,691 --> 00:21:32,426
我强烈建议你们观看

421
00:21:32,826 --> 00:21:36,763
我们已经学习六个视图类

422
00:21:36,830 --> 00:21:40,934
它们来自于AppKit
的庞大预设类库

423
00:21:41,001 --> 00:21:44,004
而且我们增加了大量的功能

424
00:21:44,071 --> 00:21:45,639
每一种视图本身都非常有用

425
00:21:45,706 --> 00:21:48,842
这些视图还有一些重叠的应用领域

426
00:21:48,909 --> 00:21:52,446
因此 这些指南可以
帮助我们在不同的

427
00:21:52,513 --> 00:21:55,282
用户界面设计中

428
00:21:55,349 --> 00:21:56,383
使用合适的视图

429
00:21:56,550 --> 00:21:58,886
为了帮助我们正确使用这些技术
为我们提供指导

430
00:21:58,952 --> 00:22:01,688
我的同事雷利·雷德
将会演示一些用例

431
00:22:01,755 --> 00:22:04,925
帮助大家创建完美的UI

432
00:22:04,992 --> 00:22:06,426
-谢谢特洛伊
-谢谢雷利

433
00:22:13,534 --> 00:22:16,470
现在 大家已经学习

434
00:22:16,537 --> 00:22:19,873
各种ContainerView样式及功能

435
00:22:19,940 --> 00:22:22,009
你们可能已知道
应该如何在你们的应用中

436
00:22:22,075 --> 00:22:23,143
使用它们

437
00:22:23,577 --> 00:22:25,946
但是 有些时候难以做出选择

438
00:22:26,013 --> 00:22:27,381
因此我想后退一步

439
00:22:28,248 --> 00:22:31,351
总体回顾刚才学习的内容

440
00:22:31,718 --> 00:22:33,453
从广义角度来看

441
00:22:33,520 --> 00:22:37,591
我们可以将ContainerView
分为两个大类别

442
00:22:37,991 --> 00:22:42,529
也就是StackView和GridView
我们称之为纯布局容器

443
00:22:42,896 --> 00:22:45,632
它们所做的事情是为你提供布局

444
00:22:46,200 --> 00:22:48,168
让你不必自己处理所有布局约束

445
00:22:48,235 --> 00:22:50,504
从而更轻松地设计
想要的布局

446
00:22:50,871 --> 00:22:52,940
它们不进行任何绘图或选择

447
00:22:53,440 --> 00:22:56,210
利用CollectionView、
TableView、OutlineView和Browser

448
00:22:56,276 --> 00:22:59,379
我们获得所需要的
数据回调ContainerView

449
00:22:59,713 --> 00:23:02,816
这些视图高效率地添加和删除视图

450
00:23:02,883 --> 00:23:06,920
这取决于你提供的数据源和绑定数据

451
00:23:08,121 --> 00:23:11,592
如果我们查看CollectionView
的数据源集合

452
00:23:11,658 --> 00:23:13,493
我们可以细分显示数据内容

453
00:23:13,861 --> 00:23:15,229
如果你的数据是表格类型的

454
00:23:15,295 --> 00:23:17,931
可以使用
TableView 或OutlineView

455
00:23:18,599 --> 00:23:20,534
如果数据是树状结构的

456
00:23:20,601 --> 00:23:23,003
可以使用OutlineView
而不是NSBrowser

457
00:23:23,804 --> 00:23:27,641
如果创建网格样式布局
或者需要自定义布局

458
00:23:27,708 --> 00:23:30,477
可以使用CollectionView

459
00:23:31,912 --> 00:23:34,948
为了进行总结
让我们来看一些应用案例

460
00:23:35,015 --> 00:23:37,918
和一些实际例子
我们先来看一个邮件应用

461
00:23:38,185 --> 00:23:41,555
具体来说 我想要
启动一个邮件消息列表

462
00:23:41,622 --> 00:23:45,692
然后分析我们如何创建
这个的设计以及为什么要这样做

463
00:23:47,194 --> 00:23:51,632
我们首先启动
CollectionView列表

464
00:23:52,699 --> 00:23:55,102
让我们思考邮件消息列表

465
00:23:55,169 --> 00:23:56,904
可能具有的不同类型的属性

466
00:23:57,304 --> 00:24:01,775
我的邮箱里有数份邮件

467
00:24:01,975 --> 00:24:04,578
你的邮件客户端需要能够处理

468
00:24:04,645 --> 00:24:06,246
大量的邮件

469
00:24:06,880 --> 00:24:08,549
我们需要使用

470
00:24:08,615 --> 00:24:10,918
一个数据回调存储界面
ContainerView

471
00:24:11,251 --> 00:24:15,022
我们应该高效率地使用视图
和内存并且获得灵敏的滚动响应

472
00:24:17,191 --> 00:24:21,094
当然 我们还需要选择功能
以便向用户显示

473
00:24:21,161 --> 00:24:23,363
他们想要查看的邮件正文

474
00:24:23,997 --> 00:24:28,101
我们将需要…
每份邮件都有很多属性…

475
00:24:28,435 --> 00:24:31,338
比如发件人 主题 日期等等

476
00:24:32,139 --> 00:24:34,641
如果你查看所有不同的属性

477
00:24:34,708 --> 00:24:37,211
可能认为需要使用表格视图

478
00:24:37,611 --> 00:24:40,714
而事实上 数据的组织结构
更像是树形

479
00:24:40,781 --> 00:24:42,749
因此我们不需要
CollectionView或Browser

480
00:24:43,317 --> 00:24:44,418
但是…

481
00:24:45,752 --> 00:24:47,087
请再思考一下

482
00:24:47,754 --> 00:24:51,024
我们可以取出
属于相同对话类别的所有邮件

483
00:24:51,091 --> 00:24:53,894
将它们分组在一起
也许还可以重叠它们

484
00:24:54,328 --> 00:24:56,997
这时 OutlineView
就成为理想的选择

485
00:24:57,231 --> 00:24:59,433
如果你看看传统的邮件视图

486
00:24:59,499 --> 00:25:01,468
如果你开启这个模式
这就是你所看到的

487
00:25:01,535 --> 00:25:02,736
有一个边框视图

488
00:25:02,803 --> 00:25:06,139
邮件正文位于底部面板

489
00:25:07,541 --> 00:25:11,245
这很好
但是这里的空间利用不理想

490
00:25:11,912 --> 00:25:17,117
具体来说 我想讨论邮件的正文

491
00:25:17,751 --> 00:25:20,287
如果不滚动
我甚至无法看到完整的邮件内容

492
00:25:20,354 --> 00:25:22,589
而这份邮件并不是很长

493
00:25:23,357 --> 00:25:29,730
作为用户 我可以更改
分拆视图 增加更多空间

494
00:25:29,796 --> 00:25:32,099
然后 我会减小
OutlineView和

495
00:25:32,165 --> 00:25:33,233
邮件列表中的空间

496
00:25:33,300 --> 00:25:36,603
我可以滚动显示更多内容
以找到我想要查看的邮件

497
00:25:37,204 --> 00:25:41,108
如果我们调整布局
可以得到这样的设计

498
00:25:41,408 --> 00:25:44,044
我们所做的事情
是使用一个综合表格单元

499
00:25:44,111 --> 00:25:48,815
它是单列表格视图
每个单元格都是一个综合单元格

500
00:25:48,882 --> 00:25:51,218
因此 我们将所有属性
放入这个单元格

501
00:25:51,418 --> 00:25:54,655
这会打开一个右侧窗口

502
00:25:54,721 --> 00:25:57,424
我们可以调出完整邮件内容

503
00:25:57,491 --> 00:26:01,628
现在 用户可以阅读更多邮件内容
而且减少滚动

504
00:26:02,162 --> 00:26:04,231
由于我们使用垂直分拆视图

505
00:26:05,032 --> 00:26:07,768
无论用户如何更改分拆视图的大小

506
00:26:07,835 --> 00:26:11,705
我始终能够在单列列表中
看到相同数量的邮件

507
00:26:12,072 --> 00:26:13,540
因此我不必…

508
00:26:13,607 --> 00:26:15,475
我不必改变滚动频率

509
00:26:15,542 --> 00:26:17,244
无论分拆视图如何变化

510
00:26:18,278 --> 00:26:22,416
让我们进一步研究并分析其利弊

511
00:26:24,585 --> 00:26:26,253
其中一个缺点是无法进行排序

512
00:26:26,320 --> 00:26:29,022
由于没有表格标题
用户无法进行排序

513
00:26:29,089 --> 00:26:31,391
改变排序可能十分有用

514
00:26:31,558 --> 00:26:34,361
必须进入邮件添加更多控件

515
00:26:34,428 --> 00:26:35,896
用户才能排序

516
00:26:37,531 --> 00:26:40,067
用户无法完全控制
每个属性的大小

517
00:26:40,601 --> 00:26:43,504
在使用多个单列时
列大小可能会发生变化

518
00:26:43,570 --> 00:26:45,672
举例来说 可能会增大发件人列宽

519
00:26:45,739 --> 00:26:47,074
或者增大主题列宽

520
00:26:47,140 --> 00:26:48,976
让它们能够一次阅读更多的主题

521
00:26:49,776 --> 00:26:54,681
但是 事实上我们能够
重点显示最常用的内容

522
00:26:55,082 --> 00:26:58,018
举例来说 如果我们查看
其中一个单元格

523
00:26:58,085 --> 00:27:02,055
我们看到邮件的发件人
用漂亮的粗体显示

524
00:27:02,923 --> 00:27:05,893
然后在右边 我们看到日期

525
00:27:06,393 --> 00:27:08,028
我们把这些项目放入StackView

526
00:27:08,095 --> 00:27:11,765
让StackView自动处理

527
00:27:11,832 --> 00:27:13,634
这两个相邻视图的布局

528
00:27:13,700 --> 00:27:17,871
日期需要的空间更大一些
视具体的日期而定

529
00:27:18,105 --> 00:27:20,440
它会自动占用发件人的空间

530
00:27:21,441 --> 00:27:24,077
主题行也是如此

531
00:27:24,144 --> 00:27:26,547
它显示为漂亮的粗体
可以使用邮件正文的单行预览

532
00:27:26,613 --> 00:27:29,416
显示其内容

533
00:27:29,483 --> 00:27:30,851
其文本颜色更深一些

534
00:27:30,918 --> 00:27:34,521
这样 我们可以重点显示发件人
然后重点显示邮件主题

535
00:27:35,155 --> 00:27:37,124
我们也可以将它们
放入一个StackView

536
00:27:37,191 --> 00:27:38,892
合适地显示邮件内容

537
00:27:39,693 --> 00:27:42,062
然后 这里有一些标记
和其它一些属性

538
00:27:42,129 --> 00:27:45,999
我们可以将其余内容
嵌入一个GridView

539
00:27:47,367 --> 00:27:50,537
最终我们的邮件列表
成为一个TableView

540
00:27:50,704 --> 00:27:52,606
它包含一个GridView

541
00:27:52,673 --> 00:27:54,575
里面嵌入一个StackView

542
00:27:57,177 --> 00:27:59,847
接下来看预览
也是就是边栏

543
00:28:00,581 --> 00:28:04,585
在这里 我要显示
《美国税法》PDF文件

544
00:28:07,054 --> 00:28:10,290
我们想要在边栏
显示每个PDF页面的预览

545
00:28:10,824 --> 00:28:13,727
我们再次从ContainerView开始

546
00:28:14,595 --> 00:28:16,597
请思考PDF的属性

547
00:28:16,797 --> 00:28:18,632
可能会很有很多的页面

548
00:28:18,899 --> 00:28:23,971
《美国税法》PDF页数
超过6500页

549
00:28:24,538 --> 00:28:26,740
当然 需要能够选择其中的页面
甚至应该能够重新排序

550
00:28:26,807 --> 00:28:30,277
预览功能允许你重新排序
PDF页面和另存文件

551
00:28:31,545 --> 00:28:32,946
我个人特别喜欢

552
00:28:33,013 --> 00:28:35,849
使用这个功能
来挑出PDF文件中的空白页

553
00:28:35,916 --> 00:28:37,017
和另存文件

554
00:28:38,285 --> 00:28:41,121
但是这意味着
我们需要支持数据源的视图组件

555
00:28:41,188 --> 00:28:44,892
我们再次使用StackView 和GridView
我们将取出内容

556
00:28:45,459 --> 00:28:47,327
然后我们进一步研究

557
00:28:47,394 --> 00:28:51,965
由于有一个单列垂直布局
因此不需要使用浏览器

558
00:28:54,701 --> 00:28:57,037
另外还需要可折叠的类别

559
00:28:58,672 --> 00:29:00,240
刚开始时 我显示过一个截屏

560
00:29:00,307 --> 00:29:03,544
PDF文件名旁边
有一个小提示三角

561
00:29:03,744 --> 00:29:06,480
预览功能让你能够在一个窗口中

562
00:29:06,547 --> 00:29:08,282
同时查看多页PDF

563
00:29:08,348 --> 00:29:10,384
而且可以很方便地

564
00:29:10,450 --> 00:29:12,819
跳转页面和重新布局

565
00:29:14,054 --> 00:29:16,056
由于我们需要可折叠的类别

566
00:29:17,257 --> 00:29:18,292
因此必须排除TableView

567
00:29:18,358 --> 00:29:20,594
那么还剩下CollectionView
或OutlineView可供选择

568
00:29:21,528 --> 00:29:24,064
这是一个有趣的选择

569
00:29:24,131 --> 00:29:25,365
应该选择哪一个呢？

570
00:29:25,899 --> 00:29:28,468
当我们调整边栏大小时
会发生什么呢？

571
00:29:28,535 --> 00:29:31,238
你可以看到页面预览

572
00:29:31,305 --> 00:29:36,310
在垂直和水平维度比例变大

573
00:29:37,144 --> 00:29:39,413
传统地 如果利用OutlineView
将需要添加更多的代码

574
00:29:39,479 --> 00:29:43,884
因为需要调整行高度

575
00:29:43,951 --> 00:29:46,987
当用户移动分拆视图时
需要处理这些工作

576
00:29:47,454 --> 00:29:49,323
但在macOS High Sierra中

577
00:29:49,389 --> 00:29:52,626
OutlineView会自动地
为你处理这些事情

578
00:29:54,161 --> 00:29:55,562
让我们来深入了解

579
00:29:55,629 --> 00:29:58,999
来看预览界面的另一部分

580
00:29:59,066 --> 00:30:00,467
这是联系人表格

581
00:30:01,101 --> 00:30:04,104
联系人表格也显示页面预览

582
00:30:04,171 --> 00:30:05,472
和页码

583
00:30:05,706 --> 00:30:09,643
它看上去很像是边栏
但实际上你使用的是GridView

584
00:30:10,277 --> 00:30:14,014
这让你能够重复使用你的数据源

585
00:30:14,081 --> 00:30:17,618
如果边栏和联系人表格
都使用CollectionView

586
00:30:17,818 --> 00:30:19,786
我们可以重复使用我们的数据源代码

587
00:30:20,320 --> 00:30:21,388
这很不错

588
00:30:21,455 --> 00:30:24,358
我们只需要更改
CollectionView的流布局

589
00:30:24,424 --> 00:30:27,861
事实上 在本例中
这正是预览所做的工作

590
00:30:30,898 --> 00:30:33,066
这是互联网账户首选项面板

591
00:30:33,133 --> 00:30:35,669
在这里我想查看账户类型

592
00:30:35,736 --> 00:30:39,239
点击一个账户类型
将出现一个表格 你可以进入

593
00:30:39,306 --> 00:30:42,109
输入详细信息
可以创建新的账户类型

594
00:30:43,477 --> 00:30:46,346
我们再次
从ContainerView列表开始

595
00:30:47,781 --> 00:30:49,750
这里有一些账户类型

596
00:30:49,816 --> 00:30:55,422
共有十个类型 我们可以
放入所有类型 然后小幅滚动

597
00:30:55,489 --> 00:31:00,327
我们不必考虑动态化的视图变更

598
00:31:00,594 --> 00:31:02,462
这是一个单维度垂直布局

599
00:31:02,529 --> 00:31:07,868
因此我们只需在
StackView和TableView中选择

600
00:31:09,503 --> 00:31:12,005
其实我们无需选择功能
事实上 每个项目都是一个按钮

601
00:31:12,072 --> 00:31:13,974
我们不想要提供选择

602
00:31:14,041 --> 00:31:17,945
而且希望在用户按下按钮之后
立即显示表格

603
00:31:19,246 --> 00:31:21,715
这看上去有点像StackView

604
00:31:22,216 --> 00:31:25,052
根据我列出的要求

605
00:31:25,118 --> 00:31:28,455
我建议你们使用StackView

606
00:31:30,757 --> 00:31:33,427
然后 账户首选项面板
使用TableView

607
00:31:34,328 --> 00:31:36,997
部分原因在于历史记录

608
00:31:38,165 --> 00:31:40,467
账户首选项面板是
在我们推出StackView

609
00:31:40,534 --> 00:31:42,302
和AppKit之前编写的
它运行良好

610
00:31:42,369 --> 00:31:44,471
你可以将TableView
设置为不具备选择功能

611
00:31:44,972 --> 00:31:47,007
代码已经存在
而且运行良好

612
00:31:49,543 --> 00:31:51,912
但是如果我们深入研究
如果滚动到底部

613
00:31:51,979 --> 00:31:53,347
将看到这个
“添加其它账户”选项

614
00:31:53,413 --> 00:31:56,283
点击它 将会添加
七个新账户类型

615
00:31:56,783 --> 00:31:58,418
那么 就有17个项目

616
00:31:58,485 --> 00:31:59,319
需要滚动查看

617
00:32:00,287 --> 00:32:02,389
StackView可以轻松地
处理这些工作

618
00:32:02,890 --> 00:32:05,926
但是你必须手动
添加项目到StackView

619
00:32:05,993 --> 00:32:07,160
代码并不多

620
00:32:08,395 --> 00:32:11,632
但是在这里 数据是动态的

621
00:32:11,698 --> 00:32:14,768
我倾向于使用支持数据源的视图

622
00:32:14,835 --> 00:32:16,603
可以告诉表格重载数据

623
00:32:16,670 --> 00:32:19,373
并从数据源提供动态数据

624
00:32:19,573 --> 00:32:22,242
因此我建议使用TableView

625
00:32:25,078 --> 00:32:27,247
这是终端的新远程连接

626
00:32:28,048 --> 00:32:30,751
这是一个很不错的
NSBrowser范例

627
00:32:31,218 --> 00:32:33,854
在这里 我要批评整个用户界面

628
00:32:33,921 --> 00:32:35,822
请看UI的大小和形状

629
00:32:35,889 --> 00:32:40,260
尤其是垂直空间
与水平空间之间的比例

630
00:32:41,061 --> 00:32:42,529
我想 最好的评价方法

631
00:32:43,497 --> 00:32:47,267
是将现有的界面

632
00:32:47,334 --> 00:32:49,069
与使用OutlineView之后的界面
进行比较

633
00:32:49,937 --> 00:32:53,507
我们立即看到 在右侧

634
00:32:53,907 --> 00:32:58,245
有一个较大的空白区域
这并没有很好地利用空间

635
00:32:59,680 --> 00:33:03,083
另外 当用户放弃当前服务商

636
00:33:03,150 --> 00:33:06,653
查找其他服务器时
他们会看到很多相似的名称

637
00:33:06,720 --> 00:33:09,489
必须进行大量的滚动操作
才能找到想要的项目

638
00:33:09,723 --> 00:33:13,260
最后 这里还有两组+和-号按钮

639
00:33:13,727 --> 00:33:14,661
它们是干什么用的？

640
00:33:15,162 --> 00:33:17,598
很显然 它们用来添加服务器和服务

641
00:33:17,664 --> 00:33:20,767
但是 哪个用来添加服务器
哪个用来添加服务呢？

642
00:33:22,503 --> 00:33:25,572
利有浏览器
可以提供合适的交互区域

643
00:33:27,407 --> 00:33:30,677
其显示十分明确
一个列用于选择服务器

644
00:33:30,744 --> 00:33:32,246
另一个列用于选择服务

645
00:33:32,312 --> 00:33:35,716
不同的+和-号按钮组
用于不同的列 非常清楚

646
00:33:39,386 --> 00:33:42,789
但是有时候 无法一码通吃

647
00:33:43,023 --> 00:33:45,192
一个典型的例子是查找程序

648
00:33:45,626 --> 00:33:47,160
查找程序具有分区控件

649
00:33:47,227 --> 00:33:51,431
可以按列表视图、
图标视图或列视图

650
00:33:51,498 --> 00:33:53,000
浏览和查找文件

651
00:33:54,568 --> 00:33:56,436
因此 对于不同的情况和数据类型

652
00:33:56,503 --> 00:33:58,172
用户可能会做出不同的选择

653
00:33:58,238 --> 00:34:00,240
你可能需要实现多种样式

654
00:34:00,307 --> 00:34:02,276
你必须考虑到这一点

655
00:34:02,709 --> 00:34:06,046
另一个例子是
Image Capture截屏

656
00:34:06,346 --> 00:34:09,081
这些是我的手机近期拍摄的照片

657
00:34:09,483 --> 00:34:11,918
这些照片显示
在Image Capture图标视图中

658
00:34:12,186 --> 00:34:14,188
我可以快速找到我想要的照片

659
00:34:14,254 --> 00:34:16,389
将它拖放并复制到桌面

660
00:34:18,025 --> 00:34:20,761
但是有时候
查找照片可能比较困难

661
00:34:20,827 --> 00:34:26,400
特别是当我寻找
具有与照片相似预览的影片时

662
00:34:27,568 --> 00:34:29,402
用户首选项的控制范围

663
00:34:29,469 --> 00:34:30,737
可以到达底部

664
00:34:31,371 --> 00:34:34,574
这是一个分区控件
允许用户从图标视图

665
00:34:34,641 --> 00:34:35,876
切换到列表视图

666
00:34:35,976 --> 00:34:39,780
现在 在列表视图中
有一个美观的多列视图

667
00:34:39,847 --> 00:34:41,380
我可以点击它们的标题

668
00:34:41,447 --> 00:34:44,885
按类型重新排序
查找我想要的影片

669
00:34:48,455 --> 00:34:50,023
最后 我想要显示…

670
00:34:50,424 --> 00:34:53,126
我想要重新构建
打印机首选项面板

671
00:34:54,261 --> 00:34:58,732
这里有一个NSTableView
它使用分组行标题

672
00:34:59,066 --> 00:35:02,135
支持打印机 传真机
甚至还支持扫描仪

673
00:35:02,903 --> 00:35:07,641
然后在右侧
有一个无表格TabView

674
00:35:08,108 --> 00:35:12,012
但是在本演讲中
我们还没有讨论过TabView

675
00:35:12,079 --> 00:35:15,315
关于无表格TabView
我想要介绍一些有趣的功能

676
00:35:16,316 --> 00:35:20,254
利用无表格TabView
可以设置不同类型的界面

677
00:35:21,221 --> 00:35:23,857
比如 为打印机设置
不同的属性

678
00:35:23,924 --> 00:35:26,393
详细的属性
不同于传真机的属性

679
00:35:26,460 --> 00:35:30,163
我可以在无表格TabView中
设置这些不同的属性

680
00:35:30,230 --> 00:35:32,332
然后当用户更改
TableView中的选择时

681
00:35:32,399 --> 00:35:34,635
编程选择表格

682
00:35:34,968 --> 00:35:38,939
然后表格将完成所有后台工作
载入合适的Zip文件

683
00:35:39,006 --> 00:35:42,142
自动为我在视图
层次结构中添加视图

684
00:35:42,709 --> 00:35:44,611
我们来看详情列表

685
00:35:44,678 --> 00:35:48,115
这里有一个StackView集合

686
00:35:48,182 --> 00:35:51,051
我们进一步细分
可以看到这里有一个GridView

687
00:35:51,118 --> 00:35:52,786
显示标签的详细属性

688
00:35:52,853 --> 00:35:54,688
和打印机的详细属性

689
00:35:54,755 --> 00:35:56,523
甚至包括页面大小

690
00:35:56,623 --> 00:36:00,460
默认打印机
及其相关弹出菜单

691
00:36:01,228 --> 00:36:04,998
在所有这些设置完成之后
当用户切换到阿拉伯语时

692
00:36:05,065 --> 00:36:08,168
所有视图立即合适地
变更为从右至左语言显示模式

693
00:36:08,235 --> 00:36:11,305
从而让阿拉伯语用户
获得良好的用户体验

694
00:36:14,908 --> 00:36:19,012
让我们进行回顾
AppKit拥有大量现成的视图

695
00:36:19,079 --> 00:36:20,647
可用于多种用途

696
00:36:21,748 --> 00:36:23,684
用户可以使用前面我讲解过的图表

697
00:36:23,750 --> 00:36:26,053
使用我介绍过的一些用例

698
00:36:26,119 --> 00:36:30,023
细化你的用户界面
充分利用空间

699
00:36:30,090 --> 00:36:32,492
分析哪种类型的ContainerView
最适合你的需求

700
00:36:32,559 --> 00:36:34,828
不要忘了
还可以组合视图

701
00:36:35,095 --> 00:36:40,200
可以在StackView内
放置GridView 反之亦然

702
00:36:42,569 --> 00:36:45,038
前面特洛伊在讲解
StackView和GridView时说过

703
00:36:45,105 --> 00:36:48,742
我们还有一些不错的学习资源

704
00:36:50,277 --> 00:36:53,347
TableView、OutlineView
和Browser也是如此

705
00:36:55,616 --> 00:36:58,118
关于CollectionView
也有一些很好的学习资源

706
00:36:59,152 --> 00:37:02,155
在开发者网站演讲218视频的
“更多信息”部分

707
00:37:02,222 --> 00:37:06,126
你可以找到这些信息的链接

708
00:37:08,729 --> 00:37:10,931
一些相关演讲包括“高级触控条”

709
00:37:10,998 --> 00:37:13,000
将在今天5:10举行

710
00:37:13,066 --> 00:37:14,635
他们将会讲解

711
00:37:14,701 --> 00:37:17,971
如何在触控条中使用
这些ContainerView

712
00:37:18,138 --> 00:37:20,874
当然 也请观看
“Cocoa开发小技巧”

713
00:37:21,008 --> 00:37:23,243
此演讲将会为你提供
一些有趣的小技巧

714
00:37:23,977 --> 00:37:27,114
请享受WWDC其余部分 谢谢大家

