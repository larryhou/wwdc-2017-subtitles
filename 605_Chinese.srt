1
00:00:23,056 --> 00:00:23,891
谢谢

2
00:00:26,159 --> 00:00:27,294
大家早上好

3
00:00:27,528 --> 00:00:29,930
欢迎来到“Swift Playground中
SceneKit的使用”演讲

4
00:00:30,497 --> 00:00:31,665
我是Michael DeWitt

5
00:00:31,798 --> 00:00:34,401
今天我很激动地向大家介绍

6
00:00:34,468 --> 00:00:37,704
如何利用SceneKit
制作Learn to Code内容

7
00:00:38,438 --> 00:00:41,108
但愿你们都已熟悉
Swift Playground

8
00:00:41,275 --> 00:00:42,743
但让我来给大家展示一个
Learn to Code

9
00:00:44,912 --> 00:00:47,781
这是一个Learn to Code
内容的示例课程

10
00:00:47,848 --> 00:00:49,449
存在于Swift Playground内

11
00:00:50,150 --> 00:00:53,387
左侧是课程和用户的代码

12
00:00:54,021 --> 00:00:54,855
但对于本场演讲

13
00:00:54,922 --> 00:00:56,990
我们实际上要重点关注右侧

14
00:00:57,090 --> 00:00:58,225
请注意即时取景

15
00:00:58,892 --> 00:01:02,362
我们可以把它放大为全屏显示
这样看得更清楚

16
00:01:03,430 --> 00:01:04,498
这个角色 百特

17
00:01:04,864 --> 00:01:08,035
现正快速绕着地图跑并收集宝石

18
00:01:08,836 --> 00:01:10,904
不停地上下台阶

19
00:01:11,505 --> 00:01:13,974
当百特收集到全部宝石之后

20
00:01:15,008 --> 00:01:16,677
我们得到了一个祝贺场景

21
00:01:17,144 --> 00:01:19,279
让学习者了解他们实现了很棒的功能

22
00:01:19,613 --> 00:01:21,415
并且百特甚至还会跳舞

23
00:01:22,149 --> 00:01:23,383
让人们了解这真的很棒

24
00:01:24,551 --> 00:01:25,986
这就是我们今天的案例研究

25
00:01:26,520 --> 00:01:31,391
我们要通过这个场景来展示
如何有效地使用SceneKit

26
00:01:31,792 --> 00:01:34,895
并把丰富的3D内容带到你的应用中去

27
00:01:36,396 --> 00:01:41,235
如果你对3D感兴趣
但还是个新手

28
00:01:41,768 --> 00:01:43,036
那你来得正合适

29
00:01:43,337 --> 00:01:46,006
因为我们要从一些
很不一样的东西开始讲起

30
00:01:47,808 --> 00:01:50,244
我们要从简单的2D场景开始讲

31
00:01:50,811 --> 00:01:55,449
关于SceneKit最好的优点之一
就是允许2D程序员

32
00:01:55,849 --> 00:01:59,186
把这个场景放在现有时间轴上

33
00:01:59,453 --> 00:02:03,056
并通过我们发布到Learn to Code中
丰富的3D内容实现3D效果

34
00:02:04,324 --> 00:02:05,993
那么这就是我们今天要谈的内容

35
00:02:06,426 --> 00:02:07,561
我们一共有40分钟

36
00:02:07,694 --> 00:02:09,630
我们可以把它分成三个部分

37
00:02:10,731 --> 00:02:12,866
首先我要讲一下原型设计

38
00:02:13,133 --> 00:02:16,003
以及如何精化想法确保其真的很棒

39
00:02:17,304 --> 00:02:19,206
关于迭代 我想谈谈

40
00:02:19,273 --> 00:02:21,708
你何时会从你的供应商处
获得一些真正的资产

41
00:02:21,808 --> 00:02:23,944
如何建立有效的管道

42
00:02:24,678 --> 00:02:27,314
然后Lemont将上台讲一下调整

43
00:02:27,447 --> 00:02:28,982
并准备好发布场景

44
00:02:30,584 --> 00:02:32,753
首先是原型设计

45
00:02:35,189 --> 00:02:39,459
这是在我们决定使用
Learn to Code

46
00:02:39,526 --> 00:02:41,595
且我们已准备好
开始创建东西时出现的

47
00:02:42,196 --> 00:02:44,831
那么你之前看到过这个图
但在这里它是在情境中

48
00:02:46,667 --> 00:02:49,970
我们一开始有来自表情集合的宝石

49
00:02:50,037 --> 00:02:51,572
和四处散放的资产

50
00:02:51,772 --> 00:02:54,975
因为我们只需要拾取并尽可能快地跑

51
00:02:55,242 --> 00:02:57,778
以在这个新应用中测试交互模型

52
00:02:58,345 --> 00:02:59,413
我们从这里学到了很多

53
00:02:59,479 --> 00:03:01,048
资产看起来怎么样并不重要

54
00:03:01,849 --> 00:03:05,519
但通过这个原型设计过程
我们开始获得一些早期反馈

55
00:03:06,653 --> 00:03:09,022
其中有些评论是关于图形的

56
00:03:09,489 --> 00:03:12,459
它…请求比如说我们
是否可以修改宝石颜色

57
00:03:12,593 --> 00:03:14,661
我们是否在场景周围添加一个边框

58
00:03:14,728 --> 00:03:17,831
或我们是否可以让相机在尽头处
转动以提供一些视觉趣味

59
00:03:18,999 --> 00:03:23,504
这是很好的反馈 它真的非常有迭代性

60
00:03:23,937 --> 00:03:24,872
当你进行原型设计时

61
00:03:24,938 --> 00:03:27,007
你不应该害怕把它们全部扔掉

62
00:03:27,641 --> 00:03:30,143
那么如果我们返回去看情境中的场景

63
00:03:30,677 --> 00:03:33,046
你可以看到它在这个页面上很单调

64
00:03:33,380 --> 00:03:36,149
视觉效果是我们得到的全部反馈

65
00:03:36,450 --> 00:03:38,752
我们只需要重新评估我们的策略

66
00:03:40,387 --> 00:03:44,725
因为我们在SpriteKit中做的
现在我们要开始使用SceneKit

67
00:03:45,459 --> 00:03:47,594
对于你们中
熟悉SpriteKit的人来说

68
00:03:48,228 --> 00:03:49,930
你了解它有以下概念：

69
00:03:50,631 --> 00:03:53,000
基本上是一个执行更新逻辑的场景

70
00:03:53,166 --> 00:03:57,738
一个把对象放在视图中的节点
还有移动对象的行动

71
00:03:58,672 --> 00:04:01,742
现在Apple开发SceneKit
的好处还包括

72
00:04:02,109 --> 00:04:04,244
它有许多这样的相同概念

73
00:04:05,746 --> 00:04:09,383
这就给了我们足够的信心
一个简单的切换

74
00:04:09,550 --> 00:04:11,885
开始使用SceneKit
并深入了解它

75
00:04:12,386 --> 00:04:13,921
那么跟你们中许多人一样

76
00:04:14,121 --> 00:04:17,824
我们看了2015年的
一场WWDC演讲

77
00:04:17,891 --> 00:04:19,993
那是一场很棒的演讲
是SceneKit团队主讲的

78
00:04:20,093 --> 00:04:23,096
内容是关于如何创建简单的场景
就像你们在这里看到的这个一样

79
00:04:24,631 --> 00:04:26,266
但不只是这样

80
00:04:26,333 --> 00:04:28,669
我们还要使用示例中的一些资产

81
00:04:29,303 --> 00:04:30,704
并重新创建我们的场景

82
00:04:32,072 --> 00:04:33,273
所以我们现在来到了这个舞台

83
00:04:33,407 --> 00:04:36,243
我们马上就会告诉你们
这只是一种更好的方式

84
00:04:36,310 --> 00:04:40,013
我的意思是它更拟真
你可以随意拖动相机

85
00:04:40,113 --> 00:04:41,915
并且它会帮助你解决等级问题

86
00:04:43,617 --> 00:04:45,118
这张幻灯片的重点是

87
00:04:45,452 --> 00:04:48,488
即使我们已经明确地提升了视觉质量

88
00:04:49,456 --> 00:04:50,524
当你设计原型时

89
00:04:50,591 --> 00:04:52,826
你仍希望使视觉保真度
保持一个低水平

90
00:04:52,993 --> 00:04:56,096
那么当我们添加新游戏结构时
比如这些门户

91
00:04:57,064 --> 00:04:58,665
我们采用了SceneKit基元实现

92
00:04:59,132 --> 00:05:00,467
因为我们不想提得太高

93
00:05:00,534 --> 00:05:03,036
以确保场景看起来绝对很棒

94
00:05:03,170 --> 00:05:04,738
我们首先要确保这是一个好主意

95
00:05:05,906 --> 00:05:09,510
所以我把这个丢到
Business Tool 101图表上

96
00:05:10,744 --> 00:05:13,080
你基本可以看到项目的整个时间轴

97
00:05:13,981 --> 00:05:16,617
你想把其中一大块分配给原型设计

98
00:05:17,150 --> 00:05:20,821
因为这是你可以做出最多修改的部分

99
00:05:20,921 --> 00:05:22,356
而做出修改需要付出的努力并不多

100
00:05:23,490 --> 00:05:25,559
尤其当你正在做3D时

101
00:05:26,126 --> 00:05:27,594
当你开始获取真实的资产时

102
00:05:27,661 --> 00:05:29,530
这是我们下一个部分要讲到的内容

103
00:05:30,097 --> 00:05:31,698
要进行修改需要付出的努力不断增加

104
00:05:32,432 --> 00:05:34,268
所以当你设计原型时请留意这一点

105
00:05:35,569 --> 00:05:38,138
那么总的来说 其实你想

106
00:05:38,205 --> 00:05:40,440
当你在设计原型时 测试你的交互模型

107
00:05:40,507 --> 00:05:41,642
这并不是与资产相关

108
00:05:42,142 --> 00:05:44,344
你想阐明你接收的反馈

109
00:05:44,745 --> 00:05:46,547
但并不想做出越来越多的修改

110
00:05:46,680 --> 00:05:48,315
想要确保这个想法是有效的

111
00:05:49,082 --> 00:05:51,885
最后利用从这部分获得的洞察力

112
00:05:51,985 --> 00:05:52,886
去写代码

113
00:05:53,220 --> 00:05:56,890
我觉得我们做的最棒的决策是
开始新建项目

114
00:05:56,957 --> 00:06:01,228
当我们朝着这点努力时
这就将我们带入了迭代

115
00:06:04,231 --> 00:06:07,367
现在我们已经有了想法
我们准备好获得一些真正的艺术了

116
00:06:07,534 --> 00:06:11,305
我们开始与设计师一起工作
我们得到了这个早期的2D样稿

117
00:06:13,540 --> 00:06:16,143
你可以看到
它现在与百特的世界很相似

118
00:06:16,410 --> 00:06:17,477
看起来要好点

119
00:06:17,945 --> 00:06:20,848
我想把这个世界分成四部分

120
00:06:21,682 --> 00:06:24,151
我要讲的第一件事就是它是如何建造的

121
00:06:24,818 --> 00:06:26,720
以及有效建造的一些策略

122
00:06:27,487 --> 00:06:33,460
接下来我们要看看如何在你的应用中
完成复杂的动画

123
00:06:33,794 --> 00:06:35,963
通过查看我们如何实现让百特上下台阶

124
00:06:37,464 --> 00:06:40,067
我们还要了解如何用水

125
00:06:40,133 --> 00:06:41,401
和其它场景元素添加视觉趣味

126
00:06:42,603 --> 00:06:45,472
然后我们就重点讲视觉部分

127
00:06:45,873 --> 00:06:47,941
但是还有整个用户方面

128
00:06:48,075 --> 00:06:51,245
实际上不能从3D场景的图形中
获得什么好处

129
00:06:51,411 --> 00:06:54,214
所以我们要花点儿时间讲讲可达性支持

130
00:06:54,281 --> 00:06:55,582
尤其是VoiceOver

131
00:06:56,683 --> 00:07:00,521
好了 首先是给这个世界建模

132
00:07:01,455 --> 00:07:04,892
那么你可以通过模具看到
我们是通过这些组块创建世界的

133
00:07:05,025 --> 00:07:06,260
我们有单项资产

134
00:07:06,660 --> 00:07:07,995
这样做是有原因的

135
00:07:09,363 --> 00:07:12,065
我们不仅需要在资产设计上迭代

136
00:07:12,132 --> 00:07:13,734
还需要在课程设计上迭代

137
00:07:14,234 --> 00:07:16,870
所以我们把像这样的简单拼图拼在一起

138
00:07:17,571 --> 00:07:20,507
确保学习者能顺利学习大纲

139
00:07:21,909 --> 00:07:25,579
但不是把这些单一的组块
放在场景编辑器中

140
00:07:25,679 --> 00:07:29,183
那会非常乏味 而是写一些代码来实现

141
00:07:29,550 --> 00:07:31,919
很像使用Learn to Code 2的学习者们

142
00:07:31,985 --> 00:07:33,287
当他们创建自己的世界时

143
00:07:34,087 --> 00:07:36,823
我们写了一些代码来生成这个
它看起来是这样的

144
00:07:38,025 --> 00:07:41,662
要创建那个世界
你首先要给它一个尺寸 5乘5

145
00:07:42,262 --> 00:07:46,466
你把元素放进去 比如演员
或你在之前的场景中见到过的百特

146
00:07:47,067 --> 00:07:48,535
然后你可以添加附加元素

147
00:07:48,602 --> 00:07:51,572
比如宝石或你在中心看到过的水

148
00:07:52,873 --> 00:07:55,342
但我展示这段代码的原因不是因为

149
00:07:55,409 --> 00:07:57,578
“哇哦 我们写了一个API
创建了一个世界” 这很酷

150
00:07:57,911 --> 00:08:01,748
而其实是因为这与图形是完全分离的

151
00:08:02,015 --> 00:08:05,285
对吧？这段代码在2D中
和在3D中一样有效

152
00:08:06,453 --> 00:08:09,089
让我实际给你展示一下这是什么意思

153
00:08:09,156 --> 00:08:10,424
这里有一个短视频

154
00:08:15,796 --> 00:08:17,865
这里有百特 正在这个世界中移动

155
00:08:18,065 --> 00:08:19,766
我们要添加一些节点

156
00:08:20,000 --> 00:08:22,035
你在场景中看到的红色和绿色节点

157
00:08:22,169 --> 00:08:25,539
其实代表了我们重建
游戏设置所使用的数据

158
00:08:29,776 --> 00:08:32,546
实际上我们所需要的就是那个数据

159
00:08:33,145 --> 00:08:36,116
我们把场景的图形

160
00:08:36,216 --> 00:08:38,552
和用于重建游戏设置的数据分离了

161
00:08:39,553 --> 00:08:40,854
这样做有几个很大的好处

162
00:08:40,921 --> 00:08:43,524
我想让你在给3D世界建模时考虑一下

163
00:08:45,092 --> 00:08:46,760
将数据与图形分离

164
00:08:47,294 --> 00:08:49,863
首先它允许你简单地置换出资产

165
00:08:50,264 --> 00:08:51,965
请记住 我们仍在这个材料上进行迭代

166
00:08:52,032 --> 00:08:54,801
无论如何我们将获得这个组块的新版本

167
00:08:55,002 --> 00:08:56,803
并且我们不想重建这些地图

168
00:08:57,004 --> 00:08:58,639
所以我们就动态地生成了地图

169
00:08:59,940 --> 00:09:02,843
它还允许你获取那个数据
并将其发送到别处

170
00:09:03,010 --> 00:09:04,645
也许你需要将其通过网络发送出去

171
00:09:04,878 --> 00:09:07,281
或在处理过程中发送一些游戏设置逻辑

172
00:09:07,347 --> 00:09:08,882
比如我们在某些游戏场地中所做的那样

173
00:09:09,883 --> 00:09:11,285
一段时间之后

174
00:09:11,351 --> 00:09:13,887
它还将允许你优化几何体

175
00:09:14,521 --> 00:09:16,590
Lemont将会具体介绍

176
00:09:16,790 --> 00:09:18,659
但有一点很关键 就是你并不依赖于

177
00:09:18,725 --> 00:09:21,228
实际的节点和场景才能实现

178
00:09:22,496 --> 00:09:23,463
我有一个警告

179
00:09:24,831 --> 00:09:27,835
你需要一些调试工具
使这个运行起来更棒

180
00:09:27,935 --> 00:09:29,203
我们在很早之前就发现了

181
00:09:29,670 --> 00:09:31,438
你不再只是查看世界了

182
00:09:31,505 --> 00:09:33,674
而是查看如何重建游戏设置

183
00:09:34,107 --> 00:09:36,710
所以我们创建了一个
非常简单的Mac应用

184
00:09:37,678 --> 00:09:40,881
这个应用可以加载
我们所拥有的全部等级

185
00:09:41,315 --> 00:09:44,651
更重要的是它有专门的场景知识

186
00:09:45,552 --> 00:09:47,821
那么既然这样 这个工具就是

187
00:09:47,888 --> 00:09:50,757
允许我们展示你之前
看到过的那些调试节点的工具

188
00:09:51,525 --> 00:09:55,028
它还可以在我们的游戏中
运行难以达到的情况

189
00:09:55,229 --> 00:09:58,699
比如当你达到祝贺序列时
围绕世界旋转

190
00:09:58,932 --> 00:10:00,601
我们想确保能在每一幅地图上使用

191
00:10:00,934 --> 00:10:03,437
但我们不想一直测试每一幅地图

192
00:10:04,004 --> 00:10:05,005
只是为了看到一个结果

193
00:10:06,473 --> 00:10:07,441
那么这就是我们的第一部分

194
00:10:07,808 --> 00:10:09,176
就是我们如何把世界拼在一起

195
00:10:09,343 --> 00:10:12,112
我们分离了数据和图形 并使用了工具

196
00:10:13,680 --> 00:10:15,816
现在讲动画

197
00:10:16,683 --> 00:10:18,585
如果我们近距离地看一下台阶

198
00:10:20,921 --> 00:10:23,857
你可以看到这其实是一个
相当复杂的几何体

199
00:10:24,057 --> 00:10:26,026
对吧？不仅有独立的台阶

200
00:10:26,293 --> 00:10:28,295
台阶上还有一些花样

201
00:10:28,562 --> 00:10:29,763
所以我们想做到超级精确

202
00:10:29,830 --> 00:10:32,566
关于我们角色的脚
落在每个台阶上的位置

203
00:10:33,634 --> 00:10:35,335
我们考虑了一些不同的策略

204
00:10:35,736 --> 00:10:39,173
对于3D场景来说
最常用的一个东西就是

205
00:10:39,406 --> 00:10:42,943
用斜坡替换台阶
因为斜坡的实现很简单

206
00:10:43,310 --> 00:10:46,180
你有一个角色 你向前移动那个角色

207
00:10:46,413 --> 00:10:48,215
你算出他们需要移动多远

208
00:10:48,415 --> 00:10:50,584
然后你只需要把他们从点A转移到点B

209
00:10:50,651 --> 00:10:51,919
当运行行走动作循环时

210
00:10:53,353 --> 00:10:55,189
对于台阶 并不是那么好做

211
00:10:55,656 --> 00:10:58,192
这是百特尝试上台阶

212
00:10:58,825 --> 00:11:00,093
如果你离近点儿看

213
00:11:00,661 --> 00:11:03,931
百特甚至没有接触到第一个台阶
他已经漂浮在半空中了

214
00:11:04,998 --> 00:11:06,633
所以我们要把这个效果做得更好

215
00:11:10,304 --> 00:11:14,441
我们要考虑的第二件事就是
使用SceneKit中的内嵌类型

216
00:11:14,508 --> 00:11:16,577
它其实是SceneKit
约束系统的一部分

217
00:11:16,643 --> 00:11:18,178
用于执行逆向运动

218
00:11:18,812 --> 00:11:21,348
现在逆向运动允许你得到超级精确度

219
00:11:21,548 --> 00:11:23,817
关于你想让角色的脚落在哪个位置

220
00:11:24,117 --> 00:11:27,454
那么我们要指定我们希望角色
上下的每一个台阶

221
00:11:28,555 --> 00:11:31,658
但它却伴随着牺牲了角色的一些个性
对吧？

222
00:11:31,725 --> 00:11:34,328
我们不能控制眼睛的运动

223
00:11:34,394 --> 00:11:36,730
或上半身的运动
不像我们想象中的那么具体

224
00:11:37,164 --> 00:11:38,599
我们其实还有第三种选择

225
00:11:39,032 --> 00:11:42,069
就是把位移合并到动画中去

226
00:11:42,569 --> 00:11:44,071
因为这是我们所采用的策略

227
00:11:44,137 --> 00:11:46,206
让我们再详细地具体看一下

228
00:11:47,841 --> 00:11:50,811
通常对绝大部分游戏来说都有节点

229
00:11:50,944 --> 00:11:53,780
代表一个位置 还有几何体

230
00:11:53,947 --> 00:11:56,049
就是你在场景中实际能看到的东西

231
00:11:57,117 --> 00:11:59,953
现在这两样东西同时移动也是很常见的

232
00:12:00,354 --> 00:12:02,856
所以你需要转换节点和几何体

233
00:12:02,956 --> 00:12:04,191
同时执行行走循环

234
00:12:04,258 --> 00:12:06,159
它会让角色从点A移动到点B

235
00:12:07,127 --> 00:12:08,795
但对于台阶
我们做了一点不一样的处理

236
00:12:10,464 --> 00:12:13,834
我们不干涉节点 并应用了一个动画

237
00:12:13,901 --> 00:12:15,869
这个动画中其实含有位移

238
00:12:16,069 --> 00:12:19,206
那么这就会把几何体从节点中移出来

239
00:12:19,873 --> 00:12:22,242
然后当动画完成后

240
00:12:22,543 --> 00:12:25,879
我们同步节点的位置并移除动画

241
00:12:27,214 --> 00:12:30,450
我们是通过SceneKit中一个
叫作SCNTransaction的类型实现的

242
00:12:31,985 --> 00:12:35,656
SCNTransaction允许你确保
在一帧中进行更新

243
00:12:36,123 --> 00:12:37,224
让我们具体看一下

244
00:12:38,525 --> 00:12:41,595
你用开始和提交调用设置

245
00:12:42,229 --> 00:12:44,531
在我们的示例中
我们想要的动画时长为零

246
00:12:44,598 --> 00:12:46,700
因为我们需要它在同一帧中发生

247
00:12:48,202 --> 00:12:52,573
我们把角色移动到新位置并移除动画

248
00:12:52,973 --> 00:12:55,943
让百特准备好下一轮的动画

249
00:12:56,810 --> 00:12:57,911
让我们看看实际效果

250
00:12:59,246 --> 00:13:00,380
先舒展一下身体

251
00:13:01,615 --> 00:13:02,749
走上台阶…

252
00:13:03,984 --> 00:13:06,453
你现在可以看到
因为我们允许这个动画师

253
00:13:06,520 --> 00:13:09,056
自由地把位移放到动画中

254
00:13:09,156 --> 00:13:11,692
针对百特的移动 我们变得非常精确了

255
00:13:12,159 --> 00:13:15,762
当它上下台阶时 百特的头也会转动

256
00:13:16,230 --> 00:13:17,731
这是一个较好的解决方案

257
00:13:17,798 --> 00:13:21,201
你需要针对你场景中的复杂动画
考虑一下

258
00:13:23,604 --> 00:13:25,305
第三点

259
00:13:26,406 --> 00:13:28,408
让我们看看如何处理场景元素

260
00:13:28,575 --> 00:13:30,110
因为它并不全与角色相关

261
00:13:30,277 --> 00:13:32,279
你还要确保这个世界感觉鲜活

262
00:13:33,547 --> 00:13:35,082
那么让我们近距离看一下水

263
00:13:36,583 --> 00:13:40,988
现在你见过我们之前曾用过
像这样的地图 是吧？

264
00:13:41,121 --> 00:13:44,358
相当基础 刚好能重建这个游戏

265
00:13:45,325 --> 00:13:47,694
但我们想实现像这样的地图

266
00:13:49,429 --> 00:13:53,166
我们的实现方式是将原始地图保存

267
00:13:53,267 --> 00:13:56,837
为SCN文件 以便添加这些附加元素

268
00:13:57,271 --> 00:14:00,174
对吧？那么我们不写代码
来放置每一个场景元素了

269
00:14:00,274 --> 00:14:03,043
我们现在可以在场景编辑器中实现了
因为那样更有意义

270
00:14:03,944 --> 00:14:05,913
若我们在SceneKit
场景编辑器中看一下

271
00:14:07,080 --> 00:14:10,984
它看起来很棒
但现在我们投入了很多时间和精力

272
00:14:11,051 --> 00:14:12,586
给每一个单独的地图

273
00:14:12,886 --> 00:14:15,856
你可以看到这是通过
左边的节点层级实现的

274
00:14:17,524 --> 00:14:21,295
那么问题是你仍然希望
保持一定数量的灵活性

275
00:14:21,361 --> 00:14:23,163
确保设计师不会在下一周过来说

276
00:14:23,230 --> 00:14:25,065
“我做了个新瀑布 看起来更好”

277
00:14:25,232 --> 00:14:27,134
那你不需要修改81幅地图

278
00:14:27,868 --> 00:14:30,704
实现方式是如果我们近距离看瀑布

279
00:14:31,672 --> 00:14:33,607
它使用了一个叫作引用节点的技术

280
00:14:34,141 --> 00:14:36,844
那么这些是我们场景中的水节点

281
00:14:37,144 --> 00:14:40,013
而箭头表示它们被引用到

282
00:14:40,080 --> 00:14:41,582
一个单一的SCN文件

283
00:14:41,782 --> 00:14:45,252
那么你只需要更新那一个文件
它就会传导到全部地图中

284
00:14:47,454 --> 00:14:49,356
现在这并不是与水相关的全部问题

285
00:14:50,090 --> 00:14:51,758
若我们再仔细看看那个SCN文件

286
00:14:53,093 --> 00:14:55,596
像水这样的元素必须得动起来
看着才会有意思

287
00:14:55,662 --> 00:14:57,097
对吧？设计师在这里做得不错

288
00:14:57,164 --> 00:15:00,000
纹理看起来超棒 但它不真实

289
00:15:01,335 --> 00:15:03,370
那么为了实现水的移动

290
00:15:03,437 --> 00:15:05,973
我们要使用一个技术
一个几何体修改器

291
00:15:06,039 --> 00:15:09,142
其实是写一个着色器 你可以通过

292
00:15:09,243 --> 00:15:11,545
右下方的按钮获取

293
00:15:12,479 --> 00:15:14,581
我把它放大一点 不然很难看到

294
00:15:15,415 --> 00:15:17,985
那会打开一个托盘
是Xcode 9中的新功能

295
00:15:18,619 --> 00:15:21,989
你可以修改或指定
你的几何体修改器

296
00:15:22,256 --> 00:15:25,993
构建由SceneKit提供给你的
这个SCN着色器几何体类型

297
00:15:26,627 --> 00:15:27,728
那么这要实现的是

298
00:15:27,794 --> 00:15:29,963
围绕瀑布移动纹理

299
00:15:30,497 --> 00:15:31,732
但它添加了一个很棒的效果

300
00:15:32,399 --> 00:15:33,433
让我们看一下效果

301
00:15:38,872 --> 00:15:39,706
开始吧

302
00:15:40,007 --> 00:15:41,942
那么现在水实际上是在流动的

303
00:15:42,075 --> 00:15:43,610
你可以看到纹理的移动

304
00:15:43,677 --> 00:15:44,978
且它添加了这个很棒的效果

305
00:15:45,445 --> 00:15:48,916
我们将采用同样的技术
处理场景中摇摆的葡萄藤

306
00:15:48,982 --> 00:15:51,251
以及被微风吹动的小草

307
00:15:51,518 --> 00:15:53,720
那么这给你的场景添加了许多生气

308
00:15:54,121 --> 00:15:56,089
这是一个很棒的技术 你可以尝试一下

309
00:15:57,424 --> 00:15:58,258
这是第三点

310
00:15:59,092 --> 00:16:00,994
我们真的很关注视觉效果

311
00:16:01,929 --> 00:16:04,498
我们采取了若干步骤
来解决如何让效果更棒的问题

312
00:16:04,831 --> 00:16:06,967
但还有另外一整个方面
也是你要考虑到的

313
00:16:07,434 --> 00:16:10,637
这就是对于有视力障碍的用户来说
场景看起来是什么样的

314
00:16:12,372 --> 00:16:15,776
那么当你尝试在VoiceOver中
设计一个很棒的体验时

315
00:16:16,510 --> 00:16:19,313
很明显 你希望更多地关注元素
而不是视觉效果

316
00:16:19,813 --> 00:16:21,949
但我不会描述我们所做的一切

317
00:16:22,015 --> 00:16:24,151
我首先希望你先听一下这个体验

318
00:16:29,256 --> 00:16:30,324
<i>打开VoiceOver</i>

319
00:16:30,557 --> 00:16:31,458
<i>横屏</i>

320
00:16:32,326 --> 00:16:34,761
<i>这个世界是五栏乘五行</i>

321
00:16:35,929 --> 00:16:39,800
<i>栏0 行0 百特的高度为0 面朝北</i>

322
00:16:40,334 --> 00:16:42,236
<i>轻触两次切换角色</i>

323
00:16:42,369 --> 00:16:45,472
<i>栏0 行1 宝石高度为0</i>

324
00:16:52,045 --> 00:16:55,148
那么…我们采取了一系列的操作

325
00:16:55,215 --> 00:16:56,984
以在Learn to Code中
支持VoiceOver

326
00:16:57,951 --> 00:16:59,453
但我希望你注意到的第一件事是

327
00:16:59,953 --> 00:17:03,290
我们其实关注的是一个
很棒的非视觉体验

328
00:17:03,457 --> 00:17:06,226
通过添加音乐 通过添加角色声音

329
00:17:06,425 --> 00:17:10,063
你让这个场景听起来很丰富

330
00:17:11,898 --> 00:17:15,169
我们还向VoiceOver中
添加了其它东西

331
00:17:15,301 --> 00:17:17,503
要深入研究这些技巧

332
00:17:17,671 --> 00:17:19,473
请参看今年的一场很不错的演讲

333
00:17:19,573 --> 00:17:21,875
关于使媒体和游戏可理解

334
00:17:23,210 --> 00:17:24,877
对我们来说非常重要的一点

335
00:17:25,212 --> 00:17:28,281
其实是使用VoiceOver
描述重要的地理位置

336
00:17:28,949 --> 00:17:31,552
我想具体介绍这个的原因是

337
00:17:31,685 --> 00:17:33,587
因为它惊人简单

338
00:17:34,421 --> 00:17:36,190
那么跟你的UIKit应用一样

339
00:17:36,924 --> 00:17:38,892
我们覆盖一个可访问性元素

340
00:17:39,960 --> 00:17:42,262
我们可以提供一个自定义标签

341
00:17:43,030 --> 00:17:45,399
在本例中 我们提供了一个标签

342
00:17:45,699 --> 00:17:48,235
用于更新世界的当前内容

343
00:17:49,536 --> 00:17:53,273
所以这是你已经在UIKit中
熟练运用的同样技巧

344
00:17:53,507 --> 00:17:54,675
就是那么简单

345
00:17:54,741 --> 00:17:56,310
你创建其中一个元素

346
00:17:57,444 --> 00:17:59,279
你指定它的帧

347
00:17:59,746 --> 00:18:03,150
我们使用SceneKit中的projectPoint
从3D到2D

348
00:18:03,750 --> 00:18:05,285
并将那个元素添加到视图中

349
00:18:06,553 --> 00:18:10,157
那么我的观点是
即便3D看起来很难获取

350
00:18:10,691 --> 00:18:11,725
它其实很简单

351
00:18:11,792 --> 00:18:13,460
它就是你已经熟悉的技巧

352
00:18:14,094 --> 00:18:16,697
那么有三个主要原因

353
00:18:17,531 --> 00:18:18,932
第一 这对于你的用户来说很棒

354
00:18:19,433 --> 00:18:21,602
最值得的其中一方面很可能

355
00:18:21,768 --> 00:18:23,537
我认为是做这个项目

356
00:18:24,705 --> 00:18:26,807
抱歉 我认为是最值得的其中一个方面

357
00:18:27,474 --> 00:18:29,376
第二是实现就是那么简单

358
00:18:30,244 --> 00:18:33,380
有来自UIKit开发中的一些
你很熟悉的东西

359
00:18:33,914 --> 00:18:35,983
第三 就像没有理由

360
00:18:36,183 --> 00:18:38,986
不让你的应用
在UIKit中可获取一样

361
00:18:39,119 --> 00:18:41,555
也应该没有理由不在3D中这样做

362
00:18:42,856 --> 00:18:45,392
那么如果你想看完整代码

363
00:18:45,726 --> 00:18:48,262
你可以参看
Learn to Code资源

364
00:18:48,629 --> 00:18:52,099
通过在Playground书中
深入研究辅助资源

365
00:18:52,165 --> 00:18:55,836
并且这个文件其实也存在于
Accessibilityextensions.swift中

366
00:18:57,571 --> 00:18:59,106
那么这就是迭代

367
00:18:59,973 --> 00:19:03,777
我们谈了你应该如何将数据
与你场景的图形分离开来

368
00:19:04,211 --> 00:19:06,046
对吧？我们将其用于给世界建模

369
00:19:06,113 --> 00:19:07,948
还有如何实现台阶动画

370
00:19:09,950 --> 00:19:12,119
你甚至应该在这个阶段就重视灵活性

371
00:19:12,186 --> 00:19:14,555
那么当你把全部时间和精力
都花在这上面

372
00:19:14,688 --> 00:19:17,057
确保你正在做像使用引用节点这样的事

373
00:19:17,191 --> 00:19:19,092
以便你仍然有一些灵活性

374
00:19:20,394 --> 00:19:23,864
那么最后 确保你提早审核可达性支持

375
00:19:24,064 --> 00:19:26,233
它不是那种最后可以扩充的东西

376
00:19:26,333 --> 00:19:29,136
如果你有计划它会惊人简单

377
00:19:30,704 --> 00:19:34,208
现在让我们谈谈
如何获取这些设计时间资产

378
00:19:34,374 --> 00:19:37,010
以及如何调整它们
使其拥有超级良好的性能

379
00:19:37,144 --> 00:19:38,812
我要邀请Lemont上台

380
00:19:41,615 --> 00:19:43,250
谢谢Michael 很棒

381
00:19:45,485 --> 00:19:47,221
大家好 我是Lemont

382
00:19:47,287 --> 00:19:49,489
我是Swift Playground
内容团队的工程师

383
00:19:50,424 --> 00:19:51,959
今天我要跟大家谈谈

384
00:19:52,025 --> 00:19:54,361
如何改进SceneKit应用的性能

385
00:19:54,928 --> 00:19:57,464
关于帧频率和用户体验

386
00:19:58,398 --> 00:20:00,000
（调整）

387
00:20:00,067 --> 00:20:03,270
当我们首次开始开发
Learn to Code时

388
00:20:04,104 --> 00:20:05,339
对我们来说最要紧的是

389
00:20:05,405 --> 00:20:07,508
拥有一个非常丰富和细致的世界

390
00:20:08,108 --> 00:20:10,377
正如你在这里所看到的
这就是我们所拥有的

391
00:20:11,011 --> 00:20:12,746
瀑布看起来很逼真

392
00:20:13,080 --> 00:20:17,184
台阶后的阴影看起来很棒

393
00:20:17,251 --> 00:20:19,353
颜色也很丰富和生动

394
00:20:19,520 --> 00:20:22,155
在瀑布中甚至还隐藏有漂亮的雕像

395
00:20:23,557 --> 00:20:26,760
但正如你所了解的
一个看起来漂亮的应用

396
00:20:27,594 --> 00:20:31,865
并不是拥有了不起用户体验的唯一方面

397
00:20:31,999 --> 00:20:33,066
还有性能

398
00:20:34,134 --> 00:20:35,369
那实际是什么意思呢？

399
00:20:36,670 --> 00:20:39,306
要获得一个不错的体验
我们实际上得有

400
00:20:39,373 --> 00:20:41,041
一个响应性很好的帧频率

401
00:20:41,208 --> 00:20:43,043
你的用户正在与你的应用进行交互

402
00:20:43,110 --> 00:20:44,745
他们正在缩放 他们正在做手势

403
00:20:45,012 --> 00:20:47,047
他们正在向场景中添加对象
移除对象

404
00:20:47,314 --> 00:20:49,183
你希望这个过程要很快 并且很流畅

405
00:20:50,884 --> 00:20:52,653
那么我要给你展示我们是如何

406
00:20:52,719 --> 00:20:54,821
在Learn to Code中
提升我们应用的性能

407
00:20:57,925 --> 00:21:01,195
让我们看一个
拥有更复杂的几何学的场景

408
00:21:01,428 --> 00:21:03,130
我提到复杂的几何学

409
00:21:03,463 --> 00:21:09,837
我的意思是这个场景由成千上万个
独立的几何体零件组成

410
00:21:11,171 --> 00:21:14,942
现在每一个零件
都分别要由GPU进行渲染

411
00:21:16,343 --> 00:21:17,878
那么让我们来看看

412
00:21:17,945 --> 00:21:19,813
我们应用的性能怎么样

413
00:21:20,647 --> 00:21:24,351
SceneKit有一个很有用的工具
叫作调试统计视图

414
00:21:26,053 --> 00:21:28,088
我想把它放大看一下

415
00:21:29,656 --> 00:21:32,926
现在你可以在你的应用中启用这个功能
只需要把

416
00:21:32,993 --> 00:21:36,296
你视图中的showStatistics属性
设为真即可

417
00:21:38,632 --> 00:21:40,634
如果我们看一下这些更有意思的数字

418
00:21:40,701 --> 00:21:43,103
…调试视图

419
00:21:43,604 --> 00:21:46,707
你会注意到我们有一个很低的帧频率
每秒29帧

420
00:21:47,341 --> 00:21:48,442
这可不好

421
00:21:49,009 --> 00:21:51,812
我们实际上想要达到每秒至少60帧

422
00:21:52,312 --> 00:21:55,115
这可以允许我们获得流畅的交互

423
00:21:55,182 --> 00:21:57,317
当用户缩放或做手势的时候

424
00:21:59,686 --> 00:22:01,588
到底是什么导致了这么低的帧频率呢？

425
00:22:02,256 --> 00:22:03,490
让我们具体来看一下

426
00:22:04,424 --> 00:22:05,659
每一帧都在做什么？

427
00:22:06,960 --> 00:22:08,795
这里的这个数字是跟渲染有关的

428
00:22:09,196 --> 00:22:13,667
是我们用来渲染
一个完整帧所需的时间

429
00:22:15,169 --> 00:22:17,304
看起来我们需要20.4毫秒

430
00:22:18,438 --> 00:22:19,506
太慢了

431
00:22:19,940 --> 00:22:22,509
如果你算一下
如果你想达到每秒60帧

432
00:22:22,576 --> 00:22:24,578
你必须得在16毫秒以下完成

433
00:22:25,913 --> 00:22:28,248
我们花了20毫秒 都在干什么呢？

434
00:22:29,449 --> 00:22:31,952
要帮助了解这个问题
我们可以看一下

435
00:22:32,019 --> 00:22:32,986
绘制调用的数字

436
00:22:33,053 --> 00:22:35,088
正如你所看到的
用这个方框突出显示了

437
00:22:37,090 --> 00:22:38,792
现在 什么是绘制调用？

438
00:22:39,927 --> 00:22:41,128
快速回顾一下

439
00:22:41,728 --> 00:22:43,397
当你想在场景中绘制对象时

440
00:22:43,463 --> 00:22:46,366
CPU必须得告诉GPU说
“嘿 绘制这个网格”

441
00:22:47,234 --> 00:22:49,736
CPU绘制这个网格或几何体对象

442
00:22:50,237 --> 00:22:51,271
那么这就是绘制调用

443
00:22:52,239 --> 00:22:54,408
看起来我们一共有877个绘制调用

444
00:22:55,375 --> 00:22:56,710
有相当多的绘制调用

445
00:22:56,877 --> 00:22:58,979
那么我们可以做什么

446
00:22:59,046 --> 00:23:00,881
以实际提升我们应用的性能呢？

447
00:23:02,316 --> 00:23:04,251
我要跟你分享一个小技巧

448
00:23:05,519 --> 00:23:09,223
那么在我们接下来的演讲中有一个主题
就是如何减少绘制调用的数量

449
00:23:12,492 --> 00:23:15,896
我要跟大家谈三个明显的时期：

450
00:23:18,031 --> 00:23:21,034
组成场景的网格几何体

451
00:23:22,202 --> 00:23:24,905
给我们的场景
提供了一个漂亮外观的材料

452
00:23:26,039 --> 00:23:28,242
以及让我们场景鲜活的光照

453
00:23:30,944 --> 00:23:34,848
让我们看一个之前展示过的例子

454
00:23:36,016 --> 00:23:39,786
现在这个场景有许多单一的零件

455
00:23:40,153 --> 00:23:43,056
我想只看其中一种 小草

456
00:23:45,392 --> 00:23:47,761
现在 如果你近距离地看

457
00:23:48,962 --> 00:23:50,664
你们数学很好吧 你可以数一下

458
00:23:50,797 --> 00:23:53,267
这个屏幕中大概有30个单一的方格

459
00:23:54,234 --> 00:23:56,036
每个方格都有自己的网格

460
00:23:56,870 --> 00:24:01,775
那么CPU必须告诉GPU
逐个渲染这些东西

461
00:24:01,942 --> 00:24:03,410
我们就有了30个绘制调用

462
00:24:04,144 --> 00:24:05,212
现在这是一个小场景

463
00:24:05,279 --> 00:24:08,482
想象一下 如果你想拥有一个很大
很广阔的世界

464
00:24:08,549 --> 00:24:09,816
有成千上万个这样的方格

465
00:24:10,150 --> 00:24:11,718
我们就会有成千上万个绘制调用

466
00:24:11,919 --> 00:24:13,654
想象一下我们的帧频率会怎么样

467
00:24:17,424 --> 00:24:21,061
你可能会注意到一点
这些小草方格可能不需要移动

468
00:24:22,162 --> 00:24:27,367
那么如果它们不移动
我们为什么要绘制这么多呢？

469
00:24:27,668 --> 00:24:30,070
我们是否也许可以绘制一个大的网格？

470
00:24:32,439 --> 00:24:33,273
这是可以的

471
00:24:35,542 --> 00:24:37,344
有一条规则我想要你记住

472
00:24:37,978 --> 00:24:42,316
就是当你与GPU通讯时
每个网格有一个绘制调用

473
00:24:42,749 --> 00:24:44,985
如果你有一千个网格
那么就有一千个绘制调用

474
00:24:46,053 --> 00:24:48,055
那么如果我们看看我们的小草方格

475
00:24:48,355 --> 00:24:50,257
实际上我们想无论如何把它们结合起来

476
00:24:50,924 --> 00:24:52,426
听起来像是个很合理的技巧

477
00:24:53,160 --> 00:24:54,361
我要给你们展示如何实现

478
00:24:57,631 --> 00:25:00,667
假如我们在场景中有两个几何体对象

479
00:25:01,201 --> 00:25:03,403
左边有一个小草方格

480
00:25:04,238 --> 00:25:06,173
右边有另一个小草方格

481
00:25:07,841 --> 00:25:10,077
它们都引用了同一种材料
它们的样子也一样

482
00:25:10,143 --> 00:25:11,378
它们只是移动了位置

483
00:25:11,712 --> 00:25:13,914
并且它们在3D空间中
有不同的地理位置

484
00:25:14,848 --> 00:25:18,285
当你把这个发送给GPU时
你将会得到两个绘制调用

485
00:25:22,856 --> 00:25:25,959
如果我们通过一个叫作扁平的过程
把这两个合并在一起

486
00:25:26,793 --> 00:25:30,264
我们所做的其实就像是在说
让我们把网格A的全部点取出来

487
00:25:30,597 --> 00:25:35,469
并把它们结合到网格B的点中
形成一个超级哥斯拉网格

488
00:25:37,437 --> 00:25:40,073
它的漂亮之处在于

489
00:25:40,307 --> 00:25:42,776
全部这些点都引用了那一种材料

490
00:25:43,110 --> 00:25:44,711
当CPU与GPU通讯时

491
00:25:44,778 --> 00:25:47,080
它要做的就只是说
“嘿 绘制这一个东西”

492
00:25:48,415 --> 00:25:53,287
完成了 现在这听来微不足道
非常简单易用

493
00:25:54,788 --> 00:25:56,256
你可以在你的应用中使用它

494
00:25:56,924 --> 00:26:01,195
通过SCNNode上的一个
叫作flattenedClone的方法

495
00:26:01,929 --> 00:26:04,898
你想做的就是确保有父节点

496
00:26:05,866 --> 00:26:07,835
包含你想要扁平化的节点

497
00:26:08,936 --> 00:26:12,072
并且返回的是一个新的扁平化网格

498
00:26:12,139 --> 00:26:15,209
你可以在你的场景中
合成和替换其它节点

499
00:26:17,010 --> 00:26:20,180
现在这个简单的技巧
在整个Learn to Code中都能使用

500
00:26:21,215 --> 00:26:23,650
所以如果我们以我之前
展示给你们的示例为例

501
00:26:24,251 --> 00:26:26,153
我可以具体到每一个部分

502
00:26:26,220 --> 00:26:28,488
关于哪些能运行这个扁平化逻辑

503
00:26:29,356 --> 00:26:32,659
我要用红色突出显示
扁平化到一起的区域

504
00:26:32,960 --> 00:26:35,329
你在这里可以看到
我们的水现在…小草方格…

505
00:26:35,896 --> 00:26:39,166
…较少的…绘制调用

506
00:26:39,900 --> 00:26:42,402
每一个红色部分相当于一个绘制调用

507
00:26:42,469 --> 00:26:44,137
而不是单一的绘制调用

508
00:26:45,873 --> 00:26:49,309
那么我们可以很大程度上减少
场景中绘制调用的次数

509
00:26:51,011 --> 00:26:53,380
我们从550次绘制调用降到了

510
00:26:53,780 --> 00:26:55,048
不到16次

511
00:26:55,916 --> 00:26:56,884
降了很多

512
00:26:59,319 --> 00:27:00,153
谢谢

513
00:27:01,855 --> 00:27:05,158
现在你得在这里用一点儿灵活性

514
00:27:05,259 --> 00:27:08,228
因为你不想全部这些乱七八糟的
你知道的

515
00:27:08,295 --> 00:27:09,696
扁平化全部这些东西

516
00:27:10,531 --> 00:27:13,534
原因正如Michael之前给你们展示的

517
00:27:14,535 --> 00:27:18,138
他让水看起来非常逼真
通过添加那个简单的着色器修改器

518
00:27:18,205 --> 00:27:19,973
为我们提供了这种非常棒的效果

519
00:27:21,175 --> 00:27:25,479
那么如果我们要扁平化所有一切

520
00:27:26,046 --> 00:27:27,681
整个世界大概会一点一点地消失

521
00:27:27,881 --> 00:27:28,815
这并不是我们想要的

522
00:27:29,850 --> 00:27:34,788
那么我们可以有选择性地
选择要扁平化的东西

523
00:27:35,088 --> 00:27:36,957
那么我们把整个瀑布扁平化

524
00:27:37,691 --> 00:27:39,993
在你的世界中或你创建的游戏中

525
00:27:40,761 --> 00:27:44,198
你可能选择让一个对象消失或移动

526
00:27:44,264 --> 00:27:46,900
或缩放或旋转或无论怎样修改它

527
00:27:47,534 --> 00:27:50,404
那么我认为要选择的东西

528
00:27:51,405 --> 00:27:53,106
应该基于你想如何使用你的几何体

529
00:27:53,173 --> 00:27:56,577
如果它有一些动态行为 你可能想与

530
00:27:56,643 --> 00:27:59,213
其它拥有同一种移动方式的东西
一起执行扁平化

531
00:28:04,251 --> 00:28:08,088
那么我要给你一些关于扁平化的小技巧

532
00:28:08,689 --> 00:28:11,358
其中一个是你想存储你的节点
以在同一个组中进行扁平化

533
00:28:11,425 --> 00:28:13,827
父组 父节点

534
00:28:14,127 --> 00:28:16,597
并不一定是同一种几何体类型

535
00:28:16,763 --> 00:28:18,198
我们在这里用的是小草方格 但是…

536
00:28:18,265 --> 00:28:20,501
比如你正在给客厅建模

537
00:28:20,567 --> 00:28:23,136
有一张沙发 一把椅子和一张桌子

538
00:28:23,203 --> 00:28:24,671
它们相对静止

539
00:28:25,372 --> 00:28:26,406
它们都可以

540
00:28:26,473 --> 00:28:29,910
放到一个节点组中
并由这个组自己执行扁平化

541
00:28:30,310 --> 00:28:31,678
在这里你想积极一点

542
00:28:31,745 --> 00:28:34,414
任何东西相对于别的东西都不会移动

543
00:28:35,482 --> 00:28:39,553
扁平化它
你将显著减少你的绘制调用数量

544
00:28:41,522 --> 00:28:43,090
现在这里有一个警告

545
00:28:44,491 --> 00:28:47,928
Learn to Code
的世界是静止的

546
00:28:47,995 --> 00:28:51,298
它是一个很小的世界
只能在屏幕上可见

547
00:28:51,765 --> 00:28:53,800
但对于你的世界 可能会非常广阔

548
00:28:53,867 --> 00:28:55,736
你可以进入某一栋大楼或你…

549
00:28:56,737 --> 00:28:59,006
…在一个大规模的地形上
或你有好几个层级

550
00:28:59,773 --> 00:29:03,076
那么你想要做的是…你不想做的是

551
00:29:03,210 --> 00:29:05,846
把全部东西都乱七八糟地堆在一起
因为即将发生的是

552
00:29:06,346 --> 00:29:08,415
如果你有整个世界的地图集

553
00:29:08,849 --> 00:29:10,951
而场景中只能看到其中一部分

554
00:29:11,018 --> 00:29:13,520
在任何时候
你都要付出一些性能方面的代价

555
00:29:13,620 --> 00:29:16,723
即渲染全部这些点和全部网格

556
00:29:17,124 --> 00:29:18,058
这并不是你想要的

557
00:29:19,459 --> 00:29:20,694
这里有一个小技巧

558
00:29:20,961 --> 00:29:23,530
就是简单地把你的世界
细分为不连续的组块

559
00:29:24,598 --> 00:29:27,267
然后在每一个组块上运行这个过程

560
00:29:27,634 --> 00:29:30,904
当你从一个组块移动到另一个组块时
当相机从一个组块移动到另一个组块时

561
00:29:31,371 --> 00:29:33,073
你实际上获得了扁平化的优点

562
00:29:33,140 --> 00:29:37,678
而不需要付出
马上在场景中渲染一切的代价

563
00:29:39,713 --> 00:29:41,682
接下来我要谈谈材料

564
00:29:42,549 --> 00:29:46,520
现在材料对你的绘制调用数量
甚至影响更大

565
00:29:48,121 --> 00:29:49,189
我会告诉你原因的

566
00:29:50,924 --> 00:29:53,360
这个帧也是来自我之前展示的那个电影

567
00:29:53,827 --> 00:29:58,632
就是我们展示扁平化的场景

568
00:29:58,699 --> 00:30:02,069
这个世界的顶部几乎是在一个网格中

569
00:30:03,203 --> 00:30:04,338
所以这是一个绘制调用

570
00:30:05,239 --> 00:30:09,343
但机警的你们可能会注意到

571
00:30:10,077 --> 00:30:14,748
这里有多种材料
比如显然这些巨石阵

572
00:30:14,815 --> 00:30:16,750
和台阶所用的材料不同

573
00:30:17,184 --> 00:30:19,786
当然不是石头自身

574
00:30:20,521 --> 00:30:21,455
那么这是怎么回事？

575
00:30:23,357 --> 00:30:24,925
让我们谈谈减少材料

576
00:30:25,292 --> 00:30:28,295
因为我们要降低到一个绘制调用

577
00:30:30,063 --> 00:30:33,066
那么我们在屏幕上有两个几何体对象

578
00:30:34,168 --> 00:30:36,336
一个在左边 一个在右边

579
00:30:37,304 --> 00:30:39,473
一个用的是沙子纹理

580
00:30:40,274 --> 00:30:43,277
一个用的是这种看起来
有沙子/小草的纹理

581
00:30:44,611 --> 00:30:47,314
如果我们运行
我之前展示给你的逻辑 扁平化

582
00:30:48,081 --> 00:30:52,052
我们实际上会把那个结合起来
哥斯拉网格

583
00:30:52,519 --> 00:30:55,289
但我们仍然引用的是两种材料

584
00:30:55,355 --> 00:30:58,258
那么当CPU与GPU通讯时 它会说

585
00:30:58,325 --> 00:31:01,762
“嘿 获取这个网格
在上边绘制一些沙子材料”

586
00:31:02,329 --> 00:31:03,297
很棒 好的

587
00:31:03,363 --> 00:31:05,465
现在再次获取这个网格
在上边绘制一部分

588
00:31:05,532 --> 00:31:07,067
小草材料

589
00:31:07,134 --> 00:31:08,402
你仍然有两个绘制调用

590
00:31:09,469 --> 00:31:13,040
你是有机会减少绘制调用的次数的

591
00:31:15,742 --> 00:31:17,811
你可能听说过纹理拼合

592
00:31:18,645 --> 00:31:20,581
但也许你并不理解这到底是什么

593
00:31:20,848 --> 00:31:22,015
这是一个非常简单的过程

594
00:31:23,217 --> 00:31:25,586
你的设计师以及3D工具

595
00:31:27,054 --> 00:31:31,458
把你的材料合并到一个纹理贴图集中

596
00:31:33,293 --> 00:31:35,963
它们会在底层更新你的几何体

597
00:31:36,029 --> 00:31:38,398
以便它指向纹理内正确的位元

598
00:31:39,166 --> 00:31:41,969
但最终结果是你有一个绘制调用

599
00:31:44,471 --> 00:31:45,372
现在能实现…

600
00:31:47,307 --> 00:31:51,378
…即便你有…几个对象或上千个对象

601
00:31:52,479 --> 00:31:54,748
在Learn to Code中
我将给你展示其中一个贴图集

602
00:31:54,815 --> 00:31:56,350
是我刚展示给你的那个世界的贴图集

603
00:31:56,950 --> 00:31:58,118
贴图集就是这个样子的

604
00:32:00,487 --> 00:32:02,623
我们有70多种材料

605
00:32:03,023 --> 00:32:05,325
我们可以浓缩成一个

606
00:32:07,127 --> 00:32:08,161
这是一种很大的节约

607
00:32:10,163 --> 00:32:12,699
这里有另一个优点你可能没有注意到

608
00:32:14,401 --> 00:32:17,271
当你向场景中添加一种材料时
当你的场景加载时

609
00:32:17,838 --> 00:32:22,509
在场景底层生成了一个着色器

610
00:32:23,377 --> 00:32:24,978
你不能启动你的场景

611
00:32:25,045 --> 00:32:26,880
除非着色器已完成编译

612
00:32:26,947 --> 00:32:29,483
如果你有70种材料
你就有70个着色器

613
00:32:29,716 --> 00:32:31,985
你有上百个对象

614
00:32:32,386 --> 00:32:35,622
上百种材料
现在冷不防想到你的加载时间…

615
00:32:35,689 --> 00:32:37,424
你被卡住了 等着场景加载

616
00:32:38,425 --> 00:32:42,296
通过将它合并为
一种材料或较少的材料

617
00:32:42,529 --> 00:32:44,898
你减少了需要编译的着色器的数量

618
00:32:45,165 --> 00:32:46,366
推进了你的启动时间

619
00:32:47,734 --> 00:32:51,705
更不要提较少的I/O了
在读写硬盘方面

620
00:32:55,542 --> 00:32:57,244
那么接下来我想谈谈光照

621
00:32:58,312 --> 00:33:00,080
现在光照很有意思 因为…

622
00:33:01,415 --> 00:33:06,220
光照允许你给你的世界增加丰富
逼真的细节

623
00:33:07,020 --> 00:33:09,456
你想象一个这样的场景
看起来是静态的 有点了无生趣

624
00:33:09,790 --> 00:33:12,426
你添加光照 现在看起来有点意思了

625
00:33:13,227 --> 00:33:17,898
那么让我们的设计师在场景中
添加一些光照

626
00:33:17,965 --> 00:33:19,333
然后给我们提供了这个视觉效果

627
00:33:20,934 --> 00:33:23,470
我们添加了聚光灯
因此当角色在世界中走来走去时

628
00:33:23,537 --> 00:33:28,308
当他们沿着瀑布或草地
移动时会投射影子

629
00:33:28,542 --> 00:33:29,376
这是个不错的效果

630
00:33:30,844 --> 00:33:34,014
我们添加了全方位光照
分散在整个场景中

631
00:33:34,882 --> 00:33:36,316
增加了一点视觉效果

632
00:33:36,416 --> 00:33:39,486
那么你可以看到前景中的台阶

633
00:33:39,553 --> 00:33:41,889
比后景中的台阶要更高亮

634
00:33:44,758 --> 00:33:46,426
最后 我们添加了环境光

635
00:33:47,094 --> 00:33:50,464
以确保场景中的一切东西都是可见的

636
00:33:50,531 --> 00:33:53,033
否则你将拥有非常暗的区域

637
00:33:53,400 --> 00:33:54,935
是光照不能照亮的区域

638
00:33:56,503 --> 00:33:57,638
你可以看到这种很棒的效果

639
00:33:57,704 --> 00:33:59,706
如果你看一下水的阴影的话

640
00:34:00,507 --> 00:34:01,341
非常整洁

641
00:34:02,676 --> 00:34:04,878
现在这里有一点性能消耗

642
00:34:04,945 --> 00:34:06,113
光照可不是免费的

643
00:34:07,281 --> 00:34:08,815
记得我告诉过你的绘制调用吧

644
00:34:09,349 --> 00:34:11,217
绘制调用的个数越多
你得到的性能就越少

645
00:34:11,485 --> 00:34:12,418
你的应用呢？

646
00:34:12,985 --> 00:34:17,224
无论何时当光照点亮网格时

647
00:34:19,059 --> 00:34:20,460
都会生成一个额外绘制调用

648
00:34:21,195 --> 00:34:22,795
你的场景中有五个光照

649
00:34:23,429 --> 00:34:25,699
你就增加了五个绘制调用

650
00:34:27,801 --> 00:34:29,803
有一种方式可以避免这种情况

651
00:34:31,205 --> 00:34:32,639
叫作光照图

652
00:34:34,074 --> 00:34:38,045
现在的情况是你的设计师
和他们的3D工具

653
00:34:38,145 --> 00:34:43,050
将运行一个过程 计算广告所在位置

654
00:34:43,116 --> 00:34:45,518
他们可以很大方地把光照
放在他们想要放的地方

655
00:34:45,585 --> 00:34:46,786
点亮所有东西

656
00:34:47,187 --> 00:34:48,822
那实际上会预计算

657
00:34:49,121 --> 00:34:51,859
你场景中的广告强度

658
00:34:52,125 --> 00:34:53,694
并把它存储在一种材料中

659
00:34:53,893 --> 00:34:56,230
而不像我们之前展示给你们的纹理一样

660
00:34:57,397 --> 00:34:59,867
这里的漂亮之处在于

661
00:35:00,834 --> 00:35:04,271
这个过程不是CPU或GPU加强的

662
00:35:04,438 --> 00:35:05,672
事实上它是免费的

663
00:35:05,739 --> 00:35:07,407
让我们再花点时间谈谈它

664
00:35:07,474 --> 00:35:11,111
而不是讲实际会占用多少CPU
来应用这个

665
00:35:12,546 --> 00:35:15,249
那么只要我们想
我们可以把光照数量降低到零

666
00:35:16,183 --> 00:35:17,017
现在我们不这样做

667
00:35:17,851 --> 00:35:19,386
我们留了一个聚光灯

668
00:35:20,020 --> 00:35:23,357
因为我们区分开了
不是每帧都会改变的光照

669
00:35:23,423 --> 00:35:24,791
我们为什么还要再次渲染这些光照呢

670
00:35:24,858 --> 00:35:26,627
我们在上一帧中就进行了渲染
但什么也没变

671
00:35:27,794 --> 00:35:29,530
但聚光灯会改变

672
00:35:29,930 --> 00:35:30,931
随着你旋转这个世界

673
00:35:30,998 --> 00:35:34,101
聚光灯也会以不同的方式照亮对象

674
00:35:35,002 --> 00:35:37,104
当你让自己的角色
在这个世界走来走去时

675
00:35:37,504 --> 00:35:41,008
它的影子会以不同方式
投射在这个世界

676
00:35:41,808 --> 00:35:42,643
所以我们保留了聚光灯

677
00:35:43,143 --> 00:35:47,414
但我们确保指定把它应用在哪里

678
00:35:49,383 --> 00:35:51,985
角色或场景的某个部分

679
00:35:53,754 --> 00:35:57,991
好消息是它可以与我之前
展示给你们的扁平化一起处理

680
00:35:58,058 --> 00:36:01,428
因为很明显 光照就像一个

681
00:36:01,495 --> 00:36:02,529
绘制调用的倍增器

682
00:36:02,829 --> 00:36:03,664
你猜怎么样

683
00:36:04,298 --> 00:36:05,432
我们减少了第一项

684
00:36:05,499 --> 00:36:10,304
我们减少了需要点亮的网格数量

685
00:36:11,805 --> 00:36:13,640
如果我们真的想在那儿放一个光照

686
00:36:13,707 --> 00:36:15,976
效果也不会比我们刚启动时差

687
00:36:17,211 --> 00:36:19,813
那么在进行这些修改后

688
00:36:20,948 --> 00:36:22,916
让我们看一下我们的性能
看看我们现在怎么样

689
00:36:25,385 --> 00:36:26,253
让我们放大

690
00:36:26,320 --> 00:36:28,222
实际上我想花点时间欣赏一下

691
00:36:28,689 --> 00:36:30,591
光照图的效果 太棒了

692
00:36:31,725 --> 00:36:33,360
如果你看一下第一个台阶的后面

693
00:36:33,427 --> 00:36:36,096
你会看到那个小的阴影以及裂缝
还有…

694
00:36:36,430 --> 00:36:38,599
…甚至在瀑布后面也稍微有点暗

695
00:36:39,433 --> 00:36:42,736
岩石周围和巨石阵中的弯曲区域

696
00:36:42,803 --> 00:36:43,904
看起来真的很棒

697
00:36:44,271 --> 00:36:46,173
你知道吗 你并没有付出任何代价

698
00:36:46,240 --> 00:36:48,909
这都是通过使用材料离线实现的

699
00:36:49,309 --> 00:36:52,045
我们的设计师
因为光照和3D工具而疯狂

700
00:36:53,146 --> 00:36:54,915
现在我放大性能图

701
00:36:57,184 --> 00:36:58,452
哇哦 我们现在达到每秒60帧了

702
00:36:58,519 --> 00:37:01,188
我们的用户不会关闭我们的应用
而去做其它事了

703
00:37:04,591 --> 00:37:05,759
让我们看看我们的渲染时间

704
00:37:07,261 --> 00:37:08,795
是2.3毫秒

705
00:37:09,429 --> 00:37:11,331
现在非常了不起 原因有很多

706
00:37:12,032 --> 00:37:13,400
第一 记得我们说过

707
00:37:13,467 --> 00:37:15,836
你必须得低于16毫秒…

708
00:37:16,436 --> 00:37:18,505
…才能…

709
00:37:20,574 --> 00:37:22,976
…实现每秒渲染60帧吗？

710
00:37:23,877 --> 00:37:25,646
刚发布的那个新iPad

711
00:37:26,446 --> 00:37:29,816
如果你想利用120赫兹技术刷新率

712
00:37:30,684 --> 00:37:32,019
你得把那个数字降到7以下

713
00:37:32,419 --> 00:37:33,520
我们是2以下 所以我们很不错

714
00:37:34,288 --> 00:37:35,122
启动它

715
00:37:37,457 --> 00:37:41,228
那么让我们谈谈净空高度

716
00:37:42,296 --> 00:37:44,131
漂亮之处是这个数字很低

717
00:37:44,431 --> 00:37:46,567
如果你想给你的场景中添加更多的对象

718
00:37:46,633 --> 00:37:48,602
也许你想添加更多的游戏设置逻辑

719
00:37:48,669 --> 00:37:52,806
通过GameplayKit
或你想联网

720
00:37:52,873 --> 00:37:55,676
或者你只想丰富你的场景

721
00:37:56,176 --> 00:37:57,778
告诉你的设计师“嘿 启动它

722
00:37:57,845 --> 00:38:00,848
让我们在场景中添加更多对象
让它变得更精致”

723
00:38:01,582 --> 00:38:04,751
或者你只想节约电量 你可以那样做

724
00:38:06,687 --> 00:38:08,288
最后让我们看看那个绘制调用的数量

725
00:38:09,590 --> 00:38:13,794
哇哦 73 你还记得吧
刚才的数字超过了700

726
00:38:14,161 --> 00:38:19,066
我们现在使用的绘制调用数量

727
00:38:19,132 --> 00:38:20,400
比刚才的十分之一还要少

728
00:38:20,934 --> 00:38:24,271
我们正在小口品尝
而不是像刚才那样狂吃

729
00:38:24,838 --> 00:38:25,672
非常棒

730
00:38:26,173 --> 00:38:27,674
我们的应用很流畅

731
00:38:28,208 --> 00:38:30,344
当我们再提到净空高度时

732
00:38:30,878 --> 00:38:31,778
你就要记得

733
00:38:32,379 --> 00:38:34,681
你要在你的应用中
实现其它事而不只是渲染

734
00:38:34,848 --> 00:38:38,819
在我们的例子中
我们在左侧运行了Swift编译器

735
00:38:39,419 --> 00:38:43,924
用户可以编辑代码并点击菜单项

736
00:38:43,991 --> 00:38:44,825
以及类似的操作

737
00:38:45,993 --> 00:38:46,927
在你的应用中

738
00:38:46,994 --> 00:38:48,829
也许用户正在做比如缩放

739
00:38:48,896 --> 00:38:50,731
缩放或做一些选择 或…

740
00:38:52,666 --> 00:38:55,169
你知道的
任何会占用更多处理时间的事情

741
00:38:55,235 --> 00:38:56,837
按照你应用中的逻辑

742
00:38:58,172 --> 00:38:59,006
很棒

743
00:39:00,908 --> 00:39:02,075
那么回顾一下

744
00:39:03,443 --> 00:39:05,078
我们讲了扁平化几何体

745
00:39:05,145 --> 00:39:08,515
如何简便地实现性能优化

746
00:39:08,582 --> 00:39:10,284
关于减少你的绘制调用数量

747
00:39:11,718 --> 00:39:13,754
我们讲了使用纹理贴图集

748
00:39:13,820 --> 00:39:15,722
就是你让你的设计师做的东西

749
00:39:15,789 --> 00:39:16,957
你只需要利用即可

750
00:39:17,024 --> 00:39:19,560
那将会减少你所使用的材料

751
00:39:19,893 --> 00:39:21,862
从而影响加载时间

752
00:39:21,962 --> 00:39:23,864
让你的应用启动更快

753
00:39:24,765 --> 00:39:29,303
还会影响磁盘I/O 使加载对象减少

754
00:39:30,270 --> 00:39:34,274
最后 它可以和几何体扁平化一起处理

755
00:39:34,541 --> 00:39:37,010
确保尽可能少地绘制调用数量

756
00:39:38,712 --> 00:39:41,481
最后使用光照图

757
00:39:42,015 --> 00:39:44,585
给你的场景添加丰富的可视化细节

758
00:39:45,919 --> 00:39:49,890
而不需要占用太多的GPU

759
00:39:50,023 --> 00:39:50,958
让你的设计师疯狂起来吧

760
00:39:53,393 --> 00:39:55,128
我们还有一些相关的演讲

761
00:39:56,029 --> 00:39:57,731
谢谢 祝你们度过一个美好的WWDC

