1
00:00:28,456 --> 00:00:28,916
>> 欢迎

2
00:00:29,436 --> 00:00:30,996
我们结合 Metal 2

3
00:00:30,996 --> 00:00:32,576
推出了许多

4
00:00:32,856 --> 00:00:34,846
新的技术 能让你们制作

5
00:00:35,116 --> 00:00:36,896
更好 更快

6
00:00:36,896 --> 00:00:37,706
更有效率的应用

7
00:00:38,206 --> 00:00:39,396
我是 Michal

8
00:00:39,396 --> 00:00:40,856
我和我的同事 Richard

9
00:00:40,856 --> 00:00:42,756
今天将给大家介绍三个主题

10
00:00:44,546 --> 00:00:46,546
通过使用 Metal2

11
00:00:46,756 --> 00:00:48,656
我们将继续减少

12
00:00:48,656 --> 00:00:50,526
高代价操作的发生

13
00:00:50,526 --> 00:00:52,266
并确保

14
00:00:52,266 --> 00:00:54,376
常用的操作

15
00:00:54,376 --> 00:00:55,176
只花费很少的代价

16
00:00:55,656 --> 00:00:57,356
历年来 我们介绍过

17
00:00:57,646 --> 00:01:00,226
预编译着色器

18
00:01:00,226 --> 00:01:02,286
渲染状态对象和去年的 Metal 堆

19
00:01:02,286 --> 00:01:04,566
以保证你能将

20
00:01:04,566 --> 00:01:06,416
高代价的操作

21
00:01:06,576 --> 00:01:08,796
移除出你的

22
00:01:09,346 --> 00:01:09,446
主要应用循环

23
00:01:10,096 --> 00:01:13,836
通过将 open GL 换成 Metal

24
00:01:13,836 --> 00:01:15,886
我们能给你提供 10 倍多的

25
00:01:16,206 --> 00:01:16,696
绘图调用

26
00:01:17,616 --> 00:01:18,996
今年 我们将介绍

27
00:01:18,996 --> 00:01:21,496
新的绑定 API

28
00:01:21,496 --> 00:01:22,866
它能为你提供更多的功能

29
00:01:22,866 --> 00:01:24,426
因此我们将

30
00:01:24,426 --> 00:01:24,946
进一步介绍它

31
00:01:26,446 --> 00:01:29,006
通过 GPU 驱动流水线

32
00:01:29,006 --> 00:01:32,016
我们将进一步把 GPU 放在

33
00:01:32,016 --> 00:01:32,856
驱动的位置

34
00:01:33,426 --> 00:01:35,326
而通过在现代 GPU 上使用 Metal 2

35
00:01:35,326 --> 00:01:37,966
你将可以创造新的算法

36
00:01:37,966 --> 00:01:40,316
新的绘制技术

37
00:01:40,926 --> 00:01:43,276
并获得完全独一无二的

38
00:01:43,276 --> 00:01:45,176
体验

39
00:01:45,546 --> 00:01:46,366
当然 说到体验

40
00:01:46,366 --> 00:01:49,096
我们在 Metal 里

41
00:01:49,096 --> 00:01:50,306
增加了很多新功能

42
00:01:50,306 --> 00:01:51,726
同时我们还有其他三个会议

43
00:01:51,726 --> 00:01:52,746
我非常希望大家能参加

44
00:01:53,586 --> 00:01:56,786
Mac 在今年迎来了 VR 技术

45
00:01:56,786 --> 00:01:58,986
通过新的 iMac  我们将

46
00:01:58,986 --> 00:02:01,486
为你提供非常强大的 GPU

47
00:02:01,976 --> 00:02:04,056
即将登陆 MacBook Pro 的

48
00:02:04,106 --> 00:02:05,646
外部 GPU 也将给你同样

49
00:02:05,646 --> 00:02:06,006
强大的功能

50
00:02:06,726 --> 00:02:09,166
这些都能让你的用户和

51
00:02:09,515 --> 00:02:11,566
你的内容创作者

52
00:02:11,566 --> 00:02:14,156
获得前所未有的

53
00:02:14,156 --> 00:02:14,936
VR 体验

54
00:02:15,576 --> 00:02:17,746
明天的会议将向你展示

55
00:02:18,486 --> 00:02:22,136
如何使用我们的

56
00:02:22,136 --> 00:02:23,876
直接显示技术

57
00:02:23,876 --> 00:02:25,996
来使你的内容快速并且

58
00:02:25,996 --> 00:02:26,846
低延迟地到达 HMD

59
00:02:28,176 --> 00:02:29,906
你将学到新的

60
00:02:29,906 --> 00:02:32,066
为了 VR 制作的 Metal API 版和新的

61
00:02:32,066 --> 00:02:33,066
工具版

62
00:02:35,856 --> 00:02:38,266
机器学习正非常迅速地

63
00:02:38,266 --> 00:02:40,296
在很多应用中成为

64
00:02:40,296 --> 00:02:42,076
我们设备的

65
00:02:42,076 --> 00:02:42,976
关键功能

66
00:02:42,976 --> 00:02:45,056
你可以用通过 Metal 2

67
00:02:45,056 --> 00:02:47,786
来使用 Metal 性能着色器

68
00:02:47,876 --> 00:02:49,726
并利用 GPU 的能力

69
00:02:49,726 --> 00:02:53,446
在测试中和

70
00:02:53,546 --> 00:02:54,536
移动设备上进行机器学习

71
00:02:55,376 --> 00:02:56,786
你可能正盯着

72
00:02:56,916 --> 00:02:58,256
我身后的图片

73
00:02:58,256 --> 00:02:59,486
在想 “这是怎么做到的？”

74
00:02:59,776 --> 00:03:01,316
我们有一个会议

75
00:03:01,316 --> 00:03:03,776
将在周四举行

76
00:03:03,776 --> 00:03:05,416
从中你能学到这个以及

77
00:03:05,416 --> 00:03:07,256
机器学习原语

78
00:03:07,256 --> 00:03:08,796
也就是我们的

79
00:03:09,036 --> 00:03:10,966
Metal 性能着色器里面的

80
00:03:10,966 --> 00:03:11,506
图像处理原语

81
00:03:13,036 --> 00:03:15,576
最后 在 Metal 2 引擎下

82
00:03:15,576 --> 00:03:17,566
我们的工具已经取得了

83
00:03:17,566 --> 00:03:18,146
重大的提升

84
00:03:18,256 --> 00:03:19,856
你将可以快速的

85
00:03:19,856 --> 00:03:21,006
对你的应用进行故障排查

86
00:03:21,556 --> 00:03:23,266
你能更容易的发现问题

87
00:03:23,686 --> 00:03:26,796
我们还将曝光一些东西

88
00:03:26,796 --> 00:03:28,226
例如 GPU 性能计数器

89
00:03:28,226 --> 00:03:29,866
以确保你能

90
00:03:29,866 --> 00:03:33,566
找到你的热点

91
00:03:33,566 --> 00:03:36,126
你的程序也将运行的更快

92
00:03:37,416 --> 00:03:39,786
好了 我希望我已经使你们

93
00:03:40,056 --> 00:03:41,946
为未来几天感到兴奋

94
00:03:41,946 --> 00:03:44,076
现在我们回到

95
00:03:44,076 --> 00:03:45,336
今天会议的

96
00:03:45,336 --> 00:03:45,866
内容

97
00:03:51,426 --> 00:03:53,576
我们将从参数缓冲器开始

98
00:03:53,576 --> 00:03:55,946
这也可能是我们今年

99
00:03:55,996 --> 00:03:57,686
在核心框架上增加的

100
00:03:57,686 --> 00:03:57,916
最重要的内容

101
00:03:58,716 --> 00:04:00,756
参数缓冲器能提供一个

102
00:04:00,756 --> 00:04:03,426
全新的高效方式来

103
00:04:03,426 --> 00:04:05,946
配置缓冲器 纹理和

104
00:04:06,416 --> 00:04:07,986
采样器  使你的应用能够使用

105
00:04:07,986 --> 00:04:11,356
被释放出来的

106
00:04:11,356 --> 00:04:13,246
可观的 CPU 资源

107
00:04:13,246 --> 00:04:15,026
并能使 GPU

108
00:04:15,026 --> 00:04:16,366
真正同时运行

109
00:04:16,366 --> 00:04:17,086
全新的计划

110
00:04:18,196 --> 00:04:20,726
下面我们来谈谈光栅顺序组

111
00:04:20,726 --> 00:04:22,966
一种新的片段着色器

112
00:04:22,966 --> 00:04:24,516
同步原语

113
00:04:25,006 --> 00:04:26,856
它能让你

114
00:04:26,856 --> 00:04:28,566
精确的控制

115
00:04:28,786 --> 00:04:30,426
片段着色器接入公共存储器的顺序

116
00:04:30,426 --> 00:04:33,026
使得你能够使用

117
00:04:33,026 --> 00:04:34,726
例如

118
00:04:35,286 --> 00:04:37,186
MacOS 上的可编程混合

119
00:04:37,246 --> 00:04:41,466
或者体素化

120
00:04:41,516 --> 00:04:42,626
顺序无关的半透明渲染

121
00:04:43,466 --> 00:04:44,866
然后我们将话题转到

122
00:04:44,866 --> 00:04:46,656
显示上来  我们将谈到

123
00:04:46,656 --> 00:04:48,396
iPad 上全新的 ProMotion 显示器

124
00:04:48,396 --> 00:04:50,496
以及如何使用 Metal

125
00:04:50,496 --> 00:04:51,526
去运行它

126
00:04:51,526 --> 00:04:54,396
我们也将简要重述

127
00:04:54,446 --> 00:04:57,376
如何用最快的速度

128
00:04:57,376 --> 00:04:58,876
以及最少的延迟

129
00:04:58,876 --> 00:05:02,606
使你的内容

130
00:05:02,606 --> 00:05:04,046
从渲染目标

131
00:05:04,046 --> 00:05:04,996
传递到眼镜上

132
00:05:05,576 --> 00:05:07,686
最后我们将以一个

133
00:05:08,106 --> 00:05:10,036
关于所有其他

134
00:05:10,036 --> 00:05:12,316
被我们加入到 iOS 和 MacOS 平台里

135
00:05:12,566 --> 00:05:15,436
以配合 Metal 生态系统的 Metal 功能调查

136
00:05:15,786 --> 00:05:16,976
结束今天的会议

137
00:05:22,336 --> 00:05:26,186
好的 关于参数缓冲器

138
00:05:26,536 --> 00:05:28,556
让我们来看看它们是什么

139
00:05:28,716 --> 00:05:29,266
以及它们如何运作的

140
00:05:29,316 --> 00:05:30,806
我将需要举个例子

141
00:05:30,806 --> 00:05:33,776
让我们想象一个简单的材料

142
00:05:33,776 --> 00:05:36,166
一个那些写过

143
00:05:36,166 --> 00:05:39,456
3D 渲染程序的人

144
00:05:39,456 --> 00:05:40,046
都会明白的材料

145
00:05:40,466 --> 00:05:42,326
在你的材料里有

146
00:05:42,326 --> 00:05:44,936
大量的数值常量

147
00:05:45,106 --> 00:05:46,236
大量的纹理

148
00:05:46,236 --> 00:05:47,416
以及多于每天两个的

149
00:05:47,466 --> 00:05:48,016
汇编程序

150
00:05:48,686 --> 00:05:53,196
而这就是你需要发送给

151
00:05:53,196 --> 00:05:54,726
GPU 来

152
00:05:54,726 --> 00:05:56,056
渲染你的原语的东西

153
00:05:56,516 --> 00:05:58,566
纹理对象很有趣

154
00:05:59,456 --> 00:06:01,026
因为他们

155
00:06:01,166 --> 00:06:03,506
不仅包含了纹理属性 例如

156
00:06:03,506 --> 00:06:06,626
宽 高 甚至还有像素格式

157
00:06:06,626 --> 00:06:08,866
它同时还包含了一个

158
00:06:08,866 --> 00:06:10,176
容纳所有美丽像素的

159
00:06:10,176 --> 00:06:11,196
内存的指针

160
00:06:11,196 --> 00:06:13,896
不幸的是 我们今天的会议

161
00:06:13,896 --> 00:06:14,766
对那些像素

162
00:06:14,766 --> 00:06:15,926
不是很感兴趣

163
00:06:15,926 --> 00:06:18,636
所以我们会放下它

164
00:06:18,636 --> 00:06:20,426
而仅仅讨论乏味的

165
00:06:20,426 --> 00:06:20,916
纹理状态

166
00:06:22,156 --> 00:06:24,456
传统的参数模型

167
00:06:24,456 --> 00:06:26,566
允许你将所有的

168
00:06:26,566 --> 00:06:29,106
常量放在 Metal 缓存器中

169
00:06:29,106 --> 00:06:30,216
然后我们创建这个

170
00:06:30,216 --> 00:06:32,126
间接方式 这样你能轻松的

171
00:06:32,126 --> 00:06:33,846
使用它 同时它还可以

172
00:06:33,846 --> 00:06:36,136
在 GPU 未过滤的情况下

173
00:06:36,136 --> 00:06:37,926
直接接入所有的数据

174
00:06:39,136 --> 00:06:41,166
但是 当面对类似

175
00:06:41,166 --> 00:06:43,386
纹理或者采样器时

176
00:06:43,386 --> 00:06:44,446
你还是需要

177
00:06:44,446 --> 00:06:46,266
通过一个 API

178
00:06:46,266 --> 00:06:47,686
在你的渲染循环中

179
00:06:47,686 --> 00:06:50,066
设置缓存器 所有的纹理

180
00:06:50,676 --> 00:06:52,146
以及采样器 只有如此

181
00:06:52,146 --> 00:06:53,396
你才能最终开始绘制工作

182
00:06:53,446 --> 00:06:55,676
即使 Metal 已经

183
00:06:55,676 --> 00:06:57,676
被高度优化了 这里还是存在

184
00:06:57,676 --> 00:06:59,336
一小部分 API 代码

185
00:06:59,336 --> 00:07:00,286
如果你将每一帧要渲染的对象数量

186
00:07:00,286 --> 00:07:02,766
和它相乘

187
00:07:02,766 --> 00:07:04,046
而事实上你确实需要

188
00:07:04,046 --> 00:07:06,156
对每一帧都做这些工作

189
00:07:06,156 --> 00:07:09,026
实际这在某种程度上限制了

190
00:07:09,026 --> 00:07:10,136
你能放在屏幕上的

191
00:07:10,136 --> 00:07:13,826
对象数量

192
00:07:13,826 --> 00:07:17,126
通过使用参数缓冲器

193
00:07:17,126 --> 00:07:19,076
我们希望拓展

194
00:07:19,486 --> 00:07:21,476
这种对常量来说方便的间接取值

195
00:07:21,786 --> 00:07:23,026
使它能应用于

196
00:07:23,026 --> 00:07:23,626
所有的东西

197
00:07:23,626 --> 00:07:26,046
事实上你可以将纹理状态

198
00:07:26,046 --> 00:07:28,226
采样器以及指向另一个缓存器的指针

199
00:07:28,226 --> 00:07:29,696
都放入一个参数缓存器中

200
00:07:29,696 --> 00:07:31,456
这可以很大程度上

201
00:07:31,456 --> 00:07:34,036
简化你的渲染流水线

202
00:07:34,036 --> 00:07:35,656
因为突然间

203
00:07:35,656 --> 00:07:37,956
你要做的唯一一件事

204
00:07:37,956 --> 00:07:40,386
就是设置缓存器

205
00:07:41,426 --> 00:07:41,806
然后绘制

206
00:07:42,016 --> 00:07:43,316
你可能发现了

207
00:07:43,316 --> 00:07:46,196
因为更少的 API 调用

208
00:07:46,196 --> 00:07:47,126
你可以在屏幕上放置更多对象了

209
00:07:47,126 --> 00:07:49,996
正如你将看到的那样

210
00:07:50,236 --> 00:07:51,726
事实上 你可以使用参数缓存器

211
00:07:51,726 --> 00:07:54,006
做到更好

212
00:07:54,656 --> 00:07:55,536
好了 我们已经做了很多

213
00:07:55,536 --> 00:07:58,746
基准测试 并在

214
00:07:58,746 --> 00:07:59,976
我们的设备上运行了参数缓冲器

215
00:08:04,426 --> 00:08:05,886
这是你将在 iPhone 7 上

216
00:08:05,886 --> 00:08:07,616
看到的例子

217
00:08:08,196 --> 00:08:10,196
使用传统的模型

218
00:08:10,526 --> 00:08:13,546
一点都不令人惊讶

219
00:08:13,646 --> 00:08:16,366
在你的绘制调用中

220
00:08:16,366 --> 00:08:17,756
用到的资源会很庞大

221
00:08:18,246 --> 00:08:22,016
而使用参数缓存器

222
00:08:22,016 --> 00:08:25,096
这个代价会很低

223
00:08:25,096 --> 00:08:26,736
甚至没有

224
00:08:26,736 --> 00:08:29,976
这已经证明了

225
00:08:29,976 --> 00:08:31,436
通过一个简单的着色器

226
00:08:31,436 --> 00:08:33,496
两个资源

227
00:08:33,496 --> 00:08:35,956
以及纹理和一个缓存器

228
00:08:36,126 --> 00:08:37,785
或者两个纹理

229
00:08:37,785 --> 00:08:39,535
你将获得 7 倍的

230
00:08:39,535 --> 00:08:40,135
性能提升

231
00:08:40,135 --> 00:08:42,186
有 8 个纹理或者 8 个资源

232
00:08:42,186 --> 00:08:45,146
如果你希望能

233
00:08:45,146 --> 00:08:47,286
将他们混合起来

234
00:08:47,286 --> 00:08:48,996
你将在 iPhone 7 上获得 18 倍的性能提升

235
00:08:48,996 --> 00:08:50,966
显然 他能在16 个资源的时候

236
00:08:50,966 --> 00:08:52,696
运行的更好

237
00:08:55,106 --> 00:08:58,116
好了 性能方面

238
00:08:58,116 --> 00:08:58,896
我就讲到这里

239
00:08:58,986 --> 00:09:01,316
接下来我将介绍一个新功能

240
00:09:01,316 --> 00:09:01,906
新的使用计划

241
00:09:01,906 --> 00:09:04,486
我们稍后会

242
00:09:04,486 --> 00:09:04,866
谈到它

243
00:09:05,066 --> 00:09:06,456
最后一个要点

244
00:09:06,456 --> 00:09:08,166
最后一个我想讲到的

245
00:09:08,166 --> 00:09:09,616
参数缓存器的好处

246
00:09:09,616 --> 00:09:10,376
是使用的方便性

247
00:09:10,976 --> 00:09:13,856
这是因为

248
00:09:13,856 --> 00:09:15,546
参数缓存器实际上

249
00:09:15,716 --> 00:09:16,686
是一个缓存器的扩展

250
00:09:16,686 --> 00:09:17,966
所以你能

251
00:09:17,966 --> 00:09:19,406
例如 提前把它准备好

252
00:09:19,406 --> 00:09:21,116
比如当你的游戏正在缓冲

253
00:09:21,116 --> 00:09:23,426
而你不需要

254
00:09:23,476 --> 00:09:25,216
在你的渲染循环时再担心它

255
00:09:25,216 --> 00:09:26,386
这将进一步

256
00:09:26,556 --> 00:09:27,836
提升你的性能

257
00:09:28,786 --> 00:09:30,356
或者你可以将它们

258
00:09:30,356 --> 00:09:31,606
与一个传统的混合模型结合

259
00:09:31,606 --> 00:09:33,866
比如在一个

260
00:09:34,066 --> 00:09:36,376
单一的绘制调用中

261
00:09:36,376 --> 00:09:38,186
这意味着你可以简单的

262
00:09:38,366 --> 00:09:39,746
用我们的工具

263
00:09:39,746 --> 00:09:40,986
来判断哪些是你应用里

264
00:09:41,256 --> 00:09:43,626
代价最高的循环

265
00:09:43,626 --> 00:09:44,946
你可以优化它

266
00:09:44,946 --> 00:09:46,526
然后你可以在剩下的一年中处理余下的问题

267
00:09:46,526 --> 00:09:49,626
在你有时间的时候

268
00:09:49,746 --> 00:09:52,936
最后 参数缓存器

269
00:09:52,936 --> 00:09:55,246
支持所有的

270
00:09:55,246 --> 00:09:55,786
Metal 设备

271
00:09:55,786 --> 00:09:57,986
所以 只要你使用了它

272
00:09:57,986 --> 00:09:59,356
你会拥有它所有的性能

273
00:09:59,356 --> 00:10:00,956
你也可以在所有的 Metal 设备上

274
00:10:00,956 --> 00:10:02,556
继续使用它

275
00:10:02,986 --> 00:10:04,076
使用的方便性 事实上

276
00:10:04,076 --> 00:10:05,796
也很好的应用在了

277
00:10:05,796 --> 00:10:06,426
着色器上

278
00:10:06,426 --> 00:10:07,836
我们将在本次会议中

279
00:10:07,836 --> 00:10:10,666
谈到一点关于

280
00:10:10,666 --> 00:10:12,576
着色器的内容

281
00:10:12,576 --> 00:10:14,806
这是我在会议开始时给大家

282
00:10:14,806 --> 00:10:15,676
提出的例子

283
00:10:16,666 --> 00:10:19,266
你可以看到

284
00:10:19,266 --> 00:10:21,596
采样器中的纹理是

285
00:10:21,596 --> 00:10:23,366
结构的一部分

286
00:10:23,366 --> 00:10:24,746
这也是你们要从这里学到的主要内容

287
00:10:25,296 --> 00:10:28,616
那就是参数缓存器

288
00:10:28,616 --> 00:10:29,976
只是一个在着色器里的结构

289
00:10:29,976 --> 00:10:31,316
你可以使用处理器里的

290
00:10:31,686 --> 00:10:33,066
所有语言

291
00:10:33,066 --> 00:10:35,266
去创造嵌入结构

292
00:10:35,266 --> 00:10:38,856
去组织你的数据 使用删除

293
00:10:38,856 --> 00:10:39,576
或者指针

294
00:10:39,766 --> 00:10:40,976
它能运行的很好

295
00:10:42,216 --> 00:10:44,486
现在让我们看看

296
00:10:44,766 --> 00:10:46,216
参数缓存器的三个主要的新功能

297
00:10:46,216 --> 00:10:47,586
第一个就是

298
00:10:47,676 --> 00:10:48,946
动态索引

299
00:10:50,276 --> 00:10:53,346
一个非常好的例子

300
00:10:53,346 --> 00:10:53,826
就是批量渲染

301
00:10:53,826 --> 00:10:56,056
如果你最近玩了

302
00:10:56,056 --> 00:10:57,436
一些开放世界游戏 你会看到

303
00:10:57,436 --> 00:11:00,686
这些游戏试图渲染

304
00:11:00,686 --> 00:11:02,506
大量特殊的

305
00:11:02,986 --> 00:11:05,036
不同角色 来创造一个

306
00:11:05,036 --> 00:11:07,546
美丽的 拟真的

307
00:11:07,606 --> 00:11:08,166
世界

308
00:11:08,696 --> 00:11:10,116
事实上

309
00:11:10,116 --> 00:11:12,246
如果你需要进行这么多绘制调用

310
00:11:12,246 --> 00:11:13,706
是一件代价很高的事情

311
00:11:15,076 --> 00:11:16,936
我们提到过 使用参数缓存器

312
00:11:16,936 --> 00:11:19,416
我们可以将所有的

313
00:11:19,416 --> 00:11:20,876
所需属性 比如

314
00:11:20,876 --> 00:11:22,096
一个人物

315
00:11:22,096 --> 00:11:24,006
放入一个单独的参数缓存器  绑定它

316
00:11:24,006 --> 00:11:25,566
这可以节省所有的 CPU 性能

317
00:11:25,566 --> 00:11:27,686
不过我们可以

318
00:11:27,686 --> 00:11:27,966
做的更好

319
00:11:27,966 --> 00:11:30,246
例如 我们可以

320
00:11:30,416 --> 00:11:32,236
创建一个参数缓存器队列

321
00:11:32,546 --> 00:11:35,266
其中每个元素代表一个

322
00:11:35,266 --> 00:11:35,726
字符

323
00:11:36,306 --> 00:11:37,476
然后 这会变得非常简单

324
00:11:37,476 --> 00:11:38,696
因为你需要做的

325
00:11:38,696 --> 00:11:40,856
就是设置这个大的缓存器

326
00:11:40,856 --> 00:11:44,016
这是第一次的 API 调用

327
00:11:44,126 --> 00:11:46,046
它可以处理单一的绘制调用实例

328
00:11:46,046 --> 00:11:47,646
比如说 1000 个实例

329
00:11:47,646 --> 00:11:49,126
因为我希望有 1000 个人物

330
00:11:49,126 --> 00:11:49,496
显示在屏幕上

331
00:11:50,096 --> 00:11:51,186
这是第二次 API 调用

332
00:11:51,256 --> 00:11:53,626
完成之后

333
00:11:53,626 --> 00:11:54,176
它就都在 GPU 上了

334
00:11:54,176 --> 00:11:55,576
在顶点着色里

335
00:11:55,576 --> 00:11:57,426
你可以用实例 ID 从队列中

336
00:11:57,426 --> 00:12:00,926
选择正确的元素

337
00:12:00,926 --> 00:12:02,266
获得人物并将他

338
00:12:02,266 --> 00:12:03,036
放置在世界里需要他的地方

339
00:12:03,036 --> 00:12:04,496
给他正确的姿势

340
00:12:04,496 --> 00:12:05,646
假如是步行周期中间

341
00:12:05,646 --> 00:12:07,766
在片段着色器中

342
00:12:07,766 --> 00:12:10,176
你再一次使用

343
00:12:10,176 --> 00:12:12,146
实例 ID 然后选择正确的材料

344
00:12:12,146 --> 00:12:13,516
正确的发色来

345
00:12:13,516 --> 00:12:14,446
完成这个人物的外貌

346
00:12:14,716 --> 00:12:17,056
所以 我们能很快将

347
00:12:17,576 --> 00:12:19,916
成千上万的绘制调用

348
00:12:19,916 --> 00:12:22,316
变成单一的一次调用

349
00:12:22,636 --> 00:12:24,156
而且它能在 CPU 中运行的更快

350
00:12:24,246 --> 00:12:25,386
在 GPU 中也更快

351
00:12:26,036 --> 00:12:29,466
在着色中

352
00:12:29,466 --> 00:12:30,036
它看上去就是如此简单

353
00:12:31,166 --> 00:12:33,066
很大程度上你的参数缓存器

354
00:12:33,066 --> 00:12:35,516
成为了一队列的结构

355
00:12:36,966 --> 00:12:40,156
你可以使用内置的实例 ID

356
00:12:40,156 --> 00:12:41,506
来选择正确的元素

357
00:12:41,506 --> 00:12:42,856
然后你可以 比如

358
00:12:42,856 --> 00:12:44,526
选择指针 然后将它传递给你的

359
00:12:44,526 --> 00:12:46,176
辅助方法或者任何

360
00:12:46,226 --> 00:12:49,176
处理数据所需的方法

361
00:12:49,256 --> 00:12:51,496
参数缓存器的第二个优秀功能

362
00:12:51,536 --> 00:12:53,206
是 GPU 设置资源

363
00:12:53,806 --> 00:12:56,436
的能力

364
00:12:56,436 --> 00:12:57,656
事实上我们为它

365
00:12:57,656 --> 00:12:58,546
创造了一个例子

366
00:12:59,486 --> 00:13:01,586
我们创造了一个

367
00:13:01,586 --> 00:13:03,876
完全在 GPU 上运行的粒子仿真

368
00:13:04,466 --> 00:13:06,036
让我来告诉你我们怎么做的

369
00:13:06,036 --> 00:13:08,216
我们将看到

370
00:13:08,216 --> 00:13:09,506
我们一会儿将看到它运行

371
00:13:10,256 --> 00:13:11,836
所以我们创建了一队

372
00:13:12,086 --> 00:13:13,316
参数缓存器 他们中每一个

373
00:13:13,366 --> 00:13:16,296
元素是一个单个的粒子

374
00:13:16,296 --> 00:13:17,756
我猜你已经看到了

375
00:13:17,756 --> 00:13:19,196
这里的趋势

376
00:13:19,766 --> 00:13:23,716
随后我们的仿真核将

377
00:13:24,596 --> 00:13:26,696
每线程的对一个粒子进行仿真

378
00:13:26,696 --> 00:13:28,796
但是我们想要

379
00:13:28,796 --> 00:13:29,966
走得更远

380
00:13:29,966 --> 00:13:32,906
我们希望使 GPU

381
00:13:32,906 --> 00:13:36,416
在核心中

382
00:13:36,416 --> 00:13:37,006
也能创造粒子

383
00:13:37,006 --> 00:13:39,106
所以 为了实现这个目标

384
00:13:39,106 --> 00:13:41,316
给予它正确的材料

385
00:13:41,316 --> 00:13:43,016
我们也有

386
00:13:43,076 --> 00:13:44,686
我们希望粒子拥有的

387
00:13:44,686 --> 00:13:45,806
所有不同材质的

388
00:13:45,806 --> 00:13:46,176
参数缓存器

389
00:13:46,906 --> 00:13:48,896
我们的仿真核

390
00:13:49,386 --> 00:13:50,866
每一次你想在样本里做一个动作时

391
00:13:51,186 --> 00:13:53,826
这个仿真核就会

392
00:13:53,826 --> 00:13:54,776
观察环境

393
00:13:54,776 --> 00:13:57,066
看看哪些是

394
00:13:57,806 --> 00:13:59,446
正确的 合适的

395
00:13:59,446 --> 00:13:59,906
材料

396
00:14:00,056 --> 00:14:01,596
打个比方 如果你在

397
00:14:01,596 --> 00:14:04,126
一片森林里 我们选择苔藓

398
00:14:04,286 --> 00:14:05,786
作为一块岩石最正确合适的材料

399
00:14:05,786 --> 00:14:08,696
然后将它复制到

400
00:14:09,126 --> 00:14:10,126
粒子上

401
00:14:11,366 --> 00:14:13,226
如果你在岩石上

402
00:14:13,226 --> 00:14:14,106
我们选择岩石材料

403
00:14:14,106 --> 00:14:15,946
在山上我们选择草

404
00:14:16,826 --> 00:14:18,506
像这样 所有东西都在 GPU 上

405
00:14:18,506 --> 00:14:22,796
它的着色真的就和

406
00:14:22,796 --> 00:14:24,206
我描述的一样

407
00:14:24,206 --> 00:14:24,946
那么简单

408
00:14:25,336 --> 00:14:26,756
如果你想在你的 GPU 上

409
00:14:26,756 --> 00:14:30,156
修改数据 你可以将它作为设备缓存器捆绑

410
00:14:30,156 --> 00:14:31,486
然后像你以前一样

411
00:14:31,486 --> 00:14:33,866
开始赋值

412
00:14:33,866 --> 00:14:34,986
但是这次你要

413
00:14:34,986 --> 00:14:37,146
复制纹理或者复制整个的

414
00:14:37,146 --> 00:14:38,676
结构

415
00:14:38,676 --> 00:14:38,966
这非常简单

416
00:14:40,106 --> 00:14:42,346
我想介绍的

417
00:14:42,346 --> 00:14:44,576
最后一个参数缓存器的

418
00:14:44,576 --> 00:14:47,116
优秀功能是

419
00:14:47,116 --> 00:14:48,116
它可以引用另外一个参数缓存器

420
00:14:48,116 --> 00:14:50,106
这样你可以

421
00:14:50,106 --> 00:14:52,936
创建一个可重复使用的

422
00:14:53,026 --> 00:14:55,816
复杂对象层级

423
00:14:55,816 --> 00:14:59,076
就像 C++ Swift

424
00:14:59,296 --> 00:15:00,046
和 Objective-C 一样

425
00:15:00,566 --> 00:15:03,676
打个比方 在我们的渲染器的例子中

426
00:15:04,376 --> 00:15:06,496
如果你有大量的对象

427
00:15:06,536 --> 00:15:09,076
但你可能只有

428
00:15:09,726 --> 00:15:11,046
很少的材料 你可以做的是

429
00:15:11,046 --> 00:15:14,556
从每个对象引用材料

430
00:15:14,556 --> 00:15:15,866
省下一些内存

431
00:15:15,866 --> 00:15:18,336
或者你可以

432
00:15:18,336 --> 00:15:19,716
将布景图构建成二进制树形网络

433
00:15:19,716 --> 00:15:21,566
在这里 当你需要时 你可以指向

434
00:15:21,566 --> 00:15:25,186
对象和树的节点

435
00:15:25,186 --> 00:15:26,436
就像你原来

436
00:15:26,436 --> 00:15:27,526
在 CPU 里使用一样

437
00:15:27,906 --> 00:15:29,396
你也可以和 CPU 分享

438
00:15:29,396 --> 00:15:30,086
这些数据

439
00:15:31,536 --> 00:15:32,846
这些就是主要的功能

440
00:15:32,846 --> 00:15:34,526
现在让我们来看看

441
00:15:34,526 --> 00:15:35,026
支持矩阵

442
00:15:35,596 --> 00:15:37,036
我们有两个层级

443
00:15:37,266 --> 00:15:39,796
层级一是被所有

444
00:15:39,796 --> 00:15:42,466
Metal 设备支持的

445
00:15:42,466 --> 00:15:43,386
你也可以提升 CPU

446
00:15:43,386 --> 00:15:43,926
的性能

447
00:15:43,926 --> 00:15:44,866
你可以得到新的

448
00:15:44,866 --> 00:15:45,276
计划语言

449
00:15:45,766 --> 00:15:49,096
但是因为 GPU 的限制

450
00:15:49,096 --> 00:15:52,296
这个层级

451
00:15:52,896 --> 00:15:54,526
不能够像我之前提到的

452
00:15:55,016 --> 00:15:56,486
通过利用 GPU 驱动

453
00:15:56,486 --> 00:15:57,346
来使用用例

454
00:15:57,776 --> 00:15:58,916
但是如果使用层级二

455
00:15:58,916 --> 00:16:00,586
你可以得到所有的

456
00:16:00,586 --> 00:16:02,396
所有的新用例

457
00:16:02,396 --> 00:16:04,126
我们也同样

458
00:16:04,126 --> 00:16:05,736
大幅提高了你能接入的

459
00:16:05,736 --> 00:16:06,176
资源

460
00:16:06,176 --> 00:16:07,416
你的渲染器能接入

461
00:16:07,466 --> 00:16:10,406
50 万的纹理和缓存器

462
00:16:10,406 --> 00:16:11,676
让你能做这些

463
00:16:11,676 --> 00:16:12,806
新的算法

464
00:16:13,696 --> 00:16:15,696
尽管层级一在所有设备上

465
00:16:15,986 --> 00:16:18,526
都被支持  层级二是

466
00:16:18,526 --> 00:16:19,826
你需要查询得到的

467
00:16:20,306 --> 00:16:22,216
但是不用担心 这个支持

468
00:16:22,216 --> 00:16:22,846
非常广泛

469
00:16:23,556 --> 00:16:25,016
所有拥有这三个 GPU 的 Mac

470
00:16:25,016 --> 00:16:26,166
都有层级二

471
00:16:26,626 --> 00:16:28,436
所有新的 MacBook Pro

472
00:16:28,436 --> 00:16:29,676
最新的 MacBook 最后层级的 MacBook Pro

473
00:16:29,676 --> 00:16:31,586
都有层级二

474
00:16:31,586 --> 00:16:33,316
所以你大可以

475
00:16:33,416 --> 00:16:33,586
玩得高兴

476
00:16:34,106 --> 00:16:35,546
现在 让我们来看看

477
00:16:35,546 --> 00:16:36,136
我承诺过给你们的样本

478
00:16:36,226 --> 00:16:39,116
我们将展示三个视频

479
00:16:39,426 --> 00:16:41,416
其中包含三个不同功能

480
00:16:41,986 --> 00:16:43,936
这个被实时渲染的地形

481
00:16:44,136 --> 00:16:45,846
有动态变化的材料

482
00:16:45,846 --> 00:16:48,346
我们利用 GPU 在地形上

483
00:16:48,346 --> 00:16:50,616
放置一些植物

484
00:16:50,616 --> 00:16:51,716
来让它更有趣

485
00:16:52,116 --> 00:16:53,326
我们也有这些我

486
00:16:53,326 --> 00:16:56,076
之前提到过的漂亮的

487
00:16:56,076 --> 00:16:56,436
粒子

488
00:16:56,656 --> 00:16:59,516
所以 就像你看到的

489
00:17:00,006 --> 00:17:01,246
我们在地形上绘制高度

490
00:17:01,246 --> 00:17:02,496
我们可以改变地表侵蚀

491
00:17:02,496 --> 00:17:03,466
随后材料也会

492
00:17:03,466 --> 00:17:04,326
跟着变化

493
00:17:04,626 --> 00:17:05,796
这就是参数缓存器优秀的地方

494
00:17:05,796 --> 00:17:08,425
因为它们

495
00:17:08,425 --> 00:17:10,965
能让我们创建一个大的

496
00:17:11,665 --> 00:17:13,506
参数缓存器

497
00:17:13,506 --> 00:17:16,406
所有的可用材料和层级都在里面

498
00:17:16,406 --> 00:17:18,455
当我们在一个像素着色器中

499
00:17:18,455 --> 00:17:20,576
渲染地形时

500
00:17:20,576 --> 00:17:21,736
我们看到的是

501
00:17:22,076 --> 00:17:24,846
地形的高度 坡度

502
00:17:25,116 --> 00:17:27,406
有多少阳光到达特定的

503
00:17:27,606 --> 00:17:29,166
像素 基于这些属性

504
00:17:29,166 --> 00:17:30,976
和其他属性

505
00:17:30,976 --> 00:17:33,866
我们能判断什么是用于

506
00:17:34,026 --> 00:17:35,446
这个像素上的最好的

507
00:17:35,446 --> 00:17:36,466
和最适合的材料

508
00:17:36,896 --> 00:17:38,046
这些都是

509
00:17:38,046 --> 00:17:40,746
实时发生的  在以前我们可能需要

510
00:17:40,746 --> 00:17:42,436
在线下

511
00:17:42,436 --> 00:17:44,316
将地形拆成小块

512
00:17:44,766 --> 00:17:47,466
分析哪些小块

513
00:17:47,466 --> 00:17:49,206
需要哪些纹理

514
00:17:49,206 --> 00:17:50,676
以使它最优化

515
00:17:51,236 --> 00:17:53,166
然后才能渲染它

516
00:17:53,166 --> 00:17:55,386
所以我们将一个

517
00:17:55,456 --> 00:17:56,546
预处理的步骤

518
00:17:56,546 --> 00:17:58,366
一个繁重的非实时的

519
00:17:58,366 --> 00:18:00,496
修改操作 变成了一个

520
00:18:00,496 --> 00:18:02,226
实时的 抱歉

521
00:18:02,286 --> 00:18:04,716
不需要处理的

522
00:18:04,716 --> 00:18:05,626
完全动态的步骤

523
00:18:08,976 --> 00:18:11,986
我们在上面加上植被

524
00:18:12,296 --> 00:18:14,086
你可以看到植被

525
00:18:14,086 --> 00:18:16,196
也是环境敏感的

526
00:18:17,026 --> 00:18:18,766
你看沙滩上的

527
00:18:18,766 --> 00:18:19,136
棕榈树

528
00:18:19,136 --> 00:18:20,826
你看山丘上

529
00:18:20,826 --> 00:18:21,816
小小的苹果树

530
00:18:23,446 --> 00:18:25,536
植被本身还是一个

531
00:18:25,536 --> 00:18:28,176
非常传统的实例渲染

532
00:18:28,176 --> 00:18:29,776
参数缓存器在这里

533
00:18:29,776 --> 00:18:32,396
能做到的是

534
00:18:32,396 --> 00:18:34,086
它使我们能将

535
00:18:34,416 --> 00:18:36,006
所有的相同属性

536
00:18:36,006 --> 00:18:37,846
分享给同样的地形材料

537
00:18:37,846 --> 00:18:39,646
并在完全分离的

538
00:18:40,126 --> 00:18:41,486
代码中间进行

539
00:18:41,486 --> 00:18:43,446
同样的地形分析功能

540
00:18:43,676 --> 00:18:45,246
当地形渲染器用

541
00:18:45,246 --> 00:18:47,326
所有这些数据去渲染像素时

542
00:18:47,326 --> 00:18:48,796
放置几何形状

543
00:18:48,796 --> 00:18:50,316
和植被的电脑

544
00:18:50,686 --> 00:18:51,956
事实上分析了相同的

545
00:18:51,956 --> 00:18:53,786
材料以判断

546
00:18:53,786 --> 00:18:56,266
最合适放置在指定地点上的

547
00:18:56,266 --> 00:18:57,026
是哪一种树

548
00:18:57,486 --> 00:18:58,616
这非常简单因为

549
00:18:58,616 --> 00:18:59,836
每次我们在做改变的时候

550
00:19:00,166 --> 00:19:01,566
我们的代码事实上没有任何变化

551
00:19:01,566 --> 00:19:02,686
我们只是增加了新的

552
00:19:02,686 --> 00:19:04,516
层级或者改变了我们的分析

553
00:19:04,516 --> 00:19:06,806
功能  可能从前我们需要

554
00:19:06,806 --> 00:19:08,526
在两个完全分离的

555
00:19:08,526 --> 00:19:10,226
代码中间处理大概 70 个纹理

556
00:19:10,226 --> 00:19:11,776
以使他们能

557
00:19:11,816 --> 00:19:17,036
同步的运行

558
00:19:17,216 --> 00:19:19,406
最后 我们有粒子

559
00:19:19,406 --> 00:19:22,226
我希望你们注意到

560
00:19:22,226 --> 00:19:25,146
他们已经找到了

561
00:19:25,146 --> 00:19:25,916
地形的材料

562
00:19:26,876 --> 00:19:28,606
我之前没有提到的是

563
00:19:28,606 --> 00:19:30,866
这些全都是被

564
00:19:31,126 --> 00:19:32,816
单个的绘制调用渲染的

565
00:19:32,816 --> 00:19:34,756
我们这里使用单个的绘制调用

566
00:19:35,086 --> 00:19:38,006
渲染了 16000 个粒子

567
00:19:38,006 --> 00:19:39,776
这个过程中完全没有

568
00:19:39,816 --> 00:19:41,586
CPU 的参与

569
00:19:42,406 --> 00:19:44,486
而且粒子不只是有

570
00:19:44,826 --> 00:19:46,316
特殊的材料 它们事实上

571
00:19:46,316 --> 00:19:47,486
还有特殊的形状 因为

572
00:19:47,766 --> 00:19:48,876
参数缓存器

573
00:19:48,936 --> 00:19:50,176
允许你在每个

574
00:19:50,176 --> 00:19:52,166
绘制调用里

575
00:19:52,166 --> 00:19:52,466
改变你的顶点缓存

576
00:19:53,526 --> 00:19:56,076
如果你试着不用

577
00:19:56,076 --> 00:19:58,466
参数缓存器去处理它

578
00:19:58,466 --> 00:20:01,956
我们需要创建一个

579
00:20:01,956 --> 00:20:04,496
复杂的控件

580
00:20:04,496 --> 00:20:06,856
在负责模仿的 GPU 和

581
00:20:06,856 --> 00:20:08,036
试图得到最佳

582
00:20:08,036 --> 00:20:09,866
绘制调用组的 CPU 之间

583
00:20:09,866 --> 00:20:11,356
来代表所有的这些变量

584
00:20:11,776 --> 00:20:13,396
有了参数缓存器

585
00:20:13,396 --> 00:20:17,116
这将变得非常非常简单

586
00:20:18,346 --> 00:20:21,706
好了 看够了美丽的图片

587
00:20:22,296 --> 00:20:25,226
让我们以一些

588
00:20:25,226 --> 00:20:28,406
API 和一些实践例子

589
00:20:28,406 --> 00:20:29,716
来结束我的部分

590
00:20:29,986 --> 00:20:33,426
就像我提到的那样

591
00:20:33,426 --> 00:20:34,926
参数缓存器是 Metal 缓存器的

592
00:20:34,926 --> 00:20:37,426
延伸 这意味着

593
00:20:37,426 --> 00:20:39,286
所有与缓存器有关的 API

594
00:20:39,286 --> 00:20:39,776
都能运行

595
00:20:39,776 --> 00:20:40,946
你可以找一个

596
00:20:40,946 --> 00:20:42,196
参数缓存器 将它复制到

597
00:20:42,196 --> 00:20:43,456
别的地方 你可以将它

598
00:20:43,456 --> 00:20:44,976
放到 CPU 和 GPU 中间

599
00:20:45,826 --> 00:20:48,106
尽管参数缓存器

600
00:20:48,106 --> 00:20:51,266
看起来像渲染器在 GPU 里的结构

601
00:20:51,266 --> 00:20:54,796
在 CPU 里你将用到

602
00:20:54,796 --> 00:20:56,816
MTLArgumentEncoder 对象去

603
00:20:56,816 --> 00:20:57,716
填充内容

604
00:20:58,676 --> 00:21:02,196
这样的抽象能让 Metal

605
00:21:02,196 --> 00:21:04,696
为任何

606
00:21:05,186 --> 00:21:06,686
实际运行的特定 GPU 上的

607
00:21:06,686 --> 00:21:08,316
指定参数缓存器

608
00:21:08,316 --> 00:21:09,376
创建一个最优化的

609
00:21:09,376 --> 00:21:09,716
内存表征

610
00:21:10,206 --> 00:21:11,506
这样你就可以得到最好的性能

611
00:21:11,896 --> 00:21:13,266
作为一个研发者

612
00:21:13,266 --> 00:21:14,686
它同时也将把你

613
00:21:15,646 --> 00:21:19,956
从焦虑的细节中解放出来

614
00:21:19,956 --> 00:21:21,956
例如 每个 GPU 如何体现

615
00:21:22,096 --> 00:21:22,966
什么是纹理

616
00:21:22,966 --> 00:21:23,986
它在存储器中应该放在什么位置

617
00:21:24,616 --> 00:21:26,746
所有这些从平台到平台的变化

618
00:21:26,886 --> 00:21:28,776
我们将它们隐藏在

619
00:21:28,776 --> 00:21:31,356
简单的界面之间

620
00:21:31,356 --> 00:21:32,616
这样你就可以写出非常简单的

621
00:21:32,616 --> 00:21:33,826
有效率的应用了

622
00:21:34,506 --> 00:21:37,106
希望你们没有

623
00:21:37,106 --> 00:21:38,006
为了我前面提到的

624
00:21:38,006 --> 00:21:38,376
编码器感到发愁

625
00:21:38,376 --> 00:21:39,886
它真的用起来非常非常

626
00:21:39,886 --> 00:21:40,286
简单

627
00:21:41,346 --> 00:21:42,396
举个例子 如果你想要

628
00:21:42,396 --> 00:21:43,856
为这个参数缓存器创建一个 参数编码器

629
00:21:43,856 --> 00:21:46,386
你只需要

630
00:21:46,386 --> 00:21:49,886
让你的 Metal 使用

631
00:21:49,886 --> 00:21:51,386
参数缓存器功能

632
00:21:51,386 --> 00:21:53,736
然后让 Metal 功能

633
00:21:53,736 --> 00:21:55,386
调用编码器

634
00:21:55,386 --> 00:21:56,116
就行了

635
00:21:56,116 --> 00:21:57,386
这就是你要做的全部了

636
00:21:57,386 --> 00:21:59,526
你得到一个对象 你开始

637
00:21:59,526 --> 00:22:02,066
使用一个熟悉的纹理

638
00:22:02,486 --> 00:22:04,586
或者像你在

639
00:22:04,586 --> 00:22:05,906
Metal 里使用

640
00:22:05,906 --> 00:22:08,666
命令编码器一样

641
00:22:08,666 --> 00:22:09,016
去填满 API

642
00:22:09,016 --> 00:22:11,916
这对我提到过的

643
00:22:11,916 --> 00:22:15,116
过渡和使用的便捷性

644
00:22:15,116 --> 00:22:15,846
也有效

645
00:22:16,866 --> 00:22:18,736
还有很多创建编码器的

646
00:22:18,736 --> 00:22:20,546
方法

647
00:22:20,546 --> 00:22:21,786
你可以使描述符

648
00:22:21,786 --> 00:22:22,686
更精确 但是

649
00:22:22,686 --> 00:22:24,706
如果你需要的话

650
00:22:24,876 --> 00:22:26,036
你可能要去查找

651
00:22:26,036 --> 00:22:27,326
参考资料

652
00:22:27,326 --> 00:22:28,956
我们建议你

653
00:22:29,566 --> 00:22:30,866
直接从着色器里获得

654
00:22:30,866 --> 00:22:31,386
参数编码器

655
00:22:33,846 --> 00:22:36,706
现在 有了这些交互

656
00:22:36,706 --> 00:22:38,396
GPU 可以介入

657
00:22:38,396 --> 00:22:40,436
修改参数缓存器

658
00:22:41,036 --> 00:22:42,286
或者动态的索引

659
00:22:42,286 --> 00:22:44,356
以及 50 万个纹理 如果这些全部混合起来

660
00:22:44,356 --> 00:22:47,526
Metal 不太可能

661
00:22:47,906 --> 00:22:49,366
去分辨

662
00:22:49,366 --> 00:22:50,466
例如在渲染的时候

663
00:22:50,466 --> 00:22:52,226
应该使用

664
00:22:52,226 --> 00:22:55,396
哪些纹理和缓存器

665
00:22:55,396 --> 00:22:57,006
但幸运的是 作为一个开发者

666
00:22:57,006 --> 00:22:58,916
你对此有

667
00:22:58,916 --> 00:22:59,126
很好的解决方法

668
00:22:59,126 --> 00:23:01,276
所以我们要求你

669
00:23:01,276 --> 00:23:02,716
对参数缓存器

670
00:23:02,716 --> 00:23:03,066
尽量的熟悉

671
00:23:04,266 --> 00:23:05,776
如果你在使用堆

672
00:23:06,646 --> 00:23:08,336
当然你需要使用堆

673
00:23:08,336 --> 00:23:09,896
在你的平台上获得

674
00:23:09,896 --> 00:23:12,506
最佳的性能

675
00:23:12,506 --> 00:23:13,766
以及组织数据的最佳方式

676
00:23:14,366 --> 00:23:15,586
你唯一要做的事

677
00:23:15,586 --> 00:23:16,936
就是告诉 Metal 你想要用一个堆

678
00:23:16,936 --> 00:23:18,886
或者多个堆

679
00:23:18,886 --> 00:23:19,816
这由你来决定

680
00:23:19,816 --> 00:23:22,356
这保证了

681
00:23:22,356 --> 00:23:24,196
在渲染循环中

682
00:23:24,196 --> 00:23:25,546
纹理是

683
00:23:25,546 --> 00:23:27,696
可用的

684
00:23:27,696 --> 00:23:29,066
如果你想做到更具体

685
00:23:29,066 --> 00:23:30,076
比如你想要

686
00:23:30,076 --> 00:23:32,586
从一个内部的着色器

687
00:23:32,586 --> 00:23:34,556
写入渲染目标 或者你

688
00:23:34,556 --> 00:23:35,626
想从一个 dev 缓存器进行读取

689
00:23:35,626 --> 00:23:38,466
你可以使用一个更加具体的 API

690
00:23:38,466 --> 00:23:40,466
然后告诉 Metal

691
00:23:40,466 --> 00:23:42,476
你想要用

692
00:23:43,476 --> 00:23:44,516
特殊的方式改变资源

693
00:23:44,516 --> 00:23:46,076
再一次的

694
00:23:46,076 --> 00:23:46,166
就是这样简单

695
00:23:46,166 --> 00:23:46,836
任何其他的事

696
00:23:46,836 --> 00:23:46,976
你都不用做

697
00:23:50,506 --> 00:23:52,196
让我们开始讲讲

698
00:23:52,196 --> 00:23:53,116
几个最佳的实践例子

699
00:23:53,116 --> 00:23:55,986
我想如果你了解 Metal

700
00:23:55,986 --> 00:23:58,076
它和我们向你介绍的

701
00:23:58,076 --> 00:24:00,076
Metal 缓存器

702
00:24:00,076 --> 00:24:00,716
十分相似

703
00:24:01,156 --> 00:24:02,586
组织你的数据的最佳

704
00:24:02,586 --> 00:24:04,706
方式是用 使用模式

705
00:24:04,706 --> 00:24:05,856
你可能有很多属性

706
00:24:05,856 --> 00:24:08,406
它们不会随着

707
00:24:08,686 --> 00:24:09,306
每个帧进行变化

708
00:24:09,396 --> 00:24:10,536
所以 将它们放入

709
00:24:10,536 --> 00:24:11,956
参数缓存器 将它和所有的

710
00:24:11,956 --> 00:24:13,166
对象共享

711
00:24:13,166 --> 00:24:13,536
这样你将节省内存

712
00:24:14,286 --> 00:24:16,076
同样的 另一方面

713
00:24:16,076 --> 00:24:17,756
你可能有很多

714
00:24:17,756 --> 00:24:19,566
属性 它们也确实随着每个

715
00:24:19,566 --> 00:24:21,106
对象进行变化

716
00:24:21,106 --> 00:24:23,496
你需要在每一帧下

717
00:24:23,496 --> 00:24:24,346
对它们进行管理

718
00:24:24,346 --> 00:24:26,946
对于这个问题 我认为

719
00:24:26,946 --> 00:24:28,066
最好的方式是

720
00:24:28,066 --> 00:24:29,226
将它们发给不同的参数缓存器

721
00:24:29,226 --> 00:24:30,396
这样你可对它进行双重缓存

722
00:24:30,396 --> 00:24:32,056
或者对任何你的管理计划

723
00:24:32,056 --> 00:24:34,786
进行两次运行 你不用

724
00:24:34,786 --> 00:24:36,576
通过其他的复制

725
00:24:36,576 --> 00:24:37,266
来使所有的数据存在里面

726
00:24:37,706 --> 00:24:39,186
然后你会有

727
00:24:39,186 --> 00:24:41,326
一些完全不会

728
00:24:41,786 --> 00:24:43,286
改变的参数缓存器

729
00:24:43,286 --> 00:24:44,456
比如材料 或者

730
00:24:45,026 --> 00:24:46,816
一些其他的属性

731
00:24:46,966 --> 00:24:49,296
对于它们 你可以

732
00:24:49,296 --> 00:24:50,296
在应用的初始化里创建它们

733
00:24:50,296 --> 00:24:53,826
然后继续应用它们

734
00:24:54,026 --> 00:24:57,576
和 Metal 缓存器相似

735
00:24:57,576 --> 00:24:59,816
想想你的数据位置 以及

736
00:24:59,816 --> 00:25:01,566
你将如何使用

737
00:25:01,566 --> 00:25:01,916
你的参数缓存器

738
00:25:02,246 --> 00:25:03,816
假如你有

739
00:25:03,816 --> 00:25:06,076
3 个纹理 接入了着色器

740
00:25:06,076 --> 00:25:08,776
一个接一个

741
00:25:09,316 --> 00:25:10,836
这时你能做的最好的事就是

742
00:25:10,836 --> 00:25:12,046
在参数缓存器里将这些

743
00:25:12,046 --> 00:25:13,216
纹理放置在相距很近的地方

744
00:25:13,216 --> 00:25:14,566
这样你才能最大化

745
00:25:14,566 --> 00:25:16,466
GPU 的缓存

746
00:25:17,376 --> 00:25:18,146
就像我在会议开始时提到的

747
00:25:18,146 --> 00:25:20,736
传统的参数模型

748
00:25:20,736 --> 00:25:23,716
不能运用到每个地方

749
00:25:23,716 --> 00:25:25,576
你要合理使用它

750
00:25:25,576 --> 00:25:26,776
并且在能使情况更方便的时候

751
00:25:26,776 --> 00:25:28,116
将它和参数缓存器

752
00:25:28,116 --> 00:25:28,786
混合使用

753
00:25:29,296 --> 00:25:30,626
比方说你需要对

754
00:25:30,626 --> 00:25:32,256
改变每个对象的单个纹理

755
00:25:33,376 --> 00:25:35,786
比如一个立方体的倒影

756
00:25:35,786 --> 00:25:37,606
只为这个创建一个

757
00:25:37,606 --> 00:25:38,786
参数缓存器然后

758
00:25:38,786 --> 00:25:40,096
每一帧都上载它 可能是一个

759
00:25:40,096 --> 00:25:40,896
系统开销

760
00:25:40,896 --> 00:25:42,826
所以 在这里我们

761
00:25:42,826 --> 00:25:43,526
使用传统的模型

762
00:25:43,656 --> 00:25:46,216
这就是

763
00:25:46,216 --> 00:25:46,576
关于参数缓存器的内容

764
00:25:46,576 --> 00:25:50,256
我真诚的希望大家能使用

765
00:25:50,256 --> 00:25:52,516
我们的新 API 并创新性的

766
00:25:52,806 --> 00:25:53,596
使用它

767
00:25:54,136 --> 00:25:57,456
请大家欢迎 Richard

768
00:25:57,546 --> 00:25:59,156
他将为大家介绍

769
00:25:59,156 --> 00:25:59,506
光栅顺序组

770
00:26:00,556 --> 00:26:02,556
[ 掌声 ]

771
00:26:02,596 --> 00:26:03,016
>> 谢谢

772
00:26:05,046 --> 00:26:06,686
大家好 谢谢你 Michal

773
00:26:06,826 --> 00:26:07,776
我将带领大家度过

774
00:26:07,776 --> 00:26:08,436
下面的展示时间

775
00:26:08,436 --> 00:26:10,006
让我们从

776
00:26:10,046 --> 00:26:10,936
光栅顺序组开始

777
00:26:12,476 --> 00:26:14,196
这是个新的功能

778
00:26:14,196 --> 00:26:16,636
它能让你控制 GPU 的

779
00:26:16,726 --> 00:26:17,866
线性调度

780
00:26:18,196 --> 00:26:19,686
以有序的运行

781
00:26:19,746 --> 00:26:20,086
片段射击线

782
00:26:20,686 --> 00:26:22,096
这让重叠的片段射击线

783
00:26:22,096 --> 00:26:23,266
能够通过存储器进行沟通

784
00:26:23,266 --> 00:26:24,876
在这之前

785
00:26:24,876 --> 00:26:27,366
大多数情况下

786
00:26:27,366 --> 00:26:28,286
是实现不了的

787
00:26:28,646 --> 00:26:30,246
所以 这开启了一个

788
00:26:30,246 --> 00:26:31,266
全新的图像算法

789
00:26:31,266 --> 00:26:32,956
如果只写入了对你的

790
00:26:33,156 --> 00:26:34,206
帧缓存器的接口或者

791
00:26:34,206 --> 00:26:36,196
接入设备存储器

792
00:26:36,196 --> 00:26:37,216
这是很难实现的

793
00:26:38,476 --> 00:26:40,986
举个例子

794
00:26:40,986 --> 00:26:42,226
我们的关键应用中的一个

795
00:26:42,306 --> 00:26:43,156
是顺序无关的

796
00:26:43,156 --> 00:26:43,926
透明渲染

797
00:26:44,746 --> 00:26:46,106
我们今天已经谈了很多

798
00:26:46,106 --> 00:26:47,476
如何降低你的 Metal 应用

799
00:26:47,476 --> 00:26:48,596
的 CPU 使用量的问题

800
00:26:48,596 --> 00:26:50,356
这个功能

801
00:26:50,356 --> 00:26:52,006
让你创建一个算法

802
00:26:52,476 --> 00:26:54,456
以实现前后颠倒的混合

803
00:26:54,456 --> 00:26:56,116
而不用为

804
00:26:56,116 --> 00:26:57,526
三角水平筛选

805
00:26:57,526 --> 00:26:57,896
而消耗 CPU

806
00:26:59,536 --> 00:27:00,736
这里有很多针对

807
00:27:00,736 --> 00:27:01,836
类似

808
00:27:01,836 --> 00:27:03,176
双层的 G-buffer

809
00:27:03,396 --> 00:27:04,236
的先进技术的研究

810
00:27:04,236 --> 00:27:05,946
这种缓存器能

811
00:27:05,946 --> 00:27:07,596
极大的提升 后处理结果 或者用

812
00:27:07,596 --> 00:27:08,846
GPU 的光栅器

813
00:27:08,846 --> 00:27:10,196
来像素化三角形网格

814
00:27:11,056 --> 00:27:12,716
对于这些存储器

815
00:27:12,716 --> 00:27:13,826
的前端接口

816
00:27:13,826 --> 00:27:15,336
在他们通往高效应用的路上

817
00:27:15,336 --> 00:27:16,516
还有很大的阻碍

818
00:27:17,296 --> 00:27:18,976
可能对于这个功能而言

819
00:27:18,976 --> 00:27:20,566
最简单最通俗的应用

820
00:27:20,566 --> 00:27:21,836
是执行

821
00:27:21,836 --> 00:27:22,776
定制混合方程

822
00:27:23,656 --> 00:27:25,076
iOS 的硬件能很自然的

823
00:27:25,076 --> 00:27:27,336
支持这样做

824
00:27:27,336 --> 00:27:29,406
但是

825
00:27:29,406 --> 00:27:31,066
这不是传统的台式机

826
00:27:31,066 --> 00:27:31,686
的硬件能够做到的

827
00:27:32,656 --> 00:27:33,906
所以我们将定制混合

828
00:27:33,906 --> 00:27:34,986
作为一个范例应用

829
00:27:34,986 --> 00:27:36,076
来介绍

830
00:27:36,076 --> 00:27:36,346
这个功能

831
00:27:38,076 --> 00:27:40,086
三角混合的经典例子

832
00:27:40,126 --> 00:27:41,316
是一个三角在

833
00:27:41,316 --> 00:27:41,836
另一个之上

834
00:27:42,776 --> 00:27:45,036
几乎所有现代的 GPU API

835
00:27:45,036 --> 00:27:46,386
都能保证在绘制调用命令中

836
00:27:46,386 --> 00:27:47,426
可以进行混合

837
00:27:47,566 --> 00:27:48,856
它能证明

838
00:27:48,926 --> 00:27:50,416
这个简便的

839
00:27:50,416 --> 00:27:50,946
串行执行的假想

840
00:27:51,796 --> 00:27:53,376
但是 事实上在幕后

841
00:27:53,376 --> 00:27:54,586
发生的事是

842
00:27:54,676 --> 00:27:56,026
GPU 硬件是高度并行的

843
00:27:56,026 --> 00:27:57,056
它将

844
00:27:57,056 --> 00:27:58,256
同时运行多个线程

845
00:27:58,836 --> 00:28:00,296
只有这个固定功能的

846
00:28:00,296 --> 00:28:01,786
混合步骤最后能

847
00:28:01,786 --> 00:28:03,046
延迟到所有东西

848
00:28:03,046 --> 00:28:05,776
都重新有序排列之后

849
00:28:05,776 --> 00:28:06,876
在混合步骤之前

850
00:28:06,876 --> 00:28:08,906
有一个隐式等待

851
00:28:10,476 --> 00:28:12,686
事情可能会随着顺序改变

852
00:28:12,686 --> 00:28:13,616
如果我们不是需要在

853
00:28:13,616 --> 00:28:14,766
片段射击的最后

854
00:28:14,766 --> 00:28:16,326
将事情排序 而是

855
00:28:16,416 --> 00:28:18,066
在正中间 因为如果这样

856
00:28:18,066 --> 00:28:20,156
三角一号想要在存储器里

857
00:28:20,156 --> 00:28:21,316
写东西 三角二号

858
00:28:21,316 --> 00:28:22,596
可以进行

859
00:28:22,596 --> 00:28:23,026
读取

860
00:28:23,306 --> 00:28:25,016
如果我们希望三角二号

861
00:28:25,016 --> 00:28:26,236
能够在其上增加 以及

862
00:28:26,236 --> 00:28:28,026
自定义三角一号的数据

863
00:28:28,026 --> 00:28:28,906
我们需要回到那个排序

864
00:28:29,646 --> 00:28:32,366
这基本上就是

865
00:28:32,366 --> 00:28:33,576
光栅顺序组可以提供的功能

866
00:28:34,706 --> 00:28:37,116
现在我要讲到

867
00:28:37,206 --> 00:28:38,156
着色器代码的例子

868
00:28:39,806 --> 00:28:41,116
如果我想要执行

869
00:28:41,116 --> 00:28:42,466
自定义的混合 一个无效

870
00:28:42,636 --> 00:28:44,456
初期的尝试

871
00:28:44,456 --> 00:28:45,726
将会替换我经典的

872
00:28:45,726 --> 00:28:46,696
图像帧缓存器

873
00:28:46,696 --> 00:28:47,996
为一个读写纹理

874
00:28:47,996 --> 00:28:49,696
它会直接对这个纹理

875
00:28:49,696 --> 00:28:50,636
执行渲染

876
00:28:50,636 --> 00:28:50,956
和混合

877
00:28:51,776 --> 00:28:53,976
当然如果我混合的线程

878
00:28:53,976 --> 00:28:55,206
还没有执行

879
00:28:55,206 --> 00:28:56,416
或者正在执行

880
00:28:56,416 --> 00:28:59,066
这整个

881
00:28:59,166 --> 00:29:00,596
修改编写顺序

882
00:29:00,596 --> 00:29:01,546
会创建一个竞争条件

883
00:29:02,076 --> 00:29:03,876
所以我们如何使用光栅顺序组

884
00:29:03,876 --> 00:29:05,146
去修复它呢

885
00:29:05,316 --> 00:29:07,416
这非常非常简单

886
00:29:08,626 --> 00:29:10,146
我要做的就是

887
00:29:10,276 --> 00:29:12,996
在有冲突访问的存储器上

888
00:29:12,996 --> 00:29:14,086
添加一个新的属性

889
00:29:14,866 --> 00:29:16,906
这时 编译程序和硬件

890
00:29:16,906 --> 00:29:17,636
会开始

891
00:29:17,636 --> 00:29:18,876
合作

892
00:29:18,876 --> 00:29:20,616
使整个一系列的着色器

893
00:29:20,866 --> 00:29:21,806
接入存储器

894
00:29:21,806 --> 00:29:22,996
从一开始

895
00:29:22,996 --> 00:29:24,176
到最后全部接入

896
00:29:24,176 --> 00:29:25,386
然后在屏幕后面将它

897
00:29:25,386 --> 00:29:26,366
转变成一个

898
00:29:26,366 --> 00:29:26,836
临界区

899
00:29:28,806 --> 00:29:29,826
你也可以将

900
00:29:29,826 --> 00:29:31,296
这个属性应用于普通的

901
00:29:31,296 --> 00:29:33,846
设备存储器指针上

902
00:29:34,536 --> 00:29:34,886
而不仅仅在纹理上

903
00:29:34,886 --> 00:29:37,606
所以通过这样做 我们得到了

904
00:29:37,606 --> 00:29:38,536
我们想要的线性调度

905
00:29:39,216 --> 00:29:40,406
线程一将继续运行

906
00:29:40,406 --> 00:29:42,116
和写入内存 而线程二号

907
00:29:42,116 --> 00:29:43,526
将停止 直到

908
00:29:43,526 --> 00:29:46,046
线程一的写入完成

909
00:29:46,046 --> 00:29:47,916
并给我们一个对

910
00:29:47,916 --> 00:29:51,576
存储器的几乎无冲突接入

911
00:29:51,926 --> 00:29:53,096
有一个

912
00:29:53,096 --> 00:29:54,106
非常重要的话题

913
00:29:54,106 --> 00:29:56,016
线程是

914
00:29:56,016 --> 00:29:57,266
相互同步的

915
00:29:57,706 --> 00:29:59,656
当然 GPU 硬件

916
00:29:59,656 --> 00:30:00,486
将要运行不止两个

917
00:30:00,486 --> 00:30:02,296
而是同时运行

918
00:30:02,296 --> 00:30:05,146
成千上万个线程

919
00:30:05,246 --> 00:30:06,396
事实上它可能

920
00:30:06,436 --> 00:30:07,746
从这些三角中

921
00:30:07,746 --> 00:30:09,136
同时运行

922
00:30:09,616 --> 00:30:12,056
所以 所有这些成千上万的

923
00:30:12,056 --> 00:30:12,816
线程

924
00:30:12,816 --> 00:30:13,966
哪个是彼此

925
00:30:13,966 --> 00:30:14,176
同步的

926
00:30:15,836 --> 00:30:17,786
我在这里高亮了像素

927
00:30:17,786 --> 00:30:18,986
因为这是这个问题的

928
00:30:18,986 --> 00:30:19,586
答案

929
00:30:20,356 --> 00:30:21,876
你 这个功能

930
00:30:21,876 --> 00:30:22,846
只能和其他线程同步

931
00:30:22,846 --> 00:30:23,986
即那些当下与你的

932
00:30:23,986 --> 00:30:25,526
片段射击线程重叠的

933
00:30:25,526 --> 00:30:27,516
那些线程

934
00:30:27,596 --> 00:30:29,106
对准同样的帧缓存的

935
00:30:29,106 --> 00:30:31,146
xy 位置的线程  对准同样的

936
00:30:31,146 --> 00:30:32,886
多样本的位置的线程

937
00:30:33,196 --> 00:30:34,306
对准同样的

938
00:30:34,306 --> 00:30:34,786
渲染目标指数的线程

939
00:30:36,726 --> 00:30:37,776
如果我希望

940
00:30:37,776 --> 00:30:39,096
它没有具体提供

941
00:30:39,136 --> 00:30:40,756
任何的保证

942
00:30:40,756 --> 00:30:41,836
让你能安全的

943
00:30:41,836 --> 00:30:43,376
由相邻像素写入的

944
00:30:43,376 --> 00:30:44,276
内存

945
00:30:45,366 --> 00:30:46,816
如果你的确需要这样的

946
00:30:46,816 --> 00:30:48,496
区域或者影响区域

947
00:30:48,496 --> 00:30:49,726
这样的算法

948
00:30:50,096 --> 00:30:51,156
你就需要回去使用

949
00:30:51,156 --> 00:30:52,326
绘制调用之间的完整内存屏障

950
00:30:52,356 --> 00:30:53,736
或者绘制调用或

951
00:30:53,736 --> 00:30:54,916
渲染通道之间的

952
00:30:54,916 --> 00:30:55,666
完整 API 屏障

953
00:30:56,376 --> 00:30:57,846
但是这会导致更加高的性能代价

954
00:30:57,846 --> 00:30:59,656
它也不能在

955
00:30:59,656 --> 00:31:00,876
你的三角与单个的

956
00:31:00,876 --> 00:31:02,236
绘制调用重叠时

957
00:31:02,236 --> 00:31:02,696
使用

958
00:31:03,336 --> 00:31:05,256
但是对于这些常用算法

959
00:31:05,256 --> 00:31:06,806
你只需要重叠

960
00:31:06,806 --> 00:31:08,206
只需要同步

961
00:31:08,836 --> 00:31:09,976
光栅顺序组能在

962
00:31:09,976 --> 00:31:11,286
大幅减少性能代价的情况下

963
00:31:11,286 --> 00:31:13,866
完成任务

964
00:31:13,866 --> 00:31:15,486
这是很简单的

965
00:31:15,676 --> 00:31:16,716
对于这个问题  这真的是

966
00:31:16,716 --> 00:31:17,356
我要说的全部了

967
00:31:17,396 --> 00:31:19,546
光栅顺序组让你

968
00:31:19,546 --> 00:31:21,246
高效的等待重叠

969
00:31:21,516 --> 00:31:24,046
并且只让重叠的线程来

970
00:31:24,046 --> 00:31:25,136
结束它们对存储器的访问

971
00:31:25,806 --> 00:31:27,586
这能让

972
00:31:27,586 --> 00:31:28,736
之前的一部分

973
00:31:28,736 --> 00:31:30,026
太没有效率的 GPU 算法

974
00:31:30,026 --> 00:31:31,296
在 GPU 硬件上被很好的使用

975
00:31:33,516 --> 00:31:35,766
着色器中间线程的

976
00:31:35,766 --> 00:31:37,076
总结是最新的

977
00:31:37,076 --> 00:31:38,556
GPU 硬件的功能

978
00:31:38,556 --> 00:31:39,286
你真的需要运行它来

979
00:31:39,286 --> 00:31:40,426
试试看

980
00:31:41,106 --> 00:31:42,446
特别的是

981
00:31:42,446 --> 00:31:43,896
它被最新的 这一周刚发布的

982
00:31:43,896 --> 00:31:45,256
AMD Vega GPU 支持 并且

983
00:31:45,256 --> 00:31:46,356
也被过去几年的 Intel GPU

984
00:31:46,356 --> 00:31:47,216
所支持

985
00:31:49,136 --> 00:31:50,196
这就要提到

986
00:31:50,196 --> 00:31:51,286
第二个功能 那就是

987
00:31:51,286 --> 00:31:52,616
新的 iPad Pro 的 ProMotion

988
00:31:52,616 --> 00:31:52,966
显示器

989
00:32:01,056 --> 00:32:02,486
ProMotion 对

990
00:32:02,616 --> 00:32:04,006
图形和游戏开发者来说

991
00:32:04,006 --> 00:32:05,186
是一个很优秀的功能

992
00:32:05,186 --> 00:32:06,226
我非常想向大家展示

993
00:32:06,226 --> 00:32:07,626
我能用它干什么

994
00:32:07,946 --> 00:32:10,466
这是第一个序列

995
00:32:10,466 --> 00:32:11,606
的时间线图

996
00:32:11,606 --> 00:32:13,946
我将向你们展示

997
00:32:13,946 --> 00:32:15,606
它展示了当 GPU 开始和结束

998
00:32:15,606 --> 00:32:16,916
制作帧 以及当

999
00:32:16,916 --> 00:32:18,056
同样的帧

1000
00:32:18,056 --> 00:32:19,256
最终到达眼镜 使用户能够看到

1001
00:32:19,256 --> 00:32:19,526
的时间

1002
00:32:20,646 --> 00:32:22,116
ProMotion 做的第一件也是最明显的事

1003
00:32:22,116 --> 00:32:23,356
是使我们现在能

1004
00:32:23,356 --> 00:32:25,146
以每秒 120 帧

1005
00:32:25,146 --> 00:32:25,556
进行渲染

1006
00:32:27,316 --> 00:32:28,896
这对任何要求

1007
00:32:28,896 --> 00:32:29,896
高速动画制作的东西

1008
00:32:29,896 --> 00:32:31,616
对任何要求

1009
00:32:31,616 --> 00:32:32,796
严苛延迟的东西

1010
00:32:32,796 --> 00:32:34,096
例如对用户触摸的追踪或者铅笔输入

1011
00:32:34,096 --> 00:32:34,756
都非常好用

1012
00:32:35,576 --> 00:32:37,876
它确实有很多抓取

1013
00:32:37,876 --> 00:32:40,336
对于每个帧 你当然只有

1014
00:32:40,336 --> 00:32:42,146
一半的 CPU 和 GPU 时间能够用

1015
00:32:42,146 --> 00:32:43,596
所以你需要

1016
00:32:43,596 --> 00:32:44,356
花很多精力去

1017
00:32:44,356 --> 00:32:46,196
优化它

1018
00:32:46,196 --> 00:32:47,276
这也会增加整个系统的

1019
00:32:47,276 --> 00:32:47,836
能量消耗

1020
00:32:48,816 --> 00:32:49,546
但是如果你得到了正确的内容

1021
00:32:49,546 --> 00:32:51,506
在它起作用的地方

1022
00:32:51,506 --> 00:32:52,686
它会回报在

1023
00:32:52,686 --> 00:32:53,576
用户体验上

1024
00:32:55,006 --> 00:32:56,566
但是 ProMotion 做到的

1025
00:32:56,566 --> 00:32:58,096
每秒渲染 120 帧

1026
00:32:58,096 --> 00:32:58,436
还要多

1027
00:32:59,176 --> 00:33:01,626
它同样为

1028
00:33:01,626 --> 00:33:03,496
何时调换下一个图像到眼镜上

1029
00:33:03,496 --> 00:33:04,546
提供更多的

1030
00:33:04,546 --> 00:33:05,016
灵活性

1031
00:33:05,726 --> 00:33:07,776
我们没有限制 每秒渲染 120 帧

1032
00:33:07,776 --> 00:33:09,906
30 帧或者 60 帧

1033
00:33:10,486 --> 00:33:12,816
当你的应用执行

1034
00:33:12,816 --> 00:33:14,056
上下移动时

1035
00:33:14,056 --> 00:33:15,446
相比于

1036
00:33:15,716 --> 00:33:16,756
固定帧率的显示器

1037
00:33:16,756 --> 00:33:17,166
ProMotion 表现的更好

1038
00:33:18,376 --> 00:33:21,186
举个例子 我这里有

1039
00:33:21,226 --> 00:33:22,586
一个时间线图 它有点

1040
00:33:22,586 --> 00:33:23,926
你懂的

1041
00:33:23,926 --> 00:33:24,986
只是为了

1042
00:33:24,986 --> 00:33:26,356
达到每秒 60 帧消耗了太多 GPU

1043
00:33:26,516 --> 00:33:27,226
你知道他们

1044
00:33:27,226 --> 00:33:28,906
每 21 毫秒制作一个帧

1045
00:33:28,906 --> 00:33:30,366
或者说 1 秒制作

1046
00:33:30,366 --> 00:33:30,836
48 帧

1047
00:33:31,576 --> 00:33:33,466
GPU 很乐意这样做

1048
00:33:33,466 --> 00:33:35,526
但是在显示器这一边

1049
00:33:35,526 --> 00:33:37,076
我们只能每 16 毫秒刷新一次

1050
00:33:37,076 --> 00:33:38,176
最后我们只能得到

1051
00:33:38,176 --> 00:33:38,976
一个跳跃模式

1052
00:33:39,046 --> 00:33:40,126
这种不顺畅就使得

1053
00:33:40,126 --> 00:33:41,866
用户在眼镜上感觉到

1054
00:33:41,866 --> 00:33:42,916
有些帧

1055
00:33:42,916 --> 00:33:43,356
比其他的要慢得多

1056
00:33:44,056 --> 00:33:47,006
这一点也不好

1057
00:33:47,306 --> 00:33:48,866
基本上全世界

1058
00:33:48,866 --> 00:33:49,846
在这种情况下通用的做法

1059
00:33:49,846 --> 00:33:50,586
就是

1060
00:33:50,586 --> 00:33:51,976
人为的将帧率

1061
00:33:51,976 --> 00:33:53,776
降低到

1062
00:33:53,776 --> 00:33:56,336
每秒 30 帧

1063
00:33:56,336 --> 00:33:57,686
他们基本上是

1064
00:33:57,686 --> 00:33:59,036
将峰顶的帧率交换出去

1065
00:33:59,036 --> 00:33:59,926
以换得一定程度的

1066
00:33:59,926 --> 00:34:00,556
连续性

1067
00:34:02,176 --> 00:34:04,146
ProMotion 在这里做的好很多

1068
00:34:04,616 --> 00:34:05,636
如果我用

1069
00:34:05,636 --> 00:34:06,596
相同的应用

1070
00:34:06,596 --> 00:34:09,126
将它移动到一个 ProMotion 显示器上

1071
00:34:09,126 --> 00:34:09,755
它会对我们的时间线造成这样的影响

1072
00:34:10,826 --> 00:34:12,036
现在 我们

1073
00:34:12,036 --> 00:34:13,596
每 4 毫秒有了一个刷新点

1074
00:34:13,596 --> 00:34:14,356
而不是每 16 毫秒

1075
00:34:15,266 --> 00:34:16,646
我们赚得了时间

1076
00:34:16,866 --> 00:34:18,286
尽管 GPU 做着

1077
00:34:18,286 --> 00:34:19,286
和以前一样的工作

1078
00:34:19,906 --> 00:34:21,976
现在这个显示器

1079
00:34:21,976 --> 00:34:23,626
持续的

1080
00:34:23,626 --> 00:34:24,136
每秒显示 48 帧

1081
00:34:24,985 --> 00:34:26,466
用户现在既能

1082
00:34:26,466 --> 00:34:28,176
有最好的帧率

1083
00:34:28,176 --> 00:34:30,156
又能体验最佳的

1084
00:34:30,156 --> 00:34:30,545
持续性

1085
00:34:31,186 --> 00:34:32,116
我们以前做的交换

1086
00:34:32,116 --> 00:34:33,056
已经完全不需要了

1087
00:34:34,246 --> 00:34:37,096
此外 第二个例子是

1088
00:34:37,096 --> 00:34:38,996
这次 应用想要

1089
00:34:38,996 --> 00:34:41,295
制作每秒 60 帧

1090
00:34:41,295 --> 00:34:42,936
但是一帧运行的时间

1091
00:34:42,936 --> 00:34:44,666
稍微久了一点

1092
00:34:44,666 --> 00:34:48,295
我们做过了最后期限

1093
00:34:48,295 --> 00:34:49,886
在一个固定帧率的显示器上

1094
00:34:49,886 --> 00:34:50,826
在显示器这一边

1095
00:34:50,826 --> 00:34:51,856
我们可能会运用

1096
00:34:51,856 --> 00:34:53,126
与之前看到的相同的模式

1097
00:34:54,585 --> 00:34:56,416
ProMotion 同样可以修复这个问题

1098
00:34:57,576 --> 00:34:58,626
一号帧一旦在眼镜上

1099
00:34:58,626 --> 00:34:59,866
它将不会

1100
00:34:59,866 --> 00:35:01,336
被扩展到 16 毫秒

1101
00:35:01,336 --> 00:35:02,666
而只是现在的 4 毫秒

1102
00:35:03,126 --> 00:35:04,526
用户感觉到的断断续续

1103
00:35:04,526 --> 00:35:06,446
会被极大程度的减少

1104
00:35:06,446 --> 00:35:09,066
二号帧和三号帧

1105
00:35:09,066 --> 00:35:11,336
他们的延迟被

1106
00:35:11,336 --> 00:35:12,286
拉回到

1107
00:35:12,286 --> 00:35:12,796
之前到位置

1108
00:35:13,426 --> 00:35:14,736
系统立刻

1109
00:35:14,736 --> 00:35:15,886
回到时间线上

1110
00:35:16,336 --> 00:35:19,136
延迟被提高

1111
00:35:19,136 --> 00:35:20,446
你的应用可以继续执行了

1112
00:35:20,516 --> 00:35:21,306
我们正好回到了

1113
00:35:21,306 --> 00:35:22,756
我们希望到达的位置

1114
00:35:23,416 --> 00:35:26,126
所以总结起来

1115
00:35:26,126 --> 00:35:27,816
它将动画变得

1116
00:35:27,816 --> 00:35:29,136
更坚定 更稳固

1117
00:35:29,136 --> 00:35:30,786
无论发生什么

1118
00:35:31,906 --> 00:35:33,816
那么你到底该

1119
00:35:33,816 --> 00:35:35,116
如何运用这些优势呢

1120
00:35:35,756 --> 00:35:38,576
对于一般的 UIKit 动画而言

1121
00:35:38,576 --> 00:35:39,546
例如 滚动观看目录或者视图

1122
00:35:39,546 --> 00:35:41,506
iOS 将完全以新的方式

1123
00:35:41,506 --> 00:35:42,516
来完成

1124
00:35:43,016 --> 00:35:44,506
它将在适合的时候

1125
00:35:44,506 --> 00:35:45,456
每秒渲染 120 帧

1126
00:35:45,526 --> 00:35:47,606
它也将在适合的时候

1127
00:35:47,696 --> 00:35:48,466
运用灵活的显示时间

1128
00:35:50,206 --> 00:35:51,256
Metal 应用

1129
00:35:51,256 --> 00:35:52,286
对时间更加敏感

1130
00:35:52,286 --> 00:35:53,466
所以对我们已经完成的功能

1131
00:35:53,466 --> 00:35:54,446
这是一个功能的选择

1132
00:35:55,766 --> 00:35:57,886
这个选择非常简单

1133
00:35:57,886 --> 00:35:59,186
你只需要在 bundle 目录下

1134
00:35:59,186 --> 00:36:00,106
的 info.plist 里添加一个

1135
00:36:00,106 --> 00:36:00,866
新的入口

1136
00:36:01,596 --> 00:36:03,206
一旦你做了这个计时的行为

1137
00:36:03,206 --> 00:36:04,616
我们的三个 Metal 显示的

1138
00:36:04,616 --> 00:36:06,266
API 会出现

1139
00:36:06,266 --> 00:36:06,536
小的变化

1140
00:36:06,536 --> 00:36:07,536
我将为你们

1141
00:36:07,536 --> 00:36:08,846
介绍这三个 API 以及

1142
00:36:08,846 --> 00:36:09,456
他们如何改变的

1143
00:36:10,226 --> 00:36:12,066
我们的第一个

1144
00:36:12,066 --> 00:36:14,046
Metal 展示 API

1145
00:36:14,466 --> 00:36:14,966
正在进行

1146
00:36:15,616 --> 00:36:18,216
它即将

1147
00:36:18,216 --> 00:36:20,156
在 GPU 结束之后的下一个

1148
00:36:20,156 --> 00:36:21,206
可以使用的刷新点上

1149
00:36:21,206 --> 00:36:22,676
把我的图像

1150
00:36:22,726 --> 00:36:24,306
显示在眼镜上

1151
00:36:25,376 --> 00:36:26,596
在固定帧率的硬件上

1152
00:36:26,596 --> 00:36:28,566
这是 16 毫秒

1153
00:36:28,566 --> 00:36:29,956
在 iPad Pro 上

1154
00:36:29,956 --> 00:36:30,626
现在是 4 毫秒

1155
00:36:31,296 --> 00:36:32,866
这是使用最简单的 API

1156
00:36:32,866 --> 00:36:33,726
因为它不需要运行

1157
00:36:33,726 --> 00:36:35,046
因此它也是在这个房间里的

1158
00:36:35,046 --> 00:36:35,966
大部分人都在使用的

1159
00:36:35,966 --> 00:36:36,296
API

1160
00:36:37,416 --> 00:36:38,476
这也是让你以

1161
00:36:38,476 --> 00:36:40,056
最低延迟

1162
00:36:40,056 --> 00:36:40,466
接入显示屏的 API

1163
00:36:41,296 --> 00:36:43,236
它一样能工作在我们的

1164
00:36:43,236 --> 00:36:44,596
固定帧率以及 ProMotion

1165
00:36:44,596 --> 00:36:46,636
硬件上 一旦你选择它

1166
00:36:46,636 --> 00:36:47,486
它将以非常好的粒度

1167
00:36:47,486 --> 00:36:47,976
进行工作

1168
00:36:51,646 --> 00:36:53,116
我们的第二个

1169
00:36:53,116 --> 00:36:54,996
Metal 展示 API

1170
00:36:54,996 --> 00:36:56,036
可以显示最短时间

1171
00:36:56,806 --> 00:36:59,236
图像无论何时

1172
00:36:59,236 --> 00:37:00,766
登陆眼镜

1173
00:37:00,766 --> 00:37:01,836
它将能使它固定在眼镜里

1174
00:37:01,836 --> 00:37:02,486
一段时间

1175
00:37:03,046 --> 00:37:03,956
如果我的图片在眼镜里

1176
00:37:03,956 --> 00:37:04,966
被放了在这里

1177
00:37:04,966 --> 00:37:06,076
它将持续 33 微秒

1178
00:37:06,076 --> 00:37:08,176
如果我的开始时间变化了

1179
00:37:08,176 --> 00:37:08,896
结束时间也会相应变化

1180
00:37:09,576 --> 00:37:11,116
如果你想要

1181
00:37:11,116 --> 00:37:12,386
帧与帧之间

1182
00:37:12,386 --> 00:37:13,796
有完美的连续性的帧率 这就是你要的 API

1183
00:37:14,416 --> 00:37:16,146
它在每秒 30 帧的时候

1184
00:37:16,146 --> 00:37:17,616
在每秒 60 帧的显示屏上

1185
00:37:17,856 --> 00:37:19,406
尤其有效

1186
00:37:19,406 --> 00:37:20,316
虽然它有时候在

1187
00:37:20,316 --> 00:37:21,446
ProMotion 上也很有效

1188
00:37:22,416 --> 00:37:24,706
而我们第三个展示的

1189
00:37:24,706 --> 00:37:25,916
变化是

1190
00:37:25,916 --> 00:37:26,386
目前最有趣的

1191
00:37:26,596 --> 00:37:28,406
它会在特定的时间显示

1192
00:37:28,736 --> 00:37:30,486
它做的事情和它听起来

1193
00:37:30,486 --> 00:37:30,996
一样

1194
00:37:31,736 --> 00:37:33,106
如果 GPU 在设定时间之前

1195
00:37:33,106 --> 00:37:34,436
就早早完成了 显示器会

1196
00:37:34,436 --> 00:37:34,836
等候

1197
00:37:35,196 --> 00:37:36,556
如果 GPU 超过了你的

1198
00:37:36,556 --> 00:37:37,966
时间限制 显示器会

1199
00:37:37,966 --> 00:37:39,606
在下一个可用的点将它

1200
00:37:39,606 --> 00:37:40,536
取出

1201
00:37:41,666 --> 00:37:44,256
如果你想创建一个完全

1202
00:37:44,256 --> 00:37:45,376
定制的动画和时间循环

1203
00:37:45,376 --> 00:37:46,596
这就是关键的 API

1204
00:37:47,286 --> 00:37:49,036
这个 API 的展示和时间

1205
00:37:49,116 --> 00:37:50,656
和 ProMotion 显示器相结合

1206
00:37:51,096 --> 00:37:52,286
基本上可以让你抛弃

1207
00:37:52,286 --> 00:37:53,446
固定帧率的概念

1208
00:37:53,446 --> 00:37:54,696
在用户将要

1209
00:37:54,696 --> 00:37:56,206
看到内容的时候

1210
00:37:56,206 --> 00:37:57,196
再进行渲染

1211
00:37:58,006 --> 00:37:59,296
如果你想要你的 Metal 视图

1212
00:37:59,296 --> 00:38:00,516
和其他正在系统里发生的东西

1213
00:38:00,516 --> 00:38:01,416
完全同步

1214
00:38:01,416 --> 00:38:03,386
例如音频 或者你想要

1215
00:38:03,386 --> 00:38:04,236
为所有的外观提供

1216
00:38:04,236 --> 00:38:05,476
零延时

1217
00:38:05,476 --> 00:38:06,606
然后在你的用户

1218
00:38:06,606 --> 00:38:07,766
将要看到内容的时候

1219
00:38:07,766 --> 00:38:09,176
再推进对象

1220
00:38:09,176 --> 00:38:11,036
这是能让你实现这些

1221
00:38:11,036 --> 00:38:11,846
的工具

1222
00:38:13,266 --> 00:38:14,116
当然在这里的技巧

1223
00:38:14,116 --> 00:38:15,326
是在下一个显示时间

1224
00:38:15,326 --> 00:38:15,896
执行对象

1225
00:38:15,896 --> 00:38:16,596
这就是你的功能

1226
00:38:17,616 --> 00:38:18,776
为了实现它 你需要一些

1227
00:38:18,776 --> 00:38:19,986
来自系统的反馈

1228
00:38:19,986 --> 00:38:21,146
来帮助你抉择

1229
00:38:21,146 --> 00:38:22,166
你真正执行的是什么

1230
00:38:22,196 --> 00:38:23,356
现在我们也把它加上了

1231
00:38:24,646 --> 00:38:26,966
所以 Metal 可绘制对象

1232
00:38:26,966 --> 00:38:28,156
是一个暂时的对象

1233
00:38:28,156 --> 00:38:29,496
它可以在显示系统里

1234
00:38:29,496 --> 00:38:30,746
追踪一个被你渲染的图像

1235
00:38:30,746 --> 00:38:31,516
的一生

1236
00:38:31,736 --> 00:38:34,896
现在它可以在特定的

1237
00:38:34,896 --> 00:38:36,426
图像显示在眼镜上时被查询到

1238
00:38:36,426 --> 00:38:37,606
当这件事发生时

1239
00:38:37,606 --> 00:38:38,346
你也可以获得一个

1240
00:38:38,346 --> 00:38:38,866
回调函数

1241
00:38:39,906 --> 00:38:41,466
所以现在你可以知道你的图片

1242
00:38:41,466 --> 00:38:42,696
什么时候会显示在眼镜上

1243
00:38:43,076 --> 00:38:44,656
以及它们被移除的时间

1244
00:38:44,656 --> 00:38:45,696
你有关键的信号 能够使你知道

1245
00:38:45,696 --> 00:38:47,356
什么时候你在获得

1246
00:38:47,356 --> 00:38:48,436
你预期中的时间

1247
00:38:48,436 --> 00:38:49,876
什么时候你没有

1248
00:38:49,876 --> 00:38:51,156
然后给你一个信号

1249
00:38:51,156 --> 00:38:51,706
以调整未来的帧

1250
00:38:54,176 --> 00:38:56,146
这就是 ProMotion 的故事

1251
00:38:56,146 --> 00:38:57,276
你将在未来

1252
00:38:57,276 --> 00:38:58,296
在新的 iPad Pro 上

1253
00:38:58,296 --> 00:38:59,326
使用它

1254
00:38:59,936 --> 00:39:01,566
在应用中几乎没有代码改变

1255
00:39:01,566 --> 00:39:02,706
的情况下

1256
00:39:02,706 --> 00:39:05,256
要想获得更多的连续性和

1257
00:39:05,256 --> 00:39:06,496
更高的帧率是

1258
00:39:06,496 --> 00:39:07,246
非常容易的

1259
00:39:07,646 --> 00:39:10,306
从这里开始 它将给你一个选项菜单

1260
00:39:10,306 --> 00:39:11,606
让你选择哪一个

1261
00:39:11,606 --> 00:39:12,766
显示时间模型会

1262
00:39:12,766 --> 00:39:13,906
对你的 app

1263
00:39:13,906 --> 00:39:14,126
产生更多好处

1264
00:39:14,976 --> 00:39:16,356
一个非常非常快的

1265
00:39:16,406 --> 00:39:18,216
Twitch 电子游戏或者

1266
00:39:18,216 --> 00:39:19,986
需要对触摸和铅笔输入进行追踪的应用

1267
00:39:19,986 --> 00:39:21,286
可能需要达到

1268
00:39:21,286 --> 00:39:22,036
每秒 120 帧

1269
00:39:22,646 --> 00:39:24,386
一个非常高端的渲染标题

1270
00:39:24,386 --> 00:39:25,766
可能需要保持

1271
00:39:25,836 --> 00:39:27,156
每秒 30 帧到 60 帧

1272
00:39:27,156 --> 00:39:28,176
或者这之间的一个数

1273
00:39:28,176 --> 00:39:30,456
以享受稳定连续的优势

1274
00:39:31,136 --> 00:39:32,266
一些想要

1275
00:39:32,266 --> 00:39:33,166
完全掌控它们的

1276
00:39:33,166 --> 00:39:34,506
时间循环的应用在这里

1277
00:39:34,506 --> 00:39:35,546
有全新的功能

1278
00:39:36,776 --> 00:39:37,956
无论你的 app 是什么

1279
00:39:37,956 --> 00:39:39,966
ProMotion 给予你这个

1280
00:39:39,966 --> 00:39:41,186
强大的新工具

1281
00:39:41,186 --> 00:39:42,446
去支持它特定的

1282
00:39:42,446 --> 00:39:42,726
动画需求

1283
00:39:42,726 --> 00:39:45,306
这就是 ProMotion

1284
00:39:46,016 --> 00:39:48,846
接下来 我有一个完全不同的

1285
00:39:48,936 --> 00:39:50,346
显示话题要谈一谈

1286
00:39:50,346 --> 00:39:51,256
那就是我们称为直接显示的

1287
00:39:51,256 --> 00:39:52,326
功能

1288
00:39:54,236 --> 00:39:56,206
所以在你的 GPU

1289
00:39:56,206 --> 00:39:58,036
完成渲染你的

1290
00:39:58,036 --> 00:39:59,306
内容和显示之后

1291
00:39:59,306 --> 00:40:00,426
发生的事情会变的

1292
00:40:00,426 --> 00:40:01,066
复杂一些

1293
00:40:01,116 --> 00:40:02,886
然后你的图像有两条

1294
00:40:02,886 --> 00:40:04,836
可以通往显示屏的路径

1295
00:40:04,836 --> 00:40:07,016
由 GPU 组合

1296
00:40:08,116 --> 00:40:08,306
然后直接放到显示屏上显示

1297
00:40:08,426 --> 00:40:10,256
它们中的第一个是

1298
00:40:10,256 --> 00:40:11,956
你的经典用户界面场景

1299
00:40:12,486 --> 00:40:13,446
我会在这里获得一系列的

1300
00:40:13,446 --> 00:40:15,086
视图 层级 和窗口

1301
00:40:15,086 --> 00:40:17,426
然后这个时候

1302
00:40:17,426 --> 00:40:18,376
系统会将

1303
00:40:18,376 --> 00:40:19,136
它们统统取出

1304
00:40:19,136 --> 00:40:19,496
然后将它们组合起来

1305
00:40:19,636 --> 00:40:20,776
它将缩放任何内容的比例

1306
00:40:20,776 --> 00:40:21,396
以适应显示屏

1307
00:40:21,396 --> 00:40:21,906
它将展示

1308
00:40:21,906 --> 00:40:22,796
色彩和空间的变换

1309
00:40:22,796 --> 00:40:23,746
它将进行

1310
00:40:23,746 --> 00:40:24,776
任何核心的图像过滤或者

1311
00:40:24,776 --> 00:40:26,056
混合 然后它将

1312
00:40:26,056 --> 00:40:27,516
产生一个用户看到的

1313
00:40:27,516 --> 00:40:28,636
最终的组合图像

1314
00:40:30,776 --> 00:40:32,436
这对于功能完善的

1315
00:40:32,436 --> 00:40:33,676
用户界面

1316
00:40:33,676 --> 00:40:34,586
是非常关键的抽象

1317
00:40:35,106 --> 00:40:38,136
但是它也全部是在 GPU 上完成

1318
00:40:38,136 --> 00:40:39,186
而且它会消耗一些时间和

1319
00:40:39,186 --> 00:40:39,706
内存

1320
00:40:40,436 --> 00:40:41,746
如果我们创建一个

1321
00:40:41,746 --> 00:40:42,646
全屏幕的应用

1322
00:40:42,646 --> 00:40:44,046
这对它来说

1323
00:40:44,046 --> 00:40:45,136
就有点过度了

1324
00:40:45,136 --> 00:40:46,316
这就是直接显示模式

1325
00:40:46,316 --> 00:40:48,106
介入的时候了

1326
00:40:48,256 --> 00:40:49,236
如果这些操作都没有被要求

1327
00:40:49,236 --> 00:40:51,496
我们可以

1328
00:40:51,496 --> 00:40:52,936
直接让显示器硬件指向你

1329
00:40:52,976 --> 00:40:54,216
刚刚渲染过的内存

1330
00:40:54,586 --> 00:40:55,856
而不需要任何

1331
00:40:55,856 --> 00:40:55,986
中间人

1332
00:40:57,646 --> 00:40:59,026
我们怎么做到的呢

1333
00:40:59,406 --> 00:41:01,196
事实证明 其实没有一个

1334
00:41:01,196 --> 00:41:02,716
API 能够直接

1335
00:41:02,716 --> 00:41:03,146
指向显示器

1336
00:41:03,916 --> 00:41:05,566
这个模式实际上是

1337
00:41:05,566 --> 00:41:06,796
任何需要 GPU 组合器

1338
00:41:06,796 --> 00:41:08,166
介入的遗漏

1339
00:41:08,836 --> 00:41:10,386
当组合器看到你的

1340
00:41:10,386 --> 00:41:11,596
场景设置 然后发现

1341
00:41:11,596 --> 00:41:13,026
这里没有需要它做的

1342
00:41:13,026 --> 00:41:14,686
这时候

1343
00:41:14,686 --> 00:41:15,626
它将离开

1344
00:41:16,426 --> 00:41:18,176
所以 你应该怎样设置你的场景

1345
00:41:18,176 --> 00:41:20,726
以使合成器

1346
00:41:20,726 --> 00:41:22,756
直接离开

1347
00:41:23,216 --> 00:41:23,706
其实这是

1348
00:41:23,706 --> 00:41:24,916
非常直观的感受

1349
00:41:24,966 --> 00:41:26,166
我的内容是否需要任何

1350
00:41:26,166 --> 00:41:27,106
非重要过程

1351
00:41:27,106 --> 00:41:27,846
语音处理就是一个

1352
00:41:27,846 --> 00:41:29,336
非常直观的开始

1353
00:41:30,066 --> 00:41:31,146
但更具体来说

1354
00:41:31,146 --> 00:41:32,166
你希望你的层级是不透明的

1355
00:41:32,726 --> 00:41:33,756
我不希望它与任何东西

1356
00:41:33,756 --> 00:41:34,096
混合

1357
00:41:34,716 --> 00:41:36,616
我们不想运用任何

1358
00:41:36,616 --> 00:41:37,716
需要核心动画或者

1359
00:41:37,716 --> 00:41:38,666
窗口服务器

1360
00:41:38,916 --> 00:41:39,946
来修改我们的像素

1361
00:41:39,946 --> 00:41:40,836
我们不想在我们的视图里

1362
00:41:40,836 --> 00:41:42,406
或者遮蔽或者过滤器这一类的东西

1363
00:41:42,406 --> 00:41:44,326
放置圆角控件

1364
00:41:45,656 --> 00:41:46,896
我们想创建一个全屏幕

1365
00:41:47,226 --> 00:41:49,496
如果你的内容

1366
00:41:49,496 --> 00:41:51,256
不完全符合

1367
00:41:51,256 --> 00:41:52,436
屏幕的纵横比例

1368
00:41:52,436 --> 00:41:53,896
你可以用全屏的 不透明的 黑色的

1369
00:41:53,896 --> 00:41:55,016
背景层来给予

1370
00:41:55,016 --> 00:41:56,396
黑色菜单栏一类的效果

1371
00:41:56,396 --> 00:41:57,216
但是最终我们还是希望

1372
00:41:57,216 --> 00:41:58,516
能模糊所有的东西

1373
00:42:01,456 --> 00:42:02,656
我们希望选择一个

1374
00:42:02,656 --> 00:42:03,636
能匹配本来面板的

1375
00:42:03,636 --> 00:42:04,306
渲染分辨率

1376
00:42:05,176 --> 00:42:06,416
这是有一点技巧性的

1377
00:42:06,416 --> 00:42:07,616
因为我们所有的

1378
00:42:07,616 --> 00:42:09,056
在 macOS 和 iOS 上搭载的

1379
00:42:09,056 --> 00:42:10,556
硬件都是有

1380
00:42:10,556 --> 00:42:12,446
虚拟桌面模式或者分辨率模式

1381
00:42:12,446 --> 00:42:13,696
它们都比真实的物理面板

1382
00:42:13,696 --> 00:42:14,676
要大

1383
00:42:14,766 --> 00:42:16,216
我们想做的最后一件事

1384
00:42:16,216 --> 00:42:17,356
是花时间去渲染很多的

1385
00:42:17,356 --> 00:42:18,256
像素 其实只要

1386
00:42:18,286 --> 00:42:19,456
在 GPU 上花时间然后再把时间

1387
00:42:19,456 --> 00:42:19,976
缩减回来就行了

1388
00:42:24,466 --> 00:42:25,846
最后 你想选择

1389
00:42:25,846 --> 00:42:26,976
颜色 空间 像素帧

1390
00:42:26,976 --> 00:42:28,046
那些显示硬件

1391
00:42:28,046 --> 00:42:29,186
会很高兴的直接读取的内容

1392
00:42:30,116 --> 00:42:31,126
在这里

1393
00:42:31,126 --> 00:42:32,216
这里有无限组合数

1394
00:42:32,216 --> 00:42:33,986
所以在这里我想

1395
00:42:33,986 --> 00:42:34,656
给你们一个

1396
00:42:34,656 --> 00:42:35,986
关于一些特殊

1397
00:42:35,986 --> 00:42:36,916
和高效组合数

1398
00:42:36,916 --> 00:42:37,576
的白名单

1399
00:42:39,926 --> 00:42:41,596
在最上方是我们的

1400
00:42:41,596 --> 00:42:44,556
老朋友 SRGB8888

1401
00:42:44,556 --> 00:42:45,496
这基本上是绝大多数应用

1402
00:42:45,496 --> 00:42:46,986
通用的像素格式

1403
00:42:46,986 --> 00:42:48,806
也是所有硬件都

1404
00:42:48,806 --> 00:42:50,626
乐于读取的

1405
00:42:50,626 --> 00:42:51,776
对于大多数人来说

1406
00:42:51,776 --> 00:42:52,196
这就是他们需要的全部了

1407
00:42:53,666 --> 00:42:55,876
但是我们已经在

1408
00:42:55,876 --> 00:42:58,096
macOS 和 iOS 硬件上都

1409
00:42:58,096 --> 00:43:00,806
搭载了广色域的 P3 显示器

1410
00:43:01,106 --> 00:43:02,246
如果你的应用

1411
00:43:02,246 --> 00:43:03,766
希望开始运用这个功能

1412
00:43:03,766 --> 00:43:04,926
来显示更多的颜色

1413
00:43:04,926 --> 00:43:06,016
你需要

1414
00:43:06,016 --> 00:43:06,396
注意一下这里

1415
00:43:06,396 --> 00:43:09,676
在这里 iOS 和 macOS 两者的概念

1416
00:43:09,676 --> 00:43:11,086
是一样的

1417
00:43:11,086 --> 00:43:11,996
虽然在细节上

1418
00:43:11,996 --> 00:43:13,316
有所不同

1419
00:43:13,316 --> 00:43:14,686
在这两者中 我们都希望

1420
00:43:14,686 --> 00:43:15,846
渲染加入像素格式

1421
00:43:17,266 --> 00:43:20,106
但是请注意 如果你

1422
00:43:20,106 --> 00:43:21,566
在 P3 显示器上

1423
00:43:21,566 --> 00:43:23,286
渲染 P3 的内容 那没有问题

1424
00:43:23,286 --> 00:43:25,686
但如果你渲染了 P3 内容

1425
00:43:25,686 --> 00:43:28,166
然后在 SRGB 的系统里去显示

1426
00:43:28,166 --> 00:43:29,266
那么 GPU 合成器可能会

1427
00:43:29,266 --> 00:43:30,326
参与进来并将色域

1428
00:43:30,326 --> 00:43:31,426
压缩以适应

1429
00:43:31,426 --> 00:43:31,796
显示器

1430
00:43:32,706 --> 00:43:34,206
所以 P3

1431
00:43:34,206 --> 00:43:34,816
不是你在任何时间

1432
00:43:34,816 --> 00:43:35,996
都想要做的

1433
00:43:36,106 --> 00:43:37,166
你最好看一看

1434
00:43:37,226 --> 00:43:39,466
当下的显示器是什么

1435
00:43:39,466 --> 00:43:40,616
然后在现有条件下工作

1436
00:43:40,986 --> 00:43:43,356
最后  为了完整性

1437
00:43:43,356 --> 00:43:44,726
我也要列出 RGBA float 16

1438
00:43:44,726 --> 00:43:45,866
它基本上是

1439
00:43:45,866 --> 00:43:48,116
普遍适应的 宽色域

1440
00:43:48,116 --> 00:43:49,406
高动态范围的像素格式

1441
00:43:49,956 --> 00:43:52,086
虽然

1442
00:43:52,086 --> 00:43:53,266
这对 macOS 的

1443
00:43:53,266 --> 00:43:54,466
扩展数据范围功能也很必要

1444
00:43:55,196 --> 00:43:56,076
值得注意的是

1445
00:43:56,076 --> 00:43:57,476
它也确实需要在所有情况下

1446
00:43:57,476 --> 00:43:57,976
运行组成 GPU 组合

1447
00:44:01,646 --> 00:44:02,566
所以就像我提到的

1448
00:44:02,566 --> 00:44:03,776
如果你编写了一个

1449
00:44:03,776 --> 00:44:04,716
广色域识别的应用

1450
00:44:04,716 --> 00:44:05,586
你确实需要考虑条件

1451
00:44:06,376 --> 00:44:07,776
幸运的是 UIKit 和

1452
00:44:07,776 --> 00:44:08,596
AppKit 都提供了非常

1453
00:44:08,596 --> 00:44:08,976
简便的 API 检查方式

1454
00:44:13,256 --> 00:44:14,786
所以 最后一步是 你怎么知道

1455
00:44:14,786 --> 00:44:16,056
你是否在

1456
00:44:16,056 --> 00:44:17,646
定向显示路径上

1457
00:44:17,646 --> 00:44:18,676
这张截屏显示的是

1458
00:44:18,676 --> 00:44:19,966
Metal 系统的

1459
00:44:19,966 --> 00:44:20,566
追踪工具

1460
00:44:20,676 --> 00:44:23,376
Metal 系统追踪是

1461
00:44:23,426 --> 00:44:25,006
一个能给你实时的

1462
00:44:25,006 --> 00:44:26,656
CPU 和 GPU 显示器时间轴的

1463
00:44:26,656 --> 00:44:27,886
开发工具

1464
00:44:28,216 --> 00:44:30,106
这基本上是

1465
00:44:30,106 --> 00:44:30,996
我之前给大家展示过的

1466
00:44:30,996 --> 00:44:31,636
图像的

1467
00:44:31,636 --> 00:44:32,236
真实版本

1468
00:44:33,396 --> 00:44:35,216
所以在这里

1469
00:44:35,216 --> 00:44:36,596
我要将渲染过的三个帧

1470
00:44:36,596 --> 00:44:37,016
高亮显示出来

1471
00:44:37,546 --> 00:44:39,106
这个有颜色的时间间隔是我

1472
00:44:39,106 --> 00:44:40,126
自己的应用渲染

1473
00:44:41,296 --> 00:44:42,716
这个灰色的间隔是

1474
00:44:42,716 --> 00:44:44,446
GPU 里的其他过程

1475
00:44:44,496 --> 00:44:46,806
我能在窗口底部

1476
00:44:46,806 --> 00:44:47,666
获得更多细节

1477
00:44:47,666 --> 00:44:48,306
我也能从背板 D 上看到它

1478
00:44:48,306 --> 00:44:50,836
这是 iOS 合成

1479
00:44:50,836 --> 00:44:51,406
的过程

1480
00:44:51,596 --> 00:44:52,606
这是我的应用

1481
00:44:52,606 --> 00:44:53,676
到 GPU 合成路径上的

1482
00:44:53,676 --> 00:44:55,946
例子

1483
00:44:55,946 --> 00:44:56,896
回到之前 重新访问

1484
00:44:56,896 --> 00:44:59,166
一些我们的最佳实践例子

1485
00:44:59,166 --> 00:45:00,486
会将它们从图片上移除

1486
00:45:00,486 --> 00:45:02,116
现在我可以返还我的 Metal 系统追踪

1487
00:45:02,556 --> 00:45:04,026
我有一个时间轴

1488
00:45:04,026 --> 00:45:05,626
可以通过它看到我已经

1489
00:45:05,716 --> 00:45:06,616
完全的

1490
00:45:06,616 --> 00:45:06,976
拥有了 GPU

1491
00:45:10,046 --> 00:45:12,006
这就是

1492
00:45:12,146 --> 00:45:12,756
直接显示

1493
00:45:12,756 --> 00:45:14,086
我们的系统合成器可以

1494
00:45:14,086 --> 00:45:15,406
在屏幕后制造很多魔法

1495
00:45:15,406 --> 00:45:16,746
以使全功能的

1496
00:45:16,746 --> 00:45:18,626
用户界面成为可能

1497
00:45:18,626 --> 00:45:19,706
但是这会产生性能消耗

1498
00:45:19,706 --> 00:45:20,976
因为要使用 GPU 来

1499
00:45:20,976 --> 00:45:21,426
做到它

1500
00:45:22,396 --> 00:45:23,456
通过了解

1501
00:45:23,456 --> 00:45:24,036
你在要求

1502
00:45:24,036 --> 00:45:25,536
合成器做什么 或者

1503
00:45:25,536 --> 00:45:26,896
更重要的是 别问

1504
00:45:26,896 --> 00:45:28,186
你没让合成器做的事

1505
00:45:28,186 --> 00:45:30,046
它就能不使用 GPU

1506
00:45:30,046 --> 00:45:31,816
从而离开

1507
00:45:31,816 --> 00:45:32,766
并返还给你一些时间

1508
00:45:33,496 --> 00:45:35,536
iOS 和 Tos 一直

1509
00:45:35,536 --> 00:45:37,046
支持直接显示

1510
00:45:37,046 --> 00:45:39,056
这对 macOS High Sierra 的

1511
00:45:39,056 --> 00:45:40,356
Metal 应用来说是

1512
00:45:40,356 --> 00:45:40,976
全新的

1513
00:45:45,366 --> 00:45:46,536
所以 讲到它 我想提到今天的

1514
00:45:46,536 --> 00:45:48,136
最后一个话题和

1515
00:45:48,136 --> 00:45:50,576
一些其他的东西

1516
00:45:50,616 --> 00:45:51,716
我们为 Metal 2

1517
00:45:51,716 --> 00:45:52,826
在核心结构和设计语言上

1518
00:45:52,826 --> 00:45:54,056
做了很多添加

1519
00:45:54,056 --> 00:45:55,306
所以现在我不打算

1520
00:45:55,306 --> 00:45:56,226
深入的讲这些东西

1521
00:45:56,226 --> 00:45:56,896
但是我想先给你们一个

1522
00:45:56,896 --> 00:45:57,236
调查

1523
00:45:57,716 --> 00:46:01,036
我们很快的添加了

1524
00:46:01,036 --> 00:46:02,026
新的 API 使它能够

1525
00:46:02,026 --> 00:46:03,916
质询 GPU

1526
00:46:03,916 --> 00:46:05,316
为每个缓存器

1527
00:46:05,316 --> 00:46:06,446
每个纹理 每个堆分配了多少内存

1528
00:46:06,736 --> 00:46:08,996
这将屏幕后

1529
00:46:08,996 --> 00:46:09,576
发生的事情

1530
00:46:09,576 --> 00:46:10,666
考虑在了其中

1531
00:46:10,666 --> 00:46:12,496
例如对齐和多种填充

1532
00:46:13,156 --> 00:46:13,996
这能为你究竟

1533
00:46:13,996 --> 00:46:15,356
使用了多少 GPU 内存

1534
00:46:15,356 --> 00:46:16,586
提供一个更准确的视角

1535
00:46:16,586 --> 00:46:19,466
我们在 Metal 设备上也有

1536
00:46:19,466 --> 00:46:22,006
一个折叠查询

1537
00:46:22,006 --> 00:46:23,766
它是你整个处理过程的

1538
00:46:23,766 --> 00:46:24,786
GPU 内存使用情况

1539
00:46:25,106 --> 00:46:26,716
这是尤其显著的

1540
00:46:26,716 --> 00:46:28,616
因为它包括了

1541
00:46:28,616 --> 00:46:29,616
所有对你不可见的

1542
00:46:29,616 --> 00:46:30,966
由驱动程序分配的内存

1543
00:46:30,966 --> 00:46:33,156
类似于

1544
00:46:33,156 --> 00:46:34,676
放置着色器代码的内存

1545
00:46:34,676 --> 00:46:35,686
命令缓存器或者其他类似的

1546
00:46:35,686 --> 00:46:36,076
东西

1547
00:46:36,576 --> 00:46:37,516
这能让你知道你

1548
00:46:37,516 --> 00:46:38,216
在哪里是关联的

1549
00:46:38,216 --> 00:46:38,946
你知道所有东西的

1550
00:46:38,946 --> 00:46:39,976
内存使用目标

1551
00:46:43,736 --> 00:46:44,666
我们有几个

1552
00:46:44,666 --> 00:46:45,586
面向计算机的添加

1553
00:46:46,026 --> 00:46:47,246
我们第一个添加的

1554
00:46:47,246 --> 00:46:48,276
是一系列着色语言功能

1555
00:46:48,276 --> 00:46:49,636
以帮助

1556
00:46:49,636 --> 00:46:50,826
你能够在 SIMD 组的

1557
00:46:50,826 --> 00:46:51,976
线程之间转换

1558
00:46:52,176 --> 00:46:54,306
如果你还不熟悉的话

1559
00:46:54,306 --> 00:46:55,526
GPU 硬件获得一个

1560
00:46:55,746 --> 00:46:57,606
单个顶点片段

1561
00:46:57,606 --> 00:46:59,586
然后计算着色器线程进入

1562
00:46:59,586 --> 00:47:00,756
SIMD 组 然后一起执行它们

1563
00:47:00,756 --> 00:47:01,986
以获得更好的效率

1564
00:47:02,536 --> 00:47:04,266
它们也被称为

1565
00:47:04,266 --> 00:47:04,726
wayfrencer warp

1566
00:47:05,766 --> 00:47:07,386
在一个组里 这些线程

1567
00:47:07,386 --> 00:47:08,506
有能力不加载或者

1568
00:47:08,506 --> 00:47:09,756
储存内存

1569
00:47:09,756 --> 00:47:10,796
直接进行对话

1570
00:47:11,386 --> 00:47:13,126
它们可以从一个

1571
00:47:13,126 --> 00:47:14,226
线程的寄存器读取值然后

1572
00:47:14,226 --> 00:47:15,096
将它们写入另一个

1573
00:47:15,096 --> 00:47:15,666
线程寄存器

1574
00:47:15,796 --> 00:47:16,516
这些就是

1575
00:47:16,516 --> 00:47:17,506
新的标准库

1576
00:47:17,506 --> 00:47:17,816
允许的内容

1577
00:47:18,916 --> 00:47:21,516
这里的广播意味着

1578
00:47:21,516 --> 00:47:22,756
我能直接从线程零的寄存器

1579
00:47:22,856 --> 00:47:24,226
读取数据

1580
00:47:24,226 --> 00:47:25,526
直接读取数据域

1581
00:47:25,526 --> 00:47:26,406
然后直接将它写进

1582
00:47:26,406 --> 00:47:27,866
正好同属于这一个组里的

1583
00:47:27,866 --> 00:47:28,796
其他 16 个线程的

1584
00:47:28,796 --> 00:47:28,976
寄存器

1585
00:47:33,146 --> 00:47:34,606
我们第二个增加

1586
00:47:34,606 --> 00:47:35,776
让你根据你的线程组大小

1587
00:47:35,776 --> 00:47:37,086
获得更多灵活性

1588
00:47:37,936 --> 00:47:39,576
例如 如果我有一个

1589
00:47:39,576 --> 00:47:40,556
像素鸟 我想要运行

1590
00:47:40,556 --> 00:47:41,916
一些漂亮的经典图像的

1591
00:47:41,916 --> 00:47:44,866
处理内核

1592
00:47:44,866 --> 00:47:45,936
但是我已经将计算内核

1593
00:47:45,936 --> 00:47:47,666
所有地方都写成了 4 乘 4 的

1594
00:47:47,716 --> 00:47:48,516
线程组

1595
00:47:49,906 --> 00:47:50,936
好吧 这导致了一些问题

1596
00:47:50,936 --> 00:47:52,246
因为

1597
00:47:52,246 --> 00:47:53,716
如果我的图片不是我的线程组的

1598
00:47:53,716 --> 00:47:55,056
数倍

1599
00:47:55,056 --> 00:47:56,066
我会产生

1600
00:47:56,066 --> 00:47:56,396
很多偏离线程

1601
00:47:57,056 --> 00:47:59,766
我想这意味着

1602
00:47:59,766 --> 00:48:01,726
我需要对它进行深入了解

1603
00:48:01,726 --> 00:48:02,546
然后当我真的要编写代码的时候

1604
00:48:02,546 --> 00:48:03,466
我必须要谨慎

1605
00:48:03,466 --> 00:48:04,326
我越界了吗

1606
00:48:04,326 --> 00:48:05,146
我需要用特殊的方法

1607
00:48:05,146 --> 00:48:05,736
来处理它

1608
00:48:05,736 --> 00:48:07,136
这是可行的 但是令人恼火

1609
00:48:07,976 --> 00:48:09,006
这基本是意味着

1610
00:48:09,006 --> 00:48:10,126
我们只是在浪费 GPU 循环

1611
00:48:10,646 --> 00:48:12,926
所以非一致线程组的大小

1612
00:48:12,926 --> 00:48:14,536
除非你声明

1613
00:48:14,536 --> 00:48:15,476
在不放大线程组大小的情况下

1614
00:48:15,476 --> 00:48:16,896
你想要在哪种维度上

1615
00:48:16,896 --> 00:48:18,136
进行你的核心运行

1616
00:48:18,736 --> 00:48:20,156
所以那些困难的工作

1617
00:48:20,156 --> 00:48:21,766
在我的网格边缘的较小的

1618
00:48:21,766 --> 00:48:23,536
线程组上

1619
00:48:23,536 --> 00:48:24,466
为了去掉

1620
00:48:24,466 --> 00:48:26,006
不必要的工作

1621
00:48:26,096 --> 00:48:28,456
它不仅提升了 GPU 的性能

1622
00:48:28,456 --> 00:48:29,556
而且还让你的核心变得更

1623
00:48:29,556 --> 00:48:29,976
容易编写

1624
00:48:34,236 --> 00:48:35,206
我们已经加入了

1625
00:48:35,206 --> 00:48:35,896
对视图端口队列的支持

1626
00:48:36,206 --> 00:48:37,736
现在你可以设置最多 16 个

1627
00:48:37,736 --> 00:48:39,396
同步的视图端口

1628
00:48:39,396 --> 00:48:41,146
而你的顶点着色器可以选择

1629
00:48:41,146 --> 00:48:42,776
每个三角想向哪一个视图端口

1630
00:48:42,776 --> 00:48:43,916
进行呈现

1631
00:48:44,626 --> 00:48:45,596
在这里我就不多讲了

1632
00:48:45,596 --> 00:48:46,256
因为明天的 Metal 2

1633
00:48:46,256 --> 00:48:48,026
VR 会议将会讲到关于它的

1634
00:48:48,026 --> 00:48:49,176
细节

1635
00:48:49,546 --> 00:48:50,546
这对左右眼的

1636
00:48:50,546 --> 00:48:51,346
有效渲染是非常

1637
00:48:51,346 --> 00:48:51,976
有价值的

1638
00:48:56,666 --> 00:48:57,476
我们已经加入了一项能力

1639
00:48:57,476 --> 00:48:59,126
它可以选择在每个像素上

1640
00:48:59,126 --> 00:49:00,076
你的多个实例位置

1641
00:49:00,076 --> 00:49:00,606
在哪里被支持

1642
00:49:01,566 --> 00:49:02,776
这让你能做一些

1643
00:49:02,776 --> 00:49:04,356
有趣的事情 包括

1644
00:49:04,356 --> 00:49:05,366
每隔一帧切换

1645
00:49:05,366 --> 00:49:07,256
你的实例位置

1646
00:49:07,256 --> 00:49:08,396
并给你一些新的 你知道

1647
00:49:08,396 --> 00:49:09,376
将一些有价值的输入加入到

1648
00:49:09,376 --> 00:49:10,386
一些随机采样抗锯齿

1649
00:49:10,386 --> 00:49:11,066
算法里

1650
00:49:15,716 --> 00:49:17,206
为了努力保持

1651
00:49:17,266 --> 00:49:18,726
使我们的平台能跟得上时代

1652
00:49:18,726 --> 00:49:19,756
让他们在任何时候

1653
00:49:19,806 --> 00:49:20,816
都有相同的功能设置

1654
00:49:20,816 --> 00:49:21,856
我们用了

1655
00:49:21,856 --> 00:49:23,356
我们在去年的 iOS 10

1656
00:49:23,356 --> 00:49:25,586
以及今年的 macOS High Sierra 上

1657
00:49:25,586 --> 00:49:26,366
搭载的资源堆

1658
00:49:26,616 --> 00:49:28,826
在这里我要

1659
00:49:28,826 --> 00:49:29,926
做一下刷新

1660
00:49:29,926 --> 00:49:32,196
因为好好使用

1661
00:49:32,196 --> 00:49:33,906
堆

1662
00:49:33,906 --> 00:49:34,816
对于很好的利用参数缓存器

1663
00:49:34,816 --> 00:49:35,246
很重要

1664
00:49:36,606 --> 00:49:37,986
堆使我们能

1665
00:49:37,986 --> 00:49:38,896
预先分配很多

1666
00:49:38,896 --> 00:49:40,786
内存  而不是

1667
00:49:40,786 --> 00:49:42,416
去到内核然后说

1668
00:49:42,506 --> 00:49:43,926
我要纹理 a 的内存

1669
00:49:43,926 --> 00:49:45,046
我要纹理 b 的内存

1670
00:49:45,046 --> 00:49:45,416
等等

1671
00:49:45,826 --> 00:49:46,896
我可以去内核

1672
00:49:46,896 --> 00:49:49,036
预先分配内存

1673
00:49:49,036 --> 00:49:50,626
增减纹理和缓存器的同时

1674
00:49:50,626 --> 00:49:51,556
不需要

1675
00:49:51,556 --> 00:49:52,906
回到

1676
00:49:52,976 --> 00:49:55,396
系统中去

1677
00:49:55,466 --> 00:49:56,766
这样做有一些好处

1678
00:49:56,946 --> 00:49:58,206
这意味着我能

1679
00:49:58,206 --> 00:49:59,116
在这个堆中更高效的

1680
00:49:59,116 --> 00:49:59,726
混合所有东西

1681
00:49:59,916 --> 00:50:00,666
这样会减少很多

1682
00:50:00,666 --> 00:50:01,026
软件开销

1683
00:50:01,786 --> 00:50:02,966
这意味着我们可以

1684
00:50:02,966 --> 00:50:03,936
经常将内存

1685
00:50:03,936 --> 00:50:04,466
压缩的更紧密一些

1686
00:50:04,466 --> 00:50:05,536
我们可以减少一些边距

1687
00:50:05,536 --> 00:50:06,686
和队列 为你省下

1688
00:50:06,686 --> 00:50:07,056
一些内存

1689
00:50:08,096 --> 00:50:10,116
这意味着当我们删除内存时

1690
00:50:10,426 --> 00:50:11,816
我们不会将内存

1691
00:50:11,816 --> 00:50:12,236
返还给系统

1692
00:50:12,576 --> 00:50:13,296
这是好事也是坏事

1693
00:50:13,996 --> 00:50:15,666
这意味着当我们分配

1694
00:50:15,666 --> 00:50:16,526
新内存时

1695
00:50:16,526 --> 00:50:17,676
当我们分配新的纹理时

1696
00:50:17,676 --> 00:50:18,656
我们不用回到系统

1697
00:50:18,656 --> 00:50:18,976
去索取新的内存

1698
00:50:22,476 --> 00:50:23,386
这也意味着你可以

1699
00:50:23,386 --> 00:50:24,916
选择对这些纹理

1700
00:50:24,916 --> 00:50:25,476
进行重命名

1701
00:50:26,256 --> 00:50:27,606
如果我有

1702
00:50:27,606 --> 00:50:29,456
渲染目标 或者

1703
00:50:29,456 --> 00:50:31,126
在渲染图形的不同通道上对

1704
00:50:31,126 --> 00:50:32,666
渲染图像进行调整

1705
00:50:33,076 --> 00:50:34,176
这意味着

1706
00:50:34,176 --> 00:50:34,886
如果我有两个中间结构

1707
00:50:34,886 --> 00:50:36,616
它们不用同时出现

1708
00:50:36,616 --> 00:50:37,966
我可以

1709
00:50:37,966 --> 00:50:38,926
为他们设置相互命名

1710
00:50:38,926 --> 00:50:43,416
我可以像这样

1711
00:50:44,096 --> 00:50:46,066
省下很多内存

1712
00:50:46,866 --> 00:50:47,906
这是一个对堆的快速调查

1713
00:50:47,996 --> 00:50:50,196
我们在 iOS 到 macOS 里都

1714
00:50:50,386 --> 00:50:52,056
添加了线性纹理

1715
00:50:52,296 --> 00:50:53,366
线性纹理能使你直接从

1716
00:50:53,366 --> 00:50:55,146
Metal 缓存器里创建纹理

1717
00:50:55,146 --> 00:50:56,736
而不用做任何的

1718
00:50:56,786 --> 00:50:57,216
复制工作

1719
00:50:59,306 --> 00:51:00,266
我们也扩展了

1720
00:51:00,266 --> 00:51:01,736
我们功能的稳定性

1721
00:51:01,736 --> 00:51:02,766
一个快速的刷新

1722
00:51:02,766 --> 00:51:03,656
稳定功能让你

1723
00:51:03,656 --> 00:51:04,886
用代码进行特殊化

1724
00:51:05,026 --> 00:51:05,926
当你在线下做完了

1725
00:51:05,926 --> 00:51:07,466
你的前端编译

1726
00:51:07,466 --> 00:51:08,636
你能够在产生最终的

1727
00:51:08,636 --> 00:51:09,886
机器代码之前就

1728
00:51:10,106 --> 00:51:11,296
对超着色器 bi-code 进行一些

1729
00:51:11,296 --> 00:51:11,856
调整和自定义

1730
00:51:12,716 --> 00:51:14,046
如果你有经典的

1731
00:51:14,046 --> 00:51:15,156
超着色器 它能为你省下

1732
00:51:15,156 --> 00:51:16,206
为每个单独序列

1733
00:51:16,206 --> 00:51:17,836
都配置一个前端编译器的

1734
00:51:17,836 --> 00:51:18,726
开销

1735
00:51:19,806 --> 00:51:21,016
所以我们已经将它变得

1736
00:51:21,016 --> 00:51:22,546
更灵活 也添加了一些

1737
00:51:22,546 --> 00:51:25,136
能特殊化参数的

1738
00:51:25,246 --> 00:51:26,286
功能

1739
00:51:28,046 --> 00:51:29,106
我们也增加了一些额外的

1740
00:51:29,106 --> 00:51:29,796
顶点数组格式

1741
00:51:29,826 --> 00:51:31,196
我们遗漏了一个或两个

1742
00:51:31,196 --> 00:51:32,396
组件顶点格式

1743
00:51:32,546 --> 00:51:34,366
我们还增加了 BGRA 顶点

1744
00:51:34,366 --> 00:51:34,916
格式

1745
00:51:37,576 --> 00:51:38,616
我们从 macOS 到 iOS 都

1746
00:51:38,616 --> 00:51:40,306
有 iOS 的

1747
00:51:40,436 --> 00:51:40,846
表面纹理支持

1748
00:51:40,846 --> 00:51:42,716
我们也在 iOS 上加入了

1749
00:51:42,716 --> 00:51:44,156
双源混合

1750
00:51:44,446 --> 00:51:46,666
这在很多延迟渲染场景下

1751
00:51:46,666 --> 00:51:47,926
尤其有用

1752
00:51:50,706 --> 00:51:52,756
这就是我关于 Metal 2

1753
00:51:52,756 --> 00:51:56,086
介绍的最后内容

1754
00:51:56,166 --> 00:51:57,586
我的同事 Michal

1755
00:51:57,586 --> 00:51:58,976
在开始的时候

1756
00:51:58,976 --> 00:52:00,266
向你们介绍了 Metal 2 的

1757
00:52:00,266 --> 00:52:00,806
总体范围

1758
00:52:01,126 --> 00:52:03,686
从 VR 到外部 GPU

1759
00:52:04,056 --> 00:52:05,206
到机器学习

1760
00:52:05,206 --> 00:52:06,886
到新的研发者工具和

1761
00:52:07,306 --> 00:52:08,026
性能分析

1762
00:52:08,026 --> 00:52:08,986
我们今天介绍的

1763
00:52:08,986 --> 00:52:10,936
这些内容

1764
00:52:10,936 --> 00:52:12,456
极大地的推动了

1765
00:52:12,576 --> 00:52:13,926
通过使用参数缓存器

1766
00:52:13,926 --> 00:52:14,386
来减少 CPU 开销

1767
00:52:15,006 --> 00:52:16,506
参数缓存器也解锁了

1768
00:52:16,506 --> 00:52:17,856
GPU 的能力

1769
00:52:17,886 --> 00:52:18,956
使它在配置

1770
00:52:18,956 --> 00:52:19,866
着色器参数时

1771
00:52:19,866 --> 00:52:21,126
掌握一些它自己的命运

1772
00:52:21,126 --> 00:52:22,536
这也少了一个

1773
00:52:22,536 --> 00:52:24,676
让它回到 CPU 去的理由

1774
00:52:25,586 --> 00:52:27,356
光栅顺序组让我们

1775
00:52:27,356 --> 00:52:28,666
在基本的东西以外

1776
00:52:28,666 --> 00:52:30,186
使用光栅器来进行混合

1777
00:52:31,356 --> 00:52:32,476
我们现在可以开始

1778
00:52:32,476 --> 00:52:34,056
利用最新的硬件能力去做到

1779
00:52:34,056 --> 00:52:36,566
你知道的

1780
00:52:36,566 --> 00:52:38,386
vox slice 三角网络或者

1781
00:52:38,616 --> 00:52:40,316
设置有序或独立的

1782
00:52:40,316 --> 00:52:41,226
透明混合

1783
00:52:41,296 --> 00:52:42,216
它们都是

1784
00:52:42,216 --> 00:52:42,816
这让它们都变成可能

1785
00:52:44,016 --> 00:52:46,656
对于新的 iPad Pros ProMotion

1786
00:52:46,656 --> 00:52:47,726
能让你对于

1787
00:52:47,726 --> 00:52:49,126
动画如何呈现给用户

1788
00:52:49,126 --> 00:52:50,226
拥有一个细粒度程度的控制

1789
00:52:50,226 --> 00:52:51,886
让你有能力既

1790
00:52:51,886 --> 00:52:53,656
得到峰顶的帧率

1791
00:52:53,656 --> 00:52:54,736
又得到最少的延迟

1792
00:52:55,136 --> 00:52:57,736
直接显示通过发现我们的

1793
00:52:57,736 --> 00:52:59,116
合成器代表你做了什么

1794
00:52:59,116 --> 00:53:00,436
来为你提供

1795
00:53:00,526 --> 00:53:01,706
重新声明 GPU 执行路径的

1796
00:53:01,706 --> 00:53:02,956
能力

1797
00:53:06,336 --> 00:53:07,536
你可以在

1798
00:53:07,536 --> 00:53:08,426
WWDC2017 的网站上看到

1799
00:53:08,426 --> 00:53:11,216
今天会议的幻灯片和视频

1800
00:53:11,876 --> 00:53:15,096
我们今年还有

1801
00:53:15,096 --> 00:53:15,996
其他三个关于 Metal 2 的会议

1802
00:53:16,596 --> 00:53:18,536
特别要提到的是

1803
00:53:18,536 --> 00:53:19,456
明天下午

1804
00:53:19,456 --> 00:53:20,696
我们的会议将集中讨论

1805
00:53:20,696 --> 00:53:21,136
VR 和 Metal 2

1806
00:53:21,326 --> 00:53:22,886
会议将

1807
00:53:22,886 --> 00:53:24,706
深入讲解你的应用

1808
00:53:24,706 --> 00:53:26,456
需要做什么 以及如何

1809
00:53:26,456 --> 00:53:28,426
做 VR 渲染的概念性简介

1810
00:53:28,426 --> 00:53:30,056
深入讲解

1811
00:53:30,056 --> 00:53:32,106
如何用 Metal 2 和 Steam VR toolkit

1812
00:53:32,106 --> 00:53:34,076
的组合来做 VR

1813
00:53:34,076 --> 00:53:36,086
它也将通过外部的

1814
00:53:36,086 --> 00:53:37,326
GPU 硬件

1815
00:53:37,326 --> 00:53:37,736
来使用 Metal

1816
00:53:39,666 --> 00:53:40,376
在周四 我们将有

1817
00:53:40,376 --> 00:53:42,286
连续两场会议 以 Metal 2

1818
00:53:42,286 --> 00:53:43,676
的优化和故障排查开始

1819
00:53:43,996 --> 00:53:45,716
会议将介绍

1820
00:53:45,716 --> 00:53:46,726
新的研发项目

1821
00:53:46,726 --> 00:53:48,106
和性能工具

1822
00:53:48,106 --> 00:53:49,376
以及所有的

1823
00:53:49,376 --> 00:53:50,086
帮助你创建尽可能完美应用

1824
00:53:50,086 --> 00:53:51,076
的工作流

1825
00:53:51,286 --> 00:53:52,826
接下去的会议

1826
00:53:52,826 --> 00:53:54,336
将会介绍

1827
00:53:54,336 --> 00:53:55,276
使用 Metal 2 进行计算

1828
00:53:55,656 --> 00:53:57,126
这将是

1829
00:53:57,126 --> 00:53:58,896
今年的重大关注点

1830
00:53:58,896 --> 00:54:00,206
使用 GPU 来做机器学习

1831
00:54:00,206 --> 00:54:00,916
应用

1832
00:54:00,916 --> 00:54:01,946
我们今年做了非常多的

1833
00:54:01,946 --> 00:54:03,806
添加 我们也希望

1834
00:54:03,806 --> 00:54:05,166
向大家展示我们做了哪些事

1835
00:54:07,206 --> 00:54:08,386
我想给大家介绍

1836
00:54:08,426 --> 00:54:10,206
几个去年的 WWDC 会议

1837
00:54:11,286 --> 00:54:12,626
第一个是  Metal 的新鲜事

1838
00:54:12,626 --> 00:54:14,186
第一部分 我们深入的讲解了

1839
00:54:14,186 --> 00:54:15,786
资源堆

1840
00:54:16,196 --> 00:54:17,146
如果你想要得到

1841
00:54:17,146 --> 00:54:18,026
参数缓存器的最好性能

1842
00:54:18,026 --> 00:54:19,836
参数缓存器和堆

1843
00:54:19,836 --> 00:54:20,936
是密不可分的

1844
00:54:20,936 --> 00:54:22,716
所以我非常鼓励

1845
00:54:22,716 --> 00:54:23,836
大家去看看视频

1846
00:54:23,836 --> 00:54:26,336
真的 你可以

1847
00:54:26,436 --> 00:54:28,416
通过一起使用这两项

1848
00:54:28,416 --> 00:54:29,326
来计划

1849
00:54:29,326 --> 00:54:29,686
制作你的应用

1850
00:54:29,756 --> 00:54:31,196
那个视频里比今天的会议

1851
00:54:31,196 --> 00:54:32,516
多讲了很多细节

1852
00:54:34,056 --> 00:54:36,016
第二 如果你对

1853
00:54:36,016 --> 00:54:38,076
直接显示和广色域

1854
00:54:38,076 --> 00:54:39,436
有兴趣

1855
00:54:39,436 --> 00:54:40,996
我们在去年有

1856
00:54:40,996 --> 00:54:41,916
一次会议全程

1857
00:54:41,916 --> 00:54:43,066
都在深入探讨

1858
00:54:43,066 --> 00:54:44,066
它背后的概念

1859
00:54:44,066 --> 00:54:44,656
和特殊性

1860
00:54:45,706 --> 00:54:47,676
在这里 我们今天的会议

1861
00:54:47,676 --> 00:54:47,796
到此结束

1862
00:54:47,796 --> 00:54:48,886
感谢大家的到来

1863
00:54:48,886 --> 00:54:49,596
希望大家

1864
00:54:49,596 --> 00:54:50,266
享受本周剩下的几天

1865
00:54:50,266 --> 00:54:50,906
谢谢大家

1866
00:54:51,516 --> 00:54:55,500
[ 掌声 ]

