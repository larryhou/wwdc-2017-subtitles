1
00:00:29,846 --> 00:00:30,336
Porcino

2
00:00:30,476 --> 00:00:32,116
我在游戏技术团队

3
00:00:32,116 --> 00:00:34,426
工作 今天在这里我想谈谈

4
00:00:34,426 --> 00:00:36,736
如何将你的艺术作品

5
00:00:36,826 --> 00:00:39,186
从最初的素材开始

6
00:00:39,186 --> 00:00:41,176
通过 Model I/O 引入到引擎

7
00:00:41,276 --> 00:00:41,676
欢迎大家

8
00:00:42,546 --> 00:00:46,006
所以在最开始 我想

9
00:00:46,006 --> 00:00:48,276
先帮大家回想一下 Model I/O 是什么

10
00:00:49,006 --> 00:00:50,766
Model I/O 是 Apple 为

11
00:00:50,766 --> 00:00:51,726
构建管道设计的成套工具

12
00:00:51,956 --> 00:00:53,776
你们可以用它来导入或导出 3D

13
00:00:53,776 --> 00:00:55,646
素材 包括多个行业的

14
00:00:55,646 --> 00:00:58,006
标准文件格式 例如

15
00:00:58,436 --> 00:01:00,546
常见的 Wavefront OBJ

16
00:01:00,656 --> 00:01:02,206
以及更现代点的 像是

17
00:01:02,206 --> 00:01:03,056
Pixar 的 USD

18
00:01:03,646 --> 00:01:06,126
它可以描绘几何结构

19
00:01:06,126 --> 00:01:07,986
材质 光线照相机

20
00:01:08,086 --> 00:01:11,416
三维像素化 灯光以及

21
00:01:11,416 --> 00:01:12,126
各种其他的东西

22
00:01:12,566 --> 00:01:14,226
它也可以进行数据格式转换

23
00:01:14,556 --> 00:01:16,146
这样不管你所拿到的素材

24
00:01:16,146 --> 00:01:17,506
原始创作时是

25
00:01:17,506 --> 00:01:18,636
什么格式

26
00:01:18,806 --> 00:01:21,576
你都可以使它们符合

27
00:01:21,576 --> 00:01:22,866
特定的步幅和布局

28
00:01:22,866 --> 00:01:23,896
以满足 Metal 的需求

29
00:01:24,476 --> 00:01:25,416
另外还有各种

30
00:01:25,416 --> 00:01:27,196
处理工具 我们

31
00:01:27,196 --> 00:01:28,436
在演讲最后会简要地

32
00:01:28,436 --> 00:01:31,276
评价一下它们

33
00:01:31,486 --> 00:01:33,986
今年我们对

34
00:01:33,986 --> 00:01:35,356
Model I/O 做了很多改进

35
00:01:35,396 --> 00:01:37,486
这里我想向大家推荐

36
00:01:37,486 --> 00:01:39,196
我们的开发人员网站 帮助大家了解更多

37
00:01:39,416 --> 00:01:41,556
为了让大家

38
00:01:41,896 --> 00:01:43,046
大致了解接下来的内容

39
00:01:43,626 --> 00:01:44,676
我们对导入器

40
00:01:44,676 --> 00:01:45,206
做了改进

41
00:01:45,206 --> 00:01:46,936
我们得到过很多这样的反馈

42
00:01:46,936 --> 00:01:49,086
当他们加载了外部

43
00:01:49,136 --> 00:01:50,306
文件格式 他们就会遇到

44
00:01:50,306 --> 00:01:50,816
问题

45
00:01:50,816 --> 00:01:52,126
我们已经根据需求进行了

46
00:01:52,646 --> 00:01:53,486
修正

47
00:01:53,906 --> 00:01:54,986
我们引入了对

48
00:01:54,986 --> 00:01:56,276
蒙皮角色动画的支持

49
00:01:56,676 --> 00:01:57,856
这点稍后

50
00:01:57,856 --> 00:01:59,876
会讲到

51
00:02:00,376 --> 00:02:02,026
我们支持融合变形

52
00:02:02,306 --> 00:02:03,656
如果你有一个角色的两种表情

53
00:02:03,656 --> 00:02:04,936
微笑以及皱眉

54
00:02:04,936 --> 00:02:06,536
利用这个数据结构

55
00:02:06,536 --> 00:02:07,516
你可以实现两个表情间的转换

56
00:02:07,966 --> 00:02:09,346
并且我们还有变换栈

57
00:02:09,836 --> 00:02:12,426
对应数据在不同

58
00:02:12,426 --> 00:02:13,966
程序中的状态 例如

59
00:02:13,966 --> 00:02:16,796
在 Maya 中动画将被

60
00:02:16,796 --> 00:02:17,926
分为

61
00:02:17,926 --> 00:02:19,326
旋转 技巧

62
00:02:19,326 --> 00:02:21,046
翻译 并以特定

63
00:02:21,046 --> 00:02:21,406
的顺序摆放

64
00:02:22,196 --> 00:02:23,566
去年我们给了大家一个

65
00:02:23,566 --> 00:02:25,976
矩阵 今年我们能用

66
00:02:26,366 --> 00:02:28,516
你们在创作工具时用的

67
00:02:28,626 --> 00:02:30,406
同样的构件组成

68
00:02:30,406 --> 00:02:31,026
动画

69
00:02:31,866 --> 00:02:36,096
现在最重要的是 Model I/O

70
00:02:36,346 --> 00:02:38,076
能够让你们对你们的数据有

71
00:02:38,076 --> 00:02:38,446
统一的视图

72
00:02:39,096 --> 00:02:42,046
所以如果你打开一个素材

73
00:02:42,046 --> 00:02:43,226
不管它原本是什么格式

74
00:02:43,226 --> 00:02:45,276
Model I/O 将

75
00:02:45,276 --> 00:02:48,036
对它进行标准化 这样你就可以

76
00:02:48,036 --> 00:02:49,726
遍历它 写一个

77
00:02:49,726 --> 00:02:51,096
代码环 它将知道

78
00:02:51,096 --> 00:02:51,986
如何每次以统一的方式

79
00:02:51,986 --> 00:02:54,556
处理所有的数据

80
00:02:54,556 --> 00:02:55,836
对你加载的每一项素材

81
00:02:55,836 --> 00:02:56,836
都是如此

82
00:02:56,836 --> 00:02:58,306
这个我放到屏幕

83
00:02:58,306 --> 00:02:59,756
上的素材

84
00:03:00,126 --> 00:03:01,436
只是车的一个小

85
00:03:01,466 --> 00:03:01,876
部件

86
00:03:02,056 --> 00:03:03,446
它有一个摄像头 还有

87
00:03:03,446 --> 00:03:03,746
光

88
00:03:04,036 --> 00:03:05,216
这辆车被分解为

89
00:03:05,216 --> 00:03:05,956
各种部件

90
00:03:05,956 --> 00:03:06,956
它有各种不同的材质

91
00:03:07,836 --> 00:03:09,526
不管我加载的是何种场景

92
00:03:09,526 --> 00:03:11,696
它都将是这样的

93
00:03:11,696 --> 00:03:12,766
并且它非常容易

94
00:03:12,766 --> 00:03:13,246
遍历

95
00:03:13,396 --> 00:03:15,546
这也是为什么 Model I/O

96
00:03:16,196 --> 00:03:18,206
真的非常容易使用 并且在管道中

97
00:03:18,206 --> 00:03:18,776
非常有用

98
00:03:20,686 --> 00:03:22,916
现在 我们想创造

99
00:03:22,916 --> 00:03:23,696
像这样的东西

100
00:03:23,696 --> 00:03:25,186
这将是我的一个小

101
00:03:25,936 --> 00:03:26,046
游戏

102
00:03:26,046 --> 00:03:28,476
这个游戏将由

103
00:03:28,476 --> 00:03:30,466
一些艺术素材组成 它们

104
00:03:30,466 --> 00:03:32,046
已经在另外一个工具中准备好了

105
00:03:32,166 --> 00:03:33,466
这个工具可以是 Maya Blender 或者

106
00:03:33,466 --> 00:03:34,146
任何其他你喜欢的工具

107
00:03:34,706 --> 00:03:36,456
然后还需要有模型

108
00:03:36,456 --> 00:03:37,716
需要有模型上的

109
00:03:37,716 --> 00:03:38,356
材料

110
00:03:38,636 --> 00:03:40,086
将有动画

111
00:03:40,776 --> 00:03:41,896
各种各样的纹理

112
00:03:42,356 --> 00:03:43,546
我们将会从各种

113
00:03:43,546 --> 00:03:45,556
不同的文件中整合

114
00:03:45,606 --> 00:03:46,126
一个场景

115
00:03:47,316 --> 00:03:51,626
一个艺术家在创造

116
00:03:51,626 --> 00:03:54,106
素材时 他们处于一个特别

117
00:03:54,146 --> 00:03:56,056
复杂的环境中

118
00:03:56,056 --> 00:03:57,676
有很多他们可以使用的工具

119
00:03:58,066 --> 00:04:00,776
对于艺术家来说 艺术作品以及

120
00:04:00,776 --> 00:04:02,846
Maya 和 Blender 这些工具的意义

121
00:04:02,846 --> 00:04:04,706
就像源代码

122
00:04:04,706 --> 00:04:05,246
对于程序员的意义

123
00:04:05,696 --> 00:04:07,106
它有各种各样

124
00:04:07,326 --> 00:04:08,546
对迭代和开发

125
00:04:08,546 --> 00:04:10,026
非常有用的东西 但是

126
00:04:10,076 --> 00:04:11,576
那些并不能让它被运用到

127
00:04:11,576 --> 00:04:12,036
运行中

128
00:04:12,036 --> 00:04:12,896
你们不需要交付代码 你们

129
00:04:12,896 --> 00:04:13,906
要交付的是编译代码

130
00:04:14,516 --> 00:04:16,495
正如你们在应用程序中

131
00:04:17,396 --> 00:04:18,666
为你们的对象编写

132
00:04:18,666 --> 00:04:19,516
源一样 我们将

133
00:04:19,516 --> 00:04:21,976
编写适用于引擎的

134
00:04:21,976 --> 00:04:22,426
最佳素材

135
00:04:23,536 --> 00:04:26,296
现在 制作基于 UI 的小工具

136
00:04:26,296 --> 00:04:28,686
是非常有吸引力的

137
00:04:29,526 --> 00:04:30,926
所以也许通过一些拖放 以及

138
00:04:30,926 --> 00:04:32,056
很多其他的操作去点击

139
00:04:32,096 --> 00:04:33,206
滑动等

140
00:04:33,206 --> 00:04:34,756
去构造那个工具

141
00:04:34,876 --> 00:04:35,866
这个过程将会很有意思

142
00:04:35,866 --> 00:04:37,106
而且最初使用的几次

143
00:04:37,106 --> 00:04:37,736
也会很有意思

144
00:04:38,306 --> 00:04:40,796
但是当我完成我的第一辆车

145
00:04:40,926 --> 00:04:42,136
艺术家又给了我另外 12 辆

146
00:04:42,136 --> 00:04:43,576
车的时候 那么

147
00:04:43,576 --> 00:04:44,966
我就必须把他们都拖进来

148
00:04:44,966 --> 00:04:46,326
一次又一次地去重复

149
00:04:46,326 --> 00:04:47,416
点击同样的

150
00:04:47,416 --> 00:04:47,736
按钮吗

151
00:04:48,146 --> 00:04:49,346
那样这个工具很快就会变得

152
00:04:49,616 --> 00:04:51,256
让人非常有负担

153
00:04:51,886 --> 00:04:52,986
这里我们要讲讲

154
00:04:52,986 --> 00:04:56,966
如何通过管道批量处理

155
00:04:56,966 --> 00:04:57,526
这个操作

156
00:04:58,566 --> 00:05:00,566
我们将从图案

157
00:05:00,566 --> 00:05:01,156
开始

158
00:05:01,606 --> 00:05:03,506
我将使用一个导出器

159
00:05:03,686 --> 00:05:05,406
将它转换为素材

160
00:05:07,026 --> 00:05:08,696
我们将使用 Model I/O 将

161
00:05:08,696 --> 00:05:10,846
这个素材转换为

162
00:05:10,846 --> 00:05:11,846
引擎就绪数据

163
00:05:12,426 --> 00:05:14,806
我们将在我们的引擎里

164
00:05:14,806 --> 00:05:17,686
加载这个引擎就绪

165
00:05:17,686 --> 00:05:18,026
数据

166
00:05:18,076 --> 00:05:19,506
我们将把它转换为

167
00:05:19,506 --> 00:05:21,216
Metal 缓冲文件 然后 Metal

168
00:05:21,366 --> 00:05:22,336
将制作一张好看的图片

169
00:05:23,586 --> 00:05:28,656
所以第一步是

170
00:05:28,856 --> 00:05:29,686
导出艺术作品

171
00:05:30,246 --> 00:05:33,696
在我们的

172
00:05:33,696 --> 00:05:35,436
这个例子中 我们使用的是 Maya

173
00:05:35,766 --> 00:05:37,236
我们有一个 Python

174
00:05:37,236 --> 00:05:38,646
脚本 它将浏览 Maya

175
00:05:38,646 --> 00:05:39,566
找到所有的东西

176
00:05:40,116 --> 00:05:42,776
它遍历复杂的层级

177
00:05:42,776 --> 00:05:46,256
和文件 然后导出一个

178
00:05:46,256 --> 00:05:46,826
素材文件

179
00:05:47,556 --> 00:05:50,216
正如我之前提到的

180
00:05:50,316 --> 00:05:51,796
选择文件格式非常

181
00:05:51,796 --> 00:05:53,116
重要 我们不会

182
00:05:53,116 --> 00:05:54,906
使用齿轮处

183
00:05:54,906 --> 00:05:55,896
有点长的东西

184
00:05:55,896 --> 00:05:57,476
例如 Wavefront OBJ 我们将

185
00:05:58,506 --> 00:06:00,156
使用比较新的

186
00:06:00,156 --> 00:06:01,486
现代的东西 也就是 Pixar 的

187
00:06:01,486 --> 00:06:02,736
USD 文件

188
00:06:02,736 --> 00:06:03,146
格式

189
00:06:03,146 --> 00:06:06,956
现在我们要简要

190
00:06:06,956 --> 00:06:10,106
介绍一下它 首先

191
00:06:10,346 --> 00:06:11,166
它有一个网站

192
00:06:11,166 --> 00:06:12,476
你可以在那儿看到网址

193
00:06:12,476 --> 00:06:15,086
在这里你可以找到

194
00:06:15,086 --> 00:06:16,186
你可能想知道的关于

195
00:06:16,186 --> 00:06:17,476
USD 的细节和各种

196
00:06:18,066 --> 00:06:18,686
信息

197
00:06:18,826 --> 00:06:21,546
现在可以在他们的网站上

198
00:06:21,546 --> 00:06:22,706
找到 Pixar 的 USD 文件格式

199
00:06:22,706 --> 00:06:25,646
这些文件多年以来用于

200
00:06:25,646 --> 00:06:27,146
制作动画

201
00:06:27,146 --> 00:06:27,866
长片

202
00:06:28,266 --> 00:06:30,436
大家可能还

203
00:06:30,436 --> 00:06:31,966
记得在去年的 SceneKit

204
00:06:31,966 --> 00:06:33,416
展示 我们把

205
00:06:33,416 --> 00:06:35,276
USD 整合到

206
00:06:35,276 --> 00:06:37,676
iOS 和 macOS

207
00:06:37,676 --> 00:06:39,366
操作系统当中

208
00:06:39,836 --> 00:06:41,326
我们一直在和

209
00:06:41,326 --> 00:06:43,126
Pixar 共同努力以不断改善

210
00:06:43,126 --> 00:06:45,166
整合情况 并且添加了

211
00:06:45,166 --> 00:06:45,826
新的功能

212
00:06:46,536 --> 00:06:49,556
那么是什么让 USD

213
00:06:49,556 --> 00:06:52,006
变得比之前所有的

214
00:06:52,836 --> 00:06:54,556
都更强大呢

215
00:06:54,556 --> 00:06:57,226
正是因为我们

216
00:06:57,226 --> 00:06:58,826
把大量的文件

217
00:06:58,996 --> 00:07:00,346
组合在一起

218
00:07:00,346 --> 00:07:01,486
创造一个复杂的场景

219
00:07:02,006 --> 00:07:04,376
在这个样本里

220
00:07:04,376 --> 00:07:07,426
我从我们的赛道里面

221
00:07:07,776 --> 00:07:09,826
拆出了一些部件 或者从我们

222
00:07:09,826 --> 00:07:12,266
有赛道的游戏里面 然后把它们运用到

223
00:07:12,266 --> 00:07:13,766
建筑物 赛道 轮胎

224
00:07:13,766 --> 00:07:15,286
墙壁 车辆以及一些轮子中

225
00:07:15,696 --> 00:07:17,566
我们逐级将这些

226
00:07:17,566 --> 00:07:19,356
组合成一个单独的

227
00:07:19,356 --> 00:07:19,686
文件

228
00:07:20,256 --> 00:07:22,006
正如我之前给你们看的

229
00:07:22,006 --> 00:07:24,496
那张表格 Model I/O

230
00:07:24,496 --> 00:07:26,296
将把一切都解读为

231
00:07:27,076 --> 00:07:28,576
容易遍历的格式

232
00:07:28,676 --> 00:07:30,396
当我们只要将文件加载到

233
00:07:30,396 --> 00:07:31,806
Model I/O 中就可以实现这点

234
00:07:32,476 --> 00:07:34,726
还有一件特别棒的事

235
00:07:34,906 --> 00:07:36,416
另外一个你们可以从

236
00:07:36,416 --> 00:07:37,826
USD 中得到的特别棒的东西

237
00:07:37,826 --> 00:07:39,196
就是变化的概念

238
00:07:39,556 --> 00:07:42,116
这对艺术家来说是一个

239
00:07:42,116 --> 00:07:43,556
非常强大的工具

240
00:07:43,556 --> 00:07:44,156
他们可以用它来创造

241
00:07:44,156 --> 00:07:44,596
场景

242
00:07:44,596 --> 00:07:46,006
如果你希望跑道上

243
00:07:46,006 --> 00:07:47,516
有很多车 我可以用

244
00:07:47,516 --> 00:07:49,156
USD 做的就是先做一个汽车

245
00:07:49,156 --> 00:07:50,826
文件 然后我可以获得

246
00:07:50,826 --> 00:07:51,996
各种颜色的变化

247
00:07:52,036 --> 00:07:53,306
大家可以看到这里有黄色的

248
00:07:53,306 --> 00:07:54,176
绿色的 红色的

249
00:07:54,486 --> 00:07:56,626
还有各种模型的变化

250
00:07:56,626 --> 00:07:58,026
有翼片的和没有翼片的

251
00:07:58,546 --> 00:07:59,996
我可以在文件里引用它们

252
00:07:59,996 --> 00:08:02,246
选择我所需要的

253
00:08:02,246 --> 00:08:04,536
版本 然后 Model I/O

254
00:08:04,826 --> 00:08:05,826
将会对它们进行平面化

255
00:08:05,826 --> 00:08:06,946
这样当你在

256
00:08:06,946 --> 00:08:08,426
遍历数据结构

257
00:08:08,426 --> 00:08:10,096
寻找你的

258
00:08:10,096 --> 00:08:12,016
缓冲数据时 它将为你

259
00:08:12,016 --> 00:08:12,886
找到合适的东西

260
00:08:13,586 --> 00:08:16,326
我还想提到的一点是

261
00:08:16,376 --> 00:08:17,966
USD 有

262
00:08:18,336 --> 00:08:21,536
ASCII 格式以及一个快速的二进制

263
00:08:21,536 --> 00:08:21,976
格式

264
00:08:22,386 --> 00:08:25,266
网格由成千上万的

265
00:08:25,266 --> 00:08:26,546
顶点和法线等组成

266
00:08:26,546 --> 00:08:27,626
我将把它输出为

267
00:08:27,626 --> 00:08:28,306
二进制

268
00:08:28,736 --> 00:08:30,496
但是另一方面 如果我只是

269
00:08:30,496 --> 00:08:31,816
随机地使用这个

270
00:08:31,816 --> 00:08:35,285
数据 我可以写一个

271
00:08:35,285 --> 00:08:37,326
像这样的文本 这里我

272
00:08:37,356 --> 00:08:41,285
有一个有关

273
00:08:41,285 --> 00:08:44,626
一辆车的动画世界 这个车将被引用

274
00:08:45,066 --> 00:08:47,146
我只是改变了

275
00:08:47,146 --> 00:08:49,476
这辆车的颜色 并且我把它放在

276
00:08:49,476 --> 00:08:50,686
动画场景中

277
00:08:50,686 --> 00:08:52,116
大家知道它并不是根据它的

278
00:08:52,426 --> 00:08:53,536
通用规则来进行动画绘制的

279
00:08:54,356 --> 00:08:56,796
这点对

280
00:08:56,796 --> 00:08:58,686
创造变化和

281
00:08:58,686 --> 00:09:00,706
离线试验迭代素材来说

282
00:09:01,116 --> 00:09:01,726
具有十分强大的功能

283
00:09:02,486 --> 00:09:06,056
我们将构建的是

284
00:09:06,056 --> 00:09:07,746
一个小的工具 它将

285
00:09:07,906 --> 00:09:08,796
把 USD

286
00:09:08,796 --> 00:09:10,736
素材转化为

287
00:09:10,876 --> 00:09:13,856
引擎就绪的数据

288
00:09:14,046 --> 00:09:16,016
命令行工具

289
00:09:16,816 --> 00:09:19,296
拥有命令行工具

290
00:09:19,296 --> 00:09:20,696
可以给我们带来的

291
00:09:20,696 --> 00:09:22,356
好处就是

292
00:09:22,356 --> 00:09:22,796
可复制性

293
00:09:22,856 --> 00:09:24,096
它可复制是因为具有

294
00:09:24,096 --> 00:09:25,076
命令行参数

295
00:09:26,306 --> 00:09:27,836
这些工具的操作可以保持

296
00:09:28,076 --> 00:09:29,396
一致因为我们有

297
00:09:29,396 --> 00:09:30,896
定义良好的输入和输出

298
00:09:30,896 --> 00:09:31,946
以及参数

299
00:09:31,946 --> 00:09:34,006
它将可编写脚本

300
00:09:34,506 --> 00:09:36,606
你可以分批处理你的工具

301
00:09:36,606 --> 00:09:37,846
将你的工具排好顺序

302
00:09:39,096 --> 00:09:39,806
它将给我们带来

303
00:09:39,866 --> 00:09:41,406
可扩展性 这是

304
00:09:41,406 --> 00:09:42,396
图形用户

305
00:09:42,396 --> 00:09:44,876
界面工具所没有的 因为我们

306
00:09:44,876 --> 00:09:46,406
可以不中断地进行

307
00:09:46,406 --> 00:09:47,076
自动操作

308
00:09:47,536 --> 00:09:49,276
例如 艺术家可能

309
00:09:49,276 --> 00:09:50,786
在某处有一个 Dropbox 文件

310
00:09:51,126 --> 00:09:51,966
他们会把

311
00:09:51,966 --> 00:09:53,366
所有的素材都放进去

312
00:09:53,366 --> 00:09:54,486
无论何时 只要他们准备好将它们整合进

313
00:09:54,486 --> 00:09:55,816
引擎 我们

314
00:09:55,816 --> 00:09:57,076
都可以用一个小脚本

315
00:09:57,076 --> 00:09:58,386
对该目录进行监测

316
00:09:59,046 --> 00:10:00,316
任何时候当它注意到有新

317
00:10:00,316 --> 00:10:02,286
文件时 我们将要介绍的

318
00:10:02,286 --> 00:10:03,426
处理器

319
00:10:03,476 --> 00:10:05,336
将自动运行 使文件

320
00:10:05,336 --> 00:10:07,106
引擎就绪 然后移动它

321
00:10:07,466 --> 00:10:09,046
这样当你们构建 Xcode 时

322
00:10:09,156 --> 00:10:10,036
所有的素材将被

323
00:10:10,036 --> 00:10:11,826
自动导入

324
00:10:11,826 --> 00:10:12,396
为你们的游戏做好准备

325
00:10:13,576 --> 00:10:15,136
最后 这种工具

326
00:10:15,136 --> 00:10:16,616
是可组合的 这正是

327
00:10:16,616 --> 00:10:18,266
表格右边的小弧线

328
00:10:18,266 --> 00:10:19,676
所表明的

329
00:10:20,186 --> 00:10:21,466
如果我们的场景中有多个工具

330
00:10:21,496 --> 00:10:23,516
它是可组合的

331
00:10:23,516 --> 00:10:24,536
它们都可以读写

332
00:10:24,536 --> 00:10:26,546
同样的数据块 然后我就

333
00:10:26,676 --> 00:10:28,326
可以将一个工具送进另外一个中

334
00:10:28,326 --> 00:10:30,236
我可以用一个工具来

335
00:10:30,236 --> 00:10:32,826
提取所有的网格 然后对它们进行

336
00:10:32,826 --> 00:10:33,446
光照贴图

337
00:10:33,446 --> 00:10:35,086
我可能做另外一个工具来寻找

338
00:10:35,086 --> 00:10:36,316
所有的纹理 然后做一个

339
00:10:36,316 --> 00:10:36,956
纹理清单

340
00:10:37,426 --> 00:10:39,016
我做了很多像这样的小工具

341
00:10:39,016 --> 00:10:40,266
然后把他们一起放进

342
00:10:40,716 --> 00:10:41,916
工作流程中

343
00:10:43,196 --> 00:10:47,136
所以 这个样本

344
00:10:47,136 --> 00:10:47,656
还是非常简单的

345
00:10:48,006 --> 00:10:49,976
它并不像很多其他的

346
00:10:49,976 --> 00:10:52,276
最佳实践

347
00:10:52,276 --> 00:10:54,316
它只是为了给大家

348
00:10:54,316 --> 00:10:55,866
一个简化的数据格式

349
00:10:55,866 --> 00:10:57,026
让大家更容易理解

350
00:10:57,186 --> 00:10:58,266
这样大家便可以将

351
00:10:58,266 --> 00:10:59,276
我们所讲的与你们

352
00:10:59,276 --> 00:10:59,886
在代码中所看到的相匹配

353
00:11:00,386 --> 00:11:01,446
其中并没有压缩 因为

354
00:11:01,536 --> 00:11:02,646
你们不会想模糊

355
00:11:02,646 --> 00:11:03,746
正在进行的操作

356
00:11:04,766 --> 00:11:06,036
它的目的是成为你们

357
00:11:06,036 --> 00:11:08,816
开始构建你们自己的

358
00:11:08,816 --> 00:11:10,476
管道工具的起点

359
00:11:10,476 --> 00:11:11,986
用它们匹配

360
00:11:11,986 --> 00:11:13,336
你们自己的引擎和数据

361
00:11:13,336 --> 00:11:13,916
格式

362
00:11:14,336 --> 00:11:17,196
我还想谈一点

363
00:11:17,196 --> 00:11:18,626
有关我们组合在一起的

364
00:11:18,626 --> 00:11:19,406
玩具引擎

365
00:11:20,856 --> 00:11:21,786
它内部有一个非常简单的

366
00:11:21,786 --> 00:11:22,576
渲染程序

367
00:11:22,576 --> 00:11:23,676
它都是用 Swift 和

368
00:11:23,676 --> 00:11:23,976
Metal 编写的

369
00:11:24,356 --> 00:11:25,536
它是一个单通道的

370
00:11:25,536 --> 00:11:26,826
渲染程序 基于实物的

371
00:11:26,826 --> 00:11:28,986
着色器 对象副本 蒙皮

372
00:11:28,986 --> 00:11:30,976
骨骼动画以及多种

373
00:11:30,976 --> 00:11:31,456
材质

374
00:11:32,176 --> 00:11:34,596
那里标出了好多

375
00:11:34,596 --> 00:11:35,076
要点

376
00:11:35,806 --> 00:11:37,186
它有一个非常直接的

377
00:11:37,186 --> 00:11:37,776
渲染循环

378
00:11:38,216 --> 00:11:39,846
在左边我们有

379
00:11:39,846 --> 00:11:41,796
那个表格以及一些需要绘制的网格

380
00:11:42,876 --> 00:11:44,326
对于我们想画的所有事物

381
00:11:44,326 --> 00:11:45,526
我们都会设置

382
00:11:46,016 --> 00:11:47,736
转换缓冲 蒙皮数据

383
00:11:47,736 --> 00:11:49,466
顶点缓冲 设置我们的管道

384
00:11:49,466 --> 00:11:51,326
状态 材质均一

385
00:11:51,646 --> 00:11:52,606
以及碎片纹理

386
00:11:52,906 --> 00:11:53,836
我们将会为制作

387
00:11:54,106 --> 00:11:55,536
好看的画面而绘制

388
00:11:55,536 --> 00:11:55,896
索引的原语

389
00:11:56,526 --> 00:11:59,776
我们把那个工具叫作

390
00:11:59,776 --> 00:12:00,466
baker

391
00:12:01,706 --> 00:12:03,666
那么我们要烤什么呢

392
00:12:06,136 --> 00:12:08,246
首先 我们要烤

393
00:12:08,246 --> 00:12:09,586
几何结构和

394
00:12:09,586 --> 00:12:11,246
变换 事物的

395
00:12:11,246 --> 00:12:12,896
样子 其所在位置

396
00:12:14,006 --> 00:12:16,016
纹理路径以及材质

397
00:12:16,016 --> 00:12:17,146
这样在我们绘制那些

398
00:12:17,146 --> 00:12:18,076
东西的时候 我们知道

399
00:12:18,076 --> 00:12:18,776
它们将呈现的样子

400
00:12:19,316 --> 00:12:20,836
实例化数据 这样当我们有

401
00:12:21,236 --> 00:12:23,026
多个轮子的时候 将

402
00:12:23,026 --> 00:12:24,296
有信息可以告诉

403
00:12:24,296 --> 00:12:26,366
我们如何高效地将那个轮子的

404
00:12:26,366 --> 00:12:27,606
多个副本放在何处

405
00:12:28,356 --> 00:12:30,146
转换动画 这样就

406
00:12:30,146 --> 00:12:31,536
可以让事物进行动画化

407
00:12:32,216 --> 00:12:33,866
最后我们将谈一下

408
00:12:33,866 --> 00:12:35,196
蒙皮和角色

409
00:12:35,196 --> 00:12:35,696
动画

410
00:12:36,306 --> 00:12:40,116
首先是几何机构和

411
00:12:40,116 --> 00:12:41,046
转换

412
00:12:42,496 --> 00:12:44,666
了解基本计算机

413
00:12:44,666 --> 00:12:45,656
绘图的话 你应该

414
00:12:45,656 --> 00:12:47,046
熟悉场景图

415
00:12:47,806 --> 00:12:48,946
这里我们有一个转换

416
00:12:48,946 --> 00:12:49,786
层级

417
00:12:49,926 --> 00:12:51,926
有转换节点 A

418
00:12:51,926 --> 00:12:52,756
和 B

419
00:12:53,126 --> 00:12:55,426
A 可能是一个世界节点

420
00:12:55,586 --> 00:12:56,826
它可能只是提供

421
00:12:56,826 --> 00:12:57,816
一个恒等

422
00:12:57,816 --> 00:12:58,616
变换

423
00:12:58,616 --> 00:13:01,196
B 是一个转换节点 它说明

424
00:13:01,196 --> 00:13:02,436
了车在世界中所处的位置

425
00:13:02,966 --> 00:13:05,686
我的赛车现在只有一个轮子

426
00:13:05,686 --> 00:13:06,566
假装你们可以在

427
00:13:06,566 --> 00:13:07,776
我的幻灯片下面看到

428
00:13:07,776 --> 00:13:08,296
其他的轮子

429
00:13:08,806 --> 00:13:10,086
我们还有车身

430
00:13:10,946 --> 00:13:14,756
转换层级工作的方式是

431
00:13:14,756 --> 00:13:16,976
如果我移动了

432
00:13:16,976 --> 00:13:18,236
母节点 那个母节点

433
00:13:18,236 --> 00:13:19,286
下面的一切

434
00:13:19,446 --> 00:13:23,036
都会作为整体一起移动

435
00:13:23,176 --> 00:13:25,666
我们想做的是

436
00:13:25,666 --> 00:13:26,976
要把那个信息放入

437
00:13:27,356 --> 00:13:29,316
我们的引擎中 这样它

438
00:13:29,316 --> 00:13:30,196
马上就可以对其进行渲染

439
00:13:30,526 --> 00:13:32,836
我们希望简洁地进行编码

440
00:13:32,836 --> 00:13:34,736
使操作容易

441
00:13:34,736 --> 00:13:36,126
存储并且

442
00:13:36,126 --> 00:13:37,586
不需要我去修复

443
00:13:37,586 --> 00:13:39,706
指示器或者任何其他的

444
00:13:40,256 --> 00:13:40,366
此类事物

445
00:13:40,586 --> 00:13:42,866
我将要做的是

446
00:13:42,866 --> 00:13:43,826
平面化

447
00:13:43,826 --> 00:13:46,056
并且直线化那个

448
00:13:46,056 --> 00:13:46,426
队列

449
00:13:46,836 --> 00:13:47,836
我希望我不需要再说

450
00:13:47,836 --> 00:13:48,216
那个单词了

451
00:13:48,796 --> 00:13:52,016
我们将进行一队列的

452
00:13:52,186 --> 00:13:53,666
本地转换

453
00:13:53,966 --> 00:13:56,446
第一个可能是

454
00:13:56,446 --> 00:13:58,216
世界

455
00:13:58,276 --> 00:13:59,226
矩阵

456
00:13:59,946 --> 00:14:01,526
然后有另外一个矩阵告诉我们

457
00:14:01,526 --> 00:14:02,406
车的位置

458
00:14:03,276 --> 00:14:05,046
另外一个矩阵告诉我

459
00:14:05,046 --> 00:14:06,296
轮子在哪里

460
00:14:07,276 --> 00:14:08,556
另外一个矩阵告诉我

461
00:14:08,556 --> 00:14:09,436
车身在哪里

462
00:14:09,436 --> 00:14:12,286
我将分配指标

463
00:14:12,286 --> 00:14:13,056
因为稍后它们将会

464
00:14:13,056 --> 00:14:14,126
非常有用

465
00:14:14,566 --> 00:14:16,586
0 1 2 3 将是

466
00:14:16,616 --> 00:14:20,386
场景图的

467
00:14:20,956 --> 00:14:21,086
中序遍历

468
00:14:21,266 --> 00:14:22,776
现在我将对那棵树

469
00:14:22,776 --> 00:14:23,336
进行编码

470
00:14:24,176 --> 00:14:25,436
我将编写另外

471
00:14:25,436 --> 00:14:26,606
一队列母指标

472
00:14:26,726 --> 00:14:29,176
第一条是 nil

473
00:14:29,176 --> 00:14:32,086
这个世界没有亲项

474
00:14:33,156 --> 00:14:36,626
这辆车的 root B 的亲项在

475
00:14:36,626 --> 00:14:38,166
索引 0 中 也就是世界

476
00:14:39,716 --> 00:14:42,926
轮子的亲项在

477
00:14:43,106 --> 00:14:45,216
B 转换节点下 其他的

478
00:14:45,216 --> 00:14:46,246
轮子也将是如此

479
00:14:47,456 --> 00:14:49,666
车身的亲项也在

480
00:14:49,666 --> 00:14:50,156
那个节点之下

481
00:14:51,126 --> 00:14:53,896
所以我们编码了一个图表

482
00:14:54,546 --> 00:14:55,836
最后我们希望能够

483
00:14:55,836 --> 00:14:57,516
告诉引擎需要

484
00:14:57,516 --> 00:14:59,136
绘制什么 所以我们将绘制

485
00:14:59,136 --> 00:15:01,186
一个轮子 它在索引 2 下面

486
00:15:01,296 --> 00:15:03,196
然后我们将绘制在

487
00:15:03,456 --> 00:15:04,606
索引 3 的车身

488
00:15:05,476 --> 00:15:08,756
我们用特别容易

489
00:15:08,936 --> 00:15:09,906
编写的方式描述了

490
00:15:09,906 --> 00:15:10,266
我们的场景

491
00:15:11,586 --> 00:15:13,606
现在我们也只需要

492
00:15:13,606 --> 00:15:14,596
描述需要画的内容

493
00:15:15,056 --> 00:15:17,196
这将是一个顶点

494
00:15:17,196 --> 00:15:19,936
描述符 也就是将

495
00:15:19,936 --> 00:15:21,216
告诉 Metal 以下信息的队列

496
00:15:21,216 --> 00:15:22,526
这些是标准的 这些是纹理

497
00:15:22,526 --> 00:15:23,496
坐标 这些是

498
00:15:23,496 --> 00:15:25,476
位置 真正的顶点可以

499
00:15:25,476 --> 00:15:26,476
自行缓冲

500
00:15:26,476 --> 00:15:28,316
然后索引缓冲器

501
00:15:28,316 --> 00:15:29,876
会表明这些

502
00:15:30,096 --> 00:15:31,346
指数对应

503
00:15:31,346 --> 00:15:32,966
这些顶点缓冲区里的三角形

504
00:15:33,526 --> 00:15:38,336
有了我们一致的

505
00:15:38,916 --> 00:15:39,886
数据结构 是很容易

506
00:15:39,886 --> 00:15:40,436
做到这点的

507
00:15:40,956 --> 00:15:41,986
我们会把所有的对象

508
00:15:41,986 --> 00:15:44,566
放在 MDLAsset 对象里运行一遍

509
00:15:44,716 --> 00:15:46,656
在我们导入它之后

510
00:15:47,396 --> 00:15:50,036
如果对象可以被放入

511
00:15:50,116 --> 00:15:52,956
MDLMesh 里面铸造 我们将拿出 MDLMesh

512
00:15:52,956 --> 00:15:54,896
以及顶点描述符 它将

513
00:15:54,896 --> 00:15:56,166
告诉我们是否获得

514
00:15:56,166 --> 00:15:59,026
位置及正常状态

515
00:15:59,086 --> 00:16:00,696
对于在网格里的所有

516
00:16:00,816 --> 00:16:02,436
顶点缓冲区 我们

517
00:16:02,436 --> 00:16:04,366
将根据顶点缓冲区和

518
00:16:04,616 --> 00:16:07,196
其长度创建 NSData

519
00:16:07,476 --> 00:16:09,536
点点点

520
00:16:09,536 --> 00:16:10,696
会告诉我们要

521
00:16:10,696 --> 00:16:12,016
把 NSData 存储在

522
00:16:12,016 --> 00:16:13,406
某处供编码使用

523
00:16:13,946 --> 00:16:17,166
然后我们将在

524
00:16:17,166 --> 00:16:18,356
子网格中运行 这里要快速

525
00:16:18,576 --> 00:16:20,006
介绍一下什么是子网格

526
00:16:20,396 --> 00:16:21,536
因为我刚刚提到了

527
00:16:21,536 --> 00:16:22,786
这个词 我们可以想想

528
00:16:22,786 --> 00:16:24,266
轮子 轮子有

529
00:16:24,266 --> 00:16:26,266
一个橡胶轮胎和一个金属圈

530
00:16:26,386 --> 00:16:26,606
对吧

531
00:16:27,036 --> 00:16:28,356
所以我们可能将有

532
00:16:28,356 --> 00:16:29,866
两种材质 所以需要有两种

533
00:16:29,866 --> 00:16:30,526
绘制调用

534
00:16:30,966 --> 00:16:31,756
但是它还是一个网格

535
00:16:31,756 --> 00:16:32,706
他们将共用很多

536
00:16:32,706 --> 00:16:33,826
顶点 例如

537
00:16:33,826 --> 00:16:35,696
轮胎和金属圈之间的

538
00:16:35,696 --> 00:16:36,106
交叉点

539
00:16:36,106 --> 00:16:37,426
所以我们将创建两个

540
00:16:37,426 --> 00:16:40,336
子网格用来索引金属圈

541
00:16:40,586 --> 00:16:42,466
以及轮胎 他们都有自己

542
00:16:42,466 --> 00:16:44,566
独立的索引缓冲器和

543
00:16:44,566 --> 00:16:44,976
网格

544
00:16:45,196 --> 00:16:47,386
我们将运行它们 然后

545
00:16:47,536 --> 00:16:47,686
铸造它们

546
00:16:47,686 --> 00:16:49,146
如果我们成功地铸造了它们 我们就

547
00:16:49,146 --> 00:16:51,896
创建了一些 NSData

548
00:16:51,896 --> 00:16:52,626
并且可以将之存储起来

549
00:16:53,256 --> 00:16:55,946
最后对于素材里面的所有

550
00:16:57,126 --> 00:16:59,136
对象 我们将

551
00:16:59,136 --> 00:17:01,696
发现对象是否进行过

552
00:17:01,696 --> 00:17:04,425
变换 然后拿到它的

553
00:17:04,425 --> 00:17:05,856
矩阵 然后把它存在

554
00:17:05,856 --> 00:17:06,116
队列中

555
00:17:06,766 --> 00:17:08,526
完善 NSEncode 并将之归档

556
00:17:08,945 --> 00:17:10,316
这些是将

557
00:17:10,316 --> 00:17:11,876
进入光盘中的缓冲器

558
00:17:12,276 --> 00:17:14,316
网格数据 描述符

559
00:17:14,316 --> 00:17:16,336
顶点以及索引缓冲器

560
00:17:16,336 --> 00:17:18,306
对场景中参数

561
00:17:18,366 --> 00:17:21,746
进行直线化后的

562
00:17:21,976 --> 00:17:23,646
场景数据 最后

563
00:17:23,646 --> 00:17:24,935
关于在哪里放置

564
00:17:24,935 --> 00:17:26,366
这些东西的

565
00:17:26,366 --> 00:17:26,715
变换数据

566
00:17:27,165 --> 00:17:31,016
接下来 我们将拿出

567
00:17:31,336 --> 00:17:33,336
所有的材质数据

568
00:17:33,896 --> 00:17:37,076
对于每一个子网格 我们

569
00:17:37,076 --> 00:17:38,406
将找出它

570
00:17:38,876 --> 00:17:39,646
可能对应一个材质

571
00:17:39,646 --> 00:17:41,186
如果我们有一个材质 那么我们

572
00:17:41,186 --> 00:17:42,926
将需要找到我们的着色器

573
00:17:43,186 --> 00:17:45,216
所需要的指数

574
00:17:45,496 --> 00:17:47,036
如果我们的着色器需要扩散

575
00:17:47,036 --> 00:17:49,086
色彩和粗糙度 那么我将

576
00:17:49,086 --> 00:17:50,836
问 MDLMaterial 你有

577
00:17:50,836 --> 00:17:52,936
哪些值 我将

578
00:17:53,046 --> 00:17:54,316
确定它为定标

579
00:17:54,316 --> 00:17:56,956
值还是纹理 然后我们

580
00:17:56,956 --> 00:17:58,466
将拿出并且记录它们

581
00:17:59,606 --> 00:18:01,026
同样 这些代码都是非常

582
00:18:01,026 --> 00:18:01,646
直接的

583
00:18:02,996 --> 00:18:04,206
如果子网格有一种材质

584
00:18:04,206 --> 00:18:06,836
它将在所有属性中运行一遍

585
00:18:07,336 --> 00:18:08,456
这里我没有向你们展示是因为

586
00:18:08,456 --> 00:18:10,046
我只是为我们的运行时着色器

587
00:18:10,046 --> 00:18:11,206
过滤出那些

588
00:18:11,206 --> 00:18:11,936
我们真正在意的东西

589
00:18:11,986 --> 00:18:13,676
但是一旦我们到了

590
00:18:13,676 --> 00:18:14,576
需要把它过滤掉的那个点

591
00:18:14,576 --> 00:18:17,096
我们将问 嗨 属性

592
00:18:17,096 --> 00:18:18,636
你是字符串还是网址

593
00:18:19,006 --> 00:18:20,466
如果是这样的话 我们将参考一个

594
00:18:20,466 --> 00:18:21,836
纹理 然后我们直接

595
00:18:21,836 --> 00:18:23,056
为之后编写出纹理通道

596
00:18:23,876 --> 00:18:25,406
不然我们就需要

597
00:18:25,826 --> 00:18:27,666
检查你是否只是一个统一

598
00:18:27,666 --> 00:18:28,996
属性 例如你是否是

599
00:18:28,996 --> 00:18:31,026
浮动值或者颜色或者

600
00:18:31,026 --> 00:18:32,536
类似的东西 如果是这样的

601
00:18:32,536 --> 00:18:33,276
那么我们将把它

602
00:18:33,276 --> 00:18:33,636
写出来

603
00:18:33,636 --> 00:18:37,956
然后再次 这是我们

604
00:18:37,956 --> 00:18:39,026
在之前的步骤里

605
00:18:39,026 --> 00:18:40,326
写出的数据 也就是

606
00:18:40,376 --> 00:18:41,326
场景图和网格

607
00:18:42,436 --> 00:18:43,866
现在我将写出

608
00:18:43,866 --> 00:18:48,416
材质均一和纹理通道

609
00:18:48,556 --> 00:18:50,566
最后进行实例化

610
00:18:53,556 --> 00:18:56,756
也就是在这里我们的汽车

611
00:18:56,756 --> 00:18:57,656
将有不只一个

612
00:18:57,716 --> 00:18:57,956
轮子

613
00:18:57,956 --> 00:18:59,856
你可能

614
00:18:59,856 --> 00:19:01,386
想多次使用

615
00:19:01,386 --> 00:19:02,756
单一的网格

616
00:19:03,476 --> 00:19:07,206
现在我的车有两个轮子了

617
00:19:07,386 --> 00:19:10,386
要把这个多次

618
00:19:10,386 --> 00:19:12,086
存储在存储器里面

619
00:19:12,086 --> 00:19:12,556
有点浪费 对吧

620
00:19:12,556 --> 00:19:14,376
它们都是同样的轮子

621
00:19:14,376 --> 00:19:15,106
只不过重复了多次

622
00:19:15,626 --> 00:19:18,866
所以 Model I/O 在

623
00:19:18,966 --> 00:19:21,496
MDLAsset 里有一个叫控制队列的东西

624
00:19:22,186 --> 00:19:24,866
当你加载一个通过实例化

625
00:19:24,866 --> 00:19:26,886
来复制数据的 Pixar USD 文件时

626
00:19:26,886 --> 00:19:28,686
Model I/O

627
00:19:28,686 --> 00:19:30,726
会注意到这点 并且收集

628
00:19:30,726 --> 00:19:32,056
所有复制对象 把它们放入

629
00:19:32,056 --> 00:19:35,026
控制队列中 而不是

630
00:19:35,026 --> 00:19:36,936
存储在单个的网格

631
00:19:37,096 --> 00:19:39,016
的节点中 相反只是引用

632
00:19:39,136 --> 00:19:40,546
它 只需要存储引用回

633
00:19:40,546 --> 00:19:42,066
控制队列的

634
00:19:42,066 --> 00:19:42,266
MDLObjective 就行

635
00:19:42,686 --> 00:19:44,086
我们就是这么做到重复利用的

636
00:19:44,616 --> 00:19:46,246
而且 由于 Metal 有非常棒的

637
00:19:46,246 --> 00:19:48,076
实例化设备 这将

638
00:19:48,076 --> 00:19:51,876
对我们非常有益

639
00:19:52,096 --> 00:19:54,396
我们将再次

640
00:19:54,396 --> 00:19:55,976
平面化各个层级 并且

641
00:19:55,976 --> 00:19:58,596
直线化队列

642
00:19:58,626 --> 00:19:59,376
和我们之前做的一样

643
00:20:00,206 --> 00:20:02,266
现在在右侧 你可以

644
00:20:02,266 --> 00:20:03,526
看到我在索引 2 3 4

645
00:20:03,526 --> 00:20:06,126
队列中有两个轮子

646
00:20:06,536 --> 00:20:07,666
但是我们希望成批处理

647
00:20:07,666 --> 00:20:08,766
那些东西 但是我们

648
00:20:08,766 --> 00:20:13,086
现在就要做这个

649
00:20:13,296 --> 00:20:14,536
我们把这些轮胎分组

650
00:20:14,536 --> 00:20:16,926
放在一起 现在我们在底部

651
00:20:16,926 --> 00:20:17,816
有了车身

652
00:20:18,396 --> 00:20:19,136
我们只要再存储

653
00:20:19,136 --> 00:20:20,706
一点点数据 也就是

654
00:20:20,706 --> 00:20:22,046
实例计数

655
00:20:22,196 --> 00:20:23,766
现在有两个轮子和一个车身

656
00:20:25,046 --> 00:20:25,826
最后它将有四个

657
00:20:25,826 --> 00:20:26,496
轮子的 相信我

658
00:20:28,206 --> 00:20:30,656
我们将调出

659
00:20:30,656 --> 00:20:31,666
我们之前已经存储好的

660
00:20:31,666 --> 00:20:33,106
数据 再到场景

661
00:20:33,106 --> 00:20:35,386
组成数据 我们将

662
00:20:35,386 --> 00:20:36,356
添加实例计数

663
00:20:37,406 --> 00:20:39,846
我们做了这些就可以得到

664
00:20:39,846 --> 00:20:41,676
一个包含多种材质和对象的

665
00:20:41,676 --> 00:20:42,786
实例化场景

666
00:20:43,346 --> 00:20:46,016
接下来我希望交给

667
00:20:46,306 --> 00:20:48,136
Nicholas 来向大家展示

668
00:20:48,286 --> 00:20:49,266
这些是如何从最开始

669
00:20:49,266 --> 00:20:49,586
再到组合到一起的

670
00:20:51,516 --> 00:20:54,500
［掌声］

671
00:21:05,096 --> 00:21:06,016
>>我要向大家展示用 Model I/O

672
00:21:06,016 --> 00:21:07,846
可以多么容易地

673
00:21:07,846 --> 00:21:09,206
把我们的素材变换为

674
00:21:09,206 --> 00:21:10,196
引擎就绪的数据

675
00:21:10,276 --> 00:21:12,376
我这里有两个文件夹

676
00:21:12,376 --> 00:21:13,646
第一个文件夹里有我们的艺术

677
00:21:13,646 --> 00:21:14,076
素材

678
00:21:14,616 --> 00:21:16,176
它包含了动画数据

679
00:21:16,806 --> 00:21:18,706
汽车 采用了蒙皮动画的方式

680
00:21:18,706 --> 00:21:19,786
它还有一堆材质

681
00:21:20,446 --> 00:21:21,476
所以我们想做的就是我们希望

682
00:21:21,476 --> 00:21:23,896
创建一个 baker

683
00:21:23,896 --> 00:21:25,626
它可以把这个数据变为引擎

684
00:21:25,626 --> 00:21:26,796
数据 然后把它放在

685
00:21:26,796 --> 00:21:27,616
第二个文件夹里

686
00:21:28,246 --> 00:21:31,216
这里我们有我们的

687
00:21:31,216 --> 00:21:32,736
baker 项目 我们要做的

688
00:21:32,736 --> 00:21:33,996
就是我们要

689
00:21:34,096 --> 00:21:35,506
慢慢地把它扩展 以从这些

690
00:21:35,506 --> 00:21:37,256
艺术素材中提取更多的

691
00:21:37,256 --> 00:21:37,696
数据

692
00:21:38,176 --> 00:21:39,126
从最简单的开始

693
00:21:39,166 --> 00:21:40,956
让我们来导出

694
00:21:40,956 --> 00:21:42,236
几何结构和转换

695
00:21:42,956 --> 00:21:44,146
为了做这点 我们将浏览

696
00:21:44,146 --> 00:21:46,186
场景图分级并且

697
00:21:46,186 --> 00:21:47,786
寻找任何是 MDLMesh 类型的

698
00:21:48,526 --> 00:21:48,626
对象

699
00:21:51,076 --> 00:21:52,156
然后我们将存储

700
00:21:52,156 --> 00:21:55,636
顶点描述符 所有的

701
00:21:55,636 --> 00:21:58,816
顶点缓冲区 然后我们

702
00:21:58,816 --> 00:22:00,326
将迭代所有的

703
00:22:00,386 --> 00:22:02,696
子网格并且拿到索引

704
00:22:02,726 --> 00:22:03,076
缓冲器

705
00:22:06,896 --> 00:22:07,896
我们将再一次浏览

706
00:22:07,936 --> 00:22:10,256
场景图 这次

707
00:22:10,256 --> 00:22:12,836
我们要寻找的是所有

708
00:22:12,836 --> 00:22:14,066
有转换组件的

709
00:22:14,066 --> 00:22:14,576
对象

710
00:22:15,456 --> 00:22:16,906
如果有的话 我们只需要存储

711
00:22:16,906 --> 00:22:17,396
矩阵就行

712
00:22:17,526 --> 00:22:19,546
第一个例子

713
00:22:19,546 --> 00:22:19,846
就是这样

714
00:22:19,846 --> 00:22:20,726
让我们运行

715
00:22:20,726 --> 00:22:20,906
它

716
00:22:26,076 --> 00:22:27,166
大家会注意到在第二个

717
00:22:27,166 --> 00:22:28,446
文件夹里 我们有一个新文档

718
00:22:28,446 --> 00:22:29,726
这就是我们的引擎就绪

719
00:22:30,406 --> 00:22:30,536
数据

720
00:22:31,956 --> 00:22:33,336
这里的第二个项目将是

721
00:22:33,336 --> 00:22:34,386
我们的引擎 它将

722
00:22:34,386 --> 00:22:35,486
读取那个数据 并且

723
00:22:35,486 --> 00:22:36,086
对其进行渲染

724
00:22:36,086 --> 00:22:37,086
我们来看看现在的

725
00:22:37,136 --> 00:22:37,376
成果

726
00:22:37,636 --> 00:22:40,066
你可能注意到 我们的

727
00:22:40,066 --> 00:22:41,336
一个赛道上有两辆车 但是

728
00:22:41,336 --> 00:22:42,126
还有颜色需要处理

729
00:22:42,126 --> 00:22:43,746
那么让我们扩展 baker

730
00:22:43,746 --> 00:22:45,116
让它也支持材质

731
00:22:50,046 --> 00:22:52,516
我们不需要寻找

732
00:22:52,516 --> 00:22:53,326
子网格上的索引缓冲器

733
00:22:53,376 --> 00:22:54,256
我们需要看看

734
00:22:54,316 --> 00:22:55,206
它是否有一个材质

735
00:22:55,206 --> 00:22:55,656
属性

736
00:22:56,116 --> 00:22:57,936
如果有的话 那么就有五个

737
00:22:57,986 --> 00:22:58,986
和以下相关的属性

738
00:22:58,986 --> 00:23:01,516
语义 baseColor 金属材质的

739
00:23:02,346 --> 00:23:04,686
粗糙度 碰撞以及

740
00:23:04,686 --> 00:23:05,996
ambientOcclusion 这些我们

741
00:23:05,996 --> 00:23:06,266
在意的东西

742
00:23:07,066 --> 00:23:08,046
并且当我们在属性里

743
00:23:08,076 --> 00:23:09,306
读取到相关的东西 我们将迭代

744
00:23:09,396 --> 00:23:11,116
浏览所有的属性

745
00:23:11,116 --> 00:23:11,886
并检查类型

746
00:23:12,436 --> 00:23:15,296
如果类型是 float 或者

747
00:23:15,346 --> 00:23:17,486
float3 我们就可以假定它是均一的

748
00:23:17,876 --> 00:23:19,826
并且我们也将记录它

749
00:23:20,706 --> 00:23:22,516
不然 如果它是字符串或网址

750
00:23:22,516 --> 00:23:24,156
我们将记录

751
00:23:24,156 --> 00:23:24,806
纹理通道

752
00:23:25,796 --> 00:23:27,036
现在让我们来运行第二个

753
00:23:27,036 --> 00:23:28,026
例子 看看我们可以在我们的

754
00:23:28,026 --> 00:23:29,846
引擎获得何种输出

755
00:23:35,046 --> 00:23:36,076
现在我没有一个赛道

756
00:23:36,076 --> 00:23:36,966
两辆车 现在还有

757
00:23:36,966 --> 00:23:37,496
材质

758
00:23:38,256 --> 00:23:40,016
我们进一步进行扩展

759
00:23:40,016 --> 00:23:41,176
并支持实例化

760
00:23:46,256 --> 00:23:48,006
之前在浏览场景图时

761
00:23:48,006 --> 00:23:49,296
我们只考虑了

762
00:23:49,346 --> 00:23:49,746
网格

763
00:23:49,896 --> 00:23:51,056
现在我们想要考虑所有

764
00:23:51,056 --> 00:23:52,436
在素材控制队列中

765
00:23:52,436 --> 00:23:53,366
的网格

766
00:23:54,196 --> 00:23:55,436
所以我们浏览控制网格

767
00:23:56,226 --> 00:23:57,246
收集所有是 MDLMesh 类型的

768
00:23:57,246 --> 00:23:59,006
对象 然后像之前那样

769
00:23:59,446 --> 00:24:00,396
存储它

770
00:24:01,246 --> 00:24:02,336
并且 我们还需要

771
00:24:02,336 --> 00:24:04,566
记录所有控制网格

772
00:24:04,566 --> 00:24:05,236
引用的对象

773
00:24:05,236 --> 00:24:06,756
这点我们可以在

774
00:24:06,756 --> 00:24:07,646
实例化属性中找到

775
00:24:08,216 --> 00:24:11,836
然后我们可以按网格区分

776
00:24:11,836 --> 00:24:14,346
实例 得出实例

777
00:24:14,346 --> 00:24:14,666
计数

778
00:24:15,696 --> 00:24:16,616
这样就完成了

779
00:24:21,146 --> 00:24:22,256
现在让我们再运行一下

780
00:24:22,336 --> 00:24:22,846
我们的场景

781
00:24:23,496 --> 00:24:26,126
现在我们有多辆车

782
00:24:26,126 --> 00:24:27,346
我们用实例化对它们进行渲染

783
00:24:28,146 --> 00:24:28,766
交回给你了 Nick

784
00:24:31,516 --> 00:24:36,026
［掌声］

785
00:24:36,526 --> 00:24:37,586
>>接下来 我们要讲一讲

786
00:24:37,806 --> 00:24:39,486
变换动画

787
00:24:40,106 --> 00:24:43,856
变换动画是

788
00:24:43,856 --> 00:24:46,346
随时间改变的变换

789
00:24:47,776 --> 00:24:49,826
现在让我们再考虑一下我们的

790
00:24:49,826 --> 00:24:51,266
场景图

791
00:24:51,876 --> 00:24:54,556
现在 在起点线上我们有

792
00:24:54,966 --> 00:24:56,866
一辆车 现在我想

793
00:24:56,866 --> 00:24:58,656
做这么一个动画

794
00:24:58,766 --> 00:25:00,866
例如在车发动之前

795
00:25:00,866 --> 00:25:02,006
车身稍微摆动

796
00:25:02,006 --> 00:25:03,826
一下 然后车再

797
00:25:03,826 --> 00:25:04,626
开走

798
00:25:05,266 --> 00:25:06,436
为了实现这个效果

799
00:25:06,436 --> 00:25:07,586
我需要在车身节点 D

800
00:25:07,586 --> 00:25:10,736
以及整个对象的

801
00:25:10,736 --> 00:25:14,956
根节点上录制

802
00:25:14,956 --> 00:25:16,396
一些动画数据来把它

803
00:25:16,396 --> 00:25:18,406
移走 也就是节点 B

804
00:25:18,966 --> 00:25:19,906
我将要记录

805
00:25:19,906 --> 00:25:21,986
两个节点的

806
00:25:21,986 --> 00:25:22,786
动画路径

807
00:25:24,256 --> 00:25:26,476
同样有了 Model I/O

808
00:25:26,476 --> 00:25:27,836
这点特别容易做到

809
00:25:29,116 --> 00:25:31,186
和之前一样 我们浏览所有的

810
00:25:31,186 --> 00:25:32,326
对象 寻找

811
00:25:32,326 --> 00:25:34,826
变换组件

812
00:25:34,826 --> 00:25:36,356
当我们找到它们的时候 我们将

813
00:25:36,356 --> 00:25:36,916
对它们进行附加

814
00:25:37,446 --> 00:25:38,396
但是现在我们还需要做

815
00:25:38,396 --> 00:25:40,356
一件事 那就是我们将

816
00:25:40,516 --> 00:25:42,366
询问变换它是否

817
00:25:42,456 --> 00:25:45,086
有键控时间

818
00:25:45,706 --> 00:25:47,796
如果没有键控时间

819
00:25:48,076 --> 00:25:50,096
那么计数为 0 我们

820
00:25:50,096 --> 00:25:51,076
直接使用就行

821
00:25:51,456 --> 00:25:52,956
如果有 1 个键控时间

822
00:25:53,066 --> 00:25:53,976
我将把它看做

823
00:25:53,976 --> 00:25:54,526
恒定

824
00:25:54,826 --> 00:25:56,726
所以我们只需要寻找计数

825
00:25:56,766 --> 00:25:58,396
大于 1 的就行

826
00:26:01,056 --> 00:26:03,296
我们现在要真正使用

827
00:26:03,526 --> 00:26:04,966
Swift 一个非常不同寻常

828
00:26:04,966 --> 00:26:05,626
非常酷的部分

829
00:26:06,066 --> 00:26:06,736
我喜欢这个部分

830
00:26:06,736 --> 00:26:08,996
我们将使用地图

831
00:26:09,246 --> 00:26:09,736
闭合

832
00:26:10,306 --> 00:26:12,936
我们将做的是

833
00:26:13,116 --> 00:26:14,956
根据时间对

834
00:26:14,956 --> 00:26:17,746
动画进行取样

835
00:26:17,746 --> 00:26:20,136
我们将创建

836
00:26:21,236 --> 00:26:22,496
与那些时间对应的

837
00:26:22,496 --> 00:26:24,446
新队列的变换 并将之

838
00:26:24,446 --> 00:26:24,926
附加在我们的缓冲器上

839
00:26:25,446 --> 00:26:27,306
现在把绘图操作

840
00:26:27,306 --> 00:26:29,176
拆开一下

841
00:26:29,436 --> 00:26:31,076
第一行说的是

842
00:26:31,076 --> 00:26:32,076
samplesTimes.map

843
00:26:32,486 --> 00:26:33,546
幻灯片上没有

844
00:26:33,546 --> 00:26:34,526
显示的是 sampleTimes

845
00:26:34,526 --> 00:26:36,226
从哪里来

846
00:26:36,816 --> 00:26:39,796
这是另外一个队列的

847
00:26:40,416 --> 00:26:42,876
keyTimes 你在这里

848
00:26:42,876 --> 00:26:43,276
可以做两件事情

849
00:26:43,646 --> 00:26:45,286
一件事是你让

850
00:26:45,286 --> 00:26:47,286
sampleTimes 队列就是

851
00:26:47,316 --> 00:26:51,626
transform.keyTimes 队列 或者如果

852
00:26:51,626 --> 00:26:53,646
相反你只是想要

853
00:26:53,646 --> 00:26:55,506
艺术家放进文件

854
00:26:55,506 --> 00:26:57,216
中的时间点 例如如果

855
00:26:57,216 --> 00:26:58,586
你想以恒定帧频

856
00:26:58,586 --> 00:27:00,166
对时间进行取样

857
00:27:00,546 --> 00:27:01,556
你可以在你希望

858
00:27:01,556 --> 00:27:03,886
的帧频下合成

859
00:27:04,056 --> 00:27:05,486
一队列变换时间

860
00:27:05,486 --> 00:27:07,226
例如 60 帧每秒

861
00:27:07,886 --> 00:27:09,536
所以当你在进行这个绘图

862
00:27:09,536 --> 00:27:12,096
操作的时候 闭合进行了

863
00:27:12,096 --> 00:27:14,126
变换 在对应队列中

864
00:27:14,126 --> 00:27:16,546
相应值的时间下

865
00:27:16,546 --> 00:27:17,906
获取本地

866
00:27:17,906 --> 00:27:18,236
变换

867
00:27:18,436 --> 00:27:19,936
我觉得这特别酷

868
00:27:21,256 --> 00:27:23,436
这是我们已经导出

869
00:27:23,436 --> 00:27:24,276
的数据

870
00:27:25,466 --> 00:27:27,986
它非常直接地

871
00:27:27,986 --> 00:27:29,336
对本地变换动画

872
00:27:29,336 --> 00:27:30,016
进行了编码

873
00:27:30,906 --> 00:27:34,746
最后蒙皮和

874
00:27:34,746 --> 00:27:35,686
角色动画

875
00:27:36,546 --> 00:27:40,386
现在我们将要拿出一辆

876
00:27:40,386 --> 00:27:42,966
小车 它

877
00:27:42,966 --> 00:27:44,046
很明显是一辆卡通车

878
00:27:44,406 --> 00:27:46,296
我们将让它可以

879
00:27:46,296 --> 00:27:48,756
扭动它的鼻子 或者

880
00:27:48,756 --> 00:27:49,026
做其他动画效果

881
00:27:50,206 --> 00:27:53,686
正如我们之前所看到的

882
00:27:53,686 --> 00:27:55,546
网格将有几何结构

883
00:27:55,656 --> 00:27:56,536
以及其他类似的

884
00:27:56,536 --> 00:27:57,656
我们之前谈论过的

885
00:27:57,656 --> 00:28:00,056
缓冲器 但是它还有

886
00:28:00,056 --> 00:28:02,496
一个被嵌入骨架的

887
00:28:02,496 --> 00:28:02,966
新东西

888
00:28:03,256 --> 00:28:05,216
我希望大家可以看到这个小小的

889
00:28:05,216 --> 00:28:06,036
绿色的骨头

890
00:28:07,036 --> 00:28:08,186
它们将被放置在

891
00:28:08,186 --> 00:28:09,396
轮子中 在下面车的

892
00:28:09,396 --> 00:28:10,476
“脊柱”位置也有一些

893
00:28:11,686 --> 00:28:15,496
那些骨头通过

894
00:28:15,496 --> 00:28:17,876
艺术家们的绘画步骤

895
00:28:17,876 --> 00:28:19,186
和顶点绑定

896
00:28:19,616 --> 00:28:22,786
所以左边的有

897
00:28:23,506 --> 00:28:25,156
一根骨头和车的前部

898
00:28:25,216 --> 00:28:26,646
绑定 靠保险杠

899
00:28:26,646 --> 00:28:27,756
还有鼻子承重

900
00:28:28,166 --> 00:28:29,506
然后在右边

901
00:28:29,826 --> 00:28:32,026
我们选择了在车身背部

902
00:28:32,026 --> 00:28:33,536
的一根骨头和

903
00:28:33,536 --> 00:28:35,086
轮子相连 所以当这根

904
00:28:35,086 --> 00:28:37,746
骨头移动时 它将影响到

905
00:28:37,746 --> 00:28:39,316
车身背部的翼片以及

906
00:28:40,026 --> 00:28:42,156
那个轮子

907
00:28:42,356 --> 00:28:44,776
我还需要提一下

908
00:28:44,776 --> 00:28:46,356
这种数据需要

909
00:28:46,386 --> 00:28:48,686
你在你的着色器中多做一点

910
00:28:48,686 --> 00:28:49,086
工作

911
00:28:49,726 --> 00:28:53,696
我们还需要一些信息

912
00:28:53,696 --> 00:28:54,856
为我们之前还没有做过的

913
00:28:54,856 --> 00:28:55,896
发车做准备

914
00:28:56,516 --> 00:28:59,236
特别是 我们有

915
00:28:59,236 --> 00:29:03,806
jointWeights per vertex 以及

916
00:29:03,806 --> 00:29:07,326
jointIndices 也就是一小

917
00:29:07,326 --> 00:29:11,076
队列指数 我们将向

918
00:29:11,076 --> 00:29:13,186
它们调用和顶点位置

919
00:29:13,626 --> 00:29:16,226
相对应节点的

920
00:29:16,226 --> 00:29:17,196
矩阵调色

921
00:29:17,676 --> 00:29:21,046
如果有两个节点或者骨头

922
00:29:21,046 --> 00:29:23,426
同时作用于一个特定顶点

923
00:29:23,796 --> 00:29:25,476
那么当我进行变换时

924
00:29:25,476 --> 00:29:27,666
那些骨头的指数将

925
00:29:28,136 --> 00:29:30,076
和顶点一起再加上一些重量

926
00:29:30,076 --> 00:29:34,276
当我在着色器中

927
00:29:34,846 --> 00:29:36,986
对它们进行变换时 它们将

928
00:29:36,986 --> 00:29:39,506
全部被结合起来 顶点

929
00:29:39,506 --> 00:29:41,606
将移动到其最后的变形

930
00:29:41,606 --> 00:29:42,156
位置

931
00:29:44,656 --> 00:29:47,536
为了从正在进行的几何结构和

932
00:29:47,836 --> 00:29:50,146
其他变换中

933
00:29:50,256 --> 00:29:52,846
单独编码骨架

934
00:29:52,846 --> 00:29:54,066
我们还需要更多的

935
00:29:54,066 --> 00:29:54,576
信息

936
00:29:55,146 --> 00:29:57,036
那就是表格

937
00:29:57,036 --> 00:29:57,716
底部中的

938
00:29:57,716 --> 00:29:58,266
骨架

939
00:29:58,266 --> 00:29:59,886
我们把它分隔开来

940
00:30:02,366 --> 00:30:04,656
所以和我们之前所做的一样

941
00:30:04,656 --> 00:30:07,586
我们将浏览绘图

942
00:30:07,586 --> 00:30:09,976
然后根据浏览顺序 0 1 2 3

943
00:30:10,096 --> 00:30:14,816
分配指数

944
00:30:15,036 --> 00:30:16,896
我们将对骨架图中的

945
00:30:16,946 --> 00:30:20,086
亲项进行编码

946
00:30:20,356 --> 00:30:21,906
和我们之前对几何图所做的

947
00:30:21,906 --> 00:30:22,336
一样

948
00:30:22,806 --> 00:30:25,046
我不会再细讲

949
00:30:25,046 --> 00:30:26,576
它的工作原理

950
00:30:26,576 --> 00:30:27,576
因为这和之前的

951
00:30:27,576 --> 00:30:27,926
完全一样

952
00:30:29,156 --> 00:30:32,106
现在我们需要对

953
00:30:32,466 --> 00:30:35,396
每一根骨头进行编码

954
00:30:35,396 --> 00:30:37,886
它们会真正影响到顶点

955
00:30:38,566 --> 00:30:43,486
层级中骨头的索引

956
00:30:43,566 --> 00:30:46,446
以及逆绑定

957
00:30:46,446 --> 00:30:46,826
姿势

958
00:30:47,336 --> 00:30:48,806
在之前的幻灯片中

959
00:30:48,806 --> 00:30:50,316
提到着色器的部分有一些

960
00:30:50,486 --> 00:30:52,766
数学运算提到某种

961
00:30:52,766 --> 00:30:53,716
调色矩阵

962
00:30:54,286 --> 00:30:56,396
逆向绑定姿势

963
00:30:56,396 --> 00:30:58,026
将需要你用多一点的

964
00:30:58,026 --> 00:31:00,236
数学运算来帮你把

965
00:31:00,236 --> 00:31:02,416
顶点放入右侧空间

966
00:31:02,416 --> 00:31:03,496
使之更容易混合

967
00:31:03,786 --> 00:31:05,336
我将让大家看一个

968
00:31:05,336 --> 00:31:06,496
例子 以了解变换的

969
00:31:06,496 --> 00:31:07,236
具体细节

970
00:31:08,776 --> 00:31:10,056
我们将浏览它们中的

971
00:31:10,056 --> 00:31:11,916
每一项 然后把那些

972
00:31:12,076 --> 00:31:13,436
矩阵和指数存储起来

973
00:31:14,086 --> 00:31:16,026
最后 做一个

974
00:31:16,026 --> 00:31:18,326
动画片段 我们将

975
00:31:18,486 --> 00:31:20,696
录制和动画片段中

976
00:31:20,696 --> 00:31:22,416
每根骨头

977
00:31:22,476 --> 00:31:26,416
对应的动画

978
00:31:26,576 --> 00:31:29,426
所以从代码的角度

979
00:31:29,426 --> 00:31:30,356
它和我们之前看到的非常像

980
00:31:31,246 --> 00:31:32,466
我们将浏览对象

981
00:31:32,466 --> 00:31:34,396
找到对象是否有

982
00:31:34,396 --> 00:31:35,296
蒙皮

983
00:31:36,486 --> 00:31:38,496
蒙皮和骨架等

984
00:31:38,496 --> 00:31:40,256
相对应 是在

985
00:31:40,326 --> 00:31:42,286
Model I/O 全新的

986
00:31:42,766 --> 00:31:44,576
MDLSkinDeformerComponent 中编码的

987
00:31:45,006 --> 00:31:46,826
所以如果我们发现一个蒙皮变形器

988
00:31:46,826 --> 00:31:49,936
组件 我们将再次

989
00:31:49,936 --> 00:31:51,316
利用

990
00:31:51,746 --> 00:31:55,536
Swift 地图闭合 利用

991
00:31:55,536 --> 00:31:57,776
Model I/O 从文件中读取

992
00:31:57,776 --> 00:31:59,796
并且存储的

993
00:31:59,796 --> 00:32:00,176
jointBindTransforms

994
00:32:00,916 --> 00:32:02,546
我们将利用这个单指令

995
00:32:02,546 --> 00:32:05,406
倒转来倒置它们

996
00:32:05,776 --> 00:32:06,646
因为数学运算需要

997
00:32:06,646 --> 00:32:08,346
将它存储在一个队列中

998
00:32:09,036 --> 00:32:12,836
然后这里是我们到现在为止

999
00:32:12,896 --> 00:32:14,146
存储的所有数据

1000
00:32:15,496 --> 00:32:17,416
我们将调出

1001
00:32:17,416 --> 00:32:19,066
骨架数据 逆向绑定

1002
00:32:19,066 --> 00:32:20,856
变换和色斑映射

1003
00:32:20,856 --> 00:32:22,786
的连接点 以及

1004
00:32:22,786 --> 00:32:24,466
骨架亲项指数

1005
00:32:25,466 --> 00:32:30,156
我想请 Nicholas

1006
00:32:30,216 --> 00:32:32,576
再次上台来向我们展示一下

1007
00:32:32,576 --> 00:32:33,196
它现在的样子

1008
00:32:35,516 --> 00:32:39,500
［掌声］

1009
00:32:47,506 --> 00:32:48,856
>>从我们上次的地方开始 我们

1010
00:32:48,856 --> 00:32:50,336
有一个赛道 多辆

1011
00:32:50,336 --> 00:32:51,736
汽车使用实例化进行渲染

1012
00:32:52,356 --> 00:32:53,576
现在我们再让它

1013
00:32:53,646 --> 00:32:54,836
支持动画效果

1014
00:32:55,306 --> 00:32:57,106
之前在我们浏览

1015
00:32:57,106 --> 00:32:58,176
场景图的时候 我们寻找

1016
00:32:58,176 --> 00:32:59,616
任何有变换组件的

1017
00:32:59,616 --> 00:33:00,846
对象 然后我们假定它是

1018
00:33:00,846 --> 00:33:01,456
恒定的

1019
00:33:02,146 --> 00:33:02,916
现在我们希望知道

1020
00:33:02,916 --> 00:33:04,146
变换是否会随着时间而改变

1021
00:33:04,146 --> 00:33:05,466
找到这个答案的最简单的办法

1022
00:33:05,466 --> 00:33:06,566
就是看看

1023
00:33:06,566 --> 00:33:07,996
keyTimes.count 是否大于

1024
00:33:07,996 --> 00:33:08,246
1

1025
00:33:09,196 --> 00:33:10,796
如果是 为了达到

1026
00:33:10,796 --> 00:33:12,856
样本的目的 我们将

1027
00:33:13,176 --> 00:33:14,316
在特定时间间隙取样

1028
00:33:14,436 --> 00:33:16,756
我们对它们进行取样

1029
00:33:16,876 --> 00:33:17,376
然后存储

1030
00:33:17,526 --> 00:33:18,626
动画就是这样的

1031
00:33:18,656 --> 00:33:19,466
现在让我们来运行这个

1032
00:33:19,466 --> 00:33:20,596
例子 看看我们的引擎

1033
00:33:20,596 --> 00:33:21,686
可以得到哪种输出

1034
00:33:28,046 --> 00:33:29,186
大家注意到

1035
00:33:29,246 --> 00:33:30,406
前面的车已经发动了

1036
00:33:31,556 --> 00:33:32,926
最后我们来

1037
00:33:32,926 --> 00:33:33,706
加上蒙皮

1038
00:33:33,706 --> 00:33:34,786
现在让我们把 baker 扩展到

1039
00:33:34,786 --> 00:33:35,706
支持蒙皮

1040
00:33:38,156 --> 00:33:40,276
所以你需要的除了有

1041
00:33:40,276 --> 00:33:41,376
网格数据 还有

1042
00:33:41,376 --> 00:33:43,436
蒙皮数据

1043
00:33:43,436 --> 00:33:45,186
所以我们需要检查

1044
00:33:45,186 --> 00:33:47,276
看看 MDLMesh 是否有

1045
00:33:47,276 --> 00:33:48,976
和 MDLSkinDeformer 一致的组件

1046
00:33:50,086 --> 00:33:51,906
如果有 那么我们

1047
00:33:51,906 --> 00:33:52,936
还需要两点额外信息

1048
00:33:52,936 --> 00:33:54,066
也就是我们需要知道

1049
00:33:54,166 --> 00:33:55,706
骨架如何和蒙皮网格绑定

1050
00:33:55,706 --> 00:33:57,366
我们还需要知道

1051
00:33:57,366 --> 00:33:58,106
动画数据

1052
00:33:58,286 --> 00:34:00,466
所以我们找到了 jointPaths 队列

1053
00:34:00,466 --> 00:34:01,646
中所有的绑定

1054
00:34:01,646 --> 00:34:02,856
骨架连接点

1055
00:34:03,476 --> 00:34:06,516
然后我们找到

1056
00:34:06,516 --> 00:34:07,456
jointBindTransforms 中的

1057
00:34:07,456 --> 00:34:08,666
骨架绑定姿势

1058
00:34:08,666 --> 00:34:11,416
现在我们已经知道我们的

1059
00:34:11,416 --> 00:34:12,536
骨架长什么样子了 让我们

1060
00:34:12,536 --> 00:34:15,076
继续根据时间对

1061
00:34:15,196 --> 00:34:16,676
骨架连接点变换进行取样

1062
00:34:16,676 --> 00:34:18,266
和我们之前对本地对象

1063
00:34:18,266 --> 00:34:18,906
变换所做的一样

1064
00:34:20,076 --> 00:34:21,275
我们根据特定的时间间隔

1065
00:34:21,275 --> 00:34:24,106
进行取样 存储矩阵

1066
00:34:24,106 --> 00:34:25,956
然后我们把它分解为

1067
00:34:25,956 --> 00:34:27,116
四元数旋转

1068
00:34:28,335 --> 00:34:30,996
翻译 然后把它存储在

1069
00:34:30,996 --> 00:34:31,866
动画片段中

1070
00:34:32,956 --> 00:34:33,806
现在让我们来运行这个

1071
00:34:33,806 --> 00:34:34,295
例子

1072
00:34:47,056 --> 00:34:48,146
所以现在我们有了一辆蒙皮汽车

1073
00:34:48,996 --> 00:34:50,335
我再总结一下我们所做的

1074
00:34:50,545 --> 00:34:51,476
我们用 Model I/O 构建了

1075
00:34:51,516 --> 00:34:52,906
一个简单的 baker

1076
00:34:52,906 --> 00:34:54,036
它可以导出几何结构和

1077
00:34:54,036 --> 00:34:55,916
变换 再加点代码

1078
00:34:55,916 --> 00:34:57,256
我们就可以对它进行扩展

1079
00:34:57,256 --> 00:34:58,586
使它支持材质

1080
00:34:58,586 --> 00:35:00,206
实例化 动画以及

1081
00:35:00,206 --> 00:35:01,156
蒙皮动画

1082
00:35:01,896 --> 00:35:03,266
这五个例子以及

1083
00:35:03,266 --> 00:35:04,296
引擎都放在

1084
00:35:04,336 --> 00:35:05,746
这个环节的代码样本中

1085
00:35:05,746 --> 00:35:07,186
大家可以根据自己的引擎需求进行

1086
00:35:07,186 --> 00:35:07,376
修改

1087
00:35:08,026 --> 00:35:09,726
交回给你了 Nick

1088
00:35:10,216 --> 00:35:12,216
［掌声］

1089
00:35:12,416 --> 00:35:13,016
>> 好的

1090
00:35:14,776 --> 00:35:16,206
快速总结一下

1091
00:35:16,906 --> 00:35:19,406
我们展示了如何把图案

1092
00:35:19,406 --> 00:35:22,346
从最初的素材创作

1093
00:35:22,476 --> 00:35:24,686
程序变成 Pixar 的 USD

1094
00:35:24,686 --> 00:35:25,816
文件格式

1095
00:35:26,696 --> 00:35:28,916
我们运用 Model I/O 将

1096
00:35:28,916 --> 00:35:31,036
素材变换为引擎就绪

1097
00:35:31,036 --> 00:35:34,916
数据 我们对它们进行编码

1098
00:35:34,916 --> 00:35:36,246
然后把它们在光盘中归档

1099
00:35:36,786 --> 00:35:38,766
我们利用 Swift 和 Metal

1100
00:35:38,816 --> 00:35:41,036
进行了简单的渲染

1101
00:35:41,136 --> 00:35:42,136
制作了一个小游戏

1102
00:35:42,706 --> 00:35:44,676
我们加载了所有的数据

1103
00:35:45,226 --> 00:35:47,846
然后我们将它进行动画化 而且我们绘制了

1104
00:35:47,846 --> 00:35:48,726
一些漂亮的画面

1105
00:35:49,626 --> 00:35:52,576
那么接下来呢

1106
00:35:52,736 --> 00:35:56,036
我会鼓励大家去

1107
00:35:56,036 --> 00:35:58,106
看看 Model I/O

1108
00:35:58,316 --> 00:35:59,686
内置的其他

1109
00:35:59,686 --> 00:35:59,836
设备

1110
00:36:00,356 --> 00:36:01,816
我们还有非常多其他工具

1111
00:36:01,986 --> 00:36:04,076
可以帮助大家构建

1112
00:36:04,076 --> 00:36:04,926
自己的工具

1113
00:36:05,266 --> 00:36:07,086
你们自己的适用于管道链的

1114
00:36:07,086 --> 00:36:07,376
工具

1115
00:36:08,036 --> 00:36:10,226
例如 如果你有一个

1116
00:36:10,226 --> 00:36:12,376
由多个对象组成的场景

1117
00:36:12,776 --> 00:36:14,266
你可以进行一个光照映射

1118
00:36:14,266 --> 00:36:14,906
操作

1119
00:36:15,096 --> 00:36:17,096
Model I/O 可以制作多种

1120
00:36:17,096 --> 00:36:18,536
射线 它将让光线四处跳动

1121
00:36:19,296 --> 00:36:21,066
它会将场景作为

1122
00:36:21,066 --> 00:36:22,296
优先事项 并且为你存储

1123
00:36:22,296 --> 00:36:22,706
所有的数据

1124
00:36:23,436 --> 00:36:26,656
它还有可以做

1125
00:36:26,656 --> 00:36:28,346
紫外线解相位的工具 我们有一个

1126
00:36:28,346 --> 00:36:30,516
小的飞机 我们可以把它

1127
00:36:30,516 --> 00:36:32,316
分为小的逻辑块

1128
00:36:32,366 --> 00:36:33,366
这样就易于绘图

1129
00:36:33,976 --> 00:36:38,326
它还有其他的操作 例如

1130
00:36:38,426 --> 00:36:40,006
这里它可以计算环境光

1131
00:36:40,006 --> 00:36:40,546
遮蔽

1132
00:36:40,906 --> 00:36:42,636
例如这个小

1133
00:36:42,636 --> 00:36:44,766
飞机 我们已经做了光线投射

1134
00:36:44,766 --> 00:36:47,006
来计算从外部

1135
00:36:47,006 --> 00:36:48,256
表面的可及性并

1136
00:36:48,256 --> 00:36:49,996
进行编码

1137
00:36:49,996 --> 00:36:51,706
飞机表面有一个信号 那么

1138
00:36:51,706 --> 00:36:54,306
你的着色器对你场景中

1139
00:36:54,306 --> 00:36:55,726
对象的渲染将会更接近

1140
00:36:56,116 --> 00:36:56,866
实景

1141
00:36:56,866 --> 00:37:00,176
这里还有一件

1142
00:37:00,266 --> 00:37:01,246
你能做的有意思的事

1143
00:37:01,936 --> 00:37:04,056
我们有各种各样

1144
00:37:04,056 --> 00:37:06,156
处理 360 度图像的工具

1145
00:37:06,486 --> 00:37:07,936
它们对于为 VR 等

1146
00:37:08,056 --> 00:37:09,356
制作全景图像

1147
00:37:09,356 --> 00:37:10,206
非常有用

1148
00:37:10,916 --> 00:37:13,516
在最左边你们

1149
00:37:13,516 --> 00:37:16,546
可以看到一张 360 度的图片

1150
00:37:16,546 --> 00:37:17,646
它是用你们知道的那种

1151
00:37:17,646 --> 00:37:18,616
小相机拍摄的

1152
00:37:19,136 --> 00:37:21,056
Model I/O 可以将它转换为

1153
00:37:21,056 --> 00:37:22,396
可供硬件使用的立方体地图

1154
00:37:22,586 --> 00:37:24,136
它也可以把一个立方体地图

1155
00:37:24,136 --> 00:37:25,136
转换回为它另外一种

1156
00:37:25,136 --> 00:37:25,596
格式

1157
00:37:25,806 --> 00:37:27,416
边上两个

1158
00:37:27,416 --> 00:37:29,056
模糊的栏

1159
00:37:29,256 --> 00:37:31,626
可以为你预计算

1160
00:37:31,626 --> 00:37:35,646
基于实物着色的

1161
00:37:36,246 --> 00:37:36,936
辐照度卷积

1162
00:37:37,226 --> 00:37:38,866
我们制作了一些

1163
00:37:38,866 --> 00:37:40,276
系数可以为

1164
00:37:40,276 --> 00:37:41,276
你的着色器所用 这样如果我们

1165
00:37:41,276 --> 00:37:42,816
把一个对象放到场景中

1166
00:37:42,816 --> 00:37:43,776
它将会找到它合适的

1167
00:37:43,776 --> 00:37:44,516
物理位置

1168
00:37:44,906 --> 00:37:46,216
它里面有很多

1169
00:37:46,216 --> 00:37:46,806
类似的东西

1170
00:37:46,806 --> 00:37:47,966
希望大家可以自己去

1171
00:37:47,966 --> 00:37:48,556
探索

1172
00:37:49,186 --> 00:37:53,146
Nicolas 刚刚也提到

1173
00:37:53,366 --> 00:37:55,346
样本在会议的网站上

1174
00:37:55,546 --> 00:37:57,736
可以供大家下载

1175
00:37:57,736 --> 00:37:59,746
所以希望大家能去用

1176
00:37:59,746 --> 00:38:00,976
那个小车的代码 或者找到其他的

1177
00:38:01,116 --> 00:38:02,166
例如那些消失的轮子

1178
00:38:04,466 --> 00:38:05,956
另外还有其他的

1179
00:38:05,956 --> 00:38:07,386
有意思的环节

1180
00:38:07,386 --> 00:38:08,966
大家可以按需要观看 以了解

1181
00:38:08,966 --> 00:38:09,816
有关这些话题的更多内容

1182
00:38:10,286 --> 00:38:13,396
其他环节有 “介绍 Metal 2”

1183
00:38:13,396 --> 00:38:15,966
“SceneKit 的新功能” 还有

1184
00:38:15,966 --> 00:38:18,316
一个我想向大家推荐的是去年大会的

1185
00:38:18,316 --> 00:38:19,926
“SceneKit 的新功能”

1186
00:38:19,926 --> 00:38:21,856
在那里我们详细

1187
00:38:21,856 --> 00:38:23,756
介绍了与 USD 的

1188
00:38:23,756 --> 00:38:24,066
融合

1189
00:38:24,066 --> 00:38:28,006
2015 年的大会也有

1190
00:38:28,146 --> 00:38:30,736
介绍 Model I/O 的相关环节

1191
00:38:30,736 --> 00:38:32,376
那里我们非常详细地

1192
00:38:32,376 --> 00:38:33,586
介绍了各种数据

1193
00:38:33,586 --> 00:38:35,306
结构 以及在那些结构上的

1194
00:38:35,306 --> 00:38:36,056
操作

1195
00:38:36,626 --> 00:38:37,766
那么 就到这里

1196
00:38:38,686 --> 00:38:40,476
感谢大家的聆听 希望

1197
00:38:40,476 --> 00:38:40,976
你们喜欢

1198
00:38:41,508 --> 00:38:43,508
［掌声］

