1
00:00:21,588 --> 00:00:22,723
大家好

2
00:00:26,994 --> 00:00:28,629
欢迎参加演讲

3
00:00:28,996 --> 00:00:31,598
我是Louis Gerbarg
是dyld团队成员

4
00:00:31,798 --> 00:00:35,302
今天我们将会讨论
应用启动的过去、现在和未来

5
00:00:36,436 --> 00:00:39,239
今天的内容很多
让我们开始吧

6
00:00:39,806 --> 00:00:40,974
我想概要介绍

7
00:00:41,041 --> 00:00:43,110
今天要讲的内容

8
00:00:43,410 --> 00:00:48,682
首先我会回顾
去年我们给出的一些建议

9
00:00:49,216 --> 00:00:51,852
然后讨论我们开发的一些新工具

10
00:00:51,919 --> 00:00:56,156
这些工具可以更方便地
找到特定类型的程序启动时间问题

11
00:00:56,757 --> 00:00:59,593
然后 我简要介绍
dyld在我们平台上的

12
00:00:59,660 --> 00:01:01,962
应用历史

13
00:01:02,529 --> 00:01:06,667
接下来我想讨论我们将在
macOS High Sierra和iOS 11中

14
00:01:06,733 --> 00:01:10,137
发布的全新dyld

15
00:01:10,671 --> 00:01:14,641
最后我想讨论
这个全新dyld的最佳实践

16
00:01:16,109 --> 00:01:20,414
首先我做一下记录

17
00:01:21,882 --> 00:01:23,917
我们希望倾听你们的意见

18
00:01:24,218 --> 00:01:28,488
如果你们遇到什么问题
可以将这些问题告诉我们

19
00:01:28,555 --> 00:01:31,992
请将标题设为“DYLD USAGE”
我们将会解答这些问题

20
00:01:34,428 --> 00:01:36,363
现在我想介绍
我们将会在本演讲中

21
00:01:36,430 --> 00:01:37,598
使用的一些术语

22
00:01:38,999 --> 00:01:42,769
首先 启动时间是什么意思？

23
00:01:43,704 --> 00:01:46,874
在本演讲中
启动时间是指

24
00:01:46,940 --> 00:01:49,443
main函数执行之前所用的时间

25
00:01:49,743 --> 00:01:53,447
如果你编写一个应用
你需要做很多的事情

26
00:01:53,514 --> 00:01:57,017
完成之后
需要加载nib文件和执行其它操作

27
00:01:57,084 --> 00:01:59,419
需要运行

28
00:02:00,387 --> 00:02:02,656
UI Application Delegates代码

29
00:02:03,357 --> 00:02:07,194
这方面的知识有很多
很多演讲都曾经进行过讨论

30
00:02:07,494 --> 00:02:10,130
今天我们讨论main执行之前
所发生的事情

31
00:02:10,197 --> 00:02:11,899
以及你可以如何加速这个过程

32
00:02:12,666 --> 00:02:17,571
此外 我还想要解释
启动收尾 这是一个新术语

33
00:02:18,505 --> 00:02:21,975
启动收尾是指启动你的程序

34
00:02:22,042 --> 00:02:23,343
所需要的全部信息

35
00:02:23,577 --> 00:02:27,714
比如使用什么dylib
它们的哪些偏移位置用于不同的符号

36
00:02:27,781 --> 00:02:29,550
代码签名是什么

37
00:02:31,118 --> 00:02:34,721
让我们进入演讲的主题

38
00:02:35,589 --> 00:02:39,226
去年我说过

39
00:02:39,293 --> 00:02:42,062
我们应该减少代码
我仍然会强调这一点

40
00:02:42,129 --> 00:02:45,532
因为代码越少 启动就越快

41
00:02:45,799 --> 00:02:49,403
无论我们如何加速
代码越少

42
00:02:49,469 --> 00:02:50,737
启动速度就越快

43
00:02:51,672 --> 00:02:53,874
这个建议始终适用

44
00:02:54,608 --> 00:02:59,713
你应该使用更少的dylib
减少嵌入的dylib

45
00:02:59,780 --> 00:03:02,249
从时间的角度来看

46
00:03:02,583 --> 00:03:04,685
使用系统库效果更好
我们将会探讨这一点

47
00:03:05,419 --> 00:03:08,388
应该声明较少的库和方法

48
00:03:08,455 --> 00:03:11,558
减少初始化函数

49
00:03:13,627 --> 00:03:16,396
最后我将会介绍一些事半功倍的方法

50
00:03:16,463 --> 00:03:19,533
你可以使用更多的Swift代码

51
00:03:19,600 --> 00:03:24,204
因为Swift从设计上
避免许多的陷阱

52
00:03:24,271 --> 00:03:27,341
在使用C、C++ 和
Objective-C可能会遇到这些陷阱

53
00:03:27,407 --> 00:03:29,443
Swift没有初始化器

54
00:03:29,910 --> 00:03:32,513
Swift不允许特定类型的
未对齐数据结构

55
00:03:32,579 --> 00:03:34,481
这样的结构会延长启动时间

56
00:03:34,548 --> 00:03:36,617
总的来说 转向Swift

57
00:03:36,683 --> 00:03:41,388
让你更容易获得快速的程序启动

58
00:03:42,523 --> 00:03:45,993
Swift代码更精简
因此性能更好

59
00:03:46,059 --> 00:03:48,762
因此请转移到
我们今年发布的新Swift

60
00:03:48,829 --> 00:03:51,532
将会提供更多的好处

61
00:03:51,965 --> 00:03:54,902
现在我们来看

62
00:03:57,371 --> 00:04:01,175
iOS 11和
macOS High Sierra中的新工具

63
00:04:01,241 --> 00:04:05,012
我们在Instruments中
加入静态初始化器跟踪

64
00:04:05,078 --> 00:04:06,413
缩短应用启动时间

65
00:04:06,480 --> 00:04:09,983
这是非常不错的功能
因为初始化器是代码

66
00:04:10,050 --> 00:04:13,453
它们在main函数之前运行
为你设置对象

67
00:04:13,520 --> 00:04:16,557
你并不能透彻地
了解main执行之前的情况

68
00:04:17,391 --> 00:04:19,625
现在Instruments
增加这个功能

69
00:04:19,692 --> 00:04:22,596
提供每个静态初始化器的准确时间

70
00:04:22,663 --> 00:04:25,432
现在我进行演示

71
00:04:25,732 --> 00:04:31,438
这里有一个应用
与WWDC上的大多数应用一样

72
00:04:31,505 --> 00:04:34,474
它也使用一些可爱的动物图片

73
00:04:35,142 --> 00:04:36,410
让我启动它

74
00:04:37,744 --> 00:04:41,248
这需要一定时间

75
00:04:42,649 --> 00:04:45,152
还需要一点时间

76
00:04:45,219 --> 00:04:48,755
启动后 我们看到几只灰鼠和猫

77
00:04:50,791 --> 00:04:54,962
让我们来看为什么
需要这么长的启动时间

78
00:04:55,596 --> 00:04:58,765
我会在Instruments中
进行分析

79
00:04:58,832 --> 00:05:04,238
我停止执行这行代码
然后运行

80
00:05:05,973 --> 00:05:09,710
现在我启动一个空模板

81
00:05:10,944 --> 00:05:13,480
添加新静态初始化器工具

82
00:05:15,849 --> 00:05:17,551
就在这里

83
00:05:17,618 --> 00:05:19,720
然后我添加一个
Time Profiler

84
00:05:19,786 --> 00:05:22,422
这样就很容易看到运行情况

85
00:05:28,295 --> 00:05:29,129
开始运行

86
00:05:29,830 --> 00:05:33,433
设置好这些工具之后
我们开始运行程序

87
00:05:35,235 --> 00:05:37,704
我们获得跟踪数据

88
00:05:38,906 --> 00:05:41,008
还没有出现

89
00:05:41,074 --> 00:05:44,378
现在出现了
在背景中可以看到

90
00:05:45,646 --> 00:05:47,014
出现显示内容

91
00:05:47,080 --> 00:05:49,683
我会放大
让你们看得更清楚

92
00:05:50,350 --> 00:05:53,453
这里有一个函数名为
waitForNetworkDebugger

93
00:05:53,520 --> 00:05:54,955
这是正确的
因为我正在从网站

94
00:05:55,022 --> 00:05:58,125
加载数据源

95
00:05:58,692 --> 00:06:00,561
我尝试进行调试

96
00:06:00,627 --> 00:06:04,898
让我们来看CPU Usage工具

97
00:06:04,965 --> 00:06:10,771
可以看到初始化器运行时间
与CPU占用时间基本相同

98
00:06:11,271 --> 00:06:14,107
在这里 可以看到dyld

99
00:06:15,609 --> 00:06:20,614
如果我这样做
可以看到哪些处理占用时间

100
00:06:21,148 --> 00:06:24,952
所用时间为9.5秒

101
00:06:25,018 --> 00:06:29,823
初始化器占用9.5秒
我们展开很多层

102
00:06:29,890 --> 00:06:33,160
通常你不用这样做
我是为了让你们看清楚运行情况

103
00:06:34,728 --> 00:06:38,298
在这里我们可以看到
waitForNetworkDebugger

104
00:06:38,365 --> 00:06:40,000
我们在初始化器调用中
见到过它

105
00:06:40,067 --> 00:06:42,336
现在你很容易找到它

106
00:06:42,703 --> 00:06:48,041
现在我返回Xcode

107
00:06:48,509 --> 00:06:52,579
看到了
这是waitForNetworkDebugger调用

108
00:06:52,646 --> 00:06:54,648
我使用C语言实现它

109
00:06:54,715 --> 00:06:56,683
因为Swift不允许做这样的事情

110
00:06:57,117 --> 00:07:01,088
我在这里创建构造函数

111
00:07:01,154 --> 00:07:03,190
如果我返回源代码

112
00:07:05,926 --> 00:07:09,930
我可以删除这个函数

113
00:07:10,931 --> 00:07:12,866
因为它仅用于调试目的

114
00:07:13,534 --> 00:07:18,238
如果运行 程序将会立即启动

115
00:07:18,906 --> 00:07:21,542
因此我们可以快速地发现

116
00:07:21,608 --> 00:07:24,144
哪些堆栈初始化器
导致启动变慢

117
00:07:24,211 --> 00:07:27,047
这涉及多个dylib

118
00:07:27,114 --> 00:07:29,383
包括系统dylib
这些系统库会占用很长时间

119
00:07:29,449 --> 00:07:32,853
这是你为它们提供的输入造成的
比如复杂的nib文件

120
00:07:33,487 --> 00:07:39,760
这依赖于High Sierra
和iOS 11的内核

121
00:07:39,826 --> 00:07:43,597
和dyld中的新基础结构
你需要新生成程序才能看到这些信息

122
00:07:43,897 --> 00:07:46,867
现在可以捕获大多数初始化器
我们还在努力捕获

123
00:07:46,934 --> 00:07:50,737
一些边界例子
但是目前你已经能够

124
00:07:50,804 --> 00:07:54,608
快速地发现
是什么占用程序启动时间

125
00:07:54,675 --> 00:07:57,711
让你能够解决问题
更快速地启动程序

126
00:07:57,778 --> 00:07:59,279
提供更好的用户体验

127
00:07:59,580 --> 00:08:00,447
谢谢

128
00:08:05,552 --> 00:08:09,022
前面我说过
我们会简要地回顾dyld的历史

129
00:08:10,023 --> 00:08:12,526
跨世纪的动态链接技术

130
00:08:12,893 --> 00:08:15,762
很早以前我们就已经推出dyld

131
00:08:15,829 --> 00:08:19,199
它们没有版本号

132
00:08:19,266 --> 00:08:23,770
这是dyld 1
包含在NeXTStep 3.3中

133
00:08:24,972 --> 00:08:26,640
可以追溯到1996年

134
00:08:26,707 --> 00:08:31,645
此前 NeXT使用静态二进制数据

135
00:08:32,513 --> 00:08:38,552
作用并不是很大 其历史早于
标准化POSIX dlopen调用

136
00:08:38,619 --> 00:08:40,854
现在dlopen还存在于
某些Unix之中

137
00:08:40,921 --> 00:08:44,591
它们是一些专用扩展
被开发者所采用

138
00:08:45,092 --> 00:08:48,061
NeXTStep
具有不同的专用扩展

139
00:08:48,128 --> 00:08:52,399
因此开发者在macOS 10
的早期版本上编写第三方包装器

140
00:08:52,466 --> 00:08:54,401
以支持标准Unix软件

141
00:08:54,768 --> 00:08:58,005
问题是这些包装器
并不能完美地支持相同的语义

142
00:08:58,071 --> 00:09:00,607
因此可能有一些边界例子
不能正常工作

143
00:09:00,674 --> 00:09:02,743
因此会造成运行缓慢

144
00:09:03,143 --> 00:09:07,848
它是在大多数使用
C++ 动态库的系统之前编写的

145
00:09:07,915 --> 00:09:09,149
这些知识很重要

146
00:09:09,550 --> 00:09:13,520
C++ 有许多的特性
比如其初始化器排序方式等

147
00:09:13,587 --> 00:09:17,791
它们在静态环境中工作良好

148
00:09:17,858 --> 00:09:20,027
但是在动态环境中

149
00:09:20,093 --> 00:09:22,930
可能会降低性能

150
00:09:23,030 --> 00:09:24,631
因此大型C++代码库

151
00:09:24,698 --> 00:09:29,636
导致动态链接器
需要完成大量的工作 速度变慢

152
00:09:33,140 --> 00:09:38,579
在发布macOS 10.0和
Cheetah前 我们还增加另外一个特性

153
00:09:38,645 --> 00:09:40,113
名称为预绑定

154
00:09:40,581 --> 00:09:44,685
你们一些人知道预绑定技术

155
00:09:46,220 --> 00:09:48,622
我知道你们会感到困惑

156
00:09:48,689 --> 00:09:52,392
我们使用预绑定技术
为系统中的所有dylib和你的程序

157
00:09:52,459 --> 00:09:56,330
找到固定地址

158
00:09:56,630 --> 00:09:59,967
动态加载器将会
加载这些地址的所有内容

159
00:10:00,033 --> 00:10:04,104
如果成功 将会编辑
所有这些二进制数据

160
00:10:04,171 --> 00:10:07,241
以获得所有预计算地址
然后下次

161
00:10:07,307 --> 00:10:10,878
当它将所有数据放入相同地址时
不必进行任何其它额外的工作

162
00:10:11,144 --> 00:10:13,580
这会大幅提高速度

163
00:10:14,248 --> 00:10:19,086
但是这也意味着
每次启动时会编辑你的二进制数据

164
00:10:19,520 --> 00:10:22,256
这并不是很好的做法

165
00:10:22,322 --> 00:10:23,991
至少从安全性来说是如此

166
00:10:25,893 --> 00:10:29,530
后来我们推出dyld 2
它是macOS Tiger的组成部分

167
00:10:30,264 --> 00:10:34,234
dyld 2是dyld的
完全重写版本

168
00:10:36,069 --> 00:10:38,805
正确支持C++初始化器语义

169
00:10:38,872 --> 00:10:44,511
我们扩展mach-o格式
并且更新dyld

170
00:10:44,578 --> 00:10:47,347
从而获得高效率的C++库支持

171
00:10:47,848 --> 00:10:51,251
它具有完整的本机dlopen
和dlsym实现

172
00:10:51,318 --> 00:10:54,988
具有正确的语义
我们弃用旧版API

173
00:10:55,055 --> 00:10:58,992
这些旧版API仍然位于macOS中
没有加入到我们的任何其它平台上

174
00:11:00,827 --> 00:11:02,996
dyld的设计目标是提高速度

175
00:11:03,463 --> 00:11:06,934
因此仅进行有限的健全性检查

176
00:11:07,000 --> 00:11:10,237
以前 恶意程序并不多

177
00:11:11,271 --> 00:11:15,142
由于它有一些安全问题

178
00:11:15,209 --> 00:11:20,414
因此我们对一些功能进行改进
提高它在现在平台上的安全性

179
00:11:21,215 --> 00:11:25,185
由于其速度大幅提升
因此我们可以减少预绑定工作量

180
00:11:25,252 --> 00:11:30,524
不同于编辑你的程序数据
我们仅编辑系统库

181
00:11:30,591 --> 00:11:33,927
可以仅在软件更新时
做这些事情

182
00:11:33,994 --> 00:11:37,097
因此在软件安装过程中

183
00:11:37,164 --> 00:11:41,735
你可能会看到
“优化系统性能”之类的文字

184
00:11:41,802 --> 00:11:46,473
这时就是在更新预绑定

185
00:11:46,540 --> 00:11:48,909
现在dyld用于所有优化

186
00:11:48,976 --> 00:11:50,477
其用途就是优化

187
00:11:51,745 --> 00:11:54,414
因此后来我们发布了dyld 2

188
00:11:55,215 --> 00:11:59,386
在过去几年我们进行大量改进
性能显著提高

189
00:11:59,453 --> 00:12:04,258
首先 我们增加了
大量的基础结构和平台

190
00:12:05,158 --> 00:12:07,961
自从dyld 2
在PowerPC发布之后

191
00:12:08,028 --> 00:12:13,033
我们增加了x86、 x86 64 arm
arm64和许多的衍生平台

192
00:12:13,667 --> 00:12:16,170
我们还推出iOS、tvOS
和watchOS

193
00:12:16,236 --> 00:12:18,939
它们全部都需要新dyld功能

194
00:12:20,040 --> 00:12:23,177
我们通过多种方式增强安全性

195
00:12:23,710 --> 00:12:26,980
增加代码签名和ASLR

196
00:12:27,047 --> 00:12:30,384
也就是地址空间配置随机加载

197
00:12:31,185 --> 00:12:33,253
这意味着每次你加载库

198
00:12:33,320 --> 00:12:34,788
它可能位于不同的地址

199
00:12:35,455 --> 00:12:38,759
如果想要了解更多详细信息
请观看去年的演讲

200
00:12:38,825 --> 00:12:43,897
在此演讲中Nick详细介绍了
如何启动程序

201
00:12:43,964 --> 00:12:46,066
最后 我们增加了
mach-o文件头中的项目

202
00:12:46,133 --> 00:12:48,001
这是重要的边界检查功能

203
00:12:48,068 --> 00:12:51,772
从而可以避免恶意二进制数据的加入

204
00:12:52,906 --> 00:12:55,776
最后 我们增强了性能

205
00:12:55,843 --> 00:12:59,580
因此我们可以消除预绑定

206
00:12:59,646 --> 00:13:02,616
转而使用共享代码

207
00:13:03,150 --> 00:13:05,085
那么什么是共享代码？

208
00:13:06,286 --> 00:13:10,958
共享代码最早被引入和iOS 3.1
和macOS Snow Leopard

209
00:13:11,825 --> 00:13:14,161
并且完全取代预绑定

210
00:13:14,895 --> 00:13:18,565
它是一个单文件
含有大多数系统dylib

211
00:13:18,999 --> 00:13:20,734
由于合并成一个文件

212
00:13:20,801 --> 00:13:22,736
因此可以进行优化

213
00:13:22,970 --> 00:13:25,272
我们重新调整所有文本段

214
00:13:25,339 --> 00:13:28,675
和所有数据段重写整个符号表

215
00:13:28,742 --> 00:13:33,180
以减小大小
从而在每个进程中

216
00:13:33,247 --> 00:13:34,781
仅挂载少量的区域

217
00:13:35,315 --> 00:13:38,852
它允许我们打包二进制数据段
节省大量的RAM

218
00:13:39,720 --> 00:13:42,823
它实际上是dylib预链接器

219
00:13:43,423 --> 00:13:47,327
我并不会讨论特定的优化结果

220
00:13:47,728 --> 00:13:50,898
但是它的RAM节约是显著的
在普通iOS系统上

221
00:13:50,964 --> 00:13:55,836
运行时可以节约500M-1GB内存

222
00:13:57,571 --> 00:14:01,208
它还预生成数据结构
供dyld和Ob-C

223
00:14:01,275 --> 00:14:03,911
在运行时使用
让我们不必在程序启动时做这些事情

224
00:14:03,977 --> 00:14:06,513
这也会节约更多RAM和时间

225
00:14:07,748 --> 00:14:12,186
共享代码在macOS上本地生成
运行dyld共享代码

226
00:14:12,252 --> 00:14:14,688
将会大幅优化系统性能

227
00:14:14,755 --> 00:14:16,623
并且带来其它好处

228
00:14:16,890 --> 00:14:19,860
在我们的其它平台上
我们在Apple生成共享代码

229
00:14:19,927 --> 00:14:21,061
然后提供给你

230
00:14:22,629 --> 00:14:24,865
刚才我讨论了共享代码

231
00:14:24,932 --> 00:14:27,768
接下来我介绍dyld 3

232
00:14:28,735 --> 00:14:33,473
dyld 3是全新的动态链接器
今天我们宣布推出它

233
00:14:34,641 --> 00:14:37,411
它完全改变动态链接概念

234
00:14:38,445 --> 00:14:42,816
将成为大多数

235
00:14:42,883 --> 00:14:44,484
macOS系统程序的默认设置

236
00:14:45,719 --> 00:14:48,355
2017 Apple OS平台上的
所有系统程序

237
00:14:48,422 --> 00:14:52,025
都会默认使用它

238
00:14:53,660 --> 00:14:57,297
在未来的Apple OS平台
和第三方程序中

239
00:14:57,364 --> 00:14:59,333
它将会全面取代dyld2

240
00:15:00,300 --> 00:15:04,271
那么 我们为什么要再次使用
动态链接器呢？

241
00:15:06,373 --> 00:15:08,675
首先是为了性能

242
00:15:08,742 --> 00:15:10,511
性能是一个永恒的主题

243
00:15:10,577 --> 00:15:13,647
我们想要尽量提高启动速度

244
00:15:14,381 --> 00:15:17,184
我们认为 它可以帮助

245
00:15:17,251 --> 00:15:19,219
我们获得最快的

246
00:15:19,286 --> 00:15:22,723
程序启动和运行速度

247
00:15:23,423 --> 00:15:29,329
其次是安全性 前面我说过
我们在dyld2中增加了些安全特性

248
00:15:29,396 --> 00:15:32,366
但是很难跟随现实情形
增强安全性

249
00:15:32,533 --> 00:15:35,335
过去几年我们做了很多的工作

250
00:15:35,402 --> 00:15:38,839
但是难以实现这个目标

251
00:15:39,740 --> 00:15:42,109
那么我们是否能够
进行更积极的安全检查

252
00:15:42,176 --> 00:15:44,178
并且从设计上提高安全性？

253
00:15:45,112 --> 00:15:48,148
最后是可测试性和可靠性

254
00:15:48,482 --> 00:15:50,317
我们能否让dyld变得更容易测试？

255
00:15:50,384 --> 00:15:53,921
为此Apple发布了很多不错的
测试框架 比如XCTest

256
00:15:53,987 --> 00:15:56,690
我们应该使用它们

257
00:15:56,757 --> 00:15:59,459
但是它们依赖于
动态链接器的底层功能

258
00:15:59,526 --> 00:16:03,897
将它们的库插入进程
因此它们不能用于

259
00:16:03,964 --> 00:16:05,933
测试现有的dyld代码

260
00:16:05,999 --> 00:16:09,703
这让我们难以测试安全性和性能水平

261
00:16:10,938 --> 00:16:13,440
我们应该如何做呢？

262
00:16:13,507 --> 00:16:17,177
我们将大多数dyld移出进程

263
00:16:19,079 --> 00:16:21,882
现在它只是普通的后台程序

264
00:16:21,949 --> 00:16:25,285
可以使用标准测试工具进行测试

265
00:16:25,352 --> 00:16:26,186
这让我们以后

266
00:16:26,253 --> 00:16:28,956
进一步提高速度和性能

267
00:16:30,157 --> 00:16:35,095
另外也允许部分dyld
驻留在进程之中

268
00:16:35,162 --> 00:16:40,367
但是驻留部分尽可小
从而减少程序的受攻击面积

269
00:16:42,135 --> 00:16:45,772
由于代码速度提升

270
00:16:45,839 --> 00:16:47,708
因此会提高启动速度

271
00:16:48,542 --> 00:16:51,545
代码运行速度是前所未有的

272
00:16:52,379 --> 00:16:53,780
为了让你知道我们是如何做到的

273
00:16:53,847 --> 00:16:57,985
我将简要演示
dyld 2如何启动程序

274
00:16:58,051 --> 00:17:01,855
在去年的“缩短程序启动时间”演讲中

275
00:17:01,922 --> 00:17:04,458
我们更详细地讨论了这个主题

276
00:17:04,525 --> 00:17:06,593
你可以观看那个演讲视频

277
00:17:06,660 --> 00:17:08,095
这是一个不错的主意

278
00:17:08,262 --> 00:17:11,865
当然你也可以听我的演讲
我会简要介绍

279
00:17:12,699 --> 00:17:16,637
我们使用dyld 2
你的程序开始启动

280
00:17:16,703 --> 00:17:19,006
我们需要分析你的mach-o文件

281
00:17:19,306 --> 00:17:22,276
弄清楚你需要哪些库

282
00:17:22,776 --> 00:17:27,247
它们可能需要其它库
我们进行递归分析

283
00:17:27,314 --> 00:17:29,483
直到获得所有dylib的完整图

284
00:17:29,550 --> 00:17:33,820
普通iOS程序
需要3-600个dylib

285
00:17:33,887 --> 00:17:35,622
数据庞大 需要进行大量的处理

286
00:17:36,924 --> 00:17:41,328
然后我们映射到所有mach-o文件
将它们放入地址空间

287
00:17:42,462 --> 00:17:45,499
然后执行符号查找

288
00:17:45,566 --> 00:17:47,167
若你的程序使用printf函数

289
00:17:47,234 --> 00:17:50,003
将会查找printf是否在库系统中

290
00:17:50,504 --> 00:17:51,872
然后我们找到它的地址

291
00:17:51,939 --> 00:17:55,275
将它复制到你的程序中的函数指针

292
00:17:56,577 --> 00:17:59,112
我们进行绑定和基址重置

293
00:17:59,179 --> 00:18:03,283
复制这些指针
由于使用随机地址

294
00:18:03,350 --> 00:18:06,486
所有指针必须使用基址

295
00:18:07,454 --> 00:18:09,489
最后 我们可以运行
你的所有初始化器

296
00:18:09,556 --> 00:18:11,558
因此前面我展示这个工具

297
00:18:11,625 --> 00:18:13,827
这时 我们准备执行main函数

298
00:18:13,894 --> 00:18:15,395
这里进行了大量的工作

299
00:18:15,929 --> 00:18:19,266
我们如何加快其速度
将这些步骤移出进程呢？

300
00:18:19,333 --> 00:18:23,837
首先我确定安全敏感性组件

301
00:18:24,104 --> 00:18:26,773
从我们的角度来看
最大的安全隐患之一

302
00:18:26,840 --> 00:18:29,943
分析mach-o文件头
和查找依赖关系

303
00:18:30,010 --> 00:18:34,014
因此人们可以使用
撰改过的mach-o文件头进行攻击

304
00:18:34,081 --> 00:18:39,152
而且你 的程序可能使用
@rpaths 它们是搜索路径

305
00:18:39,219 --> 00:18:43,190
通过撰改这些路径
或者将库插到适当的位置

306
00:18:43,257 --> 00:18:45,292
可以破坏程序

307
00:18:45,459 --> 00:18:49,062
因此我们在后台程序的进程之外
完成所有这些工作

308
00:18:49,630 --> 00:18:53,734
然后我们确定大量占用资源的部分
也就是占用缓冲的部分

309
00:18:53,800 --> 00:18:56,937
它们是符号查找
因为在给定的库中

310
00:18:57,004 --> 00:19:00,774
除非进行软件更新
或者在磁盘上更改库

311
00:19:00,841 --> 00:19:03,810
符号将始终位于库中的相同偏移位置

312
00:19:04,311 --> 00:19:08,015
我们已经确定这些内容
我们来看它们在dyld3中是怎样的

313
00:19:11,552 --> 00:19:15,923
我们将这些部分移到上层
然后向磁盘写入收尾处理

314
00:19:15,989 --> 00:19:20,861
前面我说过 启动收尾处理
是启动程序的重要环节

315
00:19:22,429 --> 00:19:29,303
稍后可以在进程中使用它
dyld 3包含这三个部分

316
00:19:30,170 --> 00:19:33,407
它是一个进程外
mach-o分析器和编译器

317
00:19:34,141 --> 00:19:37,678
也是一个进程内引擎
执行启动收尾处理

318
00:19:38,779 --> 00:19:41,381
也是一个启动收尾缓存服务

319
00:19:43,150 --> 00:19:45,786
大多数程序启动会使用缓存

320
00:19:45,853 --> 00:19:48,555
但始终不需要调用进程外
mach-o分析器或编译器

321
00:19:50,524 --> 00:19:53,760
启动收尾比mach-o更简单

322
00:19:54,261 --> 00:19:57,731
它们是内存映射文件
不需要用复杂的方法进行分析

323
00:19:57,798 --> 00:20:00,801
我们可以简单地验证它们
其作用是为了提高速度

324
00:20:03,470 --> 00:20:06,340
让我们来详细看每个部分

325
00:20:06,406 --> 00:20:10,077
因此 dyld 3
是进程外mach-o分析器

326
00:20:10,844 --> 00:20:14,014
它解析所有搜索路径

327
00:20:14,248 --> 00:20:16,316
所有rpaths
所有环境变量

328
00:20:16,383 --> 00:20:17,851
它们会影响你的启动

329
00:20:18,352 --> 00:20:20,687
然后分析mach-o二进制数据

330
00:20:21,188 --> 00:20:23,223
执行所有符号查找

331
00:20:25,192 --> 00:20:27,561
利用这些结果创建收尾处理

332
00:20:28,495 --> 00:20:29,796
它是普通的后台程序

333
00:20:29,863 --> 00:20:32,766
让我们提高测试基础架构的性能

334
00:20:34,801 --> 00:20:37,671
dyld也是一个小型进程内引擎

335
00:20:37,738 --> 00:20:40,007
这部分驻留在进程中

336
00:20:40,073 --> 00:20:41,909
是你通常会看到的部分

337
00:20:42,442 --> 00:20:46,213
它所做的事情是
检查启动收尾处理是否正确

338
00:20:47,114 --> 00:20:50,651
然后映射到dylib之中
再跳转到main函数

339
00:20:50,717 --> 00:20:52,519
你可能会注意到

340
00:20:52,953 --> 00:20:56,590
dyld3不需要分析mach-o
文件头或执行符号查找

341
00:20:56,657 --> 00:20:59,326
不需要做这些事情
就可以启动你的应用

342
00:20:59,393 --> 00:21:01,895
由于这些是花费时间的部分

343
00:21:02,296 --> 00:21:05,132
因此可以极大提高程序启动速度

344
00:21:06,600 --> 00:21:11,371
最后 dyld 3
还是一个启动收尾缓存服务

345
00:21:11,438 --> 00:21:14,241
这是什么意思呢？

346
00:21:14,308 --> 00:21:18,946
我们将系统程序收尾
直接加入到共享缓存

347
00:21:19,012 --> 00:21:22,449
我们已使用这个工具在系统中
运行和分析每个mach-o文件

348
00:21:23,083 --> 00:21:26,320
我们可以直接将它们
放入共享缓存 使它映射到缓存中

349
00:21:26,386 --> 00:21:30,357
所有dylib都使用它来启动
我们甚至不需要打开其它文件

350
00:21:31,825 --> 00:21:37,397
对于第三方程序
我们在程序安装或系统更新

351
00:21:37,464 --> 00:21:41,668
生成你的收尾处理
因为那时系统库已经发生更改

352
00:21:41,768 --> 00:21:47,407
默认情况下 将在iOS、tvOS
和watchOS上生成收尾处理

353
00:21:47,474 --> 00:21:48,909
甚至在程序运行之前

354
00:21:49,843 --> 00:21:54,248
在macOS上 由于可以
侧向加载程序 如果需要

355
00:21:54,314 --> 00:21:59,486
进程内引擎可以在首次启动时
RPC到后台程序

356
00:22:00,521 --> 00:22:03,991
在此之后 能够使用缓存的收尾处理

357
00:22:05,459 --> 00:22:09,696
正如前面我说的那样
在我们的其它平台上并不需要这样做

358
00:22:10,664 --> 00:22:13,467
我介绍了今年我们将会用于系统程序的

359
00:22:13,534 --> 00:22:16,303
这个新动态链接器
以后你们也会使用它

360
00:22:16,436 --> 00:22:19,439
我想谈一谈可能会存在的问题

361
00:22:19,506 --> 00:22:21,975
让你现在就可以开始更新你的程序

362
00:22:22,709 --> 00:22:23,877
为DYLD 3而准备

363
00:22:23,944 --> 00:22:27,881
首先它完全兼容dyld 2.x

364
00:22:27,948 --> 00:22:31,518
因此一些现有API

365
00:22:31,585 --> 00:22:35,989
会导致你的程序运行变慢
或者会在dyld 3中使用回退模式

366
00:22:36,056 --> 00:22:39,226
我们希望你们避免这个问题
稍后我们再讨论这个问题

367
00:22:39,293 --> 00:22:41,962
另外 你所做的一些优化

368
00:22:42,029 --> 00:22:46,099
现在可能已经不再需要

369
00:22:46,166 --> 00:22:49,403
因此不需要在这方面
花费过多力气

370
00:22:49,603 --> 00:22:50,704
我想要说的另一件事情是

371
00:22:50,771 --> 00:22:52,940
我们将会使用更严格的链接语义

372
00:22:53,006 --> 00:22:53,907
这是什么意思？

373
00:22:53,974 --> 00:22:59,780
很多的语义现在还无法使用

374
00:22:59,847 --> 00:23:04,518
现在甚至是错误的
在加入新动态链接器时

375
00:23:04,585 --> 00:23:06,920
我们发现很多这样的情况

376
00:23:06,987 --> 00:23:09,256
目的是为了发现所有的边界例子

377
00:23:09,590 --> 00:23:13,427
我们所做的事情
放入一个工作区以支持旧二进制数据

378
00:23:14,127 --> 00:23:16,363
但是我们并不想更进一步

379
00:23:16,430 --> 00:23:19,466
我们将会进行链接或后续检查
查看你使用哪些SDK

380
00:23:19,533 --> 00:23:23,203
然后我们将禁用新二进制数据的工作区

381
00:23:23,270 --> 00:23:27,341
让你能够解决这些问题

382
00:23:28,408 --> 00:23:30,611
新二进制数据将会造成链接器问题

383
00:23:31,945 --> 00:23:36,149
接下来我想讨论
数据段中的未对齐指针

384
00:23:36,216 --> 00:23:37,384
我说的是什么意思呢？

385
00:23:37,451 --> 00:23:40,187
假设你有一个全局性结构

386
00:23:40,254 --> 00:23:43,824
指向一个函数
或另外一个全局性函数

387
00:23:43,891 --> 00:23:46,927
在你的程序启动之前
我们必须修复这个指针

388
00:23:46,994 --> 00:23:51,899
在我们的系统上
指针必须自然对齐以获得最佳性能

389
00:23:53,166 --> 00:23:57,337
修复未对齐指针非常复杂

390
00:23:57,571 --> 00:24:01,041
它们可能覆盖多个内存页
造成更多的内存页错误

391
00:24:01,108 --> 00:24:03,744
和其它问题
这可能会产生与多处理器相关的

392
00:24:04,378 --> 00:24:06,847
细微问题

393
00:24:07,915 --> 00:24:10,851
静态链接器已经忽略这个警告

394
00:24:12,252 --> 00:24:14,588
ld警告 指针地址未对齐

395
00:24:14,655 --> 00:24:17,157
这是你的数据段所在的位置

396
00:24:18,325 --> 00:24:19,860
如果你消除所有警告

397
00:24:19,927 --> 00:24:22,596
那么问题已经得到解决

398
00:24:23,030 --> 00:24:26,266
本周我们提供的源代码
存在一些Swift键径问题

399
00:24:26,333 --> 00:24:28,669
但是它们将会被修复
你可以忽略这些问题

400
00:24:28,735 --> 00:24:31,138
但是你们可以修复这些问题

401
00:24:31,905 --> 00:24:34,374
如果你们想知道如何做

402
00:24:34,441 --> 00:24:36,276
我将会展示给你们看

403
00:24:36,343 --> 00:24:38,812
这需要大量的工作

404
00:24:38,879 --> 00:24:41,782
但是你不能在Swift中做这些事情

405
00:24:42,316 --> 00:24:45,519
请看这里的代码

406
00:24:46,553 --> 00:24:51,058
这里有一些强制进行对齐的属性

407
00:24:51,124 --> 00:24:54,127
默认情况下
编译器将会为你进行正确的对齐

408
00:24:54,194 --> 00:24:56,263
但是有些时候
你可能需要特殊的对齐

409
00:24:56,330 --> 00:24:57,564
在本例中

410
00:24:57,631 --> 00:25:00,133
默认对齐规则要求进行对齐

411
00:25:00,200 --> 00:25:03,270
我使用了两种方法
但是结果很糟糕

412
00:25:03,337 --> 00:25:04,872
你必须进行修复

413
00:25:05,772 --> 00:25:09,576
然后我构建一个全局变量

414
00:25:09,643 --> 00:25:12,246
这个变量在结构中设置指针

415
00:25:12,312 --> 00:25:13,747
这将会强制动态链接器

416
00:25:13,814 --> 00:25:16,650
在程序启动时修复指针

417
00:25:17,217 --> 00:25:21,421
如果你看到这样的代码
可以清除所有对齐

418
00:25:21,788 --> 00:25:24,892
重新调整结构
将指针放在前面

419
00:25:24,958 --> 00:25:26,894
由于这更有利于对齐

420
00:25:27,094 --> 00:25:29,396
关于C结构对齐
网上有很多的资料

421
00:25:29,463 --> 00:25:31,265
你可以查看

422
00:25:31,331 --> 00:25:34,368
但是希望你不必进行这样的处理

423
00:25:34,434 --> 00:25:37,037
如果你编写Swift代码
你肯定不必这样做

424
00:25:38,772 --> 00:25:42,342
接下来 我们讨论符号解析

425
00:25:42,576 --> 00:25:43,844
这里的含义是什么？

426
00:25:44,211 --> 00:25:47,481
dyld 2执行懒符号解析

427
00:25:48,015 --> 00:25:51,218
dyld必须加载所有符号

428
00:25:51,285 --> 00:25:53,687
这需要占用大量资源
因此应该使用缓存

429
00:25:53,754 --> 00:26:00,294
直接运行现有程序
确实会占用很多资源

430
00:26:00,360 --> 00:26:01,562
将会花费很长时间

431
00:26:01,762 --> 00:26:05,866
为此我们使用一种机制
名称为懒符号解析

432
00:26:05,933 --> 00:26:10,671
默认情况下 库中的函数指针
比如printf

433
00:26:10,737 --> 00:26:12,105
并不指向printf

434
00:26:12,439 --> 00:26:17,044
默认情况下
它指向dyld中的一个函数

435
00:26:17,110 --> 00:26:19,580
此函数返回一个
指向printf的函数指针

436
00:26:20,113 --> 00:26:24,651
因此启动时
调用printf将会进入dyld

437
00:26:24,718 --> 00:26:28,388
返回printf进行首次调用

438
00:26:28,455 --> 00:26:30,958
然后第二次
你直接调用printf

439
00:26:31,925 --> 00:26:35,495
由于我们已经缓存并且计算所有符号

440
00:26:35,562 --> 00:26:37,264
因此在程序启动时不会产生额外开销

441
00:26:37,331 --> 00:26:40,901
来绑定它们 我们将会这样做

442
00:26:42,035 --> 00:26:46,974
当你这样做时
缺失符号的行为将会有所不同

443
00:26:47,307 --> 00:26:51,078
在现有懒符号机制中
如果缺失一个符号

444
00:26:51,144 --> 00:26:53,380
首次调用 将会正确启动

445
00:26:53,447 --> 00:26:55,983
首次调用该符号
程序将会崩溃

446
00:26:56,350 --> 00:26:59,253
如果使用勤符号 将会立即崩溃

447
00:27:00,053 --> 00:27:00,988
为此…

448
00:27:03,657 --> 00:27:05,993
我们提供一个兼容模式

449
00:27:06,059 --> 00:27:07,828
我们要做的是

450
00:27:08,529 --> 00:27:14,835
我们将导致自动崩溃的符号
放入dyld 3

451
00:27:14,902 --> 00:27:17,971
如果不能找到你的符号
我们将会绑定该符号

452
00:27:18,038 --> 00:27:19,673
因此首次调用将会崩溃

453
00:27:20,207 --> 00:27:22,809
这是现在的SDK的工作模式

454
00:27:22,876 --> 00:27:27,014
在未来的SDK中 我们将强制
预先进行所有符号解析

455
00:27:27,080 --> 00:27:29,149
如果你缺失一个符号
将会崩溃

456
00:27:29,216 --> 00:27:32,819
在开发过程中
你应该能够发现这些崩溃现象

457
00:27:32,886 --> 00:27:35,355
而不是用户在程序运行时发现它们

458
00:27:36,557 --> 00:27:38,325
现在你可以模拟这些行为

459
00:27:38,392 --> 00:27:43,497
有一个特殊的链接器标记
即bind at load

460
00:27:43,564 --> 00:27:47,401
如果你将它添加到你的调试程序
将会变得很慢

461
00:27:47,467 --> 00:27:49,169
因此只应该放入调试版本

462
00:27:49,236 --> 00:27:50,337
但将它添加到调试版本

463
00:27:50,404 --> 00:27:53,373
你将会获得更可靠的行为

464
00:27:53,440 --> 00:27:56,476
这让你能够好使用dyld 3

465
00:27:57,845 --> 00:27:59,580
另外只应该在测试版本中使用

466
00:28:00,647 --> 00:28:03,917
Dlopen、dlsym
和dladdr

467
00:28:03,984 --> 00:28:07,454
去年我讲过
仅应该在十分必要时才使用它们

468
00:28:07,521 --> 00:28:08,856
但我们理解你可能要使用它们

469
00:28:08,922 --> 00:28:11,525
今年我也会讲这个问题

470
00:28:11,892 --> 00:28:13,961
它们具有一些容易出错的语义

471
00:28:14,728 --> 00:28:16,930
但是在一些情况下
仍然需要使用它们

472
00:28:16,997 --> 00:28:19,867
特别是使用dlsym找到的符号
我们需要在运行时找到它们

473
00:28:19,933 --> 00:28:21,235
我们不会提前知道这些符号

474
00:28:21,301 --> 00:28:24,171
不能使用prefetching
和presearching

475
00:28:24,571 --> 00:28:27,774
当你使用dlopen或dlsym
我们会读入以前未接触过的

476
00:28:27,841 --> 00:28:31,078
所有符号表页

477
00:28:31,411 --> 00:28:33,380
这会占用大量资源

478
00:28:33,447 --> 00:28:38,785
此外 我们可能必须RPC到后台程序

479
00:28:38,852 --> 00:28:41,021
这取决于其复杂程度

480
00:28:41,088 --> 00:28:43,390
我们正在开发一些更好的替代方法

481
00:28:43,857 --> 00:28:45,425
目前还没有完成

482
00:28:45,492 --> 00:28:47,995
我们还需了解你们的用例
以确保我们开发出的方案

483
00:28:48,061 --> 00:28:50,464
适合你们的需求

484
00:28:50,531 --> 00:28:53,267
这些方案即将会发布

485
00:28:53,333 --> 00:28:55,936
我们希望获得你们的反馈意见

486
00:28:57,571 --> 00:28:59,873
接下来我想特别谈谈dlclose

487
00:28:59,940 --> 00:29:02,509
dlclose是一个误用词

488
00:29:02,576 --> 00:29:04,111
它是一个Unix API

489
00:29:04,178 --> 00:29:05,646
如果在我们的系统上编写它

490
00:29:05,712 --> 00:29:08,615
我们会将它命名为dlrelease

491
00:29:08,682 --> 00:29:11,251
因为它实际上并不关闭dylib

492
00:29:11,318 --> 00:29:14,855
它减少refcount计数
如果refcount变为0

493
00:29:14,922 --> 00:29:16,123
将会关闭它

494
00:29:16,190 --> 00:29:17,658
它的重要性是什么？

495
00:29:18,091 --> 00:29:20,460
它并不利于资源管理

496
00:29:20,527 --> 00:29:24,398
如果你有一个库用于特定硬件

497
00:29:24,464 --> 00:29:27,968
你不应该关闭硬件
来响应dlclose

498
00:29:28,035 --> 00:29:31,805
因为程序中的其它代码
可能会在后台打开硬件

499
00:29:31,872 --> 00:29:33,407
因此你的硬件不会关闭

500
00:29:33,473 --> 00:29:35,943
应该使用显式资源管理

501
00:29:36,944 --> 00:29:39,213
我们的平台上还有很多特性

502
00:29:39,279 --> 00:29:41,648
访止dylib被卸载

503
00:29:41,715 --> 00:29:45,118
我想介绍几个例子
因为你们可能会这样做

504
00:29:45,853 --> 00:29:47,754
你的dylib中可以
有Objective-C类

505
00:29:47,821 --> 00:29:50,257
这将导致dylib不可卸载

506
00:29:50,991 --> 00:29:54,228
你可以具有Swift类
这也会导致dylib不可卸载

507
00:29:54,828 --> 00:29:58,232
你可以具有C底层线程
或C++ 线程本地变量

508
00:29:58,298 --> 00:30:00,868
这些都会导致dylib不可卸载

509
00:30:01,535 --> 00:30:06,573
因此在具有一些
现成Unix程序的macOS上

510
00:30:06,640 --> 00:30:10,644
我们会保持这个特性
但是由于我们所有其它平台上的

511
00:30:10,711 --> 00:30:12,946
几乎每个dylib都会这样做

512
00:30:13,013 --> 00:30:17,084
因此并不能在这些平台上
有效地工作

513
00:30:17,384 --> 00:30:20,988
因此我们可以将它视为
无操作指令

514
00:30:21,054 --> 00:30:23,290
不会在任何平台上进行操作

515
00:30:23,857 --> 00:30:28,695
如果这会导致问题
请告诉我们

516
00:30:30,097 --> 00:30:33,600
最后我想讨论
dyld all image infos

517
00:30:34,134 --> 00:30:37,337
这是进程中的
内在dylib的接口

518
00:30:37,404 --> 00:30:39,306
它来自于最初的dyld 1

519
00:30:40,641 --> 00:30:45,779
但是它只是内存中的一个结构
而不是API

520
00:30:45,846 --> 00:30:48,148
当我们有5或10个dylib时
并没有问题

521
00:30:48,415 --> 00:30:52,252
但是如果有300、400
500个dylib 其设计方式

522
00:30:52,319 --> 00:30:54,821
将导致浪费大量内存
我们需要回收那些内存

523
00:30:54,922 --> 00:30:57,624
我们需要高性能
而且节省内存

524
00:30:58,192 --> 00:31:00,861
在未来的版本中
我们将会取消它

525
00:31:01,161 --> 00:31:04,598
但 是会提供一个替代性API

526
00:31:04,898 --> 00:31:08,502
因此 它很少被用到
如果你要使用它

527
00:31:08,569 --> 00:31:10,370
我希望你知道为什么要使用它

528
00:31:10,437 --> 00:31:13,941
如何使用它
确保我们设计的API适合你的用例

529
00:31:14,208 --> 00:31:16,877
有很多功能已经不再适用

530
00:31:16,944 --> 00:31:20,480
不符合你的预期
如果你不需要它们

531
00:31:20,547 --> 00:31:23,016
可以忽略它们
我们希望获得这方面的信息

532
00:31:23,550 --> 00:31:25,385
请让我们知道你将如何使用它

533
00:31:25,853 --> 00:31:28,021
最后我们讨论最佳实践

534
00:31:28,455 --> 00:31:33,527
首先应确保将bind at load
添加到LD FLAGS

535
00:31:33,594 --> 00:31:35,395
应该仅在调试版本中这样做

536
00:31:36,630 --> 00:31:40,033
应修复数据段中的
任何未对齐指针

537
00:31:40,100 --> 00:31:42,836
然后还有这个警告信息

538
00:31:42,903 --> 00:31:45,038
应该使用新Swift键径功能

539
00:31:45,672 --> 00:31:47,975
消除所有警告错误

540
00:31:48,041 --> 00:31:50,077
你也可以忽略
因为我们将会解决这个问题

541
00:31:51,311 --> 00:31:54,281
当你调用dlclose时应该确保

542
00:31:54,882 --> 00:31:56,283
不依赖于任何正运行的终止函数

543
00:31:58,085 --> 00:32:03,924
我们想知道你们为何使用dlopen
dlsym、dladdr

544
00:32:03,991 --> 00:32:07,694
和all image info结构
以确保我们的替代性API

545
00:32:07,761 --> 00:32:09,863
能够满足你们的需求

546
00:32:09,930 --> 00:32:12,499
如果它们是POSIX的一部分
将会被保留

547
00:32:12,566 --> 00:32:14,768
这只会造成性能降低
对于all image infos

548
00:32:14,835 --> 00:32:17,404
它将会被取消以节省内存

549
00:32:18,572 --> 00:32:22,409
请使用DYLD USAGE标题
向我们报告漏洞

550
00:32:22,476 --> 00:32:24,444
让我们能够

551
00:32:24,511 --> 00:32:25,979
支持你们的所有用例

552
00:32:26,313 --> 00:32:29,283
更多信息请访问此URL

553
00:32:30,517 --> 00:32:34,488
去年我们举行了一个相关的演讲
名称为“缩短应用启动时间”

554
00:32:34,555 --> 00:32:38,058
你可以观看这个演讲

555
00:32:38,125 --> 00:32:40,861
复习传统动态链接的工作原理

556
00:32:41,228 --> 00:32:43,997
这个演讲更详细

557
00:32:44,064 --> 00:32:45,999
因为今天我们讲的都是新内容

558
00:32:46,366 --> 00:32:50,037
谢谢大家参加本演讲
我希望你们度过一个很棒的WWDC

