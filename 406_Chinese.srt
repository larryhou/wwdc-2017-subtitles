1
00:00:19,486 --> 00:00:20,320
大家好

2
00:00:24,191 --> 00:00:28,562
欢迎参加“使用Xcode运行时工具
发现漏洞”演讲

3
00:00:30,397 --> 00:00:33,734
我是库巴
是开发工具部门的

4
00:00:33,967 --> 00:00:35,169
程序分析团队工程师

5
00:00:35,602 --> 00:00:38,672
今天 我们讨论

6
00:00:39,173 --> 00:00:41,675
在程序运行时使用工具发现漏洞

7
00:00:42,176 --> 00:00:43,010
让我们开始

8
00:00:44,745 --> 00:00:46,780
Xcode通过多种方法

9
00:00:46,847 --> 00:00:49,183
显示程序中的漏洞

10
00:00:49,316 --> 00:00:51,552
例如 通过编辑器错误消息

11
00:00:52,052 --> 00:00:53,020
编译器警告

12
00:00:53,687 --> 00:00:54,655
分析器警告

13
00:00:55,289 --> 00:00:56,190
或测试错误等

14
00:00:57,191 --> 00:00:58,592
去年 在Xcode 8中

15
00:00:58,659 --> 00:01:02,462
我们增加一个全新的类别
其名称为Runtime Issues

16
00:01:03,497 --> 00:01:05,966
这些问题是在程序运行时

17
00:01:06,200 --> 00:01:07,467
使用多个不同的工具发现的

18
00:01:09,303 --> 00:01:12,339
当你像以前一样运行和调试程序时

19
00:01:12,439 --> 00:01:15,309
这些工具在运行时发现和检测漏洞

20
00:01:15,375 --> 00:01:19,313
然后在Xcode运行时问题导航器中
显示这些漏洞

21
00:01:20,314 --> 00:01:23,984
如果你没有注意到这个导航器

22
00:01:24,051 --> 00:01:27,187
Xcode会指示它发现一些运行时问题

23
00:01:27,721 --> 00:01:30,757
显示这个紫色警告图标

24
00:01:33,060 --> 00:01:35,929
你可以在导航器中点击这些问题

25
00:01:36,096 --> 00:01:40,267
编辑器将会告诉你
哪些代码行含有漏洞

26
00:01:42,069 --> 00:01:43,770
漏洞来源可能各不相同

27
00:01:43,837 --> 00:01:46,473
因为不同的工具报告不同类型的漏洞

28
00:01:46,974 --> 00:01:47,808
今天我们的演讲中

29
00:01:47,875 --> 00:01:50,010
讨论的所有这些工具

30
00:01:50,143 --> 00:01:52,980
可以在方案编辑器的诊断阶段找到它们

31
00:01:53,514 --> 00:01:56,350
在Xcode 9中
现在加入一些新功能

32
00:01:56,783 --> 00:01:59,786
你们可以看到
现在增加了Address Sanitizer、

33
00:02:00,087 --> 00:02:03,390
Threat Sanitizer、
Undefined Behavior Sanitizer

34
00:02:03,524 --> 00:02:05,192
和Main Thread Checker

35
00:02:05,726 --> 00:02:09,496
这些工具在程序运行时发现漏洞

36
00:02:10,062 --> 00:02:12,633
今天我们将会讨论这些工具

37
00:02:13,200 --> 00:02:15,469
首先 我们来看
Main Thread Checker

38
00:02:15,536 --> 00:02:17,571
它是Xcode 9中的全新工具

39
00:02:19,072 --> 00:02:22,276
然后我会讨论Address Sanitizer
和Thread Sanitizer

40
00:02:22,342 --> 00:02:25,479
以及今年我们对这些工具所做的改进

41
00:02:26,647 --> 00:02:29,016
我们将会介绍另外一个全新工具

42
00:02:29,116 --> 00:02:30,851
Undefined Behavior Sanitizer

43
00:02:31,785 --> 00:02:34,621
最后 我们介绍一些小技巧
和最佳实践

44
00:02:35,122 --> 00:02:37,024
让你们能够高效率地使用这些工具

45
00:02:38,058 --> 00:02:38,992
让我们开始

46
00:02:41,128 --> 00:02:44,364
Main Thread Checker
是Xcode 9中的全新工具

47
00:02:44,431 --> 00:02:48,135
它检查一些常用API的违规

48
00:02:49,136 --> 00:02:52,739
重点检查UI更新和多线程

49
00:02:53,740 --> 00:02:57,878
一些API要求你仅在主线程中使用它们

50
00:02:58,745 --> 00:03:01,415
例如 AppKit和UIKit框架中的

51
00:03:01,481 --> 00:03:03,417
许多API都这样做

52
00:03:04,084 --> 00:03:07,421
大多数macOS和iOS图形应用程序
都会使用这些API

53
00:03:07,754 --> 00:03:10,057
假设你使用这些框架

54
00:03:10,457 --> 00:03:12,426
就应该知道这些限制

55
00:03:12,559 --> 00:03:14,862
即 必须在主线程中调用这些API

56
00:03:15,562 --> 00:03:17,764
这很容易做到

57
00:03:17,831 --> 00:03:20,167
我们只需要确保
在主线程上调用这些API就可以了

58
00:03:21,502 --> 00:03:22,769
但是 有一些任务

59
00:03:22,836 --> 00:03:25,172
你并不想在主线程上执行它们

60
00:03:25,372 --> 00:03:27,441
比如下载 这时你需要等待数据到达

61
00:03:27,508 --> 00:03:29,276
另外还有图像处理任务

62
00:03:29,343 --> 00:03:32,112
通常需要大量的计算

63
00:03:33,247 --> 00:03:36,149
因此应该将这些任务移出主线程

64
00:03:36,350 --> 00:03:38,085
使UI保持快速响应

65
00:03:38,151 --> 00:03:41,255
而且不会阻止应用中的用户交互

66
00:03:42,222 --> 00:03:45,826
但是 这些任务也需要触发UI更新

67
00:03:46,760 --> 00:03:50,831
如果这些UI更新调用
AppKit或UIKit API

68
00:03:51,532 --> 00:03:53,467
将需要在主线程中进行更新

69
00:03:53,567 --> 00:03:55,435
很容易犯的错误是

70
00:03:55,502 --> 00:03:58,372
在不合适的线程中
意外调用这些UI更新

71
00:03:59,139 --> 00:04:00,874
这可能会造成严重后果

72
00:04:01,175 --> 00:04:04,811
如果UI更新缺失
会造成UI完全不更新

73
00:04:05,145 --> 00:04:06,480
或者其它显示错误

74
00:04:06,914 --> 00:04:09,816
甚至可能发生更严重的问题
比如数据损坏或程序崩溃

75
00:04:10,350 --> 00:04:11,752
因此 为了避免这些问题

76
00:04:12,085 --> 00:04:15,556
我们需要确保 仅在主线程中
进行UI更新

77
00:04:16,623 --> 00:04:19,392
为此 我想为大家介绍
Main Thread Checker

78
00:04:19,459 --> 00:04:21,128
我为大家进行展示

79
00:04:30,771 --> 00:04:32,806
这里一个简单的应用程序

80
00:04:32,873 --> 00:04:34,942
它从互联网下载一些数据

81
00:04:35,375 --> 00:04:38,846
从这个长URL下载一个文件

82
00:04:38,912 --> 00:04:40,981
这个网站是
developer.apple.com

83
00:04:41,281 --> 00:04:44,651
要下载的文件是
2013年Apple发布的一些示例代码

84
00:04:45,052 --> 00:04:46,119
它是一个zip文件

85
00:04:46,186 --> 00:04:48,155
几兆大小

86
00:04:48,222 --> 00:04:50,657
它是一个示例下载文件

87
00:04:51,692 --> 00:04:55,762
为了下载这个文件
我将用名称为URLSession的类

88
00:04:55,829 --> 00:04:57,064
这是一个Foundation类

89
00:04:57,130 --> 00:04:59,533
是一种方便的文件下载方法

90
00:05:02,069 --> 00:05:04,304
应用的UI非常简单

91
00:05:05,272 --> 00:05:08,542
含有一个按钮和一个进度条

92
00:05:08,609 --> 00:05:12,713
我们可以实现
URLSession进度回调

93
00:05:12,779 --> 00:05:16,116
在这个回调中
我更新进度条的值

94
00:05:16,350 --> 00:05:17,985
让我们运行这个程序

95
00:05:18,118 --> 00:05:22,523
看它是否显示下载进度

96
00:05:22,890 --> 00:05:25,726
点击按钮开始下载

97
00:05:26,126 --> 00:05:28,295
可以看到
有点不正常

98
00:05:28,462 --> 00:05:31,198
因为进度条在开始位置卡住了

99
00:05:31,632 --> 00:05:34,801
现在 因为某种原因
它直接跳到末尾

100
00:05:35,969 --> 00:05:39,206
因此我想
我的程序可能存在漏洞

101
00:05:39,273 --> 00:05:41,808
或者URLSession工作不正常

102
00:05:42,543 --> 00:05:43,577
此功能的最大好处是

103
00:05:43,644 --> 00:05:45,679
我不需要猜测哪里出了问题

104
00:05:45,846 --> 00:05:47,614
Xcode已经找到问题

105
00:05:48,182 --> 00:05:50,317
我们返回Xcode

106
00:05:50,551 --> 00:05:54,521
它告诉我们
发现一个运行时问题

107
00:05:55,589 --> 00:05:57,991
让我们点击这个运行时问题
查看详情

108
00:05:58,058 --> 00:06:00,360
你会看到导航器

109
00:06:00,661 --> 00:06:02,262
没有切换到Runtime Issues导航器

110
00:06:02,996 --> 00:06:03,897
它告诉我

111
00:06:03,964 --> 00:06:07,301
我在后台线程中调用一些UI API

112
00:06:08,769 --> 00:06:10,103
我点击问题

113
00:06:10,170 --> 00:06:13,874
查看含有无效API代码的代码块

114
00:06:14,441 --> 00:06:15,342
在本例中

115
00:06:15,676 --> 00:06:18,512
我们在后台线程中

116
00:06:18,579 --> 00:06:21,215
为进度指示条设置一个新值

117
00:06:21,515 --> 00:06:23,550
而这应该是在主线程中完成的

118
00:06:25,786 --> 00:06:26,854
因此这是一个异常

119
00:06:26,920 --> 00:06:30,057
因为我想要在后台线程中执行这个代码

120
00:06:30,324 --> 00:06:32,860
实际上 我没有在代码中
进行任何线程处理

121
00:06:34,061 --> 00:06:36,597
因此实际问题是
当我调用URLSession对象时

122
00:06:36,663 --> 00:06:40,200
犯了错误

123
00:06:40,667 --> 00:06:43,504
在这一行
我创建URLSession

124
00:06:43,804 --> 00:06:47,875
指定用于进度回调

125
00:06:47,941 --> 00:06:50,611
和下载完成回调的视图

126
00:06:51,078 --> 00:06:53,914
我没有提供队列
而是指定nil

127
00:06:54,014 --> 00:06:56,116
这意味着我并不关心

128
00:06:56,183 --> 00:06:59,653
URLSession可能会在后台队列中
进行这些调用

129
00:07:01,722 --> 00:07:05,993
现在 我们知道
为什么在后台线程中进行调用

130
00:07:06,293 --> 00:07:08,795
为了解决这个问题 我可能使用GCD

131
00:07:08,862 --> 00:07:11,598
将UI更新操作
分配回给主线程

132
00:07:12,165 --> 00:07:15,335
在本例中
我可以要求URLSession

133
00:07:15,402 --> 00:07:18,038
直接在主队列上进行回调

134
00:07:18,105 --> 00:07:19,273
我们将会这样做

135
00:07:20,507 --> 00:07:24,211
我要求它在主队列上进行回调

136
00:07:24,478 --> 00:07:26,580
让我们多次运行程序

137
00:07:26,647 --> 00:07:28,515
查看这是否会解决我们的问题

138
00:07:29,716 --> 00:07:31,285
点击按钮

139
00:07:31,552 --> 00:07:33,687
会看到进度条平滑地行进

140
00:07:33,754 --> 00:07:35,989
表示正在下载

141
00:07:40,060 --> 00:07:40,894
谢谢

142
00:07:43,530 --> 00:07:45,032
现在我切换到幻灯片

143
00:07:49,069 --> 00:07:49,903
在这里

144
00:07:51,605 --> 00:07:54,374
我们看到一个例子

145
00:07:54,441 --> 00:07:58,111
显示Main Thread Checker
如何帮助我们发现并修复漏洞

146
00:07:58,245 --> 00:08:00,247
因为我们在错误线程中调用一些API
而造成这个漏洞

147
00:08:00,881 --> 00:08:03,984
请注意 我并没有启用这两个选项

148
00:08:04,117 --> 00:08:06,119
因为在你使用Xcode调试器时

149
00:08:06,253 --> 00:08:08,155
默认已经启用它们

150
00:08:10,457 --> 00:08:12,526
如果想要在Xcode中找到这个代码

151
00:08:13,327 --> 00:08:16,530
可以在诊断步骤看到它

152
00:08:16,997 --> 00:08:19,132
你会注意到 在Xcode 9中

153
00:08:19,266 --> 00:08:21,835
有一个复选项 其名称为
Main Thread Checker

154
00:08:22,603 --> 00:08:25,205
在这里
可以启用或关闭这两个选项

155
00:08:26,306 --> 00:08:30,210
如果想要调试器停止
检查违规

156
00:08:30,644 --> 00:08:32,746
可以选择“Pause on Issues”复选框

157
00:08:33,280 --> 00:08:36,183
然后调试器将会在检查到问题后停止

158
00:08:36,250 --> 00:08:38,818
你可以查看当前的程序状态

159
00:08:39,318 --> 00:08:40,687
分析发生了什么问题

160
00:08:42,289 --> 00:08:43,457
（常见问题）

161
00:08:43,524 --> 00:08:45,792
现在 我们来讨论一些常见的问题

162
00:08:46,860 --> 00:08:48,695
这些问题让
Main Thread Checker检测到漏洞

163
00:08:49,496 --> 00:08:50,764
在演示中可以看到

164
00:08:51,031 --> 00:08:57,037
后台线程中

165
00:08:57,237 --> 00:08:58,405
经常会进行网络回调

166
00:08:59,239 --> 00:09:02,342
你们需要注意
应该在主线程中

167
00:09:02,576 --> 00:09:03,710
进行UI更新

168
00:09:04,645 --> 00:09:05,913
另外 当你创建和销毁

169
00:09:05,979 --> 00:09:09,249
NSView或UIView对象时
也容易产生问题

170
00:09:09,349 --> 00:09:11,952
也需要在主线程中完成这些工作

171
00:09:13,887 --> 00:09:16,523
如果你在编写库或框架

172
00:09:16,657 --> 00:09:19,126
提供一些异步API

173
00:09:19,660 --> 00:09:22,095
当设计这些API时
应该非常注意

174
00:09:22,496 --> 00:09:23,330
让我们来看看

175
00:09:26,033 --> 00:09:27,701
假设我们想要设计一个API

176
00:09:27,768 --> 00:09:30,470
用于执行长时间和高密度的计算

177
00:09:30,537 --> 00:09:33,207
它以异步方式运行

178
00:09:34,575 --> 00:09:38,846
API的调用函数需要
提供API结束处理程序

179
00:09:38,912 --> 00:09:41,481
这个收尾程序将用作
完成处理程序

180
00:09:41,548 --> 00:09:43,150
因此 当任务完成时

181
00:09:43,617 --> 00:09:46,486
API将调用
提供的收尾处理程序

182
00:09:47,387 --> 00:09:49,556
但是 这个代码示例中
并没有明确地指定

183
00:09:49,923 --> 00:09:52,459
哪个队列或线程
将会用于这个收尾处理

184
00:09:53,227 --> 00:09:55,195
在不合适的线程中处理这些代码时

185
00:09:55,262 --> 00:09:57,664
很容易产生错误

186
00:10:01,568 --> 00:10:04,805
良好的API应该要求甚至强制用户

187
00:10:05,038 --> 00:10:08,509
规定哪个视图应该用于完成处理程序

188
00:10:08,575 --> 00:10:10,544
如果你阅读这段代码示例

189
00:10:10,878 --> 00:10:14,014
很容易看到
将在提供的队列上调用收尾处理程序

190
00:10:14,081 --> 00:10:15,582
不需要阅读API文档

191
00:10:15,649 --> 00:10:17,618
就可以知道这一点

192
00:10:20,187 --> 00:10:21,021
前面我说过

193
00:10:21,221 --> 00:10:24,625
Main Thread Checker检测
API线程处理规则违规

194
00:10:25,259 --> 00:10:27,895
它支持AppKit、UIKit和WebKit

195
00:10:27,961 --> 00:10:30,163
它们是最常用的三个框架

196
00:10:30,230 --> 00:10:33,867
而且它们的许多API

197
00:10:33,934 --> 00:10:35,569
都具有相同的主线程要求

198
00:10:36,770 --> 00:10:39,473
我们的工具支持Swift和C语言

199
00:10:39,773 --> 00:10:43,043
与其它工具相比
今天我们讨论的工具

200
00:10:43,610 --> 00:10:45,412
并不需要重新编译

201
00:10:46,013 --> 00:10:48,081
你甚至可以它们用于
已有的二进制代码

202
00:10:49,716 --> 00:10:52,519
其最大的好处是
已经默认启用

203
00:10:52,586 --> 00:10:53,954
你不需要做任何事情

204
00:10:54,021 --> 00:10:55,856
就可以通过工具获得警告信息

205
00:10:55,923 --> 00:10:58,525
当你使用Xcode调试器时
就会启用此工具

206
00:10:59,660 --> 00:11:01,195
这就是Main Thread Checker

207
00:11:01,428 --> 00:11:03,297
Xcode 9包含的一个全新工具

208
00:11:12,072 --> 00:11:16,844
接下来 我们讨论
另一个方面的问题 内存问题

209
00:11:17,411 --> 00:11:20,948
接下来我们讨论Address Sanitizer
这个工具发现内存问题

210
00:11:22,182 --> 00:11:26,286
两年前 Address Sanitizer
被引入Xcode 7

211
00:11:26,353 --> 00:11:28,288
实践证明它是一个很不错的工具

212
00:11:28,355 --> 00:11:30,557
因为它能够发现严重的安全问题

213
00:11:30,691 --> 00:11:33,627
例如 内存释放后使用问题
和缓冲区溢出

214
00:11:34,695 --> 00:11:35,963
另外 当尝试诊断

215
00:11:36,029 --> 00:11:38,498
难以重现的崩溃问题时
此工具有十分有用

216
00:11:38,565 --> 00:11:41,568
因为它确定崩溃原因

217
00:11:41,969 --> 00:11:45,038
在发生崩溃时

218
00:11:45,105 --> 00:11:46,206
发现内存异常问题

219
00:11:46,273 --> 00:11:48,642
确定哪些相关代码
受到内存崩溃的影响

220
00:11:49,643 --> 00:11:51,678
如果你想知道
此工具如何工作

221
00:11:51,745 --> 00:11:53,680
以及它可以发现哪些漏洞

222
00:11:53,747 --> 00:11:56,884
建议你们观看
两年前的WWDC演讲

223
00:11:57,084 --> 00:11:59,920
其名称为“高级调试技术
与Address Sanitizer”

224
00:12:00,654 --> 00:12:02,489
在那个演讲中
我们介绍这个工具

225
00:12:02,556 --> 00:12:05,359
并讨论其底层工作原理

226
00:12:06,994 --> 00:12:11,231
Address Sanitizer集成到
Xcode UI和调试器中

227
00:12:11,465 --> 00:12:12,299
让我们来看看

228
00:12:12,499 --> 00:12:14,434
如果你想要使用Address Sanitizer

229
00:12:14,535 --> 00:12:16,570
需要做的是
再次进入方案编辑器

230
00:12:16,637 --> 00:12:19,873
你会发现有一个复选框
名称为“Address Sanitizer”

231
00:12:20,307 --> 00:12:21,842
选中后将会启用此工具

232
00:12:22,809 --> 00:12:25,345
在Xcode 9中有另外一个复选框

233
00:12:25,512 --> 00:12:29,416
名称为
“Use of stack after return”

234
00:12:29,650 --> 00:12:31,185
后面我将会介绍这个功能

235
00:12:31,952 --> 00:12:33,053
你还会注意到

236
00:12:33,320 --> 00:12:35,789
我们增加了
Malloc Scribble兼容功能

237
00:12:35,856 --> 00:12:38,659
因此可以同时启用这两个工具

238
00:12:41,094 --> 00:12:43,430
然后 你可以运行和调试你的应用

239
00:12:43,497 --> 00:12:44,665
就像以前一样

240
00:12:45,165 --> 00:12:48,569
如果程序没有任何内存问题

241
00:12:48,635 --> 00:12:52,206
没有发生内存违规
那么一切正常

242
00:12:52,773 --> 00:12:55,108
Address Sanitizer
不会中断你的工作

243
00:12:55,475 --> 00:12:58,745
但是如果发现问题
将会停止程序

244
00:12:58,812 --> 00:13:00,280
并描述问题是什么

245
00:13:00,347 --> 00:13:01,481
在本例中

246
00:13:01,882 --> 00:13:04,551
我们意外地使用
一些已释放的内存

247
00:13:05,052 --> 00:13:06,186
这是一个严重的漏洞

248
00:13:07,054 --> 00:13:09,056
当Address Sanitizer发现漏洞时

249
00:13:09,223 --> 00:13:12,025
将会显示

250
00:13:12,192 --> 00:13:14,027
关于所访问的内存的详细信息

251
00:13:14,461 --> 00:13:16,496
我们不仅会看到内存地址

252
00:13:16,830 --> 00:13:18,665
还会看到描述信息

253
00:13:18,866 --> 00:13:20,767
比如内存堆区有多大

254
00:13:20,934 --> 00:13:23,170
访问了哪些超范围字节

255
00:13:23,704 --> 00:13:27,207
还会获得内存分配和
释放回溯信息

256
00:13:27,441 --> 00:13:30,043
描述内存的分配和释放方式

257
00:13:30,544 --> 00:13:31,845
当你处理内存释放后使用问题时

258
00:13:31,912 --> 00:13:34,081
这些都是非常有用的信息

259
00:13:34,448 --> 00:13:37,251
因为它们可以帮助你诊断问题

260
00:13:39,753 --> 00:13:42,222
我们已经对
Address Sanitizer有所了解

261
00:13:42,289 --> 00:13:43,924
现在来看我们今年

262
00:13:43,991 --> 00:13:45,325
增加的一些新功能

263
00:13:45,559 --> 00:13:47,961
此工具检查两类新漏洞

264
00:13:48,161 --> 00:13:50,197
即use-after-scope
和use-after-return

265
00:13:50,264 --> 00:13:52,799
此工具还兼容Malloc Scribble

266
00:13:52,966 --> 00:13:54,401
让我们来看一些例子

267
00:13:56,837 --> 00:13:58,071
在代码示例中

268
00:13:58,539 --> 00:14:01,074
假设我们在if表达式语句中

269
00:14:01,141 --> 00:14:02,976
定义一个变量

270
00:14:04,478 --> 00:14:07,181
有一个指针指向这个变量

271
00:14:07,981 --> 00:14:10,717
然后 在if语句之外

272
00:14:11,118 --> 00:14:13,587
我们使用这个指针保存一个新值

273
00:14:14,221 --> 00:14:17,491
这是一个新值
在这里指针不再有效

274
00:14:17,658 --> 00:14:19,760
Address Sanitizer
能够检测

275
00:14:19,993 --> 00:14:21,495
并且描述问题

276
00:14:24,097 --> 00:14:28,035
另一种类型的漏洞发生在
返回时

277
00:14:28,302 --> 00:14:30,103
使用指针时

278
00:14:30,170 --> 00:14:31,772
从函数中返回之后

279
00:14:31,839 --> 00:14:35,609
在本例中
函数返回一个指向其本地变量的指针

280
00:14:36,376 --> 00:14:38,478
这意味着
函数返回之后

281
00:14:38,745 --> 00:14:40,414
指针已经不再有效

282
00:14:40,814 --> 00:14:42,115
如果尝试使用这个指针

283
00:14:42,482 --> 00:14:44,318
就会访问垃圾内存

284
00:14:44,484 --> 00:14:46,320
这时Address Sanitizer
能够检测这个错误

285
00:14:46,386 --> 00:14:48,255
并描述错误信息

286
00:14:48,789 --> 00:14:51,491
但是这种检查并不是默认启用的

287
00:14:51,558 --> 00:14:53,527
因为它会占用一些额外开销

288
00:14:53,594 --> 00:14:54,761
你应该启用此功能

289
00:14:54,995 --> 00:14:58,165
为此 你应该选中
前面我提到过的

290
00:14:58,298 --> 00:14:59,967
方案编辑器中的复选框

291
00:15:02,703 --> 00:15:04,338
（ADDRESS SANITIZER与SWIFT）

292
00:15:04,404 --> 00:15:07,074
现在 如果使用Swift开发项目

293
00:15:07,407 --> 00:15:08,642
你可能会想

294
00:15:08,809 --> 00:15:10,844
我什么要使用Address Sanitizer？

295
00:15:12,012 --> 00:15:13,714
Swift是一种更安全的语言

296
00:15:13,814 --> 00:15:16,216
但是现实情况是
许多项目使用混合语言

297
00:15:16,283 --> 00:15:18,886
它们的C和Objective-C代码
可能含有漏洞

298
00:15:19,052 --> 00:15:21,989
对于C和 Objective-C代码

299
00:15:22,456 --> 00:15:24,491
Address Sanitizer
仍然是一个非常有效的工具

300
00:15:24,558 --> 00:15:26,360
它会发现这些部分的

301
00:15:26,426 --> 00:15:27,661
代码中的内存问题

302
00:15:29,096 --> 00:15:31,832
你们一些人可能使用不安全的指针类型

303
00:15:32,366 --> 00:15:33,934
这意味着

304
00:15:34,868 --> 00:15:35,736
会产生内存安全问题

305
00:15:35,802 --> 00:15:37,504
当使用这些指针时
必须十分注意

306
00:15:37,738 --> 00:15:39,139
让我们来看代码示例

307
00:15:40,440 --> 00:15:43,076
在这个代码中 有一个字符串
“Hello, World!”

308
00:15:43,143 --> 00:15:47,247
我要将它转换成为
C样式的字符串

309
00:15:47,614 --> 00:15:48,682
使用不安全的窗口

310
00:15:50,217 --> 00:15:53,921
我要做的是调用
这个名称为withCString的字符串

311
00:15:54,087 --> 00:15:56,456
这将会为我
创建一个不安全的指针

312
00:15:58,025 --> 00:16:00,093
为我提供一个不安全的指针

313
00:16:00,160 --> 00:16:02,229
在这个结束处理中
我会传递这个指针

314
00:16:03,297 --> 00:16:06,466
如果在处理程序之外
保存这个指针

315
00:16:06,800 --> 00:16:08,702
就违反了C字符串规则

316
00:16:08,769 --> 00:16:13,974
这意味着 我尝试使用
这个内存泄漏不安全指针

317
00:16:14,141 --> 00:16:15,909
也就是说 我在尝试访问无效的内容

318
00:16:15,976 --> 00:16:18,812
Address Sanitizer
能够检测到这样的

319
00:16:18,879 --> 00:16:21,248
无效地使用不安全指针的情况
即使在Swift代码中

320
00:16:25,118 --> 00:16:26,453
为了修复这个问题 我们需要确保

321
00:16:26,520 --> 00:16:29,223
仅在结束处理程序之内
使用这个传递C字符串的

322
00:16:29,723 --> 00:16:32,059
不安全指针

323
00:16:32,125 --> 00:16:35,162
因此 我们进入结束处理代码

324
00:16:35,362 --> 00:16:37,364
修复问题

325
00:16:37,898 --> 00:16:39,766
我们可以进一步简化代码

326
00:16:39,833 --> 00:16:42,236
完全移除本地变量

327
00:16:42,870 --> 00:16:44,271
一个良好的做法是

328
00:16:44,738 --> 00:16:48,475
始终不要将不安全的指针
存储到本地变量或属性之中

329
00:16:49,877 --> 00:16:53,046
因此 如果要在Swift项目中
使用不安全的指针

330
00:16:53,380 --> 00:16:55,916
我强烈建议你
在项目中启用Address Sanitizer

331
00:16:55,983 --> 00:16:57,551
以确保

332
00:16:57,618 --> 00:17:00,120
不会错误地使用不安全的指针

333
00:17:03,423 --> 00:17:08,028
我们已经了解Address Sanitizer
如何帮助你发和修复漏洞

334
00:17:08,395 --> 00:17:12,098
但是 对于一般性调试
它也是一个非常有用的工具

335
00:17:13,200 --> 00:17:16,403
因为当你调试项目时

336
00:17:16,470 --> 00:17:20,207
你可能会想要知道
内存分配情况

337
00:17:20,874 --> 00:17:22,209
我有一个好消息要告诉你

338
00:17:22,409 --> 00:17:24,278
如果你运行Address Sanitizer

339
00:17:24,744 --> 00:17:27,915
这将能够告诉你
所查询的任何内存块的

340
00:17:27,981 --> 00:17:29,383
分配回溯信息

341
00:17:30,184 --> 00:17:32,586
另外 还提供已经释放的内存的

342
00:17:32,653 --> 00:17:34,488
释放回溯信息

343
00:17:35,255 --> 00:17:36,423
此外 它还会告知

344
00:17:36,490 --> 00:17:38,825
哪些内存字节是有效和无效的

345
00:17:40,027 --> 00:17:40,861
让我们来看看

346
00:17:41,328 --> 00:17:44,331
这次的例子不是内存崩溃

347
00:17:44,498 --> 00:17:47,067
这是一个普通调试会话

348
00:17:47,267 --> 00:17:49,403
我进入一个函数的代码行

349
00:17:50,804 --> 00:17:53,941
我可以控制点击变量视图中的任何变量

350
00:17:54,608 --> 00:17:58,912
如果变量是一个指针
可以选择“View Memory of…”

351
00:18:01,114 --> 00:18:03,617
通常这会提供一个视图

352
00:18:03,717 --> 00:18:05,786
显示内存对象字节信息

353
00:18:06,687 --> 00:18:08,889
但若启用Address Sanitizer

354
00:18:09,056 --> 00:18:12,226
可以在导航器中查看内存项目

355
00:18:12,693 --> 00:18:15,195
将会显示该内存的分配

356
00:18:15,262 --> 00:18:16,129
和释放线程跟踪

357
00:18:18,398 --> 00:18:21,168
在这个内在视图中 你还会注意到

358
00:18:21,235 --> 00:18:23,504
一些字节显示为灰色
一些字节显示为黑色

359
00:18:24,605 --> 00:18:27,407
灰色字节表示无效内存

360
00:18:27,541 --> 00:18:29,776
是禁止访问的内存

361
00:18:30,077 --> 00:18:33,013
意味着你的程序不能访问这些字节

362
00:18:33,146 --> 00:18:34,781
如果访问 就会产生错误

363
00:18:34,915 --> 00:18:37,017
Address Sanitizer
将会发现并检测到这些错误

364
00:18:39,186 --> 00:18:42,122
还可以在lldb文本控制台上

365
00:18:42,189 --> 00:18:44,057
访问内存对象的分配

366
00:18:44,258 --> 00:18:45,659
和释放信息

367
00:18:45,926 --> 00:18:48,262
我们可以使用这个指令调用内存历史

368
00:18:48,428 --> 00:18:51,365
将它作为表达式进行传递
表达式的求值结果是一个指针

369
00:18:52,633 --> 00:18:55,636
在本例中 我们直接使用这个指针值

370
00:18:55,836 --> 00:18:57,504
文本控制台将会在文本输出中

371
00:18:57,938 --> 00:19:00,641
打印分配和释放线程跟踪信息

372
00:19:04,044 --> 00:19:05,546
我希望你们知道

373
00:19:05,679 --> 00:19:08,515
Address Sanitizer
是一个非常有用的工具

374
00:19:08,582 --> 00:19:10,851
适用于C语言和Swift

375
00:19:11,318 --> 00:19:13,720
帮助处理内存损坏和崩溃问题

376
00:19:14,254 --> 00:19:17,624
这是一个非常有用的工具
可用于常规调试

377
00:19:18,625 --> 00:19:20,294
现在 让我们来看

378
00:19:20,460 --> 00:19:24,665
另一种类型的崩溃和
疑难性内存错误

379
00:19:24,731 --> 00:19:25,933
即多线程问题

380
00:19:26,733 --> 00:19:29,770
Thread Sanitizer
能够发现这些问题

381
00:19:32,439 --> 00:19:35,843
前面我说过Thread Sanitizer
能够发现多线程问题

382
00:19:35,943 --> 00:19:37,477
例如数据争用

383
00:19:38,612 --> 00:19:41,114
这些多线程问题

384
00:19:41,548 --> 00:19:44,251
通常具有时间敏感性

385
00:19:44,618 --> 00:19:47,821
这意味着
它们非常难以重现

386
00:19:49,289 --> 00:19:52,059
Thread Sanitizer
不仅能够发现数据争用

387
00:19:52,192 --> 00:19:54,328
即两个内存访问发生冲突

388
00:19:54,461 --> 00:19:57,731
而且能够发现特定程序运行期间

389
00:19:57,798 --> 00:19:59,666
并不明显的数据争用

390
00:20:01,034 --> 00:20:05,038
即使竞争内存访问发生在不同的时间

391
00:20:05,172 --> 00:20:07,174
但是它们之间不是同步的

392
00:20:07,341 --> 00:20:08,408
仍然是竞争的

393
00:20:08,575 --> 00:20:10,611
Thread Sanitizer能够发现这个问题

394
00:20:11,512 --> 00:20:14,648
那是因为下次运行程序时

395
00:20:15,349 --> 00:20:16,850
时间将会发生错位

396
00:20:16,917 --> 00:20:19,720
可能会产生内存错误

397
00:20:20,187 --> 00:20:23,357
Thread Sanitizer能够发现内存争用
即使此问题没有明确的表现

398
00:20:25,592 --> 00:20:28,962
这个工具适用于64位macOS
和64位仿真器

399
00:20:29,029 --> 00:20:31,698
如果想要更多了解底层技术

400
00:20:31,765 --> 00:20:36,003
建议你们观看去年的WWDC演讲

401
00:20:36,069 --> 00:20:38,172
名称为“Thread Sanitizer
与静态分析”

402
00:20:41,108 --> 00:20:42,476
前面我说过“数据争用”

403
00:20:42,910 --> 00:20:44,077
让我们来看它们是什么

404
00:20:46,046 --> 00:20:47,414
任何共享数据

405
00:20:47,781 --> 00:20:50,384
任何在多线程之间共享的可变数据

406
00:20:50,651 --> 00:20:52,219
都需要同步访问

407
00:20:52,853 --> 00:20:56,190
如果共享可变变量未能同步

408
00:20:56,590 --> 00:20:57,858
就意味着发生数据争用

409
00:20:57,991 --> 00:21:00,027
数据争用是未定义的行为

410
00:21:01,328 --> 00:21:02,796
存在数据争用时

411
00:21:02,863 --> 00:21:05,299
程序可能发生内存错误和崩溃

412
00:21:05,566 --> 00:21:07,768
不仅C语言

413
00:21:07,835 --> 00:21:09,503
且Swift代码也存在这些问题

414
00:21:10,103 --> 00:21:11,839
让我们来看Swift中的例子

415
00:21:14,074 --> 00:21:17,344
在本例中 有一个名称为EventLog的类

416
00:21:17,711 --> 00:21:20,948
它有一个简单的函数
名称为log

417
00:21:21,315 --> 00:21:23,717
打印一些文本信息到输出

418
00:21:24,484 --> 00:21:25,719
此函数还跟踪

419
00:21:26,119 --> 00:21:29,523
调用此log函数的lastEventSource

420
00:21:30,023 --> 00:21:31,592
将这些信息

421
00:21:31,692 --> 00:21:34,695
保存到一个共享属性
其名称为lastEventSource

422
00:21:35,262 --> 00:21:38,899
这是一个可选属性
其初始值是nil

423
00:21:38,966 --> 00:21:40,801
当用户调用log函数时

424
00:21:41,101 --> 00:21:45,272
将会加入此特定的日志源

425
00:21:46,006 --> 00:21:47,608
假设我们有两个线程

426
00:21:47,908 --> 00:21:51,178
两个线程都同时调用log函数

427
00:21:51,445 --> 00:21:54,214
假设线程一是网络子线程

428
00:21:54,281 --> 00:21:56,183
它记录某些下载完成情况

429
00:21:56,750 --> 00:21:57,851
第二个线程

430
00:21:58,118 --> 00:22:00,020
代表我们的数据子系统

431
00:22:00,087 --> 00:22:02,022
记录查询完成情况

432
00:22:03,290 --> 00:22:04,458
这就是数据争用

433
00:22:05,359 --> 00:22:08,795
因为两个线程同时访问同一内存位置

434
00:22:09,963 --> 00:22:11,832
Thread Sanitizer对此发出警告

435
00:22:13,534 --> 00:22:14,501
为了修复这个问题

436
00:22:15,903 --> 00:22:17,371
我们需要引入同步机制

437
00:22:17,504 --> 00:22:21,141
最简单的方法
是使用DispatchQueue

438
00:22:21,808 --> 00:22:23,844
因此队列是串行的

439
00:22:24,144 --> 00:22:27,014
一次仅执行一个工作项目

440
00:22:28,315 --> 00:22:29,249
如果我们将log函数主体

441
00:22:30,384 --> 00:22:33,387
封装到queue.async之中

442
00:22:34,288 --> 00:22:36,056
这将提供正确的同步

443
00:22:36,423 --> 00:22:38,425
你们会发现 这里我使用async

444
00:22:38,492 --> 00:22:40,093
因为我们并不需要等待

445
00:22:40,160 --> 00:22:42,129
此函数完成

446
00:22:42,196 --> 00:22:44,831
因为此函数并不提供任何结果

447
00:22:44,898 --> 00:22:46,366
因此并不需要等待

448
00:22:46,767 --> 00:22:50,037
这不仅会修复争用问题
而且提升性能

449
00:22:50,871 --> 00:22:53,073
因为现在无论任何人调用log函数

450
00:22:53,340 --> 00:22:55,742
将不需要等待打印函数结束

451
00:22:58,378 --> 00:23:01,281
这样确保整个类的线程安全

452
00:23:01,381 --> 00:23:03,116
我们可以从多线程调用log函数

453
00:23:05,285 --> 00:23:08,789
Grand Central Dispatch
（简称GCD）提供的

454
00:23:08,856 --> 00:23:10,190
分派队列

455
00:23:10,657 --> 00:23:11,925
可以在Swift中使用

456
00:23:11,992 --> 00:23:14,328
应该成为首选的同步方法

457
00:23:14,828 --> 00:23:18,532
即使有其它同步机制

458
00:23:18,699 --> 00:23:21,902
GCD是轻量级的
很容易在Swift中使用

459
00:23:22,769 --> 00:23:26,740
一个良好的做法是将数据
与串行分派队列相关联

460
00:23:26,974 --> 00:23:29,076
仅从这些队列访问数据

461
00:23:29,776 --> 00:23:32,646
这将保证仅以同步方法

462
00:23:32,713 --> 00:23:33,947
使用你的数据

463
00:23:34,681 --> 00:23:38,452
如果你想了解
如何使用GCD进行并发处理

464
00:23:38,585 --> 00:23:41,955
我建议你们
观看去年的WWDC演讲

465
00:23:42,022 --> 00:23:44,658
名称为“GCD和Swift 3并发程序设计”

466
00:23:47,094 --> 00:23:48,695
让我们来看

467
00:23:48,762 --> 00:23:51,598
Xcode 9中增加的
Thread Sanitizer新功能

468
00:23:52,132 --> 00:23:54,568
此工具能够检测集合争用

469
00:23:54,935 --> 00:23:57,938
和Swift代码特有的

470
00:23:58,005 --> 00:24:00,140
新漏洞类

471
00:24:02,409 --> 00:24:06,013
在以前Thread Sanitizer
仅能发现

472
00:24:06,213 --> 00:24:07,648
原始内存访问争用

473
00:24:07,814 --> 00:24:09,316
类似于前面的例子

474
00:24:09,383 --> 00:24:12,286
在上例中 我们直接访问某些存储属性

475
00:24:13,420 --> 00:24:16,390
但是 对于大型数据结构
通常需要同步处理

476
00:24:16,456 --> 00:24:17,658
例如集合数据

477
00:24:18,225 --> 00:24:20,127
请考虑这个示例代码

478
00:24:20,661 --> 00:24:24,498
在Objective-C中我们使用
一个NSMutableDictionary实例

479
00:24:25,065 --> 00:24:27,167
这两个线程使用相同的实例

480
00:24:27,234 --> 00:24:30,437
假设线程一查找词典中的值

481
00:24:30,604 --> 00:24:32,940
第二个线程尝试写入词典

482
00:24:33,707 --> 00:24:36,109
现在Xcode 9中的新功能

483
00:24:36,176 --> 00:24:38,212
能够检测此争用问题

484
00:24:41,548 --> 00:24:43,917
集合争用是一个常见的错误

485
00:24:44,985 --> 00:24:48,989
在Xcode 9中我们能够检测
Objective-C 和Swift中的

486
00:24:49,056 --> 00:24:49,890
这些问题

487
00:24:50,290 --> 00:24:51,425
请注意 这要求

488
00:24:51,491 --> 00:24:54,294
你们使用macOS、
High Sierra和iOS 11

489
00:24:54,461 --> 00:24:56,997
我们能够检测
NSMutableArray

490
00:24:57,064 --> 00:25:00,767
和NSMutableDictionary以及
Swift数组和Swift词典争用

491
00:25:01,668 --> 00:25:04,505
在这方面 我想要展示实际运行原理

492
00:25:20,521 --> 00:25:22,789
我获得采用Swift代码之前的

493
00:25:23,123 --> 00:25:26,326
旧版本WWDC应用

494
00:25:26,393 --> 00:25:28,362
的源代码

495
00:25:28,462 --> 00:25:30,130
这个版本是

496
00:25:30,197 --> 00:25:32,199
完全用Objective-C编写的

497
00:25:32,399 --> 00:25:34,701
你可以看到
从这个版权标题中看到这一点

498
00:25:34,768 --> 00:25:37,004
此程序是在2011年编写的

499
00:25:38,405 --> 00:25:41,108
是几年前编写的

500
00:25:41,175 --> 00:25:43,043
使用一些过时的概念

501
00:25:43,110 --> 00:25:46,246
比如显式线程同步 而不是使用GCD

502
00:25:46,446 --> 00:25:49,183
但是我想展示给你们看
Thread Sanitizer工作良好

503
00:25:49,249 --> 00:25:51,518
即使配合其它同步机制

504
00:25:53,787 --> 00:25:55,556
我展示给你们看的文件

505
00:25:55,956 --> 00:25:58,959
实现一个类 名称为
WWDCURLConnection

506
00:25:59,026 --> 00:26:00,627
它用作基类

507
00:26:00,694 --> 00:26:03,230
以便在此应用中完成所有网络处理

508
00:26:03,897 --> 00:26:07,901
我所做的是
在这个代码中植入一个多线程漏洞

509
00:26:08,368 --> 00:26:10,938
让我们来看
Thread Sanitizer是否能发现此漏洞

510
00:26:12,005 --> 00:26:14,541
首先 转到“产品”方案
编辑方案

511
00:26:14,608 --> 00:26:17,778
确保启用
Thread Sanitizer

512
00:26:18,345 --> 00:26:21,381
调出方案编辑

513
00:26:21,448 --> 00:26:24,318
你们可以看到
我启用Thread Sanitizer

514
00:26:24,918 --> 00:26:27,487
现在我在这个模拟器中运行这个应用

515
00:26:29,990 --> 00:26:32,626
应用在模拟器中启动时

516
00:26:32,693 --> 00:26:35,729
将会启动多个网络连接

517
00:26:36,997 --> 00:26:40,367
因此 它将会使用这个文件

518
00:26:41,101 --> 00:26:42,636
你们注意到

519
00:26:42,703 --> 00:26:46,540
Xcode在问题导航器中报告争用情况

520
00:26:47,908 --> 00:26:49,977
这个问题报告一个争用问题

521
00:26:50,043 --> 00:26:52,613
让我们点击这个问题

522
00:26:52,679 --> 00:26:54,314
进入含有这个争用问题的代码行

523
00:26:54,481 --> 00:26:58,919
在这个例子中 可以看到
我们添加一些对象到可变数据组中

524
00:27:00,287 --> 00:27:03,390
此代码的目标是

525
00:27:03,457 --> 00:27:04,658
维护一个活跃连接列表

526
00:27:04,725 --> 00:27:07,327
我们跟踪监测这个列表
是为了用于调试目的

527
00:27:08,629 --> 00:27:11,532
在创建一些新URL连接之后

528
00:27:11,598 --> 00:27:13,000
我们将它添加到列表

529
00:27:14,067 --> 00:27:15,536
可以在任何线程中完成这些工作

530
00:27:15,702 --> 00:27:18,238
任何线程可以创建新URL连接

531
00:27:18,839 --> 00:27:20,641
如果我们在导航器中

532
00:27:20,707 --> 00:27:22,242
再次查看问题详情

533
00:27:22,376 --> 00:27:23,610
我们可以看到

534
00:27:23,677 --> 00:27:27,047
有个线程三调用addObject

535
00:27:27,481 --> 00:27:30,250
另外线程五
也尝试对相同的可变数据

536
00:27:30,484 --> 00:27:32,452
调用addObject

537
00:27:33,253 --> 00:27:36,223
如果查看API调用函数

538
00:27:36,290 --> 00:27:40,227
我们将会看到
它们指向相同的代码行

539
00:27:41,061 --> 00:27:44,531
因此这是一个问题
我们在多线程中

540
00:27:44,765 --> 00:27:46,800
访问这个可变数组
而不存在任何异步

541
00:27:47,868 --> 00:27:50,604
我可以轻松地解决这个问题

542
00:27:50,671 --> 00:27:54,208
因为我注意到
这行后面的代码

543
00:27:54,274 --> 00:27:56,009
在进行某种同步处理

544
00:27:56,076 --> 00:27:58,545
它使用这个名称为
performBlock的API

545
00:27:59,012 --> 00:28:01,715
分派相同的工作到特定线程

546
00:28:01,849 --> 00:28:03,851
在本例中
此线程名为connectionThread

547
00:28:04,351 --> 00:28:07,421
这个显式线程
用于同步处理

548
00:28:07,855 --> 00:28:09,489
这是一个单线程

549
00:28:09,556 --> 00:28:13,560
进行串行工作的同步处理

550
00:28:13,861 --> 00:28:16,730
因为这是一个单线程
并没有多线程处理

551
00:28:17,331 --> 00:28:21,735
为了解决这个问题
我可以将这个addObject调用

552
00:28:22,035 --> 00:28:24,371
转移到同步处理代码块 比如这个

553
00:28:25,005 --> 00:28:26,206
这应该能够解决这个争用问题

554
00:28:26,273 --> 00:28:30,811
因为现在我们只能够
在串行执行的同步代码块内

555
00:28:31,044 --> 00:28:34,081
访问活跃连接数组

556
00:28:34,314 --> 00:28:37,251
现在 我们再次在模拟器中运行应用

557
00:28:37,417 --> 00:28:39,419
让我们查看这是否会修复争用问题

558
00:28:40,888 --> 00:28:42,489
应用再次启用时

559
00:28:42,589 --> 00:28:45,325
将会触发多个网络连接

560
00:28:45,626 --> 00:28:48,929
现在程序运行时
我们看到Xcode

561
00:28:48,996 --> 00:28:51,565
不再报告任何运行时问题

562
00:28:55,102 --> 00:28:58,405
（演示 - THREAD SANITIZER
和NSMutableArray争用）

563
00:29:01,508 --> 00:29:03,877
你已经看到
Thread Sanitizer能够看到

564
00:29:03,944 --> 00:29:05,779
Objective-C代码中的争用问题

565
00:29:06,446 --> 00:29:07,281
那么Swift又如何呢？

566
00:29:08,482 --> 00:29:10,817
同样的检测功能也适用于Swift代码

567
00:29:11,018 --> 00:29:13,320
在本例中 如果我们有一个字符串数组

568
00:29:13,987 --> 00:29:15,455
而且有两个线程

569
00:29:15,522 --> 00:29:17,958
一个线程查找数组中的值

570
00:29:18,058 --> 00:29:20,227
另一个线程写入数组

571
00:29:20,961 --> 00:29:23,897
Thread Sanitizer会发现争用问题

572
00:29:25,265 --> 00:29:28,836
解决这个问题需要
使用一个串行DispatchQueue

573
00:29:29,236 --> 00:29:33,006
确保仅在相同的同步代码块内

574
00:29:33,340 --> 00:29:34,875
访问数组

575
00:29:34,942 --> 00:29:38,712
在本例中 线程一
将使用queue.sync

576
00:29:40,681 --> 00:29:41,782
在本例中必须使用此队列

577
00:29:41,849 --> 00:29:45,953
因为我们需要从计算处理中输出值
以继续执行程序

578
00:29:46,019 --> 00:29:49,056
需要在字典中查找值

579
00:29:49,122 --> 00:29:50,724
因此我们需要等待结果

580
00:29:50,791 --> 00:29:52,392
这里我使用queue.sync

581
00:29:52,659 --> 00:29:55,195
但是对于第二线程
可以使用queue.async

582
00:29:55,262 --> 00:29:58,398
因为代码块不提供任何输出

583
00:29:58,465 --> 00:30:00,033
因此不需要等待代码完成

584
00:30:03,303 --> 00:30:05,672
因此 你可能注意到
在前面的例子中

585
00:30:05,739 --> 00:30:08,008
我没有将这个问题称为数据争用

586
00:30:08,509 --> 00:30:11,578
相反 警告信息说
这是Swift访问竞争

587
00:30:13,013 --> 00:30:16,884
Swift访问竞争
是违反通用规则的行为

588
00:30:17,284 --> 00:30:18,952
这些规则适用于所有数据结构

589
00:30:19,086 --> 00:30:21,588
不仅适用于数组和词典
而且适用于所有数据结构

590
00:30:21,655 --> 00:30:22,956
甚至自定义的数据类型

591
00:30:23,624 --> 00:30:26,527
因此 这是Swift 4中的新规则

592
00:30:27,261 --> 00:30:31,164
此规则要求
数据结构变更方法

593
00:30:31,632 --> 00:30:34,401
独占性地访问整个结构

594
00:30:35,769 --> 00:30:37,004
这并不适用于类

595
00:30:37,070 --> 00:30:39,173
因为类并没有变更方法

596
00:30:39,406 --> 00:30:42,543
任何类方法都可以更改属性

597
00:30:42,609 --> 00:30:45,512
仅需要排它性访问

598
00:30:45,579 --> 00:30:47,981
此方法所更改的属性

599
00:30:49,683 --> 00:30:52,719
因此 编译器强制要求

600
00:30:53,187 --> 00:30:55,289
将新规则应用于数据结构

601
00:30:55,355 --> 00:30:58,659
要求在编译器时间
和运行时动态地执行规则

602
00:30:59,660 --> 00:31:02,663
但是这种强制要求仅适用于单线程违规

603
00:31:02,996 --> 00:31:06,066
Thread Sanitizer
帮助你处理多线程问题

604
00:31:06,633 --> 00:31:09,269
如果想要详细了解Swift 4中的
这些新规则

605
00:31:09,336 --> 00:31:12,406
我建议你们观看
“Swift新特性”演讲

606
00:31:13,307 --> 00:31:17,211
有一个部分名为“独占性内存访问”

607
00:31:17,277 --> 00:31:19,046
讲述这些新规则

608
00:31:19,246 --> 00:31:21,748
并讨论所需要执行的要求

609
00:31:22,716 --> 00:31:24,518
让我们来看另外一个例子

610
00:31:25,619 --> 00:31:29,756
假设有个朋友要求我
为他的太空飞船编写软件

611
00:31:30,624 --> 00:31:31,792
我们设计这个数据结构

612
00:31:31,859 --> 00:31:34,027
它描述这个太空飞船的位置

613
00:31:34,394 --> 00:31:36,063
另外有一些存储属性

614
00:31:36,363 --> 00:31:40,067
描述空间和时间坐标

615
00:31:40,734 --> 00:31:43,537
有一些方法调用此结构

616
00:31:43,871 --> 00:31:46,507
因为太空飞船
可以飞行到不同的星球

617
00:31:46,740 --> 00:31:49,109
还可以飞行到相同星球的不同城市

618
00:31:49,710 --> 00:31:51,278
当然 也可以进行时空旅行

619
00:31:53,113 --> 00:31:55,682
因此这些方法更改坐标

620
00:31:55,849 --> 00:31:57,417
它们应该是变更方法

621
00:31:57,751 --> 00:31:58,952
这意味着我刚才讲到的规则

622
00:31:59,019 --> 00:32:00,988
适用于所有这些方法

623
00:32:01,488 --> 00:32:02,489
如果有两个线程

624
00:32:02,556 --> 00:32:06,226
尝试更改太空飞船的位置

625
00:32:06,293 --> 00:32:08,529
假设线程一
尝试将太空飞船

626
00:32:08,595 --> 00:32:09,730
运送到不同的星球

627
00:32:10,330 --> 00:32:12,666
第二个线程进行太空飞船的时间旅行

628
00:32:13,233 --> 00:32:15,135
这是Swift访问竞争问题

629
00:32:16,637 --> 00:32:19,072
请注意

630
00:32:19,273 --> 00:32:22,209
哪些函数和方法
访问或更改存储的属性

631
00:32:22,342 --> 00:32:24,745
并不重要

632
00:32:25,245 --> 00:32:28,015
即使时空旅行更改X、Y和Z

633
00:32:28,215 --> 00:32:30,584
其它方法仅更改时间

634
00:32:31,118 --> 00:32:32,686
这仍然是Swift访问竞争

635
00:32:33,220 --> 00:32:36,590
这些规则仅要求
当调用变更函数时

636
00:32:36,757 --> 00:32:39,426
必须独占性地

637
00:32:39,493 --> 00:32:40,627
访问整个数据结构

638
00:32:43,263 --> 00:32:46,767
很重要的一点是
通过对数据结构进行同步处理

639
00:32:47,067 --> 00:32:50,470
如果我们尝试修复这个问题

640
00:32:50,737 --> 00:32:53,073
我们尝试
在这个数据结构中

641
00:32:53,140 --> 00:32:55,142
使用DispatchQueue

642
00:32:55,209 --> 00:32:59,546
保护变更函数的主体

643
00:32:59,713 --> 00:33:01,915
这并不是正确的修复方法

644
00:33:01,982 --> 00:33:04,852
仍然是一个违规
和Swift访问竞争问题

645
00:33:05,252 --> 00:33:07,988
因为我们必须独占性访问数据结构

646
00:33:08,522 --> 00:33:10,524
以调用变更函数

647
00:33:10,657 --> 00:33:14,428
在函数内引入同步机制并不足够

648
00:33:17,030 --> 00:33:19,700
正确的修复方法是
将同步机制应用于

649
00:33:19,766 --> 00:33:22,302
这些变更方法的调用函数

650
00:33:23,036 --> 00:33:26,607
假设有一个类描述整个太空飞船

651
00:33:27,774 --> 00:33:29,409
正确的方法是在这里使用一个类

652
00:33:29,476 --> 00:33:32,546
因为这个太空飞船有一个身份

653
00:33:32,613 --> 00:33:34,248
复制这个身份并不合适

654
00:33:34,815 --> 00:33:36,416
因此在本例中 太空飞船

655
00:33:36,483 --> 00:33:40,387
可以使用队列保护位置存储属性

656
00:33:40,687 --> 00:33:44,825
如果我们确保这些方法

657
00:33:45,259 --> 00:33:48,161
仅在同步代码块内访问数据结构
例如这里的queue.sync

658
00:33:48,428 --> 00:33:50,330
这让整个类线程变得安全

659
00:33:53,467 --> 00:33:56,336
我们已经知道

660
00:33:56,670 --> 00:33:58,338
你需要同步对共享可变更变量的访问

661
00:33:58,672 --> 00:34:00,374
可以使用GCD来完成此任务

662
00:34:00,774 --> 00:34:01,708
这通常比较简单

663
00:34:01,775 --> 00:34:04,511
类似于将数据与某些串行队列进行关联

664
00:34:04,578 --> 00:34:07,381
然后仅在队列中访问数据

665
00:34:08,514 --> 00:34:11,752
Thread Sanitizer是一个很有用的工具
帮助你发现

666
00:34:11,818 --> 00:34:13,687
未进行同步的代码块

667
00:34:14,054 --> 00:34:16,857
这个问题比较容易解决

668
00:34:18,625 --> 00:34:21,962
我很高兴告诉你们

669
00:34:22,029 --> 00:34:25,632
今年我们引入另外一个Sanitizer
帮助你们发现更多类型的漏洞

670
00:34:25,732 --> 00:34:27,701
接下来沃顿将会为大家进行介绍

671
00:34:33,473 --> 00:34:34,308
请沃顿上台

672
00:34:37,744 --> 00:34:42,014
我是沃顿
负责编译器开发

673
00:34:42,081 --> 00:34:45,918
我很高兴告诉你们
今年在Xcode 9中

674
00:34:45,985 --> 00:34:49,289
我们发布了一个新工具
名为Undefined Behavior Sanitizer

675
00:34:49,389 --> 00:34:52,726
我们帮助你发现更多漏洞

676
00:34:54,094 --> 00:34:57,831
什么是
Undefined Behavior Sanitizer？

677
00:34:58,632 --> 00:35:01,869
与其它运行时工具一样

678
00:35:01,935 --> 00:35:03,904
它是一个运行时漏洞排查器

679
00:35:04,404 --> 00:35:06,607
如其名称所示

680
00:35:06,673 --> 00:35:10,744
Undefined Behavior Sanitizer
检查未定义的行为

681
00:35:11,378 --> 00:35:15,883
与Address Sanitizer和
Thread Sanitizer一样

682
00:35:17,150 --> 00:35:20,053
Undefined Behavior Sanitizer
的独特之处在于

683
00:35:20,153 --> 00:35:23,056
它专注于检查

684
00:35:23,123 --> 00:35:24,658
C语言中的不安全构造

685
00:35:26,059 --> 00:35:28,529
它兼容其它运行时工具

686
00:35:28,595 --> 00:35:30,831
能够在我们的所有设备和平台上运行

687
00:35:31,331 --> 00:35:34,768
如果你想要更详细地了解
未定义的行为

688
00:35:34,835 --> 00:35:38,772
我强烈建议你们观看
明天上午9点的演讲

689
00:35:38,872 --> 00:35:42,209
此演讲介绍如何理解未定义的行为

690
00:35:42,543 --> 00:35:45,812
介绍什么是未定义的行为

691
00:35:46,613 --> 00:35:49,683
它为什么存在 如何影响你的应用

692
00:35:52,319 --> 00:35:53,787
现在我们有些好消息告诉你们

693
00:35:57,591 --> 00:35:59,092
Undefined Behavior Sanitizer

694
00:35:59,159 --> 00:36:02,563
可以检查15种以上
不同类型的新问题

695
00:36:03,463 --> 00:36:07,334
这将帮助提高生产力

696
00:36:07,401 --> 00:36:08,836
但是此演讲仅简单介绍

697
00:36:08,902 --> 00:36:13,106
Undefined Behavior Sanitizer
可以发现哪些问题 以及它如何工作

698
00:36:13,173 --> 00:36:15,209
我们重点关注三个问题

699
00:36:15,342 --> 00:36:20,347
整型溢出 对齐违规
和nonnull返回值违规

700
00:36:22,449 --> 00:36:24,017
让我们先从整型溢出开始

701
00:36:25,619 --> 00:36:29,122
当算法表达式的结果值过大

702
00:36:29,256 --> 00:36:32,226
而无法放入变量时
就会发生整型溢出

703
00:36:32,960 --> 00:36:36,496
如果在索引表达式中发生这种漏洞

704
00:36:36,763 --> 00:36:39,166
比如 对缓冲进行索引

705
00:36:39,399 --> 00:36:42,769
或在用于计算缓冲区
的表达式中进行索引

706
00:36:42,970 --> 00:36:46,874
可能会造成严重的安全问题
而且可能会被利用

707
00:36:48,308 --> 00:36:51,979
有时候整形溢出会造成意想不到的结果

708
00:36:52,312 --> 00:36:54,915
比如 你可能会

709
00:36:54,982 --> 00:36:57,017
进行大量的加法运算

710
00:36:57,684 --> 00:36:59,019
举例来说

711
00:36:59,186 --> 00:37:01,555
你有一个最大整数值 然后对它加1

712
00:37:01,622 --> 00:37:04,725
你可能会并不得到真正的结果

713
00:37:04,791 --> 00:37:07,127
这会让你感到困惑

714
00:37:08,462 --> 00:37:12,432
现在 并非所有类型的整型溢出
都是未定义的行为

715
00:37:12,499 --> 00:37:16,236
事实上 一些类型的溢出
具有已定义的语义

716
00:37:16,303 --> 00:37:18,539
比如无符号整型溢出

717
00:37:19,473 --> 00:37:23,277
但是 无符号整型溢出
也可能造成意想不到的结果

718
00:37:23,343 --> 00:37:26,480
我们强烈建议你
进行这方面的检查

719
00:37:27,381 --> 00:37:29,449
在本主题末尾部分
我将介绍如何这样做

720
00:37:31,285 --> 00:37:34,588
让我们首先来看一个演示

721
00:37:35,322 --> 00:37:38,258
这里有一个函数

722
00:37:38,325 --> 00:37:40,727
我们可能经常编写这样的函数

723
00:37:40,827 --> 00:37:41,895
这是一个求平均值函数

724
00:37:42,262 --> 00:37:45,432
它接受一个数组和长度值

725
00:37:45,832 --> 00:37:47,134
设置累加器

726
00:37:47,301 --> 00:37:50,704
对数据组进行迭代
累加所有数组元素 然后除以个数

727
00:37:50,971 --> 00:37:52,406
得出平均值

728
00:37:53,207 --> 00:37:54,908
我们想进行测试

729
00:37:54,975 --> 00:37:57,344
以验证其行为是否正确

730
00:37:58,111 --> 00:38:00,581
让我们来看测试

731
00:38:01,381 --> 00:38:03,217
TestNonNegativeAverage

732
00:38:04,218 --> 00:38:05,219
这个测试非常简单

733
00:38:05,319 --> 00:38:08,222
我们将会创建一个数组
可容纳10,000个整数

734
00:38:09,056 --> 00:38:13,527
在数组中放入伪随机非负整数

735
00:38:13,760 --> 00:38:16,363
然后进行健全性检查

736
00:38:16,697 --> 00:38:20,000
我们检查所获取的平均值是否为非负数

737
00:38:20,133 --> 00:38:22,102
这里有一个断言

738
00:38:24,104 --> 00:38:25,739
让我们运行测试

739
00:38:25,939 --> 00:38:27,975
我们转到这里

740
00:38:28,041 --> 00:38:30,477
成功地进行生成

741
00:38:31,578 --> 00:38:33,647
我们并没有看到什么

742
00:38:33,714 --> 00:38:36,216
程序运行结束
断言顺利通过

743
00:38:36,416 --> 00:38:37,451
似乎一切顺利

744
00:38:38,352 --> 00:38:41,221
我们进行细小的改动

745
00:38:41,321 --> 00:38:43,757
将会向我们描述
为什么未定义的行为

746
00:38:43,824 --> 00:38:46,093
和整型溢出实际上非常微妙

747
00:38:46,393 --> 00:38:47,828
让我们改变数据长度

748
00:38:48,061 --> 00:38:50,631
从10,000变为10,001

749
00:38:51,265 --> 00:38:53,700
保存 然后返回

750
00:38:54,935 --> 00:38:56,069
运行程序

751
00:38:59,506 --> 00:39:02,476
断言失败

752
00:39:02,876 --> 00:39:03,911
这让人感到困惑

753
00:39:03,977 --> 00:39:06,446
你知道
数组元素都是非负整数

754
00:39:06,813 --> 00:39:10,017
我编写的函数也很简单

755
00:39:10,083 --> 00:39:11,652
只是累加这些整数

756
00:39:11,785 --> 00:39:14,021
但是突然之间发生这种错误

757
00:39:14,087 --> 00:39:16,290
导致测试未能通过

758
00:39:17,424 --> 00:39:20,694
在这些情况下可以使用
Undefined Behavior Sanitizer

759
00:39:20,761 --> 00:39:22,930
弄清楚真正的问题是什么

760
00:39:23,430 --> 00:39:25,566
因此我启用这个工具
就像刚才库巴展示的那样

761
00:39:25,666 --> 00:39:29,536
我进入Scheme Editor
这里有一个“Diagnostics”选项卡

762
00:39:30,938 --> 00:39:32,272
选中这个复选框

763
00:39:33,407 --> 00:39:34,308
然后继续

764
00:39:35,209 --> 00:39:37,477
再次点击“Run” 重新生成

765
00:39:37,544 --> 00:39:39,746
这时Undefined Behavior Sanitizer
已经启用

766
00:39:41,081 --> 00:39:41,915
我们看这里

767
00:39:42,583 --> 00:39:46,019
Undefined Behavior Sanitizer
为我们突出显示

768
00:39:46,086 --> 00:39:48,856
准确的问题原因

769
00:39:48,989 --> 00:39:51,191
非常直观地告诉我们

770
00:39:51,325 --> 00:39:53,327
问题是

771
00:39:53,560 --> 00:39:54,962
无符号整型溢出

772
00:39:55,128 --> 00:39:57,464
为我们显示发生溢出的值

773
00:39:57,598 --> 00:39:59,766
可以看到 数据非常大

774
00:39:59,833 --> 00:40:02,736
这两个值或它们之和

775
00:40:02,803 --> 00:40:04,638
无法放入32位整数

776
00:40:04,705 --> 00:40:08,675
其结果是我们获得的

777
00:40:09,443 --> 00:40:11,011
任何无效结果

778
00:40:11,078 --> 00:40:13,947
使用其完整表示
而成为负数

779
00:40:15,182 --> 00:40:18,519
可以通过多种方法解决这个问题

780
00:40:18,752 --> 00:40:21,088
我建议的两个方法是

781
00:40:21,154 --> 00:40:23,757
使用不同的算法来计算平均值

782
00:40:24,157 --> 00:40:26,627
或者在平均值函数中设置约束

783
00:40:26,693 --> 00:40:29,963
从而避免这个问题

784
00:40:31,665 --> 00:40:36,003
然后 让我们返回幻灯片

785
00:40:36,403 --> 00:40:39,239
希望你们发现
Undefined Behavior Sanitizer

786
00:40:39,306 --> 00:40:44,311
能够让你轻松地发现这些

787
00:40:44,378 --> 00:40:46,213
导致运行时错误的微妙问题

788
00:40:47,681 --> 00:40:48,515
好的

789
00:40:50,117 --> 00:40:53,420
让我们来看

790
00:40:53,820 --> 00:40:55,122
第二种类型的问题

791
00:40:55,189 --> 00:40:57,758
它们是内存对齐违规问题

792
00:40:58,892 --> 00:41:01,828
C语言中的所有类型都有大小

793
00:41:01,962 --> 00:41:04,198
而且要求进行内存对齐

794
00:41:05,666 --> 00:41:08,402
如果未对齐地加载或存储到内存块

795
00:41:08,468 --> 00:41:12,840
程序将发生内存对齐违规

796
00:41:14,041 --> 00:41:18,378
这是非常难以发现的细微漏洞

797
00:41:18,512 --> 00:41:21,715
在日常开发工作中

798
00:41:21,782 --> 00:41:24,985
你可能不会发现这样的问题

799
00:41:25,085 --> 00:41:27,721
假设你们大多数在Xcode中

800
00:41:27,788 --> 00:41:30,457
开发应用和框架
进行调试配置

801
00:41:30,991 --> 00:41:33,060
当你最终进行应用分发时

802
00:41:33,393 --> 00:41:35,462
将需要进行发行配置

803
00:41:35,963 --> 00:41:36,964
问题在于

804
00:41:37,097 --> 00:41:39,299
因为编辑器期望

805
00:41:39,366 --> 00:41:42,569
不发生对齐违规问题

806
00:41:43,203 --> 00:41:46,573
优化器通常会优化你的代码

807
00:41:46,707 --> 00:41:50,844
当启用这些优化时
会造成你的应用发行配置

808
00:41:50,911 --> 00:41:52,613
在运行时崩溃

809
00:41:54,047 --> 00:41:57,117
Undefined Behavior Sanitizer
帮助你发现这些问题

810
00:41:57,251 --> 00:41:59,753
甚至提前在调试配置中
发现问题

811
00:41:59,820 --> 00:42:00,787
这样 就不会造成

812
00:42:00,888 --> 00:42:03,257
在以后出现难以调试的错误

813
00:42:04,424 --> 00:42:07,294
在持续性存储中

814
00:42:07,361 --> 00:42:10,163
进行数据串行化或反串行化的代码
特别容易

815
00:42:10,230 --> 00:42:11,632
发生这种类型的错误

816
00:42:12,199 --> 00:42:16,303
让我们来认真看一个例子

817
00:42:19,039 --> 00:42:21,041
在本例中

818
00:42:21,141 --> 00:42:24,311
我想编写一个自定义网络协议

819
00:42:24,378 --> 00:42:26,079
将它用于我正在开发的聊天程序

820
00:42:27,214 --> 00:42:30,551
此网络协议的一个基本功能是

821
00:42:30,717 --> 00:42:33,053
定义一个数据包结构

822
00:42:34,221 --> 00:42:36,356
此数据包结构包含三个部分

823
00:42:36,857 --> 00:42:40,027
一个magic字段 表示所使用的协议

824
00:42:41,295 --> 00:42:43,697
一个payloadLength字段

825
00:42:43,764 --> 00:42:46,133
说明数据包内的消息长度

826
00:42:46,567 --> 00:42:48,235
最后是payload本身

827
00:42:48,902 --> 00:42:50,671
从本例的目的来说

828
00:42:50,737 --> 00:42:53,740
我假设int是一个四字节整数

829
00:42:54,141 --> 00:42:55,909
现在 我们需要专注于

830
00:42:56,944 --> 00:42:58,912
两个方面

831
00:42:58,979 --> 00:43:02,416
以确保自定义网络协议工作正常

832
00:43:02,616 --> 00:43:04,284
它们是发送器和接收器

833
00:43:04,551 --> 00:43:06,520
我们先来看接收器

834
00:43:07,154 --> 00:43:09,323
接收器有一个网络缓冲区

835
00:43:09,423 --> 00:43:11,992
它在这个缓冲区内组装其数据包

836
00:43:12,726 --> 00:43:13,727
准备好这些数据包

837
00:43:13,827 --> 00:43:14,962
使数据负载准备就绪

838
00:43:15,295 --> 00:43:18,498
然后通过网络发送
使接收器能够接收

839
00:43:19,233 --> 00:43:22,169
从演示的角度来说

840
00:43:22,436 --> 00:43:25,272
我已经将网络缓冲区的内存

841
00:43:25,339 --> 00:43:28,342
分割成为多个四字节块
你们很快就知道原因

842
00:43:29,877 --> 00:43:32,479
现在我已很想念库巴

843
00:43:32,613 --> 00:43:35,516
可是他早就下台了

844
00:43:36,650 --> 00:43:40,020
我想发送给库巴的第一条信息是
“Hey Kuba!”

845
00:43:40,754 --> 00:43:44,024
为此 我首先使用一个magic值

846
00:43:46,426 --> 00:43:49,429
然后指定消息的长度

847
00:43:49,496 --> 00:43:50,831
里面共有9个字符

848
00:43:51,798 --> 00:43:52,633
让我们开始

849
00:43:54,234 --> 00:43:59,139
最后我指定消息内容
即“Hey Kuba!”

850
00:44:00,774 --> 00:44:03,610
现在我们来看接收器的功能

851
00:44:05,279 --> 00:44:08,949
它接收一个指向
网络字节流缓存区的指针

852
00:44:09,383 --> 00:44:12,386
然后将这个指针转换成为
指向数据包结构的指针

853
00:44:14,121 --> 00:44:17,457
然后查找数据包内部

854
00:44:18,125 --> 00:44:19,660
找到magic字段的值

855
00:44:19,726 --> 00:44:22,930
确保它是正确的值
让我们使用正确的协议

856
00:44:23,330 --> 00:44:25,132
然后查看数据负载

857
00:44:26,567 --> 00:44:29,369
这是第一个数据包
到目前还没有问题

858
00:44:30,270 --> 00:44:31,138
让我们来看第二条消息

859
00:44:32,840 --> 00:44:35,509
第二条消息的内容是
“How's it going?”

860
00:44:36,043 --> 00:44:37,411
我们进行同样的操作

861
00:44:39,079 --> 00:44:41,582
找到magic字段值

862
00:44:43,050 --> 00:44:45,919
放入消息长度 15个字符

863
00:44:46,520 --> 00:44:47,988
然后是消息本身

864
00:44:49,289 --> 00:44:51,592
然后转到接收器端

865
00:44:51,859 --> 00:44:54,261
我们可以看到问题清单

866
00:44:55,229 --> 00:44:59,800
查看网络字节流中的索引17

867
00:45:00,534 --> 00:45:03,937
当我们查找

868
00:45:04,004 --> 00:45:05,606
数据包内的magic值时

869
00:45:06,406 --> 00:45:08,475
发生内存对齐违规

870
00:45:10,644 --> 00:45:12,145
这里可以看到

871
00:45:12,412 --> 00:45:14,848
第二个数据包的magic字段

872
00:45:14,982 --> 00:45:17,150
没有对齐为四字节边界

873
00:45:17,451 --> 00:45:20,621
因此在网络字节流中
直接取消引用它

874
00:45:20,687 --> 00:45:21,989
会造成内存对齐违规

875
00:45:22,289 --> 00:45:24,525
Undefined Behavior Sanitizer

876
00:45:24,625 --> 00:45:26,560
可以非常准确地诊断出这个问题

877
00:45:30,697 --> 00:45:31,732
如何解决这个问题呢？

878
00:45:31,965 --> 00:45:33,867
接下我们会讨论两种方法

879
00:45:34,401 --> 00:45:36,870
第一种方法是

880
00:45:36,937 --> 00:45:39,206
在网络数据包结构定义
或你已经串行化处理的任何结构中

881
00:45:39,273 --> 00:45:41,808
使用packed属性

882
00:45:42,709 --> 00:45:44,411
让我们来看这是如何工作的

883
00:45:45,946 --> 00:45:47,181
你添加packed属性

884
00:45:47,247 --> 00:45:49,683
这会更改所有结构内的

885
00:45:49,750 --> 00:45:50,851
所有字段对齐

886
00:45:51,151 --> 00:45:53,987
这是你所能够获得的

887
00:45:54,621 --> 00:45:57,124
最低可能性对齐

888
00:45:57,391 --> 00:46:01,361
这意味着该字段的任何后续加载或存储

889
00:46:01,428 --> 00:46:02,863
始终会对齐

890
00:46:03,597 --> 00:46:06,633
你可能会想
这听上去非常方便

891
00:46:06,733 --> 00:46:08,669
我想对所有项目使用packed属性

892
00:46:09,169 --> 00:46:10,737
但是你应该注意

893
00:46:11,071 --> 00:46:12,673
使用packed属性

894
00:46:12,739 --> 00:46:15,042
将会更改结构的布局

895
00:46:16,143 --> 00:46:17,978
很多情况下 它会消除

896
00:46:18,045 --> 00:46:19,780
编译器自动插入到

897
00:46:19,847 --> 00:46:20,948
数据结构中的填充

898
00:46:21,615 --> 00:46:24,618
这可能会降低应用性能

899
00:46:25,452 --> 00:46:28,956
如果你发现

900
00:46:29,022 --> 00:46:31,158
packed属性并不适合你的处理

901
00:46:31,358 --> 00:46:32,559
还有另外一种方法

902
00:46:34,828 --> 00:46:37,497
你可以使用memcpy函数

903
00:46:37,998 --> 00:46:42,002
将网络字节流

904
00:46:42,069 --> 00:46:44,137
或者已经去串行化的数据块

905
00:46:44,872 --> 00:46:47,574
复制到对齐变量之中

906
00:46:47,641 --> 00:46:49,409
对齐变量可能位于堆栈或堆之中

907
00:46:50,210 --> 00:46:54,081
memcpy是安全的
许多情况下 编译器可以进行优化

908
00:46:54,147 --> 00:46:59,086
使访问速度与未对齐访问一样快速

909
00:46:59,419 --> 00:47:01,288
这是原始未对齐访问所无法企及的

910
00:47:04,057 --> 00:47:07,461
这就是Undefined Behavior Sanitizer
的对齐违规检测功能

911
00:47:09,363 --> 00:47:12,332
让我们来看第三种类型的漏洞

912
00:47:13,333 --> 00:47:15,369
即nonnull返回值违规

913
00:47:17,371 --> 00:47:20,174
当函数的返回值

914
00:47:20,240 --> 00:47:23,610
使用nonnull属性注解时

915
00:47:24,611 --> 00:47:25,812
将发生这种问题

916
00:47:26,880 --> 00:47:29,016
但是 函数破坏

917
00:47:29,750 --> 00:47:33,620
注解所使用的协定

918
00:47:33,754 --> 00:47:35,989
并且返回nil值

919
00:47:36,657 --> 00:47:40,360
如果使用Objective-C API
将会导致崩溃

920
00:47:40,460 --> 00:47:43,263
因为这违反
Swift代码的

921
00:47:44,031 --> 00:47:44,865
返回值注解规则

922
00:47:45,566 --> 00:47:47,467
这还会导致其他问题

923
00:47:47,534 --> 00:47:49,303
如果你使用的
Objective-C API

924
00:47:49,436 --> 00:47:52,539
更严格地依赖于

925
00:47:54,441 --> 00:47:55,275
空属性关联纠错

926
00:47:56,577 --> 00:47:58,812
因此我们强烈建议你进行这种检查

927
00:47:58,879 --> 00:48:01,748
如果你的应用
使用空属性注解

928
00:48:03,283 --> 00:48:06,553
让我们来看一个

929
00:48:07,588 --> 00:48:09,156
nonnull返回值违规例子

930
00:48:10,490 --> 00:48:14,228
在本例中
我是一名业余天文爱好者

931
00:48:14,461 --> 00:48:16,396
我有一个太阳系模型

932
00:48:17,598 --> 00:48:19,867
首先我想要做的是

933
00:48:19,933 --> 00:48:21,969
建模太阳系中的卫星

934
00:48:22,035 --> 00:48:23,203
我们开始

935
00:48:23,337 --> 00:48:24,671
这是行星地球

936
00:48:24,805 --> 00:48:28,308
地球的最大卫星是月亮

937
00:48:28,542 --> 00:48:31,879
然后还有火星
我们按照直径

938
00:48:31,945 --> 00:48:34,348
对这个列表进行降序排序

939
00:48:34,615 --> 00:48:36,350
火卫一是火星的最大卫星

940
00:48:36,416 --> 00:48:37,651
火卫二是第二大卫星

941
00:48:37,718 --> 00:48:40,254
很好

942
00:48:41,321 --> 00:48:43,724
看起来这里的一个输入

943
00:48:43,790 --> 00:48:45,559
是错误的

944
00:48:47,027 --> 00:48:48,695
这让人尴尬

945
00:48:49,596 --> 00:48:50,531
最好删除它

946
00:48:50,964 --> 00:48:52,432
这样好多了

947
00:48:52,766 --> 00:48:56,603
我删除例中的遗留代码

948
00:48:57,437 --> 00:48:59,339
现在列表看上去正确了

949
00:49:00,541 --> 00:49:01,808
让我们继续

950
00:49:02,009 --> 00:49:03,143
好的

951
00:49:04,578 --> 00:49:07,314
我想做的事情是

952
00:49:07,447 --> 00:49:09,850
获得一个列表

953
00:49:09,917 --> 00:49:11,518
列出太阳系所有行星的最大卫星

954
00:49:12,553 --> 00:49:16,890
我要做的事情是
构造一个NSMutableArray

955
00:49:17,691 --> 00:49:21,628
然后添加每个行星的最大卫星
到这个数组之中

956
00:49:22,296 --> 00:49:24,298
这里的问题是

957
00:49:24,364 --> 00:49:26,033
我已经查询木星的最大卫星

958
00:49:26,366 --> 00:49:29,469
但是我创建的NS词典中没有这个条目

959
00:49:29,703 --> 00:49:30,637
因此我获取返回值nil

960
00:49:31,872 --> 00:49:35,209
Undefined Behavior Sanitizer
可以为你诊断这个问题

961
00:49:37,611 --> 00:49:41,114
让我们来看

962
00:49:41,181 --> 00:49:43,450
Undefined Behavior Sanitizer
可以为你发现什么样的问题

963
00:49:43,617 --> 00:49:44,952
并了解它的运行原理

964
00:49:45,853 --> 00:49:47,421
我将为你们展示

965
00:49:47,721 --> 00:49:51,191
如何启用这些检查功能

966
00:49:51,959 --> 00:49:53,727
这是一个项目生成设置编辑器

967
00:49:54,294 --> 00:49:57,998
在这里 可以启用
无符号整型溢出检测功能

968
00:49:58,198 --> 00:50:01,268
和空属性注解检查功能

969
00:50:02,769 --> 00:50:05,839
这是Undefined Behavior Sanitizer
Xcode 9中的新工具

970
00:50:16,650 --> 00:50:19,720
我们已经了解Xcode中
的许多运行时工具

971
00:50:19,887 --> 00:50:21,188
一些是新工具 一些经过改进

972
00:50:21,321 --> 00:50:23,223
让我们回过头来

973
00:50:23,757 --> 00:50:25,659
思考软件质量本身

974
00:50:25,893 --> 00:50:28,562
如何有效地使用这些工具？

975
00:50:31,465 --> 00:50:32,633
这需要从两个方面着手

976
00:50:33,500 --> 00:50:36,837
你需要更多地练习
使用这些工具检查你的代码

977
00:50:37,437 --> 00:50:39,106
另外应该综合性地使用这些工具

978
00:50:40,073 --> 00:50:40,908
让我们来了解

979
00:50:42,776 --> 00:50:44,344
（代码检查练习）

980
00:50:44,411 --> 00:50:48,081
当你运行含有漏洞的代码时

981
00:50:48,215 --> 00:50:50,951
运行时工具帮助你发现这些漏洞

982
00:50:51,285 --> 00:50:52,686
也许[听不清]
这不是最好的方法

983
00:50:52,753 --> 00:50:57,858
但是你必须运行含有漏洞的代码行

984
00:50:57,925 --> 00:50:59,893
才能获得

985
00:50:59,960 --> 00:51:02,262
有价值的漏洞诊断信息

986
00:51:02,462 --> 00:51:03,497
因此

987
00:51:04,097 --> 00:51:06,133
为了使用更多的代码进行练习

988
00:51:06,200 --> 00:51:08,168
发现尽可能多的问题

989
00:51:09,203 --> 00:51:12,673
我们建议你
在日常开发工作中使得这些运行时工具

990
00:51:13,574 --> 00:51:15,475
我们建议你
至少在每次软件发布之前

991
00:51:15,542 --> 00:51:18,145
启用一次这些工具

992
00:51:18,212 --> 00:51:19,980
以避免传播漏洞

993
00:51:20,047 --> 00:51:22,749
和可能的安全漏洞

994
00:51:25,385 --> 00:51:27,054
使用持续性集成

995
00:51:27,254 --> 00:51:29,923
让使用运行时工具变得更简单

996
00:51:30,390 --> 00:51:32,893
而且 在启用这些工具之后

997
00:51:32,993 --> 00:51:34,261
代码检查工作

998
00:51:34,328 --> 00:51:35,863
变得更加容易

999
00:51:36,997 --> 00:51:38,699
可以确保

1000
00:51:38,866 --> 00:51:41,435
在检查代码时

1001
00:51:41,502 --> 00:51:42,803
尽快地发现程序中的漏洞

1002
00:51:43,904 --> 00:51:46,773
帮助你跟踪程序中的代码检查情况

1003
00:51:46,840 --> 00:51:49,710
让你能够了解
每次进行持续性集成时

1004
00:51:49,943 --> 00:51:52,145
对多少代码进行了检查

1005
00:51:53,413 --> 00:51:55,782
如果你想要了解
Xcode中的持续性集成

1006
00:51:55,849 --> 00:51:57,651
和代码检查工作原理

1007
00:51:57,851 --> 00:52:01,922
建议你们观看
WWDC 2015相关主题演讲

1008
00:52:05,826 --> 00:52:08,395
确保有效地使用运行时工具的
另一个重要因素是

1009
00:52:08,462 --> 00:52:09,963
综合性地使用这些工具

1010
00:52:10,497 --> 00:52:13,667
启用的工具越多
能够发现的问题就越多

1011
00:52:14,935 --> 00:52:15,769
有一个例外

1012
00:52:15,836 --> 00:52:18,238
Address Sanitizer
和Thread Sanitizer

1013
00:52:18,305 --> 00:52:19,706
互相不兼容

1014
00:52:19,806 --> 00:52:21,675
不能同时启用这两个工具

1015
00:52:21,742 --> 00:52:23,477
但是可以同时启用其它工具

1016
00:52:24,478 --> 00:52:27,848
前面我们讲过
进入Xcode的方案编辑器

1017
00:52:27,915 --> 00:52:30,817
点击“诊断”选项卡

1018
00:52:30,884 --> 00:52:32,519
可以启用所有这些工具

1019
00:52:33,887 --> 00:52:37,124
你可能会想
这些工具会产生很大的开销

1020
00:52:38,725 --> 00:52:39,993
实际上并不是这样的

1021
00:52:40,861 --> 00:52:43,096
至少我的经验告诉我不是这样的

1022
00:52:43,197 --> 00:52:46,300
关于这些工具的执行和内存开销

1023
00:52:46,366 --> 00:52:48,068
我们有一些数据

1024
00:52:48,802 --> 00:52:51,839
我发现

1025
00:52:51,972 --> 00:52:55,275
在调试整个Xcode程序时

1026
00:52:55,342 --> 00:52:57,377
我可以同时启用多个运行时工具

1027
00:52:57,644 --> 00:52:59,246
UI依然反应灵敏

1028
00:53:00,214 --> 00:53:03,116
希望这些信息能够帮助你更好地决定

1029
00:53:03,183 --> 00:53:04,585
应该在你的本地设置及持续性集成中

1030
00:53:04,718 --> 00:53:07,321
启用哪些工具

1031
00:53:07,988 --> 00:53:10,691
我希望你认识到

1032
00:53:10,757 --> 00:53:13,794
所有这些工具都非常有价值

1033
00:53:13,961 --> 00:53:16,563
它们为你发现不同的漏洞

1034
00:53:16,830 --> 00:53:20,000
必要时应该启用它们

1035
00:53:23,237 --> 00:53:24,371
让我们进行总结

1036
00:53:24,605 --> 00:53:27,608
Xcode 9增加新工具
和经过改进的工具

1037
00:53:27,674 --> 00:53:29,710
帮助你在应用和程序中

1038
00:53:30,377 --> 00:53:32,045
发现更多的严重漏洞

1039
00:53:33,213 --> 00:53:35,449
我真心希望
你们尽早地、经常地使用它们

1040
00:53:35,749 --> 00:53:38,685
以节省调试时间
并确保用户安全性

1041
00:53:38,852 --> 00:53:41,922
希望你们使用这些工具
发现并且消除漏洞

1042
00:53:42,322 --> 00:53:44,391
如果你需要本演讲的更多信息

1043
00:53:44,625 --> 00:53:47,694
请访问我们的网站
此网站提供大量的有用链接

1044
00:53:48,529 --> 00:53:50,364
另外 一些相关的演讲
即将举行

1045
00:53:50,564 --> 00:53:53,634
它们是“Swift新特性”和
“Xcode 9调试功能”演讲

1046
00:53:53,934 --> 00:53:55,769
另外还有GCD演讲

1047
00:53:57,538 --> 00:54:00,707
以及“LLVM新特性”演讲

1048
00:54:00,774 --> 00:54:04,011
可以帮助你们了解
这些运行时工具的

1049
00:54:05,479 --> 00:54:07,014
底层Sanitizer技术

1050
00:54:08,248 --> 00:54:10,651
感谢你们参加本演讲

1051
00:54:10,918 --> 00:54:12,653
希望你们有所收获

